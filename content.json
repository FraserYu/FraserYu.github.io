{"meta":{"title":"日拱一兵｜Java｜Spring Boot｜Java并发编程｜最新干货分享","subtitle":"日拱一兵","description":"本站是日拱一兵的技术分享博客，内容涵盖Java后端技术、Spring Boot、Java并发编程等技术研究与分享，用有趣的方式解读技术","author":"tanθ","url":"https://dayarch.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-14T04:31:25.233Z","updated":"2019-11-14T04:31:25.233Z","comments":true,"path":"404.html","permalink":"https://dayarch.top/404.html","excerpt":"404 Not Found **由于更改了文章链接，原有链接丢失，但内容依旧在**试试在本站通过搜索关键字找到相关文章","text":"404 Not Found **由于更改了文章链接，原有链接丢失，但内容依旧在** 试试在本站通过搜索关键字找到相关文章"},{"title":"所有分类","date":"2019-10-31T12:18:29.000Z","updated":"2019-10-31T12:44:03.895Z","comments":true,"path":"categories/index.html","permalink":"https://dayarch.top/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-10-31T12:27:35.000Z","updated":"2019-11-01T23:45:30.022Z","comments":true,"path":"about/index.html","permalink":"https://dayarch.top/about/index.html","excerpt":"","text":""},{"title":"留言交流","date":"2019-11-03T12:15:27.885Z","updated":"2019-11-03T12:15:27.885Z","comments":true,"path":"comments/index.html","permalink":"https://dayarch.top/comments/index.html","excerpt":"为了更好的跟踪大家留言问题，留言方式选用 Gitalk, 大家只需登录 Github 账号即可留言，欢迎大家来踩☕️","text":"为了更好的跟踪大家留言问题，留言方式选用 Gitalk, 大家只需登录 Github 账号即可留言，欢迎大家来踩☕️"},{"title":"我的朋友们「友链添加在底部」","date":"2019-10-31T07:45:38.000Z","updated":"2019-11-26T02:24:36.839Z","comments":true,"path":"friends/index.html","permalink":"https://dayarch.top/friends/index.html","excerpt":"需要添加友链，请在下方留言，需要以下内容： * 头像外链（如有白名单设置，请为 https://dayarch.top 开白名单） * 网站/博客名称 * 两个描述你或网站的 tag * 网站/博客 https URL 地址","text":"需要添加友链，请在下方留言，需要以下内容： 头像外链（如有白名单设置，请为 https://dayarch.top 开白名单） 网站/博客名称 两个描述你或网站的 tag 网站/博客 https URL 地址"},{"title":"所有标签","date":"2019-10-31T12:18:52.000Z","updated":"2019-10-31T12:44:13.682Z","comments":true,"path":"tags/index.html","permalink":"https://dayarch.top/tags/index.html","excerpt":"","text":""},{"title":"网站维护日志","date":"2020-01-16T03:14:15.415Z","updated":"2020-01-16T03:14:15.415Z","comments":true,"path":"website/index.html","permalink":"https://dayarch.top/website/index.html","excerpt":"待升级/修复内容： * 文章底部 github-badge * 添加社交链接和RSS * 「关于」页面自定义改造 * 添加其他渠道链接 * bing的收录 https://www.bing.com/webmaster/home/mysites * 自定义邮箱 https://mp.weixin.qq.com/s/Mg60BmNOou-2J0g0GRUEkAs * 转移到自己的云服务器上 2019.12.17: * 「新增」添加其他平台博客链接 * 「优化」首页及文章页面去除标签等区域 * 「优化」去除背景动态效果 2019.12.13: * 「优化」完","text":"待升级/修复内容： 文章底部 github-badge 添加社交链接和RSS 「关于」页面自定义改造 添加其他渠道链接 bing的收录 https://www.bing.com/webmaster/home/mysites 自定义邮箱 https://mp.weixin.qq.com/s/Mg60BmNOou-2J0g0GRUEkAs 转移到自己的云服务器上 2019.12.17: 「新增」添加其他平台博客链接 「优化」首页及文章页面去除标签等区域 「优化」去除背景动态效果 2019.12.13: 「优化」完成文章相关链接指向功能 2019.11.7: 「优化」完成博客备份功能 2019.11.4: 「修复」网站统计访问人数不显示问题 「修复」移动端首页动态字体显示不全问题 2019.11.3: 「新增」站内导航新增豆瓣读书 「新增」右下角即时聊天工具 「新增」站点运行时间 「新增」站点字数统计 2019.11.2: 「新增」添加百度/谷歌站长以及分析工具 「新增」增加鼠标点击💥效果 「新增」首页动态文字效果 「新增」添加文章 sidebar 音乐插件 2019.11.1: 「优化」更换博客主题，以及更改颜色样式"}],"posts":[{"title":"搞定ReentrantReadWriteLock 几道小小数学题就够了","slug":"搞定ReentrantReadWriteLock-几个小小数学题就够了","date":"2020-06-21T11:20:28.000Z","updated":"2020-06-22T12:46:05.571Z","comments":true,"path":"/p/java-reentrant-read-write-lock.html","link":"","permalink":"https://dayarch.top/p/java-reentrant-read-write-lock.html","excerpt":"前言 * 文章 Java AQS队列同步器以及ReentrantLock的应用 介绍了AQS独占式获取同步状态的实现，并以 ReentrantLock 为例说明其是如何自定义同步器实现互斥锁的 * 文章 Java AQS共享式获取同步状态及Semaphore的应用分析 介绍 AQS 共享式获取同步状态的实现，并说明了 Semaphore 是如何自定义同步器实现简单限流作用的 有了以上两篇文章的铺垫，来理解本文要介绍的既有独占式，又有共享式获取同步状态的 ReadWriteLock，就非常轻松了 ReadWriteLock ReadWriteLock 直译过来为【读写锁】。现实中，读","text":"前言 文章 Java AQS队列同步器以及ReentrantLock的应用 介绍了AQS独占式获取同步状态的实现，并以 ReentrantLock 为例说明其是如何自定义同步器实现互斥锁的 文章 Java AQS共享式获取同步状态及Semaphore的应用分析 介绍 AQS 共享式获取同步状态的实现，并说明了 Semaphore 是如何自定义同步器实现简单限流作用的 有了以上两篇文章的铺垫，来理解本文要介绍的既有独占式，又有共享式获取同步状态的 ReadWriteLock，就非常轻松了 ReadWriteLockReadWriteLock 直译过来为【读写锁】。现实中，读多写少的业务场景是非常普遍的，比如应用缓存 一个线程将数据写入缓存，其他线程可以直接读取缓存中的数据，提高数据查询效率 之前提到的互斥锁都是排他锁，也就是说同一时刻只允许一个线程进行访问，当面对可共享读的业务场景，互斥锁显然是比较低效的一种处理方式。为了提高效率，读写锁模型就诞生了 效率提升是一方面，但并发编程更重要的是在保证准确性的前提下提高效率 一个写线程改变了缓存中的值，其他读线程一定是可以 “感知” 到的，否则可能导致查询到的值不准确 所以关于读写锁模型就了下面这 3 条规定： 允许多个线程同时读共享变量 只允许一个线程写共享变量 如果写线程正在执行写操作，此时则禁止其他读线程读共享变量 ReadWriteLock 是一个接口，其内部只有两个方法： 1234567public interface ReadWriteLock &#123; // 返回用于读的锁 Lock readLock(); // 返回用于写的锁 Lock writeLock();&#125; 所以要了解整个读/写锁的整个应用过程，需要从它的实现类 ReentrantReadWriteLock 说起 ReentrantReadWriteLock 类结构直接对比ReentrantReadWriteLock 与 ReentrantLock的类结构 他们又很相似吧，根据类名称以及类结构，按照咱们前序文章的分析，你也就能看出 ReentrantReadWriteLock 的基本特性： 其中黄颜色标记的的 锁降级 是看不出来的， 这里先有个印象，下面会单独说明 另外，不知道你是否还记得，Java AQS队列同步器以及ReentrantLock的应用 说过，Lock 和 AQS 同步器是一种组合形式的存在，既然这里是读/写两种锁，他们的组合模式也就分成了两种： 读锁与自定义同步器的聚合 写锁与自定义同步器的聚合 12345public ReentrantReadWriteLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this);&#125; 这里只是提醒大家，模式没有变，不要被读/写两种锁迷惑 基本示例说了这么多，如果你忘了前序知识，整体理解感觉应该是有断档的，所以先来看个示例（模拟使用缓存）让大家对 ReentrantReadWriteLock 有个直观的使用印象 1234567891011121314151617181920212223242526272829public class ReentrantReadWriteLockCache &#123; // 定义一个非线程安全的 HashMap 用于缓存对象 static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); // 创建读写锁对象 static ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 构建读锁 static Lock rl = readWriteLock.readLock(); // 构建写锁 static Lock wl = readWriteLock.writeLock(); public static final Object get(String key) &#123; rl.lock(); try&#123; return map.get(key); &#125;finally &#123; rl.unlock(); &#125; &#125; public static final Object put(String key, Object value)&#123; wl.lock(); try&#123; return map.put(key, value); &#125;finally &#123; wl.unlock(); &#125; &#125;&#125; 你瞧，使用就是这么简单。但是你知道的，AQS 的核心是锁的实现，即控制同步状态 state 的值，ReentrantReadWriteLock 也是应用AQS的 state 来控制同步状态的，那么问题来了： 一个 int 类型的 state 怎么既控制读的同步状态，又可以控制写的同步状态呢？ 显然需要一点设计了 读写状态设计如果要在一个 int 类型变量上维护多个状态，那肯定就需要拆分了。我们知道 int 类型数据占32位，所以我们就有机会按位切割使用state了。我们将其切割成两部分： 高16位表示读 低16位表示写 所以，要想准确的计算读/写各自的状态值，肯定就要应用位运算了，下面代码是 JDK1.8，ReentrantReadWriteLock 自定义同步器 Sync 的位操作 1234567891011121314151617abstract static class Sync extends AbstractQueuedSynchronizer &#123; static final int SHARED_SHIFT = 16; static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1; static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125; static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;&#125; 乍一看真是有些复杂的可怕，别慌，咱们通过几道小小数学题就可以搞定整个位运算过程 整个 ReentrantReadWriteLock 中 读/写状态的计算就是反复应用这几道数学题，所以，在阅读下面内容之前，希望你搞懂这简单的运算 基础铺垫足够了，我们进入源码分析吧 源码分析写锁分析由于写锁是排他的，所以肯定是要重写 AQS 中 tryAcquire 方法 123456789101112131415161718192021222324protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); // 获取 state 整体的值 int c = getState(); // 获取写状态的值 int w = exclusiveCount(c); if (c != 0) &#123; // w=0: 根据推理二，整体状态不等于零，写状态等于零，所以，读状态大于0，即存在读锁 // 或者当前线程不是已获取写锁的线程 // 二者之一条件成真，则获取写状态失败 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); // 根据推理一第 1 条，更新写状态值 setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true;&#125; 上述代码 第 19 行 writerShouldBlock 也并没有什么神秘的，只不过是公平/非公平获取锁方式的判断（是否有前驱节点来判断） 你瞧，写锁获取方式就是这么简单 读锁分析由于读锁是共享式的，所以肯定是要重写 AQS 中 tryAcquireShared 方法 12345678910111213141516171819202122232425262728293031protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); // 写状态不等于0，并且锁的持有者不是当前线程，根据约定 3，则获取读锁失败 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取读状态值 int r = sharedCount(c); // 这个地方有点不一样，我们单独说明 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; // 如果获取读锁失败则进入自旋获取 return fullTryAcquireShared(current);&#125; readerShouldBlock 和 writerShouldBlock 在公平锁的实现上都是判断是否有前驱节点，但是在非公平锁的实现上，前者是这样的： 12345678910111213final boolean readerShouldBlock() &#123; return apparentlyFirstQueuedIsExclusive();&#125;final boolean apparentlyFirstQueuedIsExclusive() &#123; Node h, s; return (h = head) != null &amp;&amp; // 等待队列头节点的下一个节点 (s = h.next) != null &amp;&amp; // 如果是排他式的节点 !s.isShared() &amp;&amp; s.thread != null;&#125; 简单来说，如果请求读锁的当前线程发现同步队列的 head 节点的下一个节点为排他式节点，那么就说明有一个线程在等待获取写锁（争抢写锁失败，被放入到同步队列中），那么请求读锁的线程就要阻塞，毕竟读多写少，如果还没有这点判断机制，写锁可能会发生【饥饿】 上述条件都满足了，也就会进入 tryAcquireShared 代码的第 14 行到第 25 行，这段代码主要是为了记录线程持有锁的次数。读锁是共享式的，还想记录每个线程持有读锁的次数，就要用到 ThreadLocal 了，因为这不影响同步状态 state 的值，所以就不分析了, 只把关系放在这吧 到这里读锁的获取也就结束了，比写锁稍稍复杂那么一丢丢，接下来就说明一下那个可能让你迷惑的锁升级/降级问题吧 读写锁的升级与降级个人理解：读锁是可以被多线程共享的，写锁是单线程独占的，也就是说写锁的并发限制比读锁高，所以 在真正了解读写锁的升级与降级之前，我们需要完善一下本文开头 ReentrantReadWriteLock 的例子 12345678910111213141516171819202122232425262728293031public static final Object get(String key) &#123; Object obj = null; rl.lock(); try&#123; // 获取缓存中的值 obj = map.get(key); &#125;finally &#123; rl.unlock(); &#125; // 缓存中值不为空，直接返回 if (obj!= null) &#123; return obj; &#125; // 缓存中值为空，则通过写锁查询DB，并将其写入到缓存中 wl.lock(); try&#123; // 再次尝试获取缓存中的值 obj = map.get(key); // 再次获取缓存中值还是为空 if (obj == null) &#123; // 查询DB obj = getDataFromDB(key); // 伪代码：getDataFromDB // 将其放入到缓存中 map.put(key, obj); &#125; &#125;finally &#123; wl.unlock(); &#125; return obj;&#125; 有童鞋可能会有疑问 在写锁里面，为什么代码第19行还要再次获取缓存中的值呢？不是多此一举吗？ 其实这里再次尝试获取缓存中的值是很有必要的，因为可能存在多个线程同时执行 get 方法，并且参数 key 也是相同的，执行到代码第 16 行 wl.lock() ,比如这样： 线程 A，B，C 同时执行到临界区 wl.lock()， 只有线程 A 获取写锁成功，线程B，C只能阻塞，直到线程A 释放写锁。这时，当线程B 或者 C 再次进入临界区时，线程 A 已经将值更新到缓存中了，所以线程B，C没必要再查询一次DB，而是再次尝试查询缓存中的值 既然再次获取缓存很有必要，我能否在读锁里直接判断，如果缓存中没有值，那就再次获取写锁来查询DB不就可以了嘛，就像这样： 1234567891011121314151617181920212223public static final Object getLockUpgrade(String key) &#123; Object obj = null; rl.lock(); try&#123; obj = map.get(key); if (obj == null)&#123; wl.lock(); try&#123; obj = map.get(key); if (obj == null) &#123; obj = getDataFromDB(key); // 伪代码：getDataFromDB map.put(key, obj); &#125; &#125;finally &#123; wl.unlock(); &#125; &#125; &#125;finally &#123; rl.unlock(); &#125; return obj;&#125; 这还真是不可以的，因为获取一个写入锁需要先释放所有的读取锁，如果有两个读取锁试图获取写入锁，且都不释放读取锁时，就会发生死锁，所以在这里，锁的升级是不被允许的 读写锁的升级是不可以的，那么锁的降级是可以的嘛？这个是 Oracle 官网关于锁降级的示例 ，我将代码粘贴在此处，大家有兴趣可以点进去连接看更多内容 1234567891011121314151617181920212223242526272829303132class CachedData &#123; Object data; volatile boolean cacheValid; final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() &#123; rwl.readLock().lock(); if (!cacheValid) &#123; // 必须在获取写锁之前释放读锁，因为锁的升级是不被允许的 rwl.readLock().unlock(); rwl.writeLock().lock(); try &#123; // 再次检查，原因可能是其他线程已经更新过缓存 if (!cacheValid) &#123; data = ... cacheValid = true; &#125; //在释放写锁前，降级为读锁 rwl.readLock().lock(); &#125; finally &#123; //释放写锁，此时持有读锁 rwl.writeLock().unlock(); &#125; &#125; try &#123; use(data); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125;&#125; 代码中声明了一个 volatile 类型的 cacheValid 变量，保证其可见性。 首先获取读锁，如果cache不可用，则释放读锁 然后获取写锁 在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true 然后在释放写锁前获取读锁 此时 cache中数据可用，处理cache中数据，最后释放读锁 这个过程就是一个完整的锁降级的过程，目的是保证数据可见性，听起来很有道理的样子，那么问题来了： 上述代码为什么在释放写锁之前要获取读锁呢？ 如果当前的线程A在修改完cache中的数据后，没有获取读锁而是直接释放了写锁；假设此时另一个线程B 获取了写锁并修改了数据，那么线程A无法感知到数据已被修改，但线程A还应用了缓存数据，所以就可能出现数据错误 如果遵循锁降级的步骤，线程A 在释放写锁之前获取读锁，那么线程B在获取写锁时将被阻塞，直到线程A完成数据处理过程，释放读锁，从而保证数据的可见性 那问题又来了： 使用写锁一定要降级吗？ 如果你理解了上面的问题，相信这个问题已经有了答案。假如线程A修改完数据之后， 经过耗时操作后想要再使用数据时，希望使用的是自己修改后的数据，而不是其他线程修改后的数据，这样的话确实是需要锁降级；如果只是希望最后使用数据的时候，拿到的是最新的数据，而不一定是自己刚修改过的数据，那么先释放写锁，再获取读锁，然后使用数据也无妨 在这里我要额外说明一下你可能存在的误解： 如果已经释放了读锁再获取写锁不叫锁的升级 如果已经释放了写锁在获取读锁也不叫锁的降级 相信你到这里也理解了锁的升级与降级过程，以及他们被允许或被禁止的原因了 总结本文主要说明了 ReentrantReadWriteLock 是如何应用 state 做位拆分实现读/写两种同步状态的，另外也通过源码分析了读/写锁获取同步状态的过程，最后又了解了读写锁的升级/降级机制，相信到这里你对读写锁已经有了一定的理解。如果你对文中的哪些地方觉得理解有些困难，强烈建议你回看本文开头的两篇文章，那里铺垫了非常多的内容。接下来我们就看看在应用AQS的最后一个并发工具类 CountDownLatch 吧 灵魂追问 读锁也没修改数据，还允许共享式获取，那还有必要设置读锁吗？ 在分布式环境中，你是如何保证缓存数据一致性的呢？ 当你打开看ReentrantReadWriteLock源码时，你会发现，WriteLock 中可以使用 Condition，但是ReadLock 使用Condition却会抛出UnsupportedOperationException，这是为什么呢？ 123456789// WriteLockpublic Condition newCondition() &#123; return sync.newCondition();&#125;// ReadLockpublic Condition newCondition() &#123; throw new UnsupportedOperationException();&#125; 参考 Java 并发实战 Java 并发编程的艺术 https://www.jianshu.com/p/58697bb2243e","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"Java AQS共享式获取同步状态及Semaphore的应用分析","slug":"AQS共享式获取同步状态及Semaphore的应用分析","date":"2020-06-13T07:05:28.000Z","updated":"2020-06-14T04:23:39.525Z","comments":true,"path":"/p/java-aqs-acquireshared-and-semaphore.html","link":"","permalink":"https://dayarch.top/p/java-aqs-acquireshared-and-semaphore.html","excerpt":"现陆续将Demo代码和技术文章整理在一起 Github实践精选 ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star🌟 看到本期内容这么少，是不是心动了呢？ 前言 上一篇万字长文 Java AQS队列同步器以及ReentrantLock的应用 为我们读 JUC 源码以及其设计思想做了足够多的铺垫，接下来的内容我将重点说明差异化，如果有些童鞋不是能很好的理解文中的一些内容，强烈建议回看上一篇文章，搞懂基础内容，接下来的阅读真会轻松加愉快 AQS 中我们介绍了独占式获取同步状态的多种情形： * 独占式获取锁 * 可响应中断的独占式获取锁 * 有超时限制的独占式获","text":"现陆续将Demo代码和技术文章整理在一起 Github实践精选 ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star🌟 看到本期内容这么少，是不是心动了呢？ 前言上一篇万字长文 Java AQS队列同步器以及ReentrantLock的应用 为我们读 JUC 源码以及其设计思想做了足够多的铺垫，接下来的内容我将重点说明差异化，如果有些童鞋不是能很好的理解文中的一些内容，强烈建议回看上一篇文章，搞懂基础内容，接下来的阅读真会轻松加愉快 AQS 中我们介绍了独占式获取同步状态的多种情形： 独占式获取锁 可响应中断的独占式获取锁 有超时限制的独占式获取锁 AQS 提供的模版方法里面还差共享式获取同步状态没有介绍，所以我们今天来揭开这个看似神秘的面纱 AQS 中的共享式获取同步状态独占式是你中没我，我中没你的的一种互斥形式，共享式显然就不是这样了，所以他们的唯一区别就是： 同一时刻能否有多个线程同时获取到同步状态 简单来说，就是这样滴： 我们知道同步状态 state 是维护在 AQS 中的，抛开可重入锁的概念，我在上篇文章中也提到了，独占式和共享式控制同步状态 state 的区别仅仅是这样： 所以说想了解 AQS 的 xxxShared 的模版方法，只需要知道它是怎么控制 state 的就好了 AQS共享式获取同步状态源码分析为了帮助大家更好的回忆内容，我将上一篇文章的两个关键内容粘贴在此处，帮助大家快速回忆，关于共享式，大家只需要关注【骚紫色】就可以了 自定义同步器需要重写的方法 AQS 提供的模版方法 故事就从这里说起吧 (你会发现和独占式惊人的相似)，关键代码都加了注释 123456public final void acquireShared(int arg) &#123; // 同样调用自定义同步器需要重写的方法，非阻塞式的尝试获取同步状态，如果结果小于零，则获取同步状态失败 if (tryAcquireShared(arg) &lt; 0) // 调用 AQS 提供的模版方法，进入等待队列 doAcquireShared(arg);&#125; 进入 doAcquireShared 方法： 12345678910111213141516171819202122232425262728293031323334private void doAcquireShared(int arg) &#123; // 创建共享节点「SHARED」，加到等待队列中 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; // 进入“自旋”，这里并不是纯粹意义上的死循环，在独占式已经说明过 for (;;) &#123; // 同样尝试获取当前节点的前驱节点 final Node p = node.predecessor(); // 如果前驱节点为头节点，尝试再次获取同步状态 if (p == head) &#123; // 在此以非阻塞式获取同步状态 int r = tryAcquireShared(arg); // 如果返回结果大于等于零，才能跳出外层循环返回 if (r &gt;= 0) &#123; // 这里是和独占式的区别 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 上面代码第 18 行我们提到和独占式获取同步状态的区别，贴心的给大家一个更直观的对比： 差别只在这里，所以我们就来看看 setHeadAndPropagate(node, r) 到底干了什么，我之前说过 JDK 源码中的方法命名绝大多数还是非常直观的，该方法直译过来就是 【设置头并且传播/繁衍】。独占式只是设置了头，共享式除了设置头还多了一个传播，你的疑问应该已经来了： 啥是传播，为什么会有传播这个设置呢？ 想了解这个问题，你需要先知道非阻塞共享式获取同步状态返回值的含义： 这里说的传播其实说的是 propagate &gt; 0 的情况，道理也很简单，当前线程获取同步状态成功了，还有剩余的同步状态可用于其他线程获取，那就要通知在等待队列的线程，让他们尝试获取剩余的同步状态 如果要让等待队列中的线程获取到通知，需要线程调用 release 方法实现的。接下来，我们走近 setHeadAndPropagate 一探究竟，验证一下 123456789101112131415161718 // 入参，node： 当前节点// 入参，propagate：获取同步状态的结果值，即上面方法中的变量 rprivate void setHeadAndPropagate(Node node, int propagate) &#123; // 记录旧的头部节点，用于下面的check Node h = head; // 将当前节点设置为头节点 setHead(node); // 通过 propagate 的值和 waitStatus 的值来判断是否可以调用 doReleaseShared 方法 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 如果后继节点为空或者后继节点为共享类型，则进行唤醒后继节点 // 这里后继节点为空意思是只剩下当前头节点了，另外这里的 s == null 也是判断空指针的标准写法 if (s == null || s.isShared()) doReleaseShared(); &#125; &#125; 上面方法的大方向作用我们了解了，但是代码中何时调用 doReleaseShared 的判断逻辑还是挺让人费解的，为什么会有这么一大堆的判断，我们来逐个分析一下： 这里的空判断有点让人头大，我们先挑出来说明一下： 排除了其他判断条件的干扰，接下来我们就专注分析 propagate 和 waitStatus 两个判断条件就可以了，这里再将 waitStatus 的几种状态展示在这里，帮助大家理解，【骚粉色】是我们一会要用到的： propagate &gt; 0 上面已经说过了，如果成立，直接短路后续判断，然后根据 doReleaseShared 的判断条件进行释放 propagate &gt; 0 不成立， h.waitStatus &lt; 0 成立 （注意这里的h是旧的头节点） 什么时候 h.waitStatus &lt; 0 呢？抛开 CONDITION 的使用，只剩下 SIGNAL 和 PROPAGATE，想知道这个答案，需要提前看一下 doReleaseShared() 方法了： 123456789101112131415161718192021private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; // CAS 将头节点的状态设置为0 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // 设置成功后才能跳出循环唤醒头节点的下一个节点 unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; // 将头节点状态CAS设置成 PROPAGATE 状态 !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 从 doReleaseShared() 方法中可以看出： 如果让 h.waitStatus &lt; 0 成立，只能将其设置成 PROPAGATE = -3 的情况，设置成功的前提是 h 头节点 expected 的状态是 0； 如果 h.waitStatus = 0，是上述代码第 8 行 CAS 设置成功，然后唤醒等待中的线程 所以猜测，当前线程执行到 h.waitStatus &lt; 0 的判断前，有另外一个线程刚好执行了 doReleaseShared() 方法，将 waitStatus 又设置成PROPAGATE = -3 这个理解有点绕，我们还是来画个图理解一下吧： 可能有同学还是不太能理解这么写的道理，我们一直说 propagate &lt;&gt; = 0 的情况，propagate = 0 代表的是当时/当时/当时 尝试获取同步状态没成功，但是之后可能又有共享状态被释放了，所以上面的逻辑是以防这种万一，你懂的，严谨的并发就是要防止一切万一，现在结合这个情景再来理解上面的判断你是否豁然开朗了呢？ 继续向下看， 前序条件不成立，(h = head) == null || h.waitStatus &lt; 0 注意这里的h是新的头节点） 有了上面铺垫，这个就直接画个图就更好理解啦，其实就是没有那么巧有另外一个线程掺合了 相信到这里你应该理解共享式获取同步状态的全部过程了吧，至于非阻塞共享式获取同步状态和带有超时时间获取同步状态，结合本文讲的 setHeadAndPropagate 逻辑和独占式获取同步状态的实现过程过程来看，真是一毛一样，这里就不再累述了，赶紧打开你的 IDE 去验证一下吧 我们分析了AQS 的模版方法，还一直没说 tryAcquireShared(arg) 这个方法是如何被重写的，想要了解这个，我们就来看一看共享式获取同步状态的经典应用 Semaphore Semaphore 的应用及源码分析Semaphore 概念Semaphore 中文多翻译为 【信号量】，我还特意查了一下剑桥辞典的英文解释： 其实就是信号标志（two flags），比如红绿灯，每个交通灯产生两种不同行为 Flag1-红灯：停车 Flag2-绿灯：行车 在 Semaphore 里面，什么时候是红灯，什么时候是绿灯，其实就是靠 tryAcquireShared(arg) 的结果来表示的 获取不到共享状态，即为红灯 获取到共享状态，即为绿灯 所以我们走近 Semaphore ，来看看它到底是怎么应用 AQS 的，又是怎样重写 tryAcquireShared(arg) 方法的 Semaphore 源码分析先看一下类结构 看到这里你是否有点跌眼镜，和 ReentrantLock 相似的可怕吧，如果你有些陌生，再次强烈建议你回看上一篇文章 Java AQS队列同步器以及ReentrantLock的应用 ，这里直接提速对比看公平和非公平两种重写的 tryAcquireShared(arg) 方法，没有意外，公平与否，就是判断是否有前驱节点 方法内部只是计算 state 的剩余值，那 state 的初始值是多少怎么设置呢？当然也就是构造方法了： 12345678public Semaphore(int permits) &#123; // 默认仍是非公平的同步器，至于为什么默认是非公平的，在上一篇文章中也特意说明过 sync = new NonfairSync(permits); &#125; NonfairSync(int permits) &#123; super(permits); &#125; super 方法，就会将初始值给到 AQS 中的 state 也许你发现了，当我们把 permits 设置为1 的时候，不就是 ReentrantLock 的互斥锁了嘛，说的一点也没错，我们用 Semaphore 也能实现基本互斥锁的效果 1234567891011121314static int count;//初始化信号量static final Semaphore s = new Semaphore(1);//用信号量保证互斥 static void addOne() &#123; s.acquire(); try &#123; count+=1; &#125; finally &#123; s.release(); &#125;&#125; But（英文听力中的重点），Semaphore 肯定不是为这种特例存在的，它是共享式获取同步状态的一种实现。如果使用信号量，我们通常会将 permits 设置成大于1的值，不知道你是否还记得我曾在 为什么要使用线程池? 一文中说到的池化概念，在同一时刻，允许多个线程使用连接池，每个连接被释放之前，不允许其他线程使用。所以说 Semaphore 可以允许多个线程访问一个临界区，最终很好的做到一个限流/限流/限流 的作用 虽然 Semaphore 能很好的提供限流作用，说实话，Semaphore 的限流作用比较单一，我在实际工作中使用 Semaphore 并不是很多，如果真的要用高性能限流器，Guava RateLimiter 是一个非常不错的选择，我们后面会做分析，有兴趣的可以提前了解一下 关于 Semaphore 源码，就这么三下五除二的结束了 总结不知你有没有感觉到，我们的节奏明显加快了，好多原来分散的点在被疯狂的串联起来，如果按照这个方式来阅读 JUC 源码，相信你也不会一头扎进去迷失方向，然后沮丧的退出 JUC 吧，然后面试背诵答案，然后忘记，然后再背诵？ 跟上节奏，关于共享式获取同步状态，Semaphore 只不过是非常经典的应用，ReadWriteLock 和 CountDownLatch 日常应用还是非常广泛的，我们接下来就陆续聊聊它们吧 灵魂追问 Semaphore 的 permits 设置成1 “等同于” 简单的互斥锁实现，那它和 ReentrantLock 的区别还是挺大的，都有哪些区别呢？ 你在项目中是如何使用 Semaphore 的呢？ 参考 Java 并发实战 Java 并发编程的艺术 https://blog.csdn.net/anlian523/article/details/106319294","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"Java AQS队列同步器以及ReentrantLock的应用","slug":"Java-AQS队列同步器以及ReentrantLock的应用","date":"2020-05-31T12:26:08.000Z","updated":"2020-06-02T11:41:19.518Z","comments":true,"path":"/p/java-aqs-and-reentrantlock.html","link":"","permalink":"https://dayarch.top/p/java-aqs-and-reentrantlock.html","excerpt":"写在前面 进入源码阶段了，写了十几篇的 并发系列 知识铺垫终于要派上用场了。相信很多人已经忘了其中的一些理论知识，别担心，我会在源码环节带入相应的理论知识点帮助大家回忆，做到理论与实践相结合，另外这是超长图文，建议收藏，如果对你有用还请点赞让更多人看到 Java SDK 为什么要设计 Lock 曾几何时幻想过，如果 Java 并发控制只有 synchronized 多好，只有下面三种使用方式，简单方便 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ThreeSync { private static fina","text":"写在前面进入源码阶段了，写了十几篇的 并发系列 知识铺垫终于要派上用场了。相信很多人已经忘了其中的一些理论知识，别担心，我会在源码环节带入相应的理论知识点帮助大家回忆，做到理论与实践相结合，另外这是超长图文，建议收藏，如果对你有用还请点赞让更多人看到 Java SDK 为什么要设计 Lock曾几何时幻想过，如果 Java 并发控制只有 synchronized 多好，只有下面三种使用方式，简单方便 123456789101112131415161718public class ThreeSync &#123; private static final Object object = new Object(); public synchronized void normalSyncMethod()&#123; //临界区 &#125; public static synchronized void staticSyncMethod()&#123; //临界区 &#125; public void syncBlockMethod()&#123; synchronized (object)&#123; //临界区 &#125; &#125;&#125; 如果在 Java 1.5之前，确实是这样，自从 1.5 版本 Doug Lea 大师就重新造了一个轮子 Lock 我们常说：“避免重复造轮子”，如果有了轮子还是要坚持再造个轮子，那么肯定传统的轮子在某些应用场景中不能很好的解决问题 不知你是否还记得 Coffman 总结的四个可以发生死锁的情形 ，其中【不可剥夺条件】是指： 线程已经获得资源，在未使用完之前，不能被剥夺，只能在使用完时自己释放 要想破坏这个条件，就需要具有申请不到进一步资源就释放已有资源的能力 很显然，这个能力是 synchronized 不具备的，使用 synchronized ，如果线程申请不到资源就会进入阻塞状态，我们做什么也改变不了它的状态，这是 synchronized 轮子的致命弱点，这就强有力的给了重造轮子 Lock 的理由 显式锁 Lock旧轮子有弱点，新轮子就要解决这些问题，所以要具备不会阻塞的功能，下面的三个方案都是解决这个问题的好办法（看下面表格描述你就明白三个方案的含义了） 特性 描述 API 能响应中断 如果不能自己释放，那可以响应中断也是很好的。Java多线程中断机制 专门描述了中断过程，目的是通过中断信号来跳出某种状态，比如阻塞 lockInterruptbly() 非阻塞式的获取锁 尝试获取，获取不到不会阻塞，直接返回 tryLock() 支持超时 给定一个时间限制，如果一段时间内没获取到，不是进入阻塞状态，同样直接返回 tryLock(long time, timeUnit) 好的方案有了，但鱼和熊掌不可兼得，Lock 多了 synchronized 不具备的特性，自然不会像 synchronized 那样一个关键字三个玩法走遍全天下，在使用上也相对复杂了一丢丢 Lock 使用范式synchronized 有标准用法，这样的优良传统咱 Lock 也得有，相信很多人都知道使用 Lock 的一个范式 1234567Lock lock = new ReentrantLock();lock.lock();try&#123; ...&#125;finally&#123; lock.unlock();&#125; 既然是范式（没事不要挑战更改写法的那种），肯定有其理由，我们来看一下 标准1—finally 中释放锁这个大家应该都会明白，在 finally 中释放锁，目的是保证在获取到锁之后，最终能被释放 标准2—在 try{} 外面获取锁不知道你有没有想过，为什么会有标准 2 的存在，我们通常是“喜欢” try 住所有内容，生怕发生异常不能捕获的 在 try{} 外获取锁主要考虑两个方面： 如果没有获取到锁就抛出异常，最终释放锁肯定是有问题的，因为还未曾拥有锁谈何释放锁呢 如果在获取锁时抛出了异常，也就是当前线程并未获取到锁，但执行到 finally 代码时，如果恰巧别的线程获取到了锁，则会被释放掉（无故释放） 不同锁的实现方式略有不同，范式的存在就是要避免一切问题的出现，所以大家尽量遵守范式 Lock 是怎样起到锁的作用呢？如果你熟悉 synchronized，你知道程序编译成 CPU 指令后，在临界区会有 moniterenter 和 moniterexit 指令的出现，可以理解成进出临界区的标识 从范式上来看： lock.lock() 获取锁，“等同于” synchronized 的 moniterenter指令 lock.unlock() 释放锁，“等同于” synchronized 的 moniterexit 指令 那 Lock 是怎么做到的呢？ 这里先简单说明一下，这样一会到源码分析时，你可以远观设计轮廓，近观实现细节，会变得越发轻松 其实很简单，比如在 ReentrantLock 内部维护了一个 volatile 修饰的变量 state，通过 CAS 来进行读写（最底层还是交给硬件来保证原子性和可见性），如果CAS更改成功，即获取到锁，线程进入到 try 代码块继续执行；如果没有更改成功，线程会被【挂起】，不会向下执行 但 Lock 是一个接口，里面根本没有 state 这个变量的存在： 它怎么处理这个 state 呢？很显然需要一点设计的加成了，接口定义行为，具体都是需要实现类的 Lock 接口的实现类基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的 那什么是队列同步器呢？ （这应该是你见过的最强标题党，聊了半个世纪才入正题，评论区留言骂我） 队列同步器 AQS队列同步器 （AbstractQueuedSynchronizer），简称同步器或AQS，就是我们今天的主人公 问：为什么你分析 JUC 源码，要从 AQS 说起呢？ 答：看下图 相信看到这个截图你就明白一二了，你听过的，面试常被问起的，工作中常用的 ReentrantLock ReentrantReadWriteLock Semaphore(信号量) CountDownLatch 公平锁 非公平锁 ThreadPoolExecutor (关于线程池的理解，可以查看 为什么要使用线程池? ) 都和 AQS 有直接关系，所以了解 AQS 的抽象实现，在此基础上再稍稍查看上述各类的实现细节，很快就可以全部搞定，不至于查看源码时一头雾水，丢失主线 上面提到，在锁的实现类中会聚合同步器，然后利同步器实现锁的语义，那么问题来了： 为什么要用聚合模式，怎么进一步理解锁和同步器的关系呢？ 我们绝大多数都是在使用锁，实现锁之后，其核心就是要使用方便 从 AQS 的类名称和修饰上来看，这是一个抽象类，所以从设计模式的角度来看同步器一定是基于【模版模式】来设计的，使用者需要继承同步器，实现自定义同步器，并重写指定方法，随后将同步器组合在自定义的同步组件中，并调用同步器的模版方法，而这些模版方法又回调用使用者重写的方法 我不想将上面的解释说的这么抽象，其实想理解上面这句话，我们只需要知道下面两个问题就好了 哪些是自定义同步器可重写的方法？ 哪些是抽象同步器提供的模版方法？ 同步器可重写的方法同步器提供的可重写方法只有5个，这大大方便了锁的使用者： 按理说，需要重写的方法也应该有 abstract 来修饰的，为什么这里没有？原因其实很简单，上面的方法我已经用颜色区分成了两类： 独占式 共享式 自定义的同步组件或者锁不可能既是独占式又是共享式，为了避免强制重写不相干方法，所以就没有 abstract 来修饰了，但要抛出异常告知不能直接使用该方法： 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 暖暖的很贴心（如果你有类似的需求也可以仿照这样的设计） 表格方法描述中所说的同步状态就是上文提到的有 volatile 修饰的 state，所以我们在重写上面几个方法时，还要通过同步器提供的下面三个方法（AQS 提供的）来获取或修改同步状态： 而独占式和共享式操作 state 变量的区别也就很简单了 所以你看到的 ReentrantLock ReentrantReadWriteLock Semaphore(信号量) CountDownLatch 这几个类其实仅仅是在实现以上几个方法上略有差别，其他的实现都是通过同步器的模版方法来实现的，到这里是不是心情放松了许多呢？我们来看一看模版方法： 同步器提供的模版方法上面我们将同步器的实现方法分为独占式和共享式两类，模版方法其实除了提供以上两类模版方法之外，只是多了响应中断和超时限制 的模版方法供 Lock 使用，来看一下 先不用记上述方法的功能，目前你只需要了解个大概功能就好。另外，相信你也注意到了： 上面的方法都有 final 关键字修饰，说明子类不能重写这个方法 看到这你也许有点乱了，我们稍微归纳一下： 程序员还是看代码心里踏实一点，我们再来用代码说明一下上面的关系（注意代码中的注释，以下的代码并不是很严谨，只是为了简单说明上图的代码实现）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package top.dayarch.myjuc;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * 自定义互斥锁 * * @author tanrgyb * @date 2020/5/23 9:33 PM */public class MyMutex implements Lock &#123; // 静态内部类-自定义同步器 private static class MySync extends AbstractQueuedSynchronizer&#123; @Override protected boolean tryAcquire(int arg) &#123; // 调用AQS提供的方法，通过CAS保证原子性 if (compareAndSetState(0, arg))&#123; // 我们实现的是互斥锁，所以标记获取到同步状态（更新state成功）的线程， // 主要为了判断是否可重入（一会儿会说明） setExclusiveOwnerThread(Thread.currentThread()); //获取同步状态成功，返回 true return true; &#125; // 获取同步状态失败，返回 false return false; &#125; @Override protected boolean tryRelease(int arg) &#123; // 未拥有锁却让释放，会抛出IMSE if (getState() == 0)&#123; throw new IllegalMonitorStateException(); &#125; // 可以释放，清空排它线程标记 setExclusiveOwnerThread(null); // 设置同步状态为0，表示释放锁 setState(0); return true; &#125; // 是否独占式持有 @Override protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // 后续会用到，主要用于等待/通知机制，每个condition都有一个与之对应的条件等待队列，在锁模型中说明过 Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; // 聚合自定义同步器 private final MySync sync = new MySync(); @Override public void lock() &#123; // 阻塞式的获取锁，调用同步器模版方法独占式，获取同步状态 sync.acquire(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; // 调用同步器模版方法可中断式获取同步状态 sync.acquireInterruptibly(1); &#125; @Override public boolean tryLock() &#123; // 调用自己重写的方法，非阻塞式的获取同步状态 return sync.tryAcquire(1); &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; // 调用同步器模版方法，可响应中断和超时时间限制 return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; // 释放锁 sync.release(1); &#125; @Override public Condition newCondition() &#123; // 使用自定义的条件 return sync.newCondition(); &#125;&#125; 如果你现在打开 IDE， 你会发现上文提到的 ReentrantLock ReentrantReadWriteLock Semaphore(信号量) CountDownLatch 都是按照这个结构实现，所以我们就来看一看 AQS 的模版方法到底是怎么实现锁 AQS实现分析从上面的代码中，你应该理解了lock.tryLock() 非阻塞式获取锁就是调用自定义同步器重写的 tryAcquire() 方法，通过 CAS 设置state 状态，不管成功与否都会马上返回；那么 lock.lock() 这种阻塞式的锁是如何实现的呢？ 有阻塞就需要排队，实现排队必然需要队列 CLH：Craig、Landin and Hagersten 队列，是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO）——概念了解就好，不要记 队列中每个排队的个体就是一个 Node，所以我们来看一下 Node 的结构 Node 节点AQS 内部维护了一个同步队列，用于管理同步状态。 当线程获取同步状态失败时，就会将当前线程以及等待状态等信息构造成一个 Node 节点，将其加入到同步队列中尾部，阻塞该线程 当同步状态被释放时，会唤醒同步队列中“首节点”的线程获取同步状态 为了将上述步骤弄清楚，我们需要来看一看 Node 结构 （如果你能打开 IDE 一起看那是极好的） 乍一看有点杂乱，我们还是将其归类说明一下： 上面这几个状态说明有个印象就好，有了Node 的结构说明铺垫，你也就能想象同步队列的接本结构了： 前置知识基本铺垫完毕，我们来看一看独占式获取同步状态的整个过程 独占式获取同步状态故事要从范式lock.lock() 开始 1234public void lock() &#123; // 阻塞式的获取锁，调用同步器模版方法，获取同步状态 sync.acquire(1);&#125; 进入AQS的模版方法 acquire() 123456public final void acquire(int arg) &#123; // 调用自定义同步器重写的 tryAcquire 方法 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 首先，也会尝试非阻塞的获取同步状态，如果获取失败（tryAcquire返回false），则会调用 addWaiter 方法构造 Node 节点（Node.EXCLUSIVE 独占式）并安全的（CAS）加入到同步队列【尾部】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Node addWaiter(Node mode) &#123; // 构造Node节点，包含当前线程信息以及节点模式【独占/共享】 Node node = new Node(Thread.currentThread(), mode); // 新建变量 pred 将指针指向tail指向的节点 Node pred = tail; // 如果尾节点不为空 if (pred != null) &#123; // 新加入的节点前驱节点指向尾节点 node.prev = pred; // 因为如果多个线程同时获取同步状态失败都会执行这段代码 // 所以，通过 CAS 方式确保安全的设置当前节点为最新的尾节点 if (compareAndSetTail(pred, node)) &#123; // 曾经的尾节点的后继节点指向当前节点 pred.next = node; // 返回新构建的节点 return node; &#125; &#125; // 尾节点为空，说明当前节点是第一个被加入到同步队列中的节点 // 需要一个入队操作 enq(node); return node;&#125;private Node enq(final Node node) &#123; // 通过“死循环”确保节点被正确添加，最终将其设置为尾节点之后才会返回，这里使用 CAS 的理由和上面一样 for (;;) &#123; Node t = tail; // 第一次循环，如果尾节点为 null if (t == null) &#123; // Must initialize // 构建一个哨兵节点，并将头部指针指向它 if (compareAndSetHead(new Node())) // 尾部指针同样指向哨兵节点 tail = head; &#125; else &#123; // 第二次循环，将新节点的前驱节点指向t node.prev = t; // 将新节点加入到队列尾节点 if (compareAndSetTail(t, node)) &#123; // 前驱节点的后继节点指向当前新节点，完成双向队列 t.next = node; return t; &#125; &#125; &#125;&#125; 你可能比较迷惑 enq() 的处理方式，进入该方法就是一个“死循环”，我们就用图来描述它是怎样跳出循环的 有些同学可能会有疑问，为什么会有哨兵节点？ 哨兵，顾名思义，是用来解决国家之间边界问题的，不直接参与生产活动。同样，计算机科学中提到的哨兵，也用来解决边界问题，如果没有边界，指定环节，按照同样算法可能会在边界处发生异常，比如要继续向下分析的 acquireQueued() 方法 123456789101112131415161718192021222324252627282930final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; // \"死循环\"，尝试获取锁，或者挂起 for (;;) &#123; // 获取当前节点的前驱节点 final Node p = node.predecessor(); // 只有当前节点的前驱节点是头节点，才会尝试获取锁 // 看到这你应该理解添加哨兵节点的含义了吧 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 获取同步状态成功，将自己设置为头 setHead(node); // 将哨兵节点的后继节点置为空，方便GC p.next = null; // help GC failed = false; // 返回中断标识 return interrupted; &#125; // 当前节点的前驱节点不是头节点 //【或者】当前节点的前驱节点是头节点但获取同步状态失败 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 获取同步状态成功会返回可以理解了，但是如果失败就会一直陷入到“死循环”中浪费资源吗？很显然不是，shouldParkAfterFailedAcquire(p, node) 和 parkAndCheckInterrupt() 就会将线程获取同步状态失败的线程挂起，我们继续向下看 123456789101112131415161718192021private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 获取前驱节点的状态 int ws = pred.waitStatus; // 如果是 SIGNAL 状态，即等待被占用的资源释放，直接返回 true // 准备继续调用 parkAndCheckInterrupt 方法 if (ws == Node.SIGNAL) return true; // ws 大于0说明是CANCELLED状态， if (ws &gt; 0) &#123; // 循环判断前驱节点的前驱节点是否也为CANCELLED状态，忽略该状态的节点，重新连接队列 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 将当前节点的前驱节点设置为设置为 SIGNAL 状态，用于后续唤醒操作 // 程序第一次执行到这返回为false，还会进行外层第二次循环，最终从代码第7行返回 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 到这里你也许有个问题： 这个地方设置前驱节点为 SIGNAL 状态到底有什么作用？ 保留这个问题，我们陆续揭晓 如果前驱节点的 waitStatus 是 SIGNAL状态，即 shouldParkAfterFailedAcquire 方法会返回 true ，程序会继续向下执行 parkAndCheckInterrupt 方法，用于将当前线程挂起 123456789101112private final boolean parkAndCheckInterrupt() &#123; // 线程挂起，程序不会继续向下执行 LockSupport.park(this); // 根据 park 方法 API描述，程序在下述三种情况会继续向下执行 // 1. 被 unpark // 2. 被中断(interrupt) // 3. 其他不合逻辑的返回才会继续向下执行 // 因上述三种情况程序执行至此，返回当前线程的中断状态，并清空中断状态 // 如果由于被中断，该方法会返回 true return Thread.interrupted();&#125; 被唤醒的程序会继续执行 acquireQueued 方法里的循环，如果获取同步状态成功，则会返回 interrupted = true 的结果 程序继续向调用栈上层返回，最终回到 AQS 的模版方法 acquire 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 你也许会有疑惑: 程序已经成功获取到同步状态并返回了，怎么会有个自我中断呢？ 123static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 如果你不能理解中断，强烈建议你回看 Java多线程中断机制 到这里关于获取同步状态我们还遗漏了一条线，acquireQueued 的 finally 代码块如果你仔细看你也许马上就会有疑惑: 到底什么情况才会执行 if(failed) 里面的代码 ？ 12if (failed) cancelAcquire(node); 这段代码被执行的条件是 failed 为 true，正常情况下，如果跳出循环，failed 的值为false，如果不能跳出循环貌似怎么也不能执行到这里，所以只有不正常的情况才会执行到这里，也就是会发生异常，才会执行到此处 查看 try 代码块，只有两个方法会抛出异常： node.processor() 方法 自己重写的 tryAcquire() 方法 先看前者： 很显然，这里抛出的异常不是重点，那就以 ReentrantLock 重写的 tryAcquire() 方法为例 另外，上面分析 shouldParkAfterFailedAcquire 方法还对 CANCELLED 的状态进行了判断，那么 什么时候会生成取消状态的节点呢？ 答案就在 cancelAcquire 方法中， 我们来看看 cancelAcquire到底怎么设置/处理 CANNELLED 的 12345678910111213141516171819202122232425262728293031323334353637383940414243private void cancelAcquire(Node node) &#123; // 忽略无效节点 if (node == null) return; // 将关联的线程信息清空 node.thread = null; // 跳过同样是取消状态的前驱节点 Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // 跳出上面循环后找到前驱有效节点，并获取该有效节点的后继节点 Node predNext = pred.next; // 将当前节点的状态置为 CANCELLED node.waitStatus = Node.CANCELLED; // 如果当前节点处在尾节点，直接从队列中删除自己就好 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; int ws; // 1. 如果当前节点的有效前驱节点不是头节点，也就是说当前节点不是头节点的后继节点 if (pred != head &amp;&amp; // 2. 判断当前节点有效前驱节点的状态是否为 SIGNAL ((ws = pred.waitStatus) == Node.SIGNAL || // 3. 如果不是，尝试将前驱节点的状态置为 SIGNAL (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; // 判断当前节点有效前驱节点的线程信息是否为空 pred.thread != null) &#123; // 上述条件满足 Node next = node.next; // 将当前节点有效前驱节点的后继节点指针指向当前节点的后继节点 if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; // 如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点 unparkSuccessor(node); &#125; node.next = node; // help GC &#125; 看到这个注释你可能有些乱了，其核心目的就是从等待队列中移除 CANCELLED 的节点，并重新拼接整个队列，总结来看，其实设置 CANCELLED 状态节点只是有三种情况，我们通过画图来分析一下： 至此，获取同步状态的过程就结束了，我们简单的用流程图说明一下整个过程 获取锁的过程就这样的结束了，先暂停几分钟整理一下自己的思路。我们上面还没有说明 SIGNAL 的作用， SIGNAL 状态信号到底是干什么用的？这就涉及到锁的释放了，我们来继续了解，整体思路和锁的获取是一样的， 但是释放过程就相对简单很多了 独占式释放同步状态故事要从 unlock() 方法说起 1234public void unlock() &#123; // 释放锁 sync.release(1);&#125; 调用 AQS 模版方法 release，进入该方法 1234567891011121314public final boolean release(int arg) &#123; // 调用自定义同步器重写的 tryRelease 方法尝试释放同步状态 if (tryRelease(arg)) &#123; // 释放成功，获取头节点 Node h = head; // 存在头节点，并且waitStatus不是初始状态 // 通过获取的过程我们已经分析了，在获取的过程中会将 waitStatus的值从初始状态更新成 SIGNAL 状态 if (h != null &amp;&amp; h.waitStatus != 0) // 解除线程挂起状态 unparkSuccessor(h); return true; &#125; return false;&#125; 查看 unparkSuccessor 方法，实际是要唤醒头节点的后继节点 12345678910111213141516171819202122private void unparkSuccessor(Node node) &#123; // 获取头节点的waitStatus int ws = node.waitStatus; if (ws &lt; 0) // 清空头节点的waitStatus值，即置为0 compareAndSetWaitStatus(node, ws, 0); // 获取头节点的后继节点 Node s = node.next; // 判断当前节点的后继节点是否是取消状态，如果是，需要移除，重新连接队列 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从尾节点向前查找，找到队列第一个waitStatus状态小于0的节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 如果是独占式，这里小于0，其实就是 SIGNAL if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) // 解除线程挂起状态 LockSupport.unpark(s.thread);&#125; 有同学可能有疑问： 为什么这个地方是从队列尾部向前查找不是 CANCELLED 的节点？ 原因有两个： 第一，先回看节点加入队列的情景： 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 节点入队并不是原子操作，代码第6、7行 12node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作是尾节点入队的原子操作，如果此时代码还没执行到 pred.next = node; 这时又恰巧执行了unparkSuccessor方法，就没办法从前往后找了，因为后继指针还没有连接起来，所以需要从后往前找 第二点原因，在上面图解产生 CANCELLED 状态节点的时候，先断开的是 Next 指针，Prev指针并未断开，因此这也是必须要从后往前遍历才能够遍历完全部的Node 同步状态至此就已经成功释放了，之前获取同步状态被挂起的线程就会被唤醒，继续从下面代码第 3 行返回执行： 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 继续返回上层调用栈, 从下面代码15行开始执行，重新执行循环，再次尝试获取同步状态 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 到这里，关于独占式获取/释放锁的流程已经闭环了，但是关于 AQS 的另外两个模版方法还没有介绍 响应中断 超时限制 独占式响应中断获取同步状态故事要从lock.lockInterruptibly() 方法说起 1234public void lockInterruptibly() throws InterruptedException &#123; // 调用同步器模版方法可中断式获取同步状态 sync.acquireInterruptibly(1);&#125; 有了前面的理解，理解独占式可响应中断的获取同步状态方式，真是一眼就能明白了： 12345678public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 尝试非阻塞式获取同步状态失败，如果没有获取到同步状态，执行代码7行 if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; 继续查看 doAcquireInterruptibly 方法： 1234567891011121314151617181920212223private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 获取中断信号后，不再返回 interrupted = true 的值，而是直接抛出 InterruptedException throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 没想到 JDK 内部也有如此相近的代码，可响应中断获取锁没什么深奥的，就是被中断抛出 InterruptedException 异常（代码第17行），这样就逐层返回上层调用栈捕获该异常进行下一步操作了 趁热打铁，来看看另外一个模版方法： 独占式超时限制获取同步状态这个很好理解，就是给定一个时限，在该时间段内获取到同步状态，就返回 true， 否则，返回 false。好比线程给自己定了一个闹钟，闹铃一响，线程就自己返回了，这就不会使自己是阻塞状态了 既然涉及到超时限制，其核心逻辑肯定是计算时间间隔，因为在超时时间内，肯定是多次尝试获取锁的，每次获取锁肯定有时间消耗，所以计算时间间隔的逻辑就像我们在程序打印程序耗时 log 那么简单 nanosTimeout = deadline - System.nanoTime() 故事要从 lock.tryLock(time, unit) 方法说起 1234public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; // 调用同步器模版方法，可响应中断和超时时间限制 return sync.tryAcquireNanos(1, unit.toNanos(time));&#125; 来看 tryAcquireNanos 方法 1234567public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; 是不是和上面 acquireInterruptibly 方法长相很详细了，继续查看来 doAcquireNanos 方法，看程序, 该方法也是 throws InterruptedException，我们在中断文章中说过，方法标记上有 throws InterruptedException 说明该方法也是可以响应中断的，所以你可以理解超时限制是 acquireInterruptibly 方法的加强版，具有超时和非阻塞控制的双保险 12345678910111213141516171819202122232425262728293031323334353637private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; // 超时时间内，为获取到同步状态，直接返回false if (nanosTimeout &lt;= 0L) return false; // 计算超时截止时间 final long deadline = System.nanoTime() + nanosTimeout; // 以独占方式加入到同步队列中 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; // 计算新的超时时间 nanosTimeout = deadline - System.nanoTime(); // 如果超时，直接返回 false if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // 判断是最新超时时间是否大于阈值 1000 nanosTimeout &gt; spinForTimeoutThreshold) // 挂起线程 nanosTimeout 长时间，时间到，自动返回 LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 上面的方法应该不是很难懂，但是又同学可能在第 27 行上有所困惑 为什么 nanosTimeout 和 自旋超时阈值1000进行比较？ 123456/** * The number of nanoseconds for which it is faster to spin * rather than to use timed park. A rough estimate suffices * to improve responsiveness with very short timeouts. */static final long spinForTimeoutThreshold = 1000L; 其实 doc 说的很清楚，说白了，1000 nanoseconds 时间已经非常非常短暂了，没必要再执行挂起和唤醒操作了，不如直接当前线程直接进入下一次循环 到这里，我们自定义的 MyMutex 只差 Condition 没有说明了，不知道你累了吗？我还在坚持 Condition如果你看过之前写的 并发编程之等待通知机制 ，你应该对下面这个图是有印象的： 如果当时你理解了这个模型，再看 Condition 的实现，根本就不是问题了，首先 Condition 还是一个接口，肯定也是需要有实现类的 那故事就从 lock.newnewCondition 说起吧 1234public Condition newCondition() &#123; // 使用自定义的条件 return sync.newCondition();&#125; 自定义同步器重封装了该方法： 123Condition newCondition() &#123; return new ConditionObject();&#125; ConditionObject 就是 Condition 的实现类，该类就定义在了 AQS 中，只有两个成员变量： 1234/** First node of condition queue. */private transient Node firstWaiter;/** Last node of condition queue. */private transient Node lastWaiter; 所以，我们只需要来看一下 ConditionObject 实现的 await / signal 方法来使用这两个成员变量就可以了 123456789101112131415161718192021public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); // 同样构建 Node 节点，并加入到等待队列中 Node node = addConditionWaiter(); // 释放同步状态 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; // 挂起当前线程 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 这里注意用词，在介绍获取同步状态时，addWaiter 是加入到【同步队列】，就是上图说的入口等待队列，这里说的是【等待队列】，所以 addConditionWaiter 肯定是构建了一个自己的队列： 1234567891011121314151617private Node addConditionWaiter() &#123; Node t = lastWaiter; if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; // 新构建的节点的 waitStatus 是 CONDITION，注意不是 0 或 SIGNAL 了 Node node = new Node(Thread.currentThread(), Node.CONDITION); // 构建单向同步队列 if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125; 这里有朋友可能会有疑问： 为什么这里是单向队列，也没有使用CAS 来保证加入队列的安全性呢？ 因为 await 是 Lock 范式 try 中使用的，说明已经获取到锁了，所以就没必要使用 CAS 了，至于是单向，因为这里还不涉及到竞争锁，只是做一个条件等待队列 在 Lock 中可以定义多个条件，每个条件都会对应一个 条件等待队列，所以将上图丰富说明一下就变成了这个样子： 线程已经按相应的条件加入到了条件等待队列中，那如何再尝试获取锁呢？signal / signalAll 方法就已经排上用场了 1234567public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125; Signal 方法通过调用 doSignal 方法，只唤醒条件等待队列中的第一个节点 123456789private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; // 调用该方法，将条件等待队列的线程节点移动到同步队列中 &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125; 继续看 transferForSignal 方法 123456789101112final boolean transferForSignal(Node node) &#123; if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; // 重新进行入队操作 Node p = enq(node); int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) // 唤醒同步队列中该线程 LockSupport.unpark(node.thread); return true;&#125; 所以我们再用图解一下唤醒的整个过程 到这里，理解 signalAll 就非常简单了，只不过循环判断是否还有 nextWaiter，如果有就像 signal 操作一样，将其从条件等待队列中移到同步队列中 123456789private void doSignalAll(Node first) &#123; lastWaiter = firstWaiter = null; do &#123; Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; &#125; while (first != null);&#125; 不知你还是否记得，我在并发编程之等待通知机制 中还说过一句话 没有特殊原因尽量用 signalAll 方法 什么时候可以用 signal 方法也在其中做了说明，请大家自行查看吧 这里我还要多说一个细节，从条件等待队列移到同步队列是有时间差的，所以使用 await() 方法也是范式的， 同样在该文章中做了解释 有时间差，就会有公平和不公平的问题，想要全面了解这个问题，我们就要走近 ReentrantLock 中来看了，除了了解公平/不公平问题，查看 ReentrantLock 的应用还是要反过来验证它使用的AQS的，我们继续吧 ReentrantLock 是如何应用的AQS独占式的典型应用就是 ReentrantLock 了，我们来看看它是如何重写这个方法的 乍一看挺奇怪的，怎么里面自定义了三个同步器：其实 NonfairSync，FairSync 只是对 Sync 做了进一步划分： 从名称上你应该也知道了，这就是你听到过的 公平锁/非公平锁了 何为公平锁/非公平锁？生活中，排队讲求先来后到视为公平。程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平 我们来对比一下 ReentrantLock 是如何实现公平锁和非公平锁的 其实没什么大不了，公平锁就是判断同步队列是否还有先驱节点的存在，只有没有先驱节点才能获取锁；而非公平锁是不管这个事的，能获取到同步状态就可以，就这么简单，那问题来了： 为什么会有公平锁/非公平锁的设计？考虑这个问题，我们需重新回忆上面的锁获取实现图了，其实上面我已经透露了一点 主要有两点原因： 原因一：恢复挂起的线程到真正锁的获取还是有时间差的，从人类的角度来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用 CPU 的时间片，尽量减少 CPU 空闲状态时间 ####原因二： 不知你是否还记得我在 面试问，创建多少个线程合适？ 文章中反复提到过，使用多线程很重要的考量点是线程切换的开销，想象一下，如果采用非公平锁，当一个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的几率就变得非常大，所以就减少了线程的开销 相信到这里，你也就明白了，为什么 ReentrantLock 默认构造器用的是非公平锁同步器 123public ReentrantLock() &#123; sync = new NonfairSync();&#125; 看到这里，感觉非公平锁 perfect，非也，有得必有失 使用公平锁会有什么问题？ 公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “饥饿” 如何选择公平锁/非公平锁？相信到这里，答案已经在你心中了，如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了，否则那就用公平锁还大家一个公平 我们还差最后一个环节，真的要挺住 可重入锁到这里，我们还没分析 ReentrantLock 的名字，JDK 起名这么有讲究，肯定有其含义，直译过来【可重入锁】 为什么要支持锁的重入？ 试想，如果是一个有 synchronized 修饰的递归调用方法，程序第二次进入被自己阻塞了岂不是很大的笑话，所以 synchronized 是支持锁的重入的 Lock 是新轮子，自然也要支持这个功能，其实现也很简单，请查看公平锁和非公平锁对比图，其中有一段代码： 12// 判断当前线程是否和已占用锁的线程是同一个else if (current == getExclusiveOwnerThread()) 仔细看代码， 你也许发现，我前面的一个说明是错误的，我要重新解释一下 重入的线程会一直将 state + 1， 释放锁会 state - 1直至等于0，上面这样写也是想帮助大家快速的区分 总结本文是一个长文，说明了为什么要造 Lock 新轮子，如何标准的使用 Lock，AQS 是什么，是如何实现锁的，结合 ReentrantLock 反推 AQS 中的一些应用以及其独有的一些特性 独占式获取锁就这样介绍完了，我们还差 AQS 共享式 xxxShared 没有分析，结合共享式，接下来我们来阅读一下 Semaphore，ReentrantReadWriteLock 和 CountLatch 等 另外也欢迎大家的留言，如有错误之处还请指出，我的手酸了，眼睛干了，我去准备撸下一篇….. 灵魂追问 为什么更改 state 有 setState() , compareAndSetState() 两种方式，感觉后者更安全，但是锁的视线中有好多地方都使用了 setState()，安全吗？ 下面代码是一个转账程序，是否存在死锁或者锁的其他问题呢？ 12345678910111213141516171819202122232425class Account &#123; private int balance; private final Lock lock = new ReentrantLock(); // 转账 void transfer(Account tar, int amt)&#123; while (true) &#123; if(this.lock.tryLock()) &#123; try &#123; if (tar.lock.tryLock()) &#123; try &#123; this.balance -= amt; tar.balance += amt; &#125; finally &#123; tar.lock.unlock(); &#125; &#125;//if &#125; finally &#123; this.lock.unlock(); &#125; &#125;//if &#125;//while &#125;//transfer&#125; 参考 Java 并发实战 Java 并发编程的艺术 https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"Java多线程中断机制","slug":"Java多线程中断机制","date":"2020-05-17T05:50:15.000Z","updated":"2020-05-17T06:09:50.249Z","comments":true,"path":"/p/java-concurrency-interrupt-mechnism.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-interrupt-mechnism.html","excerpt":"| 好看请赞，养成习惯 * 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 * If you can NOT explain it simply, you do NOT understand it well enough 现陆续将Demo代码和技术文章整理在一起 Github实践精选 ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star🌟 横看成岭侧成峰，远近高低各不同，并发编程理论系列基本已经结束，相信大家有了理论的铺垫，近看源码才能发现其设计之美，不会一头雾水 本来是要介绍 AQS 作为我们走进并发编程源码环节的","text":"| 好看请赞，养成习惯 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough 现陆续将Demo代码和技术文章整理在一起 Github实践精选 ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star🌟 横看成岭侧成峰，远近高低各不同，并发编程理论系列基本已经结束，相信大家有了理论的铺垫，近看源码才能发现其设计之美，不会一头雾水 本来是要介绍 AQS 作为我们走进并发编程源码环节的第一步，但 AQS 涉及的知识点也还真有点多，每一个都够单独拿出来说一说，恰巧有朋友私信我“不理解线程的中断机制”，中断机制又恰巧是 AQS API实现的一部分，更贯穿于整个并发编程内容中。于是就打算单独说一说这个小机制，先让大家做到心中有 number 在学习/编写并发程序时，总会听到/看到如下词汇： 线程被中断或抛出InterruptedException 设置了中断标识 清空了中断标识 判断线程是否被中断 在 Java Thread 类又提供了长相酷似，让人傻傻分不清的三个方法来处理并发中断问题： interrupt() interrupted() isInterrupted() 看到这我不禁会问自己： 什么是中断机制？ 刚刚接触【中断】这个词时，先入为主的概念就是“直接中断/打断”正在做的事，使其停止。我的理解是这样的： 你：在打游戏 女朋友：别打游戏了，赶快过来吃饭 你：听到女朋友招呼之后立马中断手中的游戏乖乖过去吃饭 在多线程编程中，中断是一种【协同】机制，怎么理解这么高大上的词呢？就是女朋友叫你吃饭，你收到了中断游戏通知，但是否马上放下手中的游戏去吃饭看你心情 。在程序中怎样演绎这个心情就看具体的业务逻辑了，Java 的中断机制就是这么简单 如果还没改变这个先入为主的概念，我怀你你没有女朋友（😭）我们拥抱一下 为什么会有中断机制？中断是一种协同机制，我觉得就是解决【当局者迷】的状况 现实中，你努力忘我没有昼夜的工作，如果再没有人告知你中断，你身体是吃不消的。 在多线程的场景中，有的线程可能迷失在怪圈无法自拔（自旋浪费资源），这时就可以用其他线程在恰当的时机给它个中断通知，被“中断”的线程可以选择在恰当的时机选择跳出怪圈，最大化的利用资源 那程序中如何中断？怎样识别是否中断？又如何处理中断呢？这就与上文提到的三个方法有关了 interrupt() VS isInterrupted() VS interrupted()Java 的每个线程对象里都有一个 boolean 类型的标识，代表是否有中断请求，可你寻遍 Thread 类你也不会找到这个标识，因为这是通过底层 native 方法实现的。 interrupt()interrupt() 方法是 唯一一个 可以将上面提到中断标志设置为 true 的方法，从这里可以看出，这是一个 Thread 类 public 的对象方法，所以可以推断出任何线程对象都可以调用该方法，进一步说明就是可以一个线程 interrupt 其他线程，也可以 interrupt 自己。其中，中断标识的设置是通过 native 方法 interrupt0 完成的 在 Java 中，线程被中断的反应是不一样的，脾气不好的直接就抛出了 InterruptedException() ， 该方法注释上写的很清楚，当线程被阻塞在： wait() join() sleep() 这些方法时，如果被中断，就会抛出 InterruptedException 受检异常（也就是必须要求我们 catch 进行处理的） 熟悉 JUC 的朋友可能知道，其实被中断抛出 InterruptedException 的远远不止这几个方法，比如： 反向推理，这些可能阻塞的方法如果声明有 throws InterruptedException ， 也就暗示我们它们是可中断的 调用 interrput() 方法后，中断标识就被设置为 true 了，那我们怎么利用这个中断标识，来判断某个线程中断标识到底什么状态呢？ isInterrupted() 这个方法名起的非常好，因为比较符合我们 bean boolean 类型字段的 get 方法规范，没错，该方法就是返回中断标识的结果： true：线程被中断， false：线程没被中断或被清空了中断标识（如何清空我们一会看） 拿到这个标识后，线程就可以判断这个标识来执行后续的逻辑了。有起名好的，也有起名不好的，就是下面这个方法： interrupted()按照常规翻译，过去时时态，这就是“被打断了/被打断的”，其实和上面的 isInterrupted() 方法差不多，两个方法都是调用 private 的 isInterrupted() 方法， 唯一差别就是会清空中断标识（这是从方法名中怎么也看不出来的） 因为调用该方法，会返回当前中断标识，同时会清空中断标识，就有了那一段有点让人迷惑的方法注释： 来段程序你就会明白上面注释的意思了： 1234Thread.currentThread().isInterrupted(); // trueThread.interrupted() // true，返回true后清空了中断标识将其置为 falseThread.currentThread().isInterrupted(); // falseThread.interrupted() // false 这个方法总觉得很奇怪，现实中有什么用呢？ 当你可能要被大量中断并且你想确保只处理一次中断时，就可以使用这个方法了 该方法在 JDK 源码中应用也非常多，比如（后续文章会具体分析，这里知道该方法的作用和使用场景就好）： 相信到这里你已经能明确分辨三胞胎都是谁，并发挥怎样的作用了，那么有哪些场景我们可以使用中断机制呢？ 中断机制的使用场景通常，中断的使用场景有以下几个 点击某个桌面应用中的关闭按钮时（比如你关闭 IDEA，不保存数据直接中断好吗？）； 某个操作超过了一定的执行时间限制需要中止时； 多个线程做相同的事情，只要一个线程成功其它线程都可以取消时； 一组线程中的一个或多个出现错误导致整组都无法继续时； 因为中断是一种协同机制，提供了更优雅中断方式，也提供了更多的灵活性，所以当遇到如上场景等，我们就可以考虑使用中断机制了 使用中断机制有哪些注意事项其实使用中断机制无非就是注意上面说的两项内容： 中断标识 InterruptedException 前浪已经将其总结为两个通用原则，我们后浪直接站在肩膀上用就可以了，来看一下这两个原则是什么： 原则-1 如果遇到的是可中断的阻塞方法, 并抛出 InterruptedException，可以继续向方法调用栈的上层抛出该异常；如果检测到中断，则可清除中断状态并抛出 InterruptedException，使当前方法也成为一个可中断的方法 原则-2 若有时候不太方便在方法上抛出 InterruptedException，比如要实现的某个接口中的方法签名上没有 throws InterruptedException，这时就可以捕获可中断方法的 InterruptedException 并通过 Thread.currentThread.interrupt() 来重新设置中断状态。 再通过个例子来加深一下理解： 本意是当前线程被中断之后，退出while(true), 你觉得代码有问题吗？（先不要向下看） 123456789101112Thread th = Thread.currentThread();while(true) &#123; if(th.isInterrupted()) &#123; break; &#125; // 省略业务代码 try &#123; Thread.sleep(100); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;&#125; 打开 Thread.sleep 方法： sleep 方法抛出 InterruptedException后，中断标识也被清空置为 false，我们在catch 没有通过调用 th.interrupt() 方法再次将中断标识置为 true，这就导致无限循环了 这两个原则很好理解。总的来说，我们应该留意 InterruptedException，当我们捕获到该异常时，绝不可以默默的吞掉它，什么也不做，因为这会导致上层调用栈什么信息也获取不到。其实在编写程序时，捕获的任何受检异常我们都不应该吞掉 JDK 中有哪些使用中断机制的地方呢？中断机制贯穿整个并发编程中，这里只简单列觉大家经常会使用的，我们可以通过阅读JDK源码来进一步了解中断机制以及学习如何使用中断机制 ThreadPoolExecutorThreadPoolExecutor 中的 shutdownNow 方法会遍历线程池中的工作线程并调用线程的 interrupt 方法来中断线程 FutureTaskFutureTask 中的 cancel 方法，如果传入的参数为 true，它将会在正在运行异步任务的线程上调用 interrupt 方法，如果正在执行的异步任务中的代码没有对中断做出响应，那么 cancel 方法中的参数将不会起到什么效果 总结到这里你应该理解Java 并发编程中断机制的含义了，它是一种协同机制，和你先入为主的概念完全不一样。区分了三个相近方法，说明了使用场景以及使用原则，同时又给出JDK源码一些常见案例，相信你已经胸中有沟壑了，接下来，跟上节奏，我们陆续走进源码吧 灵魂追问 抛出 InterruptedException 后，中断标识就一定被清空吗？ 处在死锁状态的线程是否可以被中断呢？ 进入临界区的线程能否被中断呢？如果不能有什么办法能响应中断吗？ 个人感觉interrupted这个方法名称不是特别好，如果你也觉得不好，让你设计这个地方，你有什么想法？ 有朋友可能会问文章开头的图，同时看一个类的不同部分怎么实现的？不等您开口，我就全盘的招了，其实就是屏幕分割（在文件上鼠标右键-&gt;选择水平/垂直分割），这样在同时查看某些代码时还是很方便的（带鱼屏垂直分割真是爽翻天），保姆式演示如下： 参考 Java 并发编程实战 Java并发编程的艺术 https://www.infoq.cn/article/java-interrupt-mechanism https://coderanch.com/t/237332/certification/explain-interrupt-isInterrupted-interrupted-method https://dzone.com/articles/waiting-for-coroutines","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"Intellij IDEA 配置和插件合集","slug":"Intellij-IDEA-配置和插件合集","date":"2020-05-03T01:43:47.000Z","updated":"2020-05-03T03:06:59.310Z","comments":true,"path":"/p/intellij-idea-configuration-and-plugins.html","link":"","permalink":"https://dayarch.top/p/intellij-idea-configuration-and-plugins.html","excerpt":"最近在陆续写 Java 并发编程系列，好多朋私信问我的不是并发内容本身，而是我的 IDEA 主题配置。我就姑且认为好的主题配置可以写出更好的并发程序吧 即便这种可能性只有万分之一，我也要把我的 IDEA 相关值得配置的内容/插件和大家分享出来 先来一张我的 IDE 截图，有你看中的地方吗？ 插件篇 好用的插件总是让人： 神清气爽，精神抖擞 ，丰神异彩，炯炯有神，神采奕奕，气贯长虹 ，英姿飒爽，精神焕发 下面所有插件都可以按照文中标注的名称在 IDEA 插件市场中直接搜索并安装 Material Theme UI Material Theme UI 在主题下载量排行榜中高居第一","text":"最近在陆续写 Java 并发编程系列，好多朋私信问我的不是并发内容本身，而是我的 IDEA 主题配置。我就姑且认为好的主题配置可以写出更好的并发程序吧 即便这种可能性只有万分之一，我也要把我的 IDEA 相关值得配置的内容/插件和大家分享出来 先来一张我的 IDE 截图，有你看中的地方吗？ 插件篇好用的插件总是让人： 神清气爽，精神抖擞 ，丰神异彩，炯炯有神，神采奕奕，气贯长虹 ，英姿飒爽，精神焕发 下面所有插件都可以按照文中标注的名称在 IDEA 插件市场中直接搜索并安装 Material Theme UIMaterial Theme UI 在主题下载量排行榜中高居第一。安装主题后（在页面底部就会有进入主题的快捷入口），选择自己喜欢的主题进行微调就可以啦，如果懒得做配置，按照下图勾选相应设置就和我的一样了： Rainbow Brackets翻译过来叫【彩虹括号】，该插件除了可以实现多彩的括号匹配外，我使用更多的是其【区域代码高亮】功能 ，这样可以清晰定位区域代码内容 Mac 快捷键：cmd + 鼠标右键; Windows 快捷键：ctrl + 鼠标右键 你也可以使用非选中部分暗淡效果 快捷键：alt + 鼠标右键 相比之下，我更喜欢第一种高亮效果 CodotaCodota 总结起来有三大功能： 1. 智能自动补全让编码速度更快当编写代码时，Codota 可以快速的完成智能补全以及高频用法提示 2. 从经过测试或证明过的程序中获得编码建议如果我们觉得给出的提示不够清晰，可以使用快捷键： ctrl + shift + o ， 快速查询相关使用案例，同时可以通过添加关键字进行过滤，查找到更加精确的代码样例 3. 不脱离IDE发现并利用更多开源代码当你不知道某个类如何使用时，可以直接使用快捷键：ctrl + shift + y ， 然后输入关键字，会查询到很多【开源框架】中使用该类的经典案例。不用脱离 IDE，没有广告，没有废话，只有经典的代码样例，你说爽不爽？ 如果你用 Eclipse ，Codota 也是完美支持的 Key Promoter X高效的编码脱离不开快捷键的使用，但是 IDEA 中的快捷键实在太多了，不是很方便记忆，Key Promoter X 会根据你使用的功能提示你设置快捷键 设置完后，如果你忘记了该快捷键，再次通过鼠标点击该功能时，设置好的快捷键就会相应的提示出来，真是深知码农苦啊 Alibaba Java Code Guideline安装该插件后，你编写的代码就会按照 Alibaba 编码规约规范我们编写的代码（谁说我们不能写出和大厂一样规范的代码？） 比如通过Executors 快速创建一个线程池是不被允许的，具体原因已经在我会手动创建线程，为什么要使用线程池? 中说明，当检测出之后，鼠标悬浮在上面会给出提示，按快捷键 cmd + F1 会更完整的告诉你为什么不可以，同时还给出你应该怎样编写的样例 （暖暖的，很贴心） CodeGlance英文直译【代码一瞥】，细心的朋友已经在开篇的图中看到了这个设置，安装该插件后，IDE右侧会出现一个mini 视图，比如看 ConcurrentHashMap 源码，那么长的内容，可以通过该插件快速的拖动到大概位置，方便很多 Restful Tookit这个插件之前我有介绍过，编写 RESTful 接口必不可少的插件，编写完接口当然还需要调试，搭配HTTP Client 一起使用才更香 IntelliJ IDEA HTTP Client高级使用详解，相信你学会使用这个，不单单是你个人，你们整个小组都会因此受益 CamelCase编码离不开字符串的使用，安装该插件后，可以通过快捷键 shift + alt + U 快速的切换字符串格式，当然如果你只是单纯的切换大小写，使用 shift + cmd + U 更便捷一些 设置篇方法分割线以及字符缩进通过方法分割线可以更清晰明了的区分方法的边界，通过字符缩进也可以让代码的层次感更加明显，先来看整体效果 只需要按照下图勾选相应选项就可以了 （现在是不是很清晰？） Editor 边栏位置设置如果你不能熟悉的使用 cmd + E 快捷键（一不小心给了提示）打开你最近常用的文件，顶部位置可显示的打开的类名称少之又少，所以通过挪动 Editor 的显示位置，就可以解决这个痛点问题，现在是不是极度舒适了呢？ 当你觉得需要 IDEA 帮助你更高效的工作时，不妨去插件市场搜搜看，没准就有意想不到的惊喜。另外，这是一个 IDEA 设置篇的合集，我会陆续将更多设置和好用的插件整合到这一篇文章当中，为了不错过更多精彩内容，你可以直接选择收藏啦 最后，我也整理了很多可以帮你高效工作的工具，公众号回复【工具】即可","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://dayarch.top/tags/IntelliJ-IDEA/"}]},{"title":"为什么要使用线程池?","slug":"为什么要使用线程池","date":"2020-04-19T07:17:38.000Z","updated":"2020-04-22T00:29:08.547Z","comments":true,"path":"/p/why-we-need-to-use-threadpool.html","link":"","permalink":"https://dayarch.top/p/why-we-need-to-use-threadpool.html","excerpt":"上一篇文章 面试问我，创建多少个线程合适？我该怎么说 从定性到定量的分析了如何创建正确个数的线程来最大化利用系统资源（其实就是几道小学数学题）。通常来讲，有了个这个知识点傍身，按需手动创建相应个数的线程就好 但是现实中，你也许听过或者被要求： 尽量避免手动创建线程，应使用线程池统一管理线程 为什么会有这样的要求？背后的道理又是怎样的呢？顺着这个经验理论来推断，那肯定是手动创建线程有缺点 手动创建线程有什么缺点？ 1. 不受控风险 2. 频繁创建开销大 不受控风险 这个缺点，相信你也可以说出一二 系统资源有限，每个人针对不同业务都可以手动创建线程，并且创建标准不一样（比如线程没有","text":"上一篇文章 面试问我，创建多少个线程合适？我该怎么说 从定性到定量的分析了如何创建正确个数的线程来最大化利用系统资源（其实就是几道小学数学题）。通常来讲，有了个这个知识点傍身，按需手动创建相应个数的线程就好 但是现实中，你也许听过或者被要求： 尽量避免手动创建线程，应使用线程池统一管理线程 为什么会有这样的要求？背后的道理又是怎样的呢？顺着这个经验理论来推断，那肯定是手动创建线程有缺点 手动创建线程有什么缺点？ 不受控风险 频繁创建开销大 不受控风险这个缺点，相信你也可以说出一二 系统资源有限，每个人针对不同业务都可以手动创建线程，并且创建标准不一样（比如线程没有名字）。当系统运行起来，所有线程都在疯狂抢占资源，无组织无纪律，混乱场面可想而知（出现问题，自然也就不可能轻易的发现和解决） 如果有位神奇的小伙伴，为每个请求都创建一个线程，当大量请求铺面而来的时候，这好比一个正规木马程序，内存被无情榨干耗尽（你无情，你冷酷，你无理取闹） 另外，过多的线程自然也会引起上下文切换的开销 总的来说，不受控风险很大 频繁创建开销大 面试问：频繁手动创建线程有什么问题？ 答：开销大 这貌似是一个不假思索就可以回答出来的正确答案。那我要继续问了 面试官：创建一个线程干了什么就开销大了？和我们创建一个普通 Java 对象有什么差别？ 答： … 嗯…啊 按照常规理解 new Thread() 创建一个线程和 new Object() 没有什么差别。Java中万物接对象，因为 Thread 的老祖宗也是 Object 如果你真是这么理解的，说明你对线程的生命周期还不是很理解，请回看之前的 Java线程生命周期这样理解挺简单的 在这篇文章中我们明确说明，new Thread() 在操作系统层面并没有创建新的线程，这是编程语言特有的。真正转换为操作系统层面创建一个线程，还要调用操作系统内核的API，然后操作系统要为该线程分配一系列的资源 废话不多说，我们将二者做个对比： new Object() 过程1Object obj = new Object(); 当我需要【对象】时，我就会给自己 new 一个（不知你是否和我一样），这个过程你应该很熟悉了： 分配一块内存 M 在内存 M 上初始化该对象 将内存 M 的地址赋值给引用变量 obj 就是这么简单 创建一个线程的过程上面已经提到了，创建一个线程还要调用操作系统内核API。为了更好的理解创建并启动一个线程的开销，我们需要看看 JVM 在背后帮我们做了哪些事情： 它为一个线程栈分配内存，该栈为每个线程方法调用保存一个栈帧 每一栈帧由一个局部变量数组、返回值、操作数堆栈和常量池组成 一些支持本机方法的 jvm 也会分配一个本机堆栈 每个线程获得一个程序计数器，告诉它当前处理器执行的指令是什么 系统创建一个与Java线程对应的本机线程 将与线程相关的描述符添加到JVM内部数据结构中 线程共享堆和方法区域 这段描述稍稍有点抽象，用数据来说明创建一个线程（即便不干什么）需要多大空间呢？答案是大约 1M 左右 1java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -XX:+PrintNMTStatistics -version 上图是我用 Java8 的测试结果，19个线程，预留和提交的大概都是19000+KB，平均每个线程大概需要 1M 左右的大小（Java11的结果完全不同，这个大家自行测试吧） 相信到这里你已经明白了，对于性能要求严苛的现在，频繁手动创建/销毁线程的代价是非常巨大的，解决方案自然也是你知道的线程池了 什么是线程池？你常见的数据库连接池，实例池，还有XX池，OO池，各种池，都是一种池化（pooling）思想，简而言之就是为了最大化收益，并最小化风险，将资源统一在一起管理的思想 Java 也提供了它自己实现的线程池模型—— ThreadPoolExecutor。套用上面池化的想象来说，Java线程池就是为了最大化高并发带来的性能提升，并最小化手动创建线程的风险，将多个线程统一在一起管理的思想 为了了解这个管理思想，我们当前只需要关注 ThreadPoolExecutor 构造方法就可以了 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 这么复杂的构造方法在JDK中还真是不多见，为了个更形象化的让大家理解这几个核心参数，我们以多数人都经历过的春运（北京——上海）来说明 序号 参数名称 参数解释 春运形象说明 1 corePoolSize 表示常驻核心线程数，如果大于0，即使本地任务执行完也不会被销毁 日常固定的列车数辆（不管是不是春运，都要有固定这些车次运行） 2 maximumPoolSize 表示线程池能够容纳可同时执行的最大线程数 春运客流量大，临时加车，加车后，总列车次数不能超过这个最大值，否则就会出现调度不开等问题 （结合workqueue） 3 keepAliveTime 表示线程池中线程空闲的时间，当空闲时间达到该值时，线程会被销毁，只剩下 corePoolSize 个线程位置 春运压力过后，临时的加车（如果空闲时间超过keepAliveTime）就会被撤掉，只保留日常固定的列车车次数量用于日常运营 4 unit keepAliveTime 的时间单位，最终都会转换成【纳秒】，因为CPU的执行速度杠杠滴 keepAliveTime 的单位，春运以【天】为计算单位 5 workQueue 当请求的线程数大于 corePoolSize 时，线程进入该阻塞队列 春运压力异常大，（达到corePoolSize）也不能满足要求，所有乘坐请求都会进入该阻塞队列中排队, 队列满，还有额外请求，就需要加车了 6 threadFactory 顾名思义，线程工厂，用来生产一组相同任务的线程，同时也可以通过它增加前缀名，虚拟机栈分析时更清晰 比如（北京——上海）就属于该段列车所有前缀，表明列车运输职责 7 handler 执行拒绝策略，当 workQueue 达到上限，同时也达到 maximumPoolSize 就要通过这个来处理，比如拒绝，丢弃等，这是一种限流的保护措施 当workQueue排队也达到队列最大上线，maximumPoolSize 就要提示无票等拒绝策略了,因为我们不能加车了，当前所有车次已经满负载 整体来看就是这样： 试想，如果有请求就新建一趟列车，请求结束就“销毁”这趟列车，频繁往复这样操作，这样的代价肯定是不能接受的。 可以看到，使用线程池不但能完成手动创建线程可以做到的工作，同时也填补了手动线程不能做到的空白。归纳起来说，线程池的作用包括： 利用线程池管理并服用线程，控制最大并发数（手动创建线程很难得到保证） 实现任务线程队列缓存策略和拒绝机制 实现某些与实践相关的功能，如定时执行，周期执行等（比如列车指定时间运行） 隔离线程环境，比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大。因此，通过配置独立的线程池，将较慢的交易服务与搜索服务个离开，避免个服务线程互相影响 相信到这里，你已经了解线程池的基本思想了，在使用过程中还是有几个注意事项要说明一下的 线程池使用思想/注意事项不能忽略的线程池拒绝策略我们很难准确的预测未来的最大并发量，所以定制合理的拒绝策略是必不可少的步骤。默认情况， ThreadPoolExecutor 提供了四种拒绝策略： AbortPolicy：默认的拒绝策略，会 throw RejectedExecutionException 拒绝 CallerRunsPolicy：提交任务的线程自己去执行该任务 DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列 DiscardPolicy：相当大胆的策略，直接丢弃任务，没有任何异常抛出 不同的框架（Netty，Dubbo）都有不同的拒绝策略，我们也可以通过实现 RejectedExecutionHandler 自定义的拒绝策略 对于采用何种策略，具体要看执行的任务重要程度。如果是一些不重要任务，可以选择直接丢弃；如果是重要任务，可以采用降级（所谓降级就是在服务无法正常提供功能的情况下，采取的补救措施。具体采用何种降级手段，这也是要看具体场景）处理，例如将任务信息插入数据库或者消息队列，启用一个专门用作补偿的线程池去进行补偿 没有绝对的拒绝策略，只有适合那一个，但在设计过程中千万不要忽略掉拒绝策略就可以 禁止使用Executors创建线程池相信很多人都看到过这个问题（阿里巴巴Java开发手册说明禁止使用 Executors 创建线程池），我把出处（P247）截图在此： Executors 大大的简化了我们创建各种类型线程池的方式，为什么还不让使用呢？ 其实，只要你打开看看它的静态方法参数就会明白了 传入的workQueue 是一个边界为 Integer.MAX_VALUE 队列，我们也可以变相的称之为无界队列了，因为边界太大了，这么大的等待队列也是非常消耗内存的 1234567/** * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125; 另外该 ThreadPoolExecutor方法使用的是默认拒绝策略（直接拒绝），但并不是所有业务场景都适合使用这个策略，当很重要的请求过来直接选择拒绝显然是不合适的 总的来说，使用 Executors 创建的线程池太过于理想化，并不能满足很多现实中的业务场景，所以要求我们通过 ThreadPoolExecutor来创建，并传入合适的参数 总结当我们需要频繁的创建线程时，我们要考虑到通过线程池统一管理线程资源，避免不可控风险以及额外的开销 了解了线程池的几个核心参数概念后，我们也需要经过调优的过程来设置最佳线程参数值（这个过程时必不可少的） 线程池虽然弥补了手动创建线程的缺陷和空白，同时，合理的降级策略能大大增加系统的稳定性 阿里巴巴手册都是前辈们无数填坑后总结的精华，你也应该遵守相应的指示，结合自己的实际业务场景，设定合适的参数来创建线程池 灵魂追问 我们说了这么多线程池的好，那使用线程池有哪些缺点或限制呢？ 为什么不建议所有业务共用一个线程池？有什么缺点？ 给线程池设置指定前缀，有哪些方式？ 参考感谢前辈们总结的精华，自己所写的并发系列好多都参考了以下资料 Java 并发编程实战 Java 并发编程之美 码出高效 Java 并发编程的艺术 ifeve 美团技术团队","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"如何清爽的安排日常？","slug":"如何合理的安排日常？","date":"2020-04-12T08:01:18.000Z","updated":"2020-04-15T00:16:02.641Z","comments":true,"path":"/p/how-to-organize-your-day.html","link":"","permalink":"https://dayarch.top/p/how-to-organize-your-day.html","excerpt":"有朋友私信问我如何安排日常，以及相对高效的写东西？我觉得有必要单独写一篇文章来和大家交流这个事 不做没有灵魂的 TODO List 我们都是上进的好青年，大家手里应该都有自己的 TODO list，我通常会用 Microsoft To Do 这款软件做简单的日常安排 求学期间，每个寒暑假临近，我都可以把做各种 plan，立各种 flag 的气质拿捏的死死的。如你所料，假期过后一个 plan 都没有做，一个 flag 都没有完成。 这种表面风光，实则没有了灵魂TODO list 只是短期心理慰藉，当需要验证结果时，情绪轻则低落一会，重则焦虑半天 造成这种问题的原因很简单 * 大杂","text":"有朋友私信问我如何安排日常，以及相对高效的写东西？我觉得有必要单独写一篇文章来和大家交流这个事 不做没有灵魂的 TODO List我们都是上进的好青年，大家手里应该都有自己的 TODO list，我通常会用 Microsoft To Do 这款软件做简单的日常安排 求学期间，每个寒暑假临近，我都可以把做各种 plan，立各种 flag 的气质拿捏的死死的。如你所料，假期过后一个 plan 都没有做，一个 flag 都没有完成。 这种表面风光，实则没有了灵魂TODO list 只是短期心理慰藉，当需要验证结果时，情绪轻则低落一会，重则焦虑半天 造成这种问题的原因很简单 大杂烩 TODO 没有轻重缓急 没有可以落地的执行计划和自我约束能力 如何解决这个问题呢？ 筛选做事我们知道三思而后行，做 plan 好像没有成本一样，我却忘记了三思而后行的道理。导致 todo list 又臭又长的原因多数出于冲动性思维，这是人性，但我不打算逆人性而为之，我选择在原有基础上，再多做两个 todo list（你没看错） 清单B（Agile Backlog）：日常天马行空的，意淫的，临时想到的，我都会放到这个清单里面，满足了我这【收藏】梦 清单G（Agile Grooming）: 反复查看清单A，自我反问，某一项是你想要的吗？最终在该清单G中留下3到7个选项 清单S（Agile Sprint）：灵魂拷问自己，做出取舍，最多能留下 1到3个 这样我们只需在短时间内关注清单S的内容，当清单S的内容做完，重复这个筛选步骤即可。我的欲望清单并没有删减，只是换了个视角，感觉完全不一样了 优先级事有【轻重缓急】，这四个字的排列组合就是你熟悉的象限图了 排列优先级是基本技能，注意这个图是要持续更新的，而不是一成不变的 Tips: 生活中总会有很多插曲来打断我们的计划，所以我并不会将时间排的很满，一定要给自己留有一些buffer，这样不至于被其他事打断，导致原有事情做不完而带来的挫败感，但也不能留太多buffer，因为我们都有拖延症/惰性 另外，生活中的大多数事情都处在第二象限【重要 &amp; 不紧急】，所以如何分解任务，制定计划，并按部就班执行就显得很重要了 不要将整块时间碎片化都知道有连续性的做事会比较高效，这就需要整块的时间，但当我有整块时间时，貌似并不珍惜这个福利，一会看手机聊天，一会读书，一会看视频。感觉自己忙忙碌碌，实则什么都没做成，过后需要验证成果时，一片茫然，原因是我们将时间碎片化了 我们能保持专注的时间有限，过长时间的约束自己反而是逆人性的行为，所以我们就需要在专注和放松之间找到一个平衡点 番茄工作法 按照番茄工作法，一个番茄钟是25分钟，番茄钟铃响，休息3～5分钟，继续下一个番茄钟。番茄钟内科学的让我保持专注；休息时间又让我简单把玩手机。更重要的是可以将整块事情按照番茄钟进行细分，形成可执行的计划（Chrome浏览器就有相应的番茄插件，比如我用的这个） 最大化利用碎片化时间大家的碎片化时间真的非常多，感觉可以玩手机的时间都是我们的碎片化时间（你脑补一下你通常都在什么时候玩手机） 这个时间我们能做什么？ 简单拉伸动作和扩展运动 回顾过去一两天的点点滴滴做个复盘总结，做到心中有数 平时订阅的高质量公众号集中阅读（比如日拱一兵，这个广告打的连我自己都猝不及防） 给家人朋友一些问候 …… 你会发现，生活中的一些细枝末节小事，都可以通过碎片化时间来完成，不会忙忙碌碌 分清主次大家都是成年人，生活中肯定不止一两件事需要你照顾。即便同样多的事，每个人照顾的方式和顺序不一样，得到的结果和感受自然也就不一样，为了说明这个问题，我把很久以前看过的一个视频放到这里【如果视频打不开，可以点开打开如何清爽的安排日常？ 查看】 像视频中说的一样，偶尔给自己几杯啤酒（我酒精过敏就不喝了） 寻找我们都是程序员，我就拿程序工作的事情举例子： 你写了无数个CRUD，带给你的是什么感觉？ 你做了简单的调优，性能提升了几个百分比，带给的是什么感觉？ 你通过努力，克服一些困难，完成一些你之前看似很难得的问题，带给你的是什么感觉？ 我们无时无刻不需要自身的成就感来驱动自我，下面这句话是我焦虑的时候发给我的朋友佳兴大佬得到的回复，希望对你有帮助 最后，都说执行困难，如果你没有行之有效的方法，请按照上面这些方法进行逐步改善，自然会给你带来幸福感和成就感，也就自然会推动你做下一步执行 我也在改变思维和方式的路上… 我们一起 最后如果你通过这个方法改变了很多，一定要记得回来告诉我，这会给我带来很大成就感​","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"其他","slug":"Life/其他","permalink":"https://dayarch.top/categories/Life/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://dayarch.top/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"面试问，创建多少个线程合适？","slug":"面试问，创建多少个线程合适？","date":"2020-04-06T13:02:39.000Z","updated":"2020-04-08T08:58:56.737Z","comments":true,"path":"/p/how-many-threads-should-be-created.html","link":"","permalink":"https://dayarch.top/p/how-many-threads-should-be-created.html","excerpt":"为什么要使用多线程？ 防止并发编程出错最好的办法就是不写并发程序 既然多线程编程容易出错，为什么它还经久不衰呢？ A：那还用说，肯定在某些方面有特长呗，比如你知道的【它很快，非常快】 我也很赞同这个答案，但说的不够具体 并发编程适用于什么场景？ 如果问你选择多线程的原因就是一个【快】字，面试也就不会出那么多幺蛾子了。你有没有问过你自己 1. 并发编程在所有场景下都是快的吗？ 2. 知道它很快，何为快？怎样度量？ 想知道这两个问题的答案，我们需要一个从【定性】到【定量】的分析过程 使用多线程就是在正确的场景下通过设置正确个数的线程来最大化程序的运行速度（我感觉你还是啥也没","text":"为什么要使用多线程？ 防止并发编程出错最好的办法就是不写并发程序 既然多线程编程容易出错，为什么它还经久不衰呢？ A：那还用说，肯定在某些方面有特长呗，比如你知道的【它很快，非常快】 我也很赞同这个答案，但说的不够具体 并发编程适用于什么场景？如果问你选择多线程的原因就是一个【快】字，面试也就不会出那么多幺蛾子了。你有没有问过你自己 并发编程在所有场景下都是快的吗？ 知道它很快，何为快？怎样度量？ 想知道这两个问题的答案，我们需要一个从【定性】到【定量】的分析过程 使用多线程就是在正确的场景下通过设置正确个数的线程来最大化程序的运行速度（我感觉你还是啥也没说） 将这句话翻译到硬件级别就是要充分的利用 CPU 和 I/O 的利用率 两个正确得到保证，也就能达到最大化利用 CPU 和 I/O的目的了。最关键是，如何做到两个【正确】？ 在聊具体场景的时候，我们必须要拿出我们的专业性来。送你两个名词 buff 加成 CPU 密集型程序 I/O 密集型程序 CPU 密集型程序 一个完整请求，I/O操作可以在很短时间内完成， CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分 假如我们要计算 1+2+….100亿 的总和，很明显，这就是一个 CPU 密集型程序 在【单核】CPU下，如果我们创建 4 个线程来分段计算，即： 线程1计算 [1,25亿） …… 以此类推 线程4计算 [75亿，100亿] 我们来看下图他们会发生什么？ 由于是单核 CPU，所有线程都在等待 CPU 时间片。按照理想情况来看，四个线程执行的时间总和与一个线程5独自完成是相等的，实际上我们还忽略了四个线程上下文切换的开销 所以，单核CPU处理CPU密集型程序，这种情况并不太适合使用多线程 此时如果在 4 核CPU下，同样创建四个线程来分段计算，看看会发生什么？ 每个线程都有 CPU 来运行，并不会发生等待 CPU 时间片的情况，也没有线程切换的开销。理论情况来看效率提升了 4 倍 所以，如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率 I/O密集型程序 与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分 我们都知道在进行 I/O 操作时，CPU是空闲状态，所以我们要最大化的利用 CPU，不能让其是空闲状态 同样在单核 CPU 的情况下： 从上图中可以看出，每个线程都执行了相同长度的 CPU 耗时和 I/O 耗时，如果你将上面的图多画几个周期，CPU操作耗时固定，将 I/O 操作耗时变为 CPU 耗时的 3 倍，你会发现，CPU又有空闲了，这时你就可以新建线程 4，来继续最大化的利用 CPU。 综上两种情况我们可以做出这样的总结： 线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程。 到这里，相信你已经知道第一个【正确】使用多线程的场景了，那创建多少个线程是正确的呢？ 创建多少个线程合适？面试如果问到这个问题，这可是对你理论和实践的统考。想完全答对，你必须要【精通/精通/精通】小学算术 从上面知道，我们有 CPU 密集型和 I/O 密集型两个场景，不同的场景当然需要的线程数也就不一样了 CPU 密集型程序创建多少个线程合适？有些同学早已经发现，对于 CPU 密集型来说，理论上 线程数量 = CPU 核数（逻辑） 就可以了，但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1， 为什么呢？ 《Java并发编程实战》这么说： 计算（CPU）密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。 所以对于CPU密集型程序， CPU 核数（逻辑）+ 1 个线程数是比较好的经验值的原因了 I/O密集型程序创建多少个线程合适？上面已经让大家按照图多画几个周期（你可以动手将I/O耗时与CPU耗时比例调大，比如6倍或7倍），这样你就会得到一个结论，对于 I/O 密集型程序： 最佳线程数 = (1/CPU利用率) = 1 + (I/O耗时/CPU耗时) 我这么体贴，当然担心有些同学不理解这个公式，我们将上图的比例手动带入到上面的公式中： 这是一个CPU核心的最佳线程数，如果多个核心，那么 I/O 密集型程序的最佳线程数就是： 最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * （1 + （I/O耗时/CPU耗时)） 说到这，有些同学可能有疑问了，要计算 I/O 密集型程序，是要知道 CPU 利用率的，如果我不知道这些，那要怎样给出一个初始值呢？ 按照上面公式，假如几乎全是 I/O耗时，所以纯理论你就可以说是 2N（N=CPU核数），当然也有说 2N + 1的，（我猜这个 1 也是 backup），没有找到具体的推倒过程，在【并发编程实战-8.2章节】截图在此，大家有兴趣的可以自己看看 理论上来说，理论上来说，理论上来说，这样就能达到 CPU 100% 的利用率 如果理论都好用，那就用不着实践了，也就更不会有调优的事出现了。不过在初始阶段，我们确实可以按照这个理论之作为伪标准， 毕竟差也可能不会差太多，这样调优也会更好一些 谈完理论，咱们说点实际的，公式我看懂了（定性阶段结束），但是我有两个疑问： 我怎么知道具体的 I/O耗时和CPU耗时呢？ 怎么查看CPU利用率？ 没错，我们需要定量分析了 幸运的是，我们并不是第一个吃螃蟹的仔儿，其实有很多 APM （Application Performance Manager）工具可以帮我们得到准确的数据，学会使用这类工具，也就可以结合理论，在调优的过程得到更优的线程个数了。我这里简单列举几个，具体使用哪一个，具体应用还需要你自己去调研选择，受篇幅限制，暂不展开讨论了 SkyWalking CAT zipkin 上面了解了基本的理论知识，那面试有可能问什么？又可能会以怎样的方式提问呢？ 面试小问小问一 假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s 如何设计线程个数，使得可以在1s内处理完20个Transaction？ 但是，但是，这是因为没有考虑到CPU数目。家里又没矿，一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销（希望这句话你可以主动说出来），这就需要调优了，来做到最佳 balance 小问二 计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？ 如果不知道请拿三年级期末考试题重新做（今天晚自习留下来），答案是： 线程数 = 8 * (1 + 100/5) = 168 (个) 那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？ 同样，这是没有考虑 CPU 数目，接下来就又是细节调优的阶段了 因为一次请求不仅仅包括 CPU 和 I/O操作，具体的调优过程还要考虑内存资源，网络等具体内容 增加 CPU 核数一定能解决问题吗？看到这，有些同学可能会认为，即便我算出了理论线程数，但实际CPU核数不够，会带来线程上下文切换的开销，所以下一步就需要增加 CPU 核数，那我们盲目的增加 CPU 核数就一定能解决问题吗？ 在讲互斥锁的内容是，我故意遗留了一个知识: 怎么理解这个公式呢？ 这个结论告诉我们，假如我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。 如何简单粗暴的理解串行百分比（其实都可以通过工具得出这个结果的）呢？来看个小 Tips： Tips: 临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比 现在你应该理解我在讲解 synchronized 关键字时所说的： 最小化临界区范围，因为临界区的大小往往就是瓶颈问题的所在，不要像乱用try catch那样一锅端 总结多线程不一定就比单线程高效，比如大名鼎鼎的 Redis （后面会分析），因为它是基于内存操作，这种情况下，单线程可以很高效的利用CPU。而多线程的使用场景一般时存在相当比例的I/O或网络操作 另外，结合小学数学题，我们已经了解了如何从定性到定量的分析的过程，在开始没有任何数据之前，我们可以使用上文提到的经验值作为一个伪标准，其次就是结合实际来逐步的调优（综合 CPU，内存，硬盘读写速度，网络状况等）了 最后，盲目的增加 CPU 核数也不一定能解决我们的问题，这就要求我们严格的编写并发程序代码了 灵魂追问 我们已经知道创建多少个线程合适了，为什么还要搞一个线程池出来？ 创建一个线程都要做哪些事情？为什么说频繁的创建线程开销很大？ 多线程通常要注意共享变量问题，为什么局部变量就没有线程安全问题呢？ …… 参考感谢前辈们总结的精华，自己所写的并发系列好多都参考了以下资料 Java 并发编程实战 Java 并发编程之美 码出高效 Java 并发编程的艺术 ifeve 下一篇文章，我们就来说说，你熟悉又陌生的线程池问题","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"Java线程生命周期这样理解挺简单的","slug":"Java线程生命周期这样理解挺简单的","date":"2020-03-25T06:32:03.000Z","updated":"2020-03-25T07:19:39.290Z","comments":true,"path":"/p/java-thread-life-cycle.html","link":"","permalink":"https://dayarch.top/p/java-thread-life-cycle.html","excerpt":"为什么要了解线程的生命周期？ 之前写过 Spring Bean 生命周期三部曲： 1. Spring Bean生命周期之缘起 2. Spring Bean生命周期之缘尽 3. Spring Aware 到底是什么？ 有朋友留言说：“了解了它们的生命周期后，使用 Spring Bean 好比看到它们的行动轨迹，现在使用就一点都不慌了”。我和他一样，了解事物的生命周期目的很简单，唯【不慌】也 Java 并发系列 已经写了很多，从来还没提起过那个它【Java线程生命周期】。有了前序理论图文的铺垫，在走进源码世界之前，谈论它的时机恰好到了。因为，编写并发程序的核心之一就是正确的摆弄线程","text":"为什么要了解线程的生命周期？之前写过 Spring Bean 生命周期三部曲： Spring Bean生命周期之缘起 Spring Bean生命周期之缘尽 Spring Aware 到底是什么？ 有朋友留言说：“了解了它们的生命周期后，使用 Spring Bean 好比看到它们的行动轨迹，现在使用就一点都不慌了”。我和他一样，了解事物的生命周期目的很简单，唯【不慌】也 Java 并发系列 已经写了很多，从来还没提起过那个它【Java线程生命周期】。有了前序理论图文的铺垫，在走进源码世界之前，谈论它的时机恰好到了。因为，编写并发程序的核心之一就是正确的摆弄线程状态 线程生命周期的几种状态刚接触线程生命周期时，我总是记不住，也理解不了他们的状态，可以说是比较混乱，更别说它们之间是如何进行状态转换的了。原因是我把操作系统通用线程状态和编程语言封装后的线程状态 概念混淆在一起了 操作系统通用线程状态个人觉得通用线程状态更符合我们的思考习惯。其状态总共有 5 种 （如下图）。对于经常写并发程序的同学来说，其嘴里经常念的都是操作系统中的这些通用线程状态，且看 除去生【初始状态】死【终止状态】，其实只是三种状态的各种转换，听到这句话是不是心情放松了很多呢？ 为了更好的说明通用线程状态和 Java 语言中的线程状态，这里还是先对前者进行简短的说明 初始状态 线程已被创建，但是还不被允许分配CPU执行。注意，这个被创建其实是属于编程语言层面的，实际在操作系统里，真正的线程还没被创建， 比如 Java 语言中的 new Thread()。 可运行状态 线程可以分配CPU执行，这时，操作系统中线程已经被创建成功了 运行状态 操作系统会为处在可运行状态的线程分配CPU时间片，被 CPU 临幸后，处在可运行状态的线程就会变为运行状态 休眠状态 如果处在运行状态的线程调用某个阻塞的API或等待某个事件条件可用，那么线程就会转换到休眠状态，注意：此时线程会释放CPU使用权，休眠的线程永远没有机会获得CPU使用权，只有当等待事件出现后，线程会从休眠状态转换到可运行状态 终止状态 线程执行完或者出现异常 (被interrupt那种不算的哈，后续会说)就会进入终止状态，正式走到生命的尽头，没有起死回生的机会 接下来就来看看你熟悉又陌生，面试又经常被问到的Java 线程生命周期吧 Java语言线程状态在 Thread 的源码中，定义了一个枚举类 State，里面清晰明了的写了Java语言中线程的6种状态： NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED 这里要做一个小调查了，你有查看过这个类和读过其注释说明吗？（欢迎留言脚印哦） 耳边响起五环之歌，Java中线程状态竟然比通用线程状态的 5 种多1种，变成了 6 种。这个看似复杂，其实并不是你想的那样，Java在通用线程状态的基础上，有裁剪，也有丰富，整体来说是少一种。再来看个图，注意颜色区分哦 Java 语言中 将通用线程状态的可运行状态和运行状态合并为 Runnable， 将休眠状态细分为三种 (BLOCKED/WAITING/TIMED_WAITING); 反过来理解这句话，就是这三种状态在操作系统的眼中都是休眠状态，同样不会获得CPU使用权 看上图右侧【Java语言中的线程状态】，进一步简洁的说，除去线程生死，我们只要玩转 RUNNABLE 和休眠状态的转换就可以了，编写并发程序也多数是这两种状态的转换。所以我们需要了解，有哪些时机，会触发这些状态转换 远看看轮廓， 近看看细节。我们将上面Java语言中的图进行细化，将触发的节点放到图中 (这看似复杂的图，其实三句话就能分解的，所以别慌)，且看： RUNNABLE与BLOCKED状态转换当且仅有（just only）一种情况会从 RUNNABLE 状态进入到 BLOCKED 状态，就是线程在等待 synchronized 内置隐式锁；如果等待的线程获取到了 synchronized 内置隐式锁，也就会从 BLOCKED 状态变为 RUNNABLE 状态了 注意： 上面提到，以操作系统通用状态来看，线程调用阻塞式 API，会变为休眠状态（释放CPU使用权），但在JVM层面，Java线程状态不会发生变化，也就是说Java线程的状态依旧会保持在 RUNNABLE 状态。JVM并不关心操作系统调度的状态。在JVM看来，等待CPU使用权（操作系统里是处在可执行状态）与等待I/O（操作系统是处在休眠状态），都是等待某个资源，所以都归入了RUNNABLE 状态 ​ —— 摘自《Java并发编程实战》 RUNNABLE与WAITING状态转换调用不带时间参数的等待API，就会从RUNNABLE状态进入到WAITING状态；当被唤醒就会从WAITING进入RUNNABLE状态 RUNNABLE与 TIMED-WAITING 状态转换调用带时间参数的等待API，自然就从 RUNNABLE 状态进入 TIMED-WAITING 状态；当被唤醒或超时时间到就会从TIMED_WAITING进入RUNNABLE状态 看图中的转换 API 挺多的，其实不用担心，后续分析源码章节，自然就会记住的，现在有个印象以及知道状态转换的节点就好了 相信到这里，你看Java线程生命周期的眼神就没那么迷惑了，重点就是RUNNABLE与休眠状态的切换，接下来我们看一看，如何查看线程中的状态，以及具体的代码触发点 如何查看线程处在什么状态程序中调用 getState() 方法Thread 类中同样存在 getState() 方法用于查看当前线程状态，该方法就是返回上面提到的枚举类 State NEW就是上面提到， 编程语言中特有的，通过继承 Thread 或实现 Runnable 接口定义线程后，这时的状态都是 NEW 12Thread thread = new Thread(() -&gt; &#123;&#125;);System.out.println(thread.getState()); RUNNABLE调用了 start() 方法之后，线程就处在 RUNNABLE 状态了 1234Thread thread = new Thread(() -&gt; &#123;&#125;);thread.start();//Thread.sleep(1000);System.out.println(thread.getState()); BLOCKED等待 synchronized 内置锁，就会处在 BLOCKED 状态 12345678910111213141516171819202122232425262728public class ThreadStateTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new DemoThreadB()); Thread t2 = new Thread(new DemoThreadB()); t1.start(); t2.start(); Thread.sleep(1000); System.out.println((t2.getState())); System.exit(0); &#125;&#125;class DemoThreadB implements Runnable &#123; @Override public void run() &#123; commonResource(); &#125; public static synchronized void commonResource() &#123; while(true) &#123; &#125; &#125;&#125; WAITING调用线程的 join() 等方法，从 RUNNABLE 变为 WAITING 状态 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; Thread main = Thread.currentThread(); Thread thread2 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); e.printStackTrace(); &#125; System.out.println(main.getState()); &#125;); thread2.start(); thread2.join(); &#125; TIMED-WAITING调用了 sleep(long) 等方法，线程从 RUNNABLE 变为 TIMED-WAITING 状态 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; Thread thread3 = new Thread(() -&gt; &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // 为什么要调用interrupt方法？ Thread.currentThread().interrupt(); e.printStackTrace(); &#125; &#125;); thread3.start(); Thread.sleep(1000); System.out.println(thread3.getState()); &#125; TERMINATED线程执行完自然就到了 TERMINATED 状态了 1234Thread thread = new Thread(() -&gt; &#123;&#125;);thread.start();Thread.sleep(1000);System.out.println(thread.getState()); 以上是程序中查看线程，自己写写测试看看状态还好，现实中的程序怎么可能允许你加这么多无用代码，所以，翠花，上酸菜（jstack） jstack 命令查看相信你听说过这玩意，jstack 命令就比较强大了，不仅能查看线程当前状态，还能看调用栈，锁等线程栈信息 大家可以随意写一些程序，这里我用了上面 WAITING 状态的代码, 修改睡眠时间 Thread.sleep(100000)，然后在终端按照下图标示依次执行下图命令 更多功能还请大家自行查看，后续会单独写文章来教大家如何使用jstack查看线程栈信息 Arthas这个利器，无须多言吧，线上找茬监控没毛病，希望你可以灵活使用这个工具，攻克疑难杂症 查看线程栈详细信息，非常方便：https://alibaba.github.io/arthas/thread.html 相信你已经和Arthas确认了眼神 关于线程生命周期状态整体就算说完了，编写并发程序时多问一问自己： 调用某个API会将你的线程置为甚么状态？ 多问自己几次，自然就记住上面的图了 灵魂追问 为什么调用 Thread.sleep, catch异常后，调用了Thread.currentThread().interrupt(); 进入 BLOCKED只有一种情况，就是等待 synchronized 监视器锁，那调用 JUC 中的 Lock.lock() 方法，如果某个线程等待这个锁，这个线程状态是什么呢？为什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041public class ThreadStateTest &#123;public static void main(String[] args) throws InterruptedException &#123; TestLock testLock = new TestLock(); Thread thread2 = new Thread(() -&gt; &#123; testLock.myTestLock(); &#125;, \"thread2\"); Thread thread1 = new Thread(() -&gt; &#123; testLock.myTestLock(); &#125;, \"thread1\"); thread1.start(); Thread.sleep(1000); thread2.start(); Thread.sleep(1000); System.out.println(\"****\" + (thread2.getState())); Thread.sleep(20000); &#125; &#125;@Slf4jclass TestLock&#123; private final Lock lock = new ReentrantLock(); public void myTestLock()&#123; lock.lock(); try&#123; Thread.sleep(10000); log.info(\"testLock status\"); &#125; catch (InterruptedException e) &#123; log.error(e.getMessage()); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; synchronized 和 Lock 有什么区别？ 我这面也在逐步总结常见的并发面试问题（总结ing……）答案整理好后会通知大家，请持续关注 同时，这里也整理了一点 Java 硬核资料，有需要的就公众号回复【资料】/【666】吧","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"并发编程之等待通知机制","slug":"并发编程之等待通知机制","date":"2020-03-15T07:47:24.000Z","updated":"2020-03-15T08:07:45.452Z","comments":true,"path":"/p/waiting-notification-mechanism.html","link":"","permalink":"https://dayarch.top/p/waiting-notification-mechanism.html","excerpt":"并发编程为什么会有等待通知机制 上一篇文章说明了 Java并发死锁解决思路 ， 解决死锁的思路之一就是 破坏请求和保持条件, 所有柜员都要通过唯一的账本管理员一次性拿到所有转账业务需要的账本，就像下面这样： 没有等待/通知机制之前，所有柜员都通过死循环的方式不断向账本管理员申请所有账本，程序的体现就是这样： 1 2 while(!accountBookManager.getAllRequiredAccountBook(this, target)) ； 假如账本管理员是年轻小伙，腿脚利落（即执行 getAllRequiredAccountBook方法耗时短），并且多个柜员转账","text":"并发编程为什么会有等待通知机制上一篇文章说明了 Java并发死锁解决思路 ， 解决死锁的思路之一就是 破坏请求和保持条件, 所有柜员都要通过唯一的账本管理员一次性拿到所有转账业务需要的账本，就像下面这样： 没有等待/通知机制之前，所有柜员都通过死循环的方式不断向账本管理员申请所有账本，程序的体现就是这样： 12while(!accountBookManager.getAllRequiredAccountBook(this, target)) ； 假如账本管理员是年轻小伙，腿脚利落（即执行 getAllRequiredAccountBook方法耗时短），并且多个柜员转账的业务冲突量不大，这个方案简单粗暴且有效，柜员只需要尝试几次就可以成功（即通过少量的循环可以实现） 过了好多年，年轻的账本管理员变成了年迈的老人，行动迟缓（即执行 getAllRequiredAccountBook 耗时长），同时，多个柜员转账的业务冲突量也变大，之前几十次循环能做到的，现在可能就要申请成千上百，甚至上万次才能完成一次转账 人工无限申请浪费口舌， 程序无限申请浪费CPU。聪明的人就想到了 等待/通知 机制 等待/通知机制无限循环实在太浪费CPU，而理想情况应该是这样： 柜员A如果拿不到所有账本，就傲娇的不再继续问了（线程阻塞自己 wait） 柜员B归还了柜员A需要的账本之后就主动通知柜员A账本可用（通知等待的线程 notify/notifyAll） 做到这样，就能避免循环等待消耗CPU的问题了 现实中有太多场景都在应用等待/通知机制。欢迎观临红浪漫，比如去XX办证，去医院就医/体检。 下面请自行脑补一下去医院就医或体检的画面, 整体流程类似这样： 序号 就医 程序解释（自己的视角） 1 挂号成功，到诊室门口排号候诊 排号的患者（线程）尝试获取【互斥锁】 2 大夫叫到自己，进入诊室就诊 自己【获取到互斥锁】 3 大夫简单询问，要求做检查（患者缺乏报告不能诊断病因） 进行【条件判断】，线程要求的条件【没满足】 4 自己出去做检查 线程【主动释放】持有的互斥锁 5 大夫叫下一位患者 另一位患者（线程）获取到互斥锁 6 自己拿到检测报告 线程【曾经】要求的条件得到满足（实则【被通知】） 7 再次在诊室门口排号候诊 再次尝试获取互斥锁 8 … … 在【程序解释】一列，我将关键字（排队、锁、等待、释放….）已经用 【】 框了起来。Java 语言中，其内置的关键字 synchronized 和 方法wait()，notify()/notifyAll() 就能实现上面提到的等待/通知机制，我们将这几个关键字实现流程现形象化的表示一下： 这可不是一个简单的图，下面还要围绕这个图做很多文章，不过这里我必须要插播几个面试基础知识点了： 一个锁对应一个【入口等待队列】，不同锁的入口等待队列没任何关系，说白了他们就不存在竞争关系。你想呀，不同患者进入眼科和耳鼻喉科看大夫一点冲突都没有 wait(), notify()/notifyAll() 要在 synchronized 内部被使用，并且，如果锁的对象是this，就要 this.wait()，this.notify()/this.notifyAll() , 否则JVM就会抛出 java.lang.IllegalMonitorStateException 的。你想呀，等待/通知机制就是从【竞争】环境逐渐衍生出来的策略，不在锁竞争内部使用或等待/通知错了对象， 自然是不符合常理的 有了上面知识的铺垫，要想将无限循环策略改为等待通知策略，你还需要问自己四个问题： 灵魂 4 问 我们拿钱庄账本管理员的例子依依做以上回答： 我们优化钱庄转账的程序： 12345678910111213141516171819202122232425public class AccountBookManager &#123; List&lt;Object&gt; accounts = new ArrayList&lt;&gt;(2); synchronized boolean getAllRequiredAccountBook( Object from, Object to)&#123; if(accounts.contains(from) || accounts.contains(to))&#123; try&#123; this.wait(); &#125;catch(Exception e)&#123; &#125; &#125; else&#123; accounts.add(from); accounts.add(to); return true; &#125; &#125; // 归还资源 synchronized void releaseObtainedAccountBook(Object from, Object to)&#123; accounts.remove(from); accounts.remove(to); notify(); &#125;&#125; 就这样【看】 【似】 【完】 【美】的解决了，其实上面的程序有两个大坑： 坑一在上面 this.wait() 处，使用了 if 条件判断，会出现天大的麻烦，来看下图（从下往上看）： notify 唤醒的那一刻，线程【曾经/曾经/曾经】要求的条件得到了满足，从这一刻开始，到去条件等队列中唤醒线程，再到再次尝试获取锁是有时间差的，当再次获取到锁时，线程曾经要求的条件是不一定满足，所以需要重新进行条件判断，所以需要将 if 判断改成 while 判断 1234567891011121314synchronized boolean getAllRequiredAccountBook( Object from, Object to)&#123; while(accounts.contains(from) || accounts.contains(to))&#123; try&#123; this.wait(); &#125;catch(Exception e)&#123; &#125; &#125; else&#123; accounts.add(from); accounts.add(to); return true; &#125;&#125; 一个线程可以从挂起状态变为可运行状态（也就是被唤醒），即使线程没有被其他线程调用notify()/notifyAll() 方法进行通知，或被中断，或者等待超时，这就是所谓的【虚假唤醒】。虽然虚假唤醒很少发生，但要防患于未然，做法就是不停的去测试该线程被唤醒条件是否满足 ——摘自《Java并发编程之美》 有同学可能还会产生疑问，为什么while就可以？ 因为被唤醒的线程再次获取到锁之后是从原来的 wait 之后开始执行的，wait在循环里面，所以会再次进入循环条件重新进行条件判断。 如果不理解这个道理就记住一句话： 从哪里跌倒就从哪里爬起来；在哪里wait，就从wait那里继续向后执行 所以，这也就成了使用wait()的标准范式 至于坑二，是线程归还所使用的账户之后使用 notify 而不是 notifyAll 进行通知，由于坑很大，需要一些知识铺垫来说明 为什么说尽量使用 notifyAll()notify() 和 notifyAll() 到底啥区别？ notify() 函数 随机唤醒一个：一个线程调用共享对象的 notify() 方法，会唤醒一个在该共享变量上调用 wait() 方法后被挂起的线程，一个共享变量上可能有多个线程在等待，具体唤醒那一个，是随机的 notifyAll() 函数 唤醒所有： 与notify() 不同，notifyAll() 会唤醒在该共享变量上由于调用wait() 方法而被挂起的所有线程 看个非常简单的程序例子吧 示例程序一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Slf4jpublic class NotifyTest &#123; private static volatile Object resourceA = new Object(); public static void main(String[] args) throws InterruptedException &#123; Thread threadA = new Thread(() -&gt; &#123; synchronized (resourceA)&#123; log.info(\"threadA get resourceA lock\"); try&#123; log.info(\"threadA begins to wait\"); resourceA.wait(); log.info(\"threadA ends wait\"); &#125;catch (InterruptedException e)&#123; log.error(e.getMessage()); &#125; &#125; &#125;); Thread threadB = new Thread(() -&gt; &#123; synchronized (resourceA)&#123; log.info(\"threadB get resourceA lock\"); try&#123; log.info(\"threadB begins to wait\"); resourceA.wait(); log.info(\"threadB ends wait\"); &#125;catch (InterruptedException e)&#123; log.error(e.getMessage()); &#125; &#125; &#125;); Thread threadC = new Thread(() -&gt; &#123; synchronized (resourceA)&#123; log.info(\"threadC begin to notify\"); resourceA.notify(); &#125; &#125;); threadA.start(); threadB.start(); Thread.sleep(1000); threadC.start(); threadA.join(); threadB.join(); threadC.join(); log.info(\"main thread over now\"); &#125;&#125; 来看运行结果 程序中我们使用notify()随机通知resourceA的等待队列的一个线程，threadA被唤醒，threadB却没有打印出 threadB ends wait 这句话，遗憾的死掉了 将 notify() 换成 notifyAll() 的结果想必你已经知道了 使用 notifyAll() 确实不会遗落等待队列中的线程，但也产生了比较强烈的竞争，如果notify() 设计的本身就是 bug，那么这个函数应该早就从 JDK 中移除了，它随机通知一个线程的形式必定是有用武之地的 什么时候可以使用 notify() notify() 的典型的应用就是线程池（按照上面的三个条件你自问自答验证一下是这样吗？） 这里我们拿一个 JUC 下的类来看看 notify() 的用处 Tips: notify() 等同于 signal() wait() 等同于 await() 在IDE中，打开 ArrayBlockingQueue.java 所有的入队 public 方法offer()/put() 内部都调用了 private 的 enqueue() 方法 所有的出队 public 方法poll()/take() 内部都调用了 private 的 dequeue() 方法 将这个模型进行精简就是下面这个样子： 123456789101112131415161718192021222324252627282930313233343536373839public class SimpleBlockingQueue&lt;T&gt; &#123; final Lock lock = new ReentrantLock(); // 条件变量：队列不满 final Condition notFull = lock.newCondition(); // 条件变量：队列不空 final Condition notEmpty = lock.newCondition(); // 入队 void enq(T x) &#123; lock.lock(); try &#123; while (队列已满)&#123; // 等待队列不满 notFull.await(); &#125; // 省略入队操作... //入队后,通知可出队 notEmpty.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125; // 出队 void deq()&#123; lock.lock(); try &#123; while (队列已空)&#123; // 等待队列不空 notEmpty.await(); &#125; // 省略出队操作... //出队后，通知可入队 notFull.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 如果满足上面这三个条件，notify() 的使用就恰到好处；我们用使用 notify()的条件进行验证 有的同学看到这里可能会稍稍有一些疑惑，await()/signal() 和 wait()/notify() 组合的玩法看着不太一样呢，你疑惑的没有错 因为 Java 内置的监视器锁模型是 MESA 模型的精简版 MESA模型MESA 监视器模型中说，每一个条件变量都对应一个条件等待队列 对应到上面程序： 队列已满是前提条件，条件变量A就是notFull，也就是notFull.await; notFull.signal 队列已空是前提条件，条件变量B就是notEmpty，也就是notEmpty.await; notEmpty.signal/sign 即便notFull.signalAll, 也和await在notEmpty 条件变量队列的线程没半毛钱关系 而Java内置监视器模型就只会有一个【隐形的】条件变量 如果是synchronized修饰的普通方法，条件变量就是 this 如果是synchronized修饰的静态方法，条件变量就是类 如果是synchronized块，条件变量就是块中的内容了 说完了这些，你有没有恍然大悟的感觉呢 总结如果业务冲突不大，循环等待是一种简单粗暴且有效的方式；但是当业务冲突大之后，通知/等待机制是必不可少的使用策略 通过这篇文章，相信你已经可以通过灵魂4问，知道如何将循环等待改善成通知/等待模型了；另外也知道如何正确的使用通知/等待机制了 灵魂追问 钱庄转账的业务，条件都是判断账户是否被支配，都是执行相同的转账业务，为什么就不可以用notify() 而只能用notifyAll() 呢 ResourceA的例子，为什么使用notify通知，程序没有打印出 main thread over now， 而使用notifyAll() 却打印出来了呢？ 参考感谢前辈们总结的精华，自己所写的并发系列好多都参考了以下资料 Java 并发编程实战 Java 并发编程之美 码出高效 Java 并发编程的艺术 https://www.geeksforgeeks.org/difference-notify-notifyall-java/ … 下面的文章，就需要聊聊【线程的生命周期】了，只有熟知线程的生命周期，你才能更好的编写并发程序。 我这面也在逐步总结常见的并发面试问题（总结ing……）答案整理好后会通知大家，请持续关注 同时，这里也整理了一点 Java 硬核资料，有需要的就公众号回复【资料】/【666】吧","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"volatile和synchronized图文透彻讲解","slug":"volatile和synchronized关键字图文讲解不同","date":"2020-03-04T03:37:38.000Z","updated":"2020-03-04T03:51:00.887Z","comments":true,"path":"/p/difference-between-volatile-and-synchronized-keyword.html","link":"","permalink":"https://dayarch.top/p/difference-between-volatile-and-synchronized-keyword.html","excerpt":"* 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 * If you can NOT explain it simply, you do NOT understand it well enough 现陆续将Demo代码和技术文章整理在一起 Github实践精选 ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star🌟 之前写了几篇 Java并发编程的系列 文章，有个朋友微群里问我，还是不能理解 volatile 和 synchronized 二者的区别, 他的问题主要可以归纳为这几个： * volatile 与 synchron","text":"你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough 现陆续将Demo代码和技术文章整理在一起 Github实践精选 ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star🌟 之前写了几篇 Java并发编程的系列 文章，有个朋友微群里问我，还是不能理解 volatile 和 synchronized 二者的区别, 他的问题主要可以归纳为这几个： volatile 与 synchronized 在处理哪些问题是相对等价的？ 为什么说 volatile 是 synchronized 弱同步的方式？ volatile 除了可见性问题，还能解决什么问题？ 二者我要如何选择使用？ 如果你不能回答上面的几个问题，说明你对二者的区别还有一些含混。本文就通过图文的方式好好说说他们微妙的关系 都听过【天上一天，地下一年】，假设 CPU 执行一条普通指令需要一天，那么 CPU 读写内存就得等待一年的时间。 受【木桶原理】的限制，在CPU眼里，程序的整体性能都被内存的办事效率拉低了，为了解决这个短板，硬件同学也使用了我们做软件常用的提速策略——使用缓存Cache（实则是硬件同学给软件同学挖的坑） Java 内存模型（JMM）CPU 增加了缓存均衡了与内存的速度差异，这一增加还是好几层。 此时内存的短板不再那么明显，CPU甚喜。但随之却带来很多问题 看上图，每个核都有自己的一级缓存（L1 Cache），有的架构里面还有所有核共用的二级缓存（L2 Cache）。使用缓存之后，当线程要访问共享变量时，如果 L1 中存在该共享变量，就不会再逐级访问直至主内存了。所以，通过这种方式，就补上了访问内存慢的短板 具体来说，线程读/写共享变量的步骤是这样： 从主内存复制共享变量到自己的工作内存 在工作内存中对变量进行处理 处理完后，将变量值更新回主内存 假设现在主内存中有共享变量 X， 其初始值为 0 线程1先访问变量 X， 套用上面的步骤就是这样： L1 和 L2 中都没有发现变量 X，直到在主内存中找到 拷贝变量 X 到 L1 和 L2 中 在 L1 中将 X 的值修改为1，并逐层写回到主内存中 此时，在线程 1 眼中，X 的值是这样的： 接下来，线程 2 同样按照上面的步骤访问变量 X L1 中没有发现变量 X L2 中发现了变量X 从L2中拷贝变量到L1中 在L1中将X 的值修改为2，并逐层写回到主内存中 此时，线程 2 眼中，X 的值是这样的： 结合刚刚的两次操作，当线程1再访问变量x，我们看看有什么问题： 此刻，如果线程 1 再次将 x=1回写，就会覆盖线程2 x=2 的结果，同样的共享变量，线程拿到的结果却不一样（线程1眼中x=1；线程2眼中x=2），这就是共享变量内存不可见的问题。 怎么补坑呢？今天的两位主角闪亮登场，不过在说明 volatile关键字之前，我们先来说说你最熟悉的 synchronized 关键字 synchronized遇到线程不安全的问题，习惯性的会想到用 synchronized 关键字来解决问题，暂且先不论该办法是否合理，我们来看 synchronized 关键字是怎么解决上面提到的共享变量内存可见性问题的 【进入】synchronized 块的内存语义是把在 synchronized 块内使用的变量从线程的工作内存中清除，从主内存中读取 【退出】synchronized 块的内存语义事把在 synchronized 块内对共享变量的修改刷新到主内存中 二话不说，无情向下看 volatile volatile当一个变量被声明为 volatile 时： 线程在【读取】共享变量时，会先清空本地内存变量值，再从主内存获取最新值 线程在【写入】共享变量时，不会把值缓存在寄存器或其他地方（就是刚刚说的所谓的「工作内存」），而是会把值刷新回主内存 有种换汤不换药的感觉，你看的一点都没错 所以，当使用 synchronized 或 volatile 后，多线程操作共享变量的步骤就变成了这样： 简单点来说就是不再参考 L1 和 L2 中共享变量的值，而是直接访问主内存 来点踏实的，上例子🌰 1234567891011121314public class ThreadNotSafeInteger &#123; /** * 共享变量 value */ private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125;&#125; 经过前序分析铺垫，很明显，上面代码中，共享变量 value 存在大大的隐患，尝试对其作出一些改变 先使用 volatile 关键字改造： 1234567891011121314public class ThreadSafeInteger &#123; /** * 共享变量 value */ private volatile int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125;&#125; 再使用 synchronized 关键字改造 1234567891011121314public class ThreadSafeInteger &#123; /** * 共享变量 value */ private int value; public synchronized int getValue() &#123; return value; &#125; public synchronized void setValue(int value) &#123; this.value = value; &#125;&#125; 这两个结果是完全相同，在解决【当前】共享变量数据可见性的问题上，二者算是等同的 如果说 synchronized 和 volatile 是完全等同的，那就没必要设计两个关键字了，继续看个例子 1234567891011121314151617181920212223242526272829303132333435@Slf4jpublic class VisibilityIssue &#123; private static final int TOTAL = 10000;// 即便像下面这样加了 volatile 关键字修饰不会解决问题，因为并没有解决原子性问题 private volatile int count; public static void main(String[] args) &#123; VisibilityIssue visibilityIssue = new VisibilityIssue(); Thread thread1 = new Thread(() -&gt; visibilityIssue.add10KCount()); Thread thread2 = new Thread(() -&gt; visibilityIssue.add10KCount()); thread1.start(); thread2.start(); try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; log.error(e.getMessage()); &#125; log.info(\"count 值为：&#123;&#125;\", visibilityIssue.count); &#125; private void add10KCount()&#123; int start = 0; while (start ++ &lt; TOTAL)&#123; this.count ++; &#125; &#125;&#125; 其实就是将上面setValue 简单赋值操作 （this.value = value;）变成了 （this.count ++;）形式，如果你运行代码，你会发现，count的值始终是处于1w和2w之间的 将上面方法再以 synchronized 的形式做改动 123456789101112131415@Slf4jpublic class VisibilityIssue &#123; private static final int TOTAL = 10000; private int count; //... 同上 private synchronized void add10KCount()&#123; int start = 0; while (start ++ &lt; TOTAL)&#123; this.count ++; &#125; &#125;&#125; 再次运行代码，count 结果就是 2w 两组代码，都通过 volatile 和 synchronized 关键字以同样形式修饰，怎么有的可以带来相同结果，有的却不能呢？ 这就要说说二者的不同了 count++ 程序代码是一行，但是翻译成 CPU 指令确是三行( 不信你用 javap -c 命令试试) synchronized 是独占锁/排他锁（就是有你没我的意思），同时只能有一个线程调用 add10KCount 方法，其他调用线程会被阻塞。所以三行 CPU 指令都是同一个线程执行完之后别的线程才能继续执行，这就是通常说说的 原子性 （线程执行多条指令不被中断） 但 volatile 是非阻塞算法（也就是不排他），当遇到三行 CPU 指令自然就不能保证别的线程不插足了，这就是通常所说的，volatile 能保证内存可见性，但是不能保证原子性 一句话，那什么时候才能用volatile关键字呢？（千万记住了，重要事情说三遍，感觉这句话过时了） 如果写入变量值不依赖变量当前值，那么就可以用 volatile 如果写入变量值不依赖变量当前值，那么就可以用 volatile 如果写入变量值不依赖变量当前值，那么就可以用 volatile 比如上面 count++ ，是获取-计算-写入三步操作，也就是依赖当前值的，所以不能靠volatile 解决问题 到这里，文章开头第一个问题【volatile 与 synchronized 在处理哪些问题是相对等价的？】答案已经揭晓了 先自己脑补一下，如果让你同一段时间内【写几行代码】就要去【数钱】，数几下钱就要去【唱歌】，唱完歌又要去【写代码】，反复频繁这样操作，还要接上上一次的操作（代码接着写，钱累加着数，歌接着唱）还需要保证不出错，你累不累？ synchronized 是排他的，线程排队就要有切换，这个切换就好比上面的例子，要完成切换，还得记准线程上一次的操作，很累CPU大脑，这就是通常说的上下文切换会带来很大开销 volatile 就不一样了，它是非阻塞的方式，所以在解决共享变量可见性问题的时候，volatile 就是 synchronized 的弱同步体现了 到这，文章的第二个问题【为什么说 volatile 是 synchronized 弱同步的方式？】你也应该明白了吧 volatile 除了还能解决可见性问题，还能解决编译优化重排序问题，之前的文章已经介绍过，请大家点击链接自行查看就好（面试常问的双重检查锁单例模式为什么不是线程安全的也可以在里面找到答案哦）： 有序性可见性，Happens-before来搞定 面试volatile关键字时，我们应该具备哪些谈资？ 看完这两篇文章，相信第三个问题也就迎刃而解了 了解了这些，相信你也就懂得如何使用了 精挑细选，终于整理完初版 Java 技术栈硬核资料，抢先看就公众号回复【资料】/【666】吧 灵魂追问 你了解线程的生命周期吗？不同的状态流转是什么样的？ 为什么线程有通知唤醒机制？ 下一篇文章，我们来说说【唤醒线程为什么建议用notifyAll而不建议用notify呢？】","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"},{"name":"volatile","slug":"volatile","permalink":"https://dayarch.top/tags/volatile/"},{"name":"synchronized","slug":"synchronized","permalink":"https://dayarch.top/tags/synchronized/"}]},{"title":"Java后端的我在学Node.js 你敢信？","slug":"Java后端的我在学Node-js-你敢信？","date":"2020-02-27T00:40:40.482Z","updated":"2020-02-27T01:01:23.540Z","comments":true,"path":"/p/start-to-learn-nodejs.html","link":"","permalink":"https://dayarch.top/p/start-to-learn-nodejs.html","excerpt":"项目需要，我需要储备一些Node.js 相关的知识了，整体感觉是一件好事 背景 从前，我也写过前端，不过那会最多用到HTML5 +jQuery相关技术。也没有准确的时间点来划分，我就忽忽悠悠的专注于Java后端了 像现在的大前端Angular、VUE、REACT这些大前端框架我只是略有了解，完全没有用过，用Node作为中间服务器也是相对陌生状态，项目中需要，我是一定不会放过这个可以掉头发的良机（想法很简答， 跳出自己的舒适区） 毕竟要在实际项目中写Node代码的，这么严峻的问题我是要认真对待的，要不然会让队友消耗太多 WTFs/min 能量（这是什么含义？请看【读《Clean C","text":"项目需要，我需要储备一些Node.js 相关的知识了，整体感觉是一件好事 背景从前，我也写过前端，不过那会最多用到HTML5 +jQuery相关技术。也没有准确的时间点来划分，我就忽忽悠悠的专注于Java后端了 像现在的大前端Angular、VUE、REACT这些大前端框架我只是略有了解，完全没有用过，用Node作为中间服务器也是相对陌生状态，项目中需要，我是一定不会放过这个可以掉头发的良机（想法很简答， 跳出自己的舒适区） 毕竟要在实际项目中写Node代码的，这么严峻的问题我是要认真对待的，要不然会让队友消耗太多 WTFs/min 能量（这是什么含义？请看【读《Clean Code 代码整洁之道》之感悟】），作为一个小白，通过学习一小段时间还是有所收获的，下面主要说一下我的学习过程，请有经验的大佬多指正，让俺少走点弯路多留几根头发 Node.js 学习和大家一样，我也是各种上网查阅资料，这里将目前的学习过程做个简单的记录 Node.js 官网学习一样东西，第一步自然是先打开官网，这里根正苗红，与众不同 优点：很快可以有一个相对直观的了解，文档与API齐全 缺点：这里的苗太正了，【事件驱动、构建在V8引擎】等陌生词汇直接让我眼冒金星，这类词语就好比小时候父母对我们说的词汇，只有长大之后才会明白 面对这些陌生的内容，我并不是很担心（内心懵的一P），相信长大后会明白的，随手毫不留情把网站关掉 tutorialspointtutorialspoint 是我非常喜欢的学习网站，上面有很多技术教程，先来个截图瞧瞧 优点：教程内容简单明了，循序渐进，案例代码齐全 缺点：这是一个英文网站 （Tips: 看英文文档应该成为我们的必备技能之一） 不要被英文网站吓到，其实没什么陌生词汇，按照Node.js 教程 从头到尾撸了一遍，有了相对全面的了解，知道了基本骨架内容, 一边撸一遍记笔记（忽略着潦草的字） 中途还是有很多不理解的内容，都用黄色的笔圈了出来，放在后面慢慢查阅，紧跟主线，以防自己跑偏 极客时间/慕课网教学视频是前辈多年浓缩的精华，有了一些基础概念，我会选择站在巨人的肩膀上整体看一下。日常主要通过【极客时间】和【慕课网】这两个网站搜索视频资料，其中还在极客时间购买了下面的这门课 这门课的基础知识讲的不算多，前序章节以石头剪刀布的简单游戏来说明Node.js一些特性，后面实战实现极客时间【详情/列表/评论】等页面 杨浩老师讲解的很清晰，中间穿插着很多冷幽默，但对于小白的我来说，这门课看早了，里面讲的很多内容我还不能理解，但是里面说的一些构建思想，比如CommonJS，这些内容还是十分受用的，视频课程目前看了超过2/3，我选择按下暂停键，觉得有必要写一些Demo来使用上面学到的一些知识点了，我相信当我再回头过来看这个视频的收获一定是不一样的 Github欢迎来到世界最大的同性交友网站，想不到要写一个什么样的Demo，于是来这里搜索一下，还真找到了自建博客的学习性项目N-Blog （你有什么需求完全可以先来上面找找轮子的） 找项目有几看： commits的活跃度 星标/fork数量 README/wiki编写质量 Issues处理情况 按照上述几个标准确认过眼神，这是我要找的姑娘 该项目主要应用下面几项技术： Node.js: 8.9.1 MongoDB: 3.4.10 Express: 4.16.2 看技术栈，就可以认定，这是接近真实项目的存在，于是，按部就班的敲代码，敲代码，敲代码（不是复制粘贴），因为敲代码就可能会出现错误，这样也在学习中逐步学会了调试 通过两天时间也终于做出了最终的效果 麻雀虽小，五脏俱全，在实现过程遇到了太多问题，比如： npm全局安装权限问题 Homebrew 安装MongoDB不支持services指令问题 陌生的API使用问题 …… 在学习的过程中我都有做记录，同时结合项目内容做了下面这张思维导图，只有全部点亮这些叶子，才能算是做完了这个Demo（更多细节内容隐藏在了节点notes里面） 这个思维导图肯定不是标准的Node.js 学习内容，只不过是应对我本次基础的学习，后续的学习会不断对这个思维导图进行修正的 总结你以为我们就可以彻底抛弃官网了吗？在调试与编写代码的过程中，遇到某个知识点，就要果断回到官网查看，那里有最权威的解释。另外，带有目的性的查看官网总比一头扎进去舒服的多，你觉得呢 与其说这是我这几天学习Node.js 方式，不如说这是我学习新东西的整体方法和路线，写这篇文章也想借此当个话题和大家聊聊，欢迎大家留言或进群分享彼此的学习方法/读书笔记/技术交流等，共同进步 隔三差五，我也会输出一些Node.js 相关的内容，你以为我喜新厌旧了？在我心中，Java依旧是我怡红院的头牌（我必须宠她） 最后，不要永远呆在自己的舒适区，stay hungry， stay foolish","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Node.js","slug":"Coding/Node-js","permalink":"https://dayarch.top/categories/Coding/Node-js/"}],"tags":[]},{"title":"闲着无聊考个PMP玩玩","slug":"闲着无聊考个PMP玩玩","date":"2020-02-11T03:17:05.000Z","updated":"2020-02-11T03:18:15.436Z","comments":true,"path":"/p/pmp-certificate.html","link":"","permalink":"https://dayarch.top/p/pmp-certificate.html","excerpt":"本已将PMP考试记录在2019年年终总结的事件之一里了，春节有朋友问我，想让我分享一下，我回想了整个过程还是挺有趣的，于是本文就以纪实的形式写写考PMP的那点事，有兴趣的可以私聊，避免说广告 PMP（Project Management Professional）学名「项目管理专家」，我叫它「拍马屁」。2019年4月的时候在朋友圈看到有两位朋友先后【注意是先后，有埋伏】晒出来PMP的证件出来，看着挺好看的（文末有，还是纪念版，这个理由好牵强），就果断去骚扰了他们询问具体情况 朋友A：有的公司认可这个证件，没事考个还挺有用的。 朋友B：考试险过，不知道有没有用，有朋友考，一起跟着考了 心","text":"本已将PMP考试记录在2019年年终总结的事件之一里了，春节有朋友问我，想让我分享一下，我回想了整个过程还是挺有趣的，于是本文就以纪实的形式写写考PMP的那点事，有兴趣的可以私聊，避免说广告 PMP（Project Management Professional）学名「项目管理专家」，我叫它「拍马屁」。2019年4月的时候在朋友圈看到有两位朋友先后【注意是先后，有埋伏】晒出来PMP的证件出来，看着挺好看的（文末有，还是纪念版，这个理由好牵强），就果断去骚扰了他们询问具体情况 朋友A：有的公司认可这个证件，没事考个还挺有用的。 朋友B：考试险过，不知道有没有用，有朋友考，一起跟着考了 心想，毕业后好久都没考过试，不能自废武功，把从小培养的考试技能（考试应该是中国孩子的童子功吧）荒废掉，就这样在内心中了要考这个证件的草 人难免有冲动和拖延症，我也不例外，转眼间来到了8月，公司飘来一封邮件，考XX证件可以报销，炎热的夏季我瞬间精神了一点，我是个俗人，考试费用挺贵的，好几K呢，既然公司能给报销很多，那就着手安排呗 我还是想省点费用，我就又找朋友A确认是否可以自学 朋友A：能自学，但是很难（这句话很PMP哲学啊，后面你就懂了） 我内心其实是抵触培训班的，比如前段时间那么大的XX英语培训机构就跑路了，我天资和聪敏不搭边，那就挺着报个培训班吧，找到培训机构的人，直接微信转账就成了，转账的那一刻，内心强烈的痛了一下 这个节点报名，只能报考12月7号的考试了（应该是每年3/6/9/12月份都有考试），被培训老师拉到一个微信群中，指导我们如何在PMI网站上注册报名等，钱那么贵，填写报考信息异常谨慎，高考都是随便填的 没几天，就收到了培训机构发来的资料（其实主要是电子版/纸质版的书），作为Java程序员，我一直保留着那本已经泛黄的神书《Java编程思想》，我把PMP的书和这本书放在一起对比一下自己体会吧 机构老师说：国庆假期最好自己从头到尾看一遍，最差也要看前三张，看不懂也要硬看，节后就要去机构上课了，讲课节奏会很快 培训费教了让我自己学我是肯定不干的，我不是亏了😂，其实我假期真的硬着头皮看了，勉强看完第三章，但是到底看了个啥我也浑然不知，我的天资果真无情的打我 总共有8节线下课程，都是周六周日的全天课程，那段时间项目还特别忙，有两次周末的加班我也没有去，内心还是对不住我组内的兄弟们的。那段时间的节奏，算是9N7（N不固定）吧 培训课如期开始，每天内容很慢，培训老师的能力不是瞎胡闹的，总是能各种穿针引线，感觉老师都这样讲课，学生应该不会困吧，应对考前突击，后几节课就是边讲课边做模拟题了 12月7号，考试终于到来，说说有关考试： 考试时间：9:00am——13:pm，中途没有暂停，题型全部是单项选择题，总共200道题，考试只需要带身份证（纸，笔，计算器，水，钟表，考场都提供） 考试考题非常灵活，简单来说，如果四个选项都对，选择最对的；如果四个选项都错，选错最少的那个，经过四个小时的煎熬苦战，临近考试结束前10分钟涂完答题卡，考完完全懵逼状态，因为没有标准答案，因为历届考题都不发布标准答案，考完饿的不行，回家狠狠的吃了一顿，其他的一切就看运气吧 一个月后的某个早晨，培训老师突然在群里说可以查成绩了，但是，但是，但是不是所有考生一下都能查到成绩，考试成绩分一周时间陆续全部公布，你就说有多变态吧，群里其他朋友已经出成绩了，我快把手机刷爆也没有得到我的成绩，带着恐慌和担忧开始睡觉 整宿都在做梦，一会没过，吓醒，庆幸这是梦，考试成绩还没到呢；一会过了，高兴的醒了，遗憾这为什么是个梦；天蒙蒙亮，已全然没有睡意，祈祷式翻看邮件，一封新邮件的到来让我心跳加倍，Congra……，终于能过个好年，考试成绩过了，还很意外，得了个5A，还是晒一张图吧 赶上PMP考试多少周年，这一版证书很特别，是红色滴，其他的都是蓝色的，hiahia 整个过程到这里就结束了，接下来说说我对PMP的看法： IT行业管理模式越来越扁平化，很少有纯管理岗，也很少有纯技术岗，相对来说有技术的管理岗更好一些，因为干什么事心中都是有底的 PMP考试本身没什么意义，但是在整个备考过程锻炼的逻辑思维，以及要短期内学习那么厚一本书的内容的归纳能力这些软技能都是非常值得学习的，单纯编写代码很难学习到这方面的技能 部分公司认可，还是能在薪水和一些发展上带来一定的帮助，能有多少，还看自己的实际能力，老师也说，想做好项目管理，不霍霍几个项目，单纯考一个证就是纸上谈兵，任何项目过程都很复杂难办 回看整个考试，其实难度觉得不大，我也是想借此机会重拾考试技能包，为接下来的几个考试认证，包括Elastic Search 或 AWS 做一些铺垫，找找感觉，算是考试试水吧 毕竟是为了应对考试拿结果，如果时间不充裕，找个靠谱的培训机构还是值得的，自学我觉得浪费很多时间，不如多看看其他方便的东西 到这里了，有兴趣的私聊吧，毕竟每个人的情况还是不一样滴","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"其他","slug":"Life/其他","permalink":"https://dayarch.top/categories/Life/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://dayarch.top/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"Java 12 新特性一览","slug":"Java-12-新特性一览","date":"2020-02-10T06:30:27.000Z","updated":"2020-02-10T06:45:45.751Z","comments":true,"path":"/p/jdk12-new-feature-overview.html","link":"","permalink":"https://dayarch.top/p/jdk12-new-feature-overview.html","excerpt":"* 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 * If you can NOT explain it simply, you do NOT understand it well enough 现陆续将Demo代码和技术文章整理在一起 Github实践精选，本文同样收录在此，方便大家阅读查看，觉得不错，还请Star🌟 日常工作对集合操作真的太频繁了，前端时间就写过一篇关于Java 12 集合的文章 Java12 Collectors.teeing 的使用详解 ， 有朋友留言说这个功能比较好用。个人觉得 Java12还有几个特性可以尝试","text":"你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough 现陆续将Demo代码和技术文章整理在一起 Github实践精选，本文同样收录在此，方便大家阅读查看，觉得不错，还请Star🌟 日常工作对集合操作真的太频繁了，前端时间就写过一篇关于Java 12 集合的文章 Java12 Collectors.teeing 的使用详解 ， 有朋友留言说这个功能比较好用。个人觉得 Java12还有几个特性可以尝试使用，这篇文章就出炉了 如果你目前使用的Java版本不是12，也没有关系，早已为你准备好良方，SDKMAN 统一灵活管理多版本Java ，可以让你快速各种尝鲜新特性 String API 变化String.indent()indent 「缩进」这个单词大家很熟悉了，这是Java12处理字符串的新功能，先来看方法定义： 该方法很简单，只接收一个 int 类型的参数表示缩进值，这里的 n 既可以是正数，也可以是负数，只不过是增加空格 space 和移除空格的差别，来看个例子： 12String result = \"foo\\nbar\\nbar2\".indent(4);System.out.println(result); 打印结果是这样的（考验眼力的时候到了，仔细看截图在IDE中设置的缩进小点点😜）： 调用 indent 方法会自动添加一个换行符号 \\n ，在该方法的实现中也明确给了注释说明，目的是为了行终结符的规范化 注意：对于 Tab 就是当成一个字符来看到，比如我们把上面的例子稍作修改： 12String result = \"foo\\nbar\\n\\tbar2\".indent(4);System.out.println(result); 来看打印结果，注意和上面的不同： 就是这么简单，我们继续向下看 String.transform()transform 「转换」，我们经常会遇到字符串形势转换的需求，transform方法接收一个 Function 类型的参数， 生成一个全新形式的字符串 12345678910List&lt;String&gt; names = List.of( \" Alex\", \"brian\");List&lt;String&gt; transformedNames = new ArrayList&lt;&gt;();for (String name : names)&#123; String transformedName = name.transform(String::strip) .transform(StringUtils::toCamelCase); transformedNames.add(transformedName);&#125; 有朋友可能会说，这个和单纯的对字符串 trim 或者其他操作有什么区别啊？因为接受的参数是 Function类型，当Function类型作为入参时，内部的处理逻辑将增加更多灵活性 Files.mismatch(Path, Path)有时候，我们需要比较两个文件的内容是否相同，这个API就派上用场了，该方法比较两个 path 下的文件，并且返回一个 long 值，这个值表示第一处不匹配的字节位置。如果返回-1，说明两个文件相等，还是来看个例子： 12345678910Path file1 = Paths.get(\"/Users/fraser/Documents/projects/personal/learning-demo-collection/jdk12-demo/src/file1.txt\"); Path file2 = Paths.get(\"/Users/fraser/Documents/projects/personal/learning-demo-collection/jdk12-demo/src/file2.txt\"); try &#123; long mismatch = Files.mismatch(file1, file2); System.out.println(mismatch); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 两个文件内容分别是： 1234//file1.txt大家好，我是日拱一兵，叫我拱哥就好//file2.txt大家好，我是日拱一兵，叫我兵兵就好 查看运行结果： 建议大家查看一下 mismatch 的实现逻辑，有个小算法在里面的 Support for Unicode 11 （当个了解就好了）当下，Emoji 表情符号在社交媒体渠道上扮演着重要角色，所以支持最新的 Unicode 规范比以往任何时候都更重要。Java 12保持了同步并支持Unicode 11。Unicode 11增加了684个字符，共137,374个字符，增加了7个新脚本，共146个脚本。 Switch Expressions(Preview)这个更改扩展了switch语句。为什么这么说？ 语句（我们原来那样使用） 表达式（不必为每个case块定义一个break语句，我们可以简单地使用箭头语法） 变量赋值（使用新的switch表达式，我们可以直接将switch语句分配给一个变量） 12345678910boolean isWeekend = switch (day) &#123; case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; false; case SATURDAY, SUNDAY -&gt; true; default -&gt; throw new IllegalStateException(\"Illegal day entry :: \" + day);&#125;; System.out.println(isWeekend); 注意： 要使用此预览特性，请记住，我们必须在应用程序启动期间使用-enable-preview标志显式地指示JVM。 Compact Number Formatting (紧凑的数据格式)由用户界面或命令行工具呈现的大数字总是很难展现。使用数字的缩写形式则要直观很多。前端为了更有好的数据展现形式，很早就有相应的组件实现了。现在后端小伙伴也可以在java12中应用这个特性了 紧凑的数字表示更易于阅读，并且在不丢失原始含义的情况下，在屏幕上需要更少的空间。 例子：3.6M 比 3,600,000 容易读得多 Java 12 引入了一个叫做 NumberFormat.getCompactNumberInstance(Locale, NumberFormat.Style)的静态方法。用于创建紧凑数字表示形式，来看例子： 1234NumberFormat formatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);String formattedString = formatter.format(25000L);System.out.println(formattedString); 来看运行结果： 另外，CompactNumberFormat 是 NumberFormat的子类，我们可以自定义它的实例（其实就是格式化样式等），很简单，这个大家自行查看吧 总结Java近两年升级真是太快了，了解一些新功能总是没错的，大家动手实践试试吧，以后遇到类似的需求至少能避免我们重复造轮子了….. 灵魂追问 你们项目中Java的版本是多少？ 项目中你会怎样建议某些工具的升级？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"}]},{"title":"IntelliJ IDEA HTTP Client高级使用详解","slug":"IntelliJ-IDEA-HTTP-Client高级使用详解","date":"2020-02-07T02:30:15.000Z","updated":"2020-02-27T00:54:29.557Z","comments":true,"path":"/p/http-client-advanced-usage.html","link":"","permalink":"https://dayarch.top/p/http-client-advanced-usage.html","excerpt":"* 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 * If you can NOT explain it simply, you do NOT understand it well enough 陆续将Demo代码和技术文章整理在一起 Github实践精选，方便大家阅读查看，觉得不错，还请Star🌟🌟🌟🌟🌟🌟 抗击疫情，在家办公。工作照常干，领导需要几个新功能接口开发。以前在公司办公，通常开发完的功能没什么问题，暴露出 Swagger 接口文档，直接找旁边的前端大人联调测试了 当下，君在长江头，我在长江尾，夜夜思君不敢出门见","text":"你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough 陆续将Demo代码和技术文章整理在一起 Github实践精选，方便大家阅读查看，觉得不错，还请Star🌟🌟🌟🌟🌟🌟 抗击疫情，在家办公。工作照常干，领导需要几个新功能接口开发。以前在公司办公，通常开发完的功能没什么问题，暴露出 Swagger 接口文档，直接找旁边的前端大人联调测试了 当下，君在长江头，我在长江尾，夜夜思君不敢出门见君啊，一切测试全交给自己吧， 虽然想念前端，但是在家办公也绝对是和在公司办公一样一样的，高效不（qu）摸鱼 插播背景在多个产品线上来回穿切换着开发功能，以前用Postman的场景是这样的: 实际远远不止这几个文件夹来归类多个产品线的接口，Postman的功能非常强大，但是面对以下这些状况时，我觉得调试一个接口太麻烦了 （这里不讨论工具的好坏，工具是帮助我们提高效率的，每个人的需求也不一样，我只说明我个人遇到的一些情况，不喜请勿喷） 查找配置多数要通过鼠标点来点去, 与习惯文本和快捷键操作的便捷方式违背 调试别人接口要导入他们的一些数据，比较麻烦 多个产品线环境变量查看不直观 写完接口要来回切换应用进行测试，比如（IDEA &lt;——&gt; Postman） 快速定位接口比较麻烦 …… 无意间发现 IntelliJ IDEA 的 HTTP Client 工具刚好能解决我上面提到的一些问题，简单的说就是能直接在 IDEA 的代码编辑器中 创建，编辑，执行 HTTP请求，就像这样(如果你心动了，请继续向下看吧)： 于是，去官网查看一番作出如下整理： 走进 Http ClientHTTP Client 是 IDEA 默认绑定好并启用的插件，如果你那里没有启用，按照下图启用就好 点击菜单：Tools — HTTP Client — Test RESTful Web Service 接下来进入下面的界面： 上图已给出提示，REST Client 是被弃用的，点击右侧的 Convert request to new format , 进到下面界面： 默认会创建一个名为 rest-api.http 的文件，该文件被存储在 Scratches 文件夹下，为了突出主角光环，关于 Scratch Files 请官网自行查看 （继续向下看不影响理解的），黄色框线的功能也非常有用，继续向下看 创建 HTTP request 文件刚刚提到的 rest-api.http 就是 HTTP request 文件，可以通过两种方式创建： 通过快捷键 ⇧⌘N 然后选择 HTTP Request. （文件存放在Scratches 文件夹） 通过菜单操作 File—New—HTTP Request （文件存放在我们指定的目录下，就和我们平时创建class/package是一样一样滴） 如果在项目中使用，这里推荐使用第二种方式，因为它可以作为项目文件，通过 Git 提交到仓库，大家共享文件，共同维护接口请求数据，自然就不会出现调试别人接口还要导入他人数据的情况啦 编辑 HTTP request 文件我们模拟实际项目中场景来编辑文件 用户登录，成功后获取 Token，通常是 POST 请求 用户后续访问行为都要在请求头中携带登录成功返回的 Token 通过点击 Add Request，选择相应的方法就可以编写啦 都知道，通常写一个完整的请求需要写好多内容，贴心的 IDEA 给我们提供了模版，我们只需要在 Examples 中找模版就可以啦，比如找 POST 请求的模版，选取合适的拷贝过去就可以，so easy～～～ 到这里，就可以发送基本的请求了，但是，一个项目中接口众多，如何快速生成参数？如何快速切换端口？如何让登录之后的每个请求自动携带成功返回的 Token？我们需要更高级的玩法 HTTP Client 进阶玩法使用环境变量在编写HTTP请求时，可以使用变量对其元素进行参数化。变量可以保存请求的host、port和path、查询参数或值、请求头值或请求体值等. 使用变量的方式非常简单，就用两个大括号包围定义好的变量就可以了，就像这样： 当然我们也要有地方定义变量 定义环境变量环境变量需要定义在环境文件中，环境文件有两种： 创建名为 rest-client.env.json 或者 http-client.env.json 的环境文件(其实里面就是保存 JSON 数据)，该文件里可以定义用在整个项目上的所有常规变量 创建名为rest-client.private.env.json 或者 http-client.private.env.json， 看文件名你应该也猜到这是保存敏感数据的，比如密码，token等，该文件默认是被加入到 VCS 的 ignore文件中的，同时优先级高于其他环境文件， 也就是说，该文件的变量会覆盖其他环境文件中的变量值 里面的文件内容就像这样 1234567891011121314&#123; \"dev\": &#123; \"host\": \"localhost\", \"port\": 8081, \"identifier\": \"tanrgyb\", \"password\": \"iloveu\" &#125;, \"prod\": &#123; \"host\": \"dayarch.top\", \"port\": 8080, \"identifier\": \"admin\", \"password\": \"admin\" &#125;&#125; 运行一下我们编写的请求吧： IDEA自动识别多个环境，这样就可以轻而易举的切换环境，使用不同的变量值了（这皮鞋，你说亮不亮，还有更亮的） 巧用 response handler 脚本上面提到，我们要让登录成功后的所有请求都自动携带成功返回的 Token，这样不用我们每次都手动将其添加到header中，同样有两种方式将脚本插入到请求中 内嵌方式 12345GET host/api/test&gt; &#123;%response 脚本%&#125; 外部文件方式（就是将内嵌的脚本抽离出到文件中） 123GET host/api/test&gt; scripts/my-script.js 以登录返回获取的token设置到变量中为例，看代码： 1234567POST http://&#123;&#123;host&#125;&#125;:&#123;&#123;port&#125;&#125;/loginContent-Type: application/jsonAccept: application/json&gt; &#123;%client.global.set(\"auth_token\", response.body.result.token); %&#125; 注意response.body.result.token 是我按照我登录返回的数据结构写的，不同结构不一样，你也可以是这样的 response.body.token , response.body 之后根据你的数据结构发挥吧 我还是不放心，把我的登录返回结构（项目中怎样设计这种结构，可以参考之前写的Springboot返回统一JSON数据格式是怎么实现的？ )粘贴在此处吧，这回理解了吧？ 接下来我们就可以愉快的在其他请求上携带这个 Token 了 注意这里的Authorization 类型，大家根据自己的实际情况做修改，比如：Authorization: Bearer 以上这些已经满足我的日常使用，没有进一步了解更多，更多关于 Response 脚本的用法请大家查看官网 HTTP Response reference吧 你以为到这里结束了（OMG），还有香料需要和大家分享，搭配上面功能使用更棒哦 辅助功能说明RestfulToolkitRestfulToolkit 同样是个插件，在插件市场搜索安装即可 安装了这个插件后，打开侧边栏，项目的所有接口信息都会展现在此处： 我常用的功能就是把指定接口生成的JSON数据拷贝到 HTTP request 文件中，免去手写的麻烦了，你说方便不？ 除此之外，使用快捷键 cmd+\\, 可以根据关键字快速找到接口，回车迅速到达代码接口位置，这也是带来了极大的便利 Live Template项目中请求内容各有不同，IDEA标准提供的GET POST 请求案例可能还不能满足我们的需求，这时我们就可以利用 Live Template 定制自己的模版，迅速生成request 内容，像这样： JSON ViewerJSON Viewer是一款 Chrome浏览器插件，在浏览器 Omini-box 中输入 json-viewer + Tab, 粘贴json在此处，就可以对json数据进行格式化了 打开开发者工具，在Network下双击某个HTTP请求，会自动在 new tab下格式化返回的json数据，免去了粘贴数据然后格式化的烦恼 关于自测接口的干货我抖的差不多了，抖抖更健康 总结再次重申，不做工具党，也没有任何批判之意，工具只是为了让我们更高效的工作，选择适合自己的。从上面的介绍中来看，IDEA HTTP client 搭配我说的几个辅助功能很好的解决了文章开头说明的几个问题，对我个人情况来说，足矣！！ 截图码字不易 如果你认为本文对你有帮助，还请「在看/转发/赞」（这就是送我的大火箭🚀，大跑车🚗，大灰机✈️） 如果你还发现了更好的功能还请补充在留言区，我回头继续补充这块内容，万分感谢 公众号回复「工具」，还有更精彩的等着你 灵魂追问 Kibana的Dev Tools用来调试ES接口，可以延伸了解一下 你在项目中如何高效测试接口与联调的呢？还请大方赐教 在家办公和公司办公对你有什么影响？ 参考 Testing RESTful web services","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://dayarch.top/tags/IntelliJ-IDEA/"}]},{"title":"读《Clean Code 代码整洁之道》之感悟","slug":"读《Clean-Code-代码简洁之道》之感悟","date":"2020-02-05T03:35:46.000Z","updated":"2020-02-07T02:32:22.250Z","comments":true,"path":"/p/book-reviews-clean-code.html","link":"","permalink":"https://dayarch.top/p/book-reviews-clean-code.html","excerpt":"盲目自信，自认为已经敲了几年代码，还看什么整洁之道啊。我那可爱的书架读懂了我的心思，很明事理的保护起来这本小可爱，未曾让它与我牵手 最近项目中的 bug 有点多，改动代码十分吃力，每看一行代码都带一句“这是什么XX代码啊，真XX难改”，这样持续了好几天，有天晚上坐在书房回想这几天发生的一切，仰头定睛思考，我终于和它重新确认了眼神💗 股票见涨你知道买了, 汽车撞墙知道拐了, 孩子死了你来奶了, 大鼻涕到嘴你知道甩了, bug难改知道愤慨了 马上翻开书，前言章节，映入眼帘的就是下面这一张图 代码质量的唯一有效度量是：WTFs（what the fuck）/minute 真的太","text":"盲目自信，自认为已经敲了几年代码，还看什么整洁之道啊。我那可爱的书架读懂了我的心思，很明事理的保护起来这本小可爱，未曾让它与我牵手 最近项目中的 bug 有点多，改动代码十分吃力，每看一行代码都带一句“这是什么XX代码啊，真XX难改”，这样持续了好几天，有天晚上坐在书房回想这几天发生的一切，仰头定睛思考，我终于和它重新确认了眼神💗 股票见涨你知道买了, 汽车撞墙知道拐了, 孩子死了你来奶了, 大鼻涕到嘴你知道甩了, bug难改知道愤慨了 马上翻开书，前言章节，映入眼帘的就是下面这一张图 代码质量的唯一有效度量是：WTFs（what the fuck）/minute 真的太精辟了，这不就是这几天我白天经历的吗？代码已然是 bad code 了，我们应该怎么面对这种情况呢？ 每个公司的规范还不一样，本文是读书笔记，不会说明太多的代码规范，只是阐明我们应该怎样做或者抱着什么样的心态来写代码吧 如果你看到这里，我要引用书中的一句话： 第一，你是个程序员；第二；你想成为更好的程序员。我们需要更好的程序员 专业的态度做国内项目/产品，通常都是指明deadline的，但是截止到deadline之前，需求量的多少是不固定的，说白了是“以deadline不变应需求万变”，美其名曰「敏捷」 我们经常要面对短期内开发出大量需求的请求，很可能为了快速完成这些需求，胡乱的堆叠代码，上线之后一声长叹庆幸这个功能开发的结束。过了好久，有关这个功能的需求有所变化，重新查看代码时，直接就 WTF 了……，再一看是自己写的，你说尴尬不？ 如果是因为任务多胡乱叠加代码，我们就应该在接受需求的时候提出我们的看法： 过多的需求在短期内上线的代码质量不能得到保证 假如你是医生，病人要求你不用洗手就可以给他做手术，因为洗手浪费时间，你会答应吗？医生绝对会拒绝，因为你比病人更了解疾病和感染的风险。如果医生照做，那是绝对不专业的做法 作为程序员，如果遵从了不了解混乱风险经理的意愿，也是不专业的做法 “你以为可以不听经理的？不听经理的，是会被炒鱿鱼的”，经理能否听的进去，我们都要提出我们的看法。提出多次还被无视，也不要灰心丧气，继续提出我们专业的看法… untile die, 为了部落 如果你有底线，守住就好；如果没有，适应就好。只为很久之后看到代码说 WTF 时，避免主角是自己的尴尬 我们是作者Javadoc 中的@author字段告诉我们自己是什么身份，我们是作者。如果类上没有标注日期和作者，alibaba代码检查工具会给出提示，就像这样： 这里建议大家在 IDE 中安装该插件，如果你不知道作为作者应有的规范，那就让这个插件辅助你吧 据统计，读代码与写代码花费的时间比例超过 10:1， 因为我们在写新代码时会一直在读旧代码，项目越到后期这个比例越明显 我们是作者，就有责任和读者做好沟通。每次写代码的时候，记得自己是作者，要为评判你工作的读者写代码. 这些读者可能是你现在组内的伙伴，也可能是将来要接管你的任务的新伙伴，避免别人嘴里 WTF 的主角是你，定期 Review 自己的代码，你定会发现可以改善的地方，比如用策略模式更改过多的 if else等，代码整洁了，又学会了设计模式，岂不是两全其美 心有余，力要足很多朋友说，我也想写出整洁的代码，但是目前实力不允许啊。 写出整洁的代码的功力不是一蹴而就的，需要持续不断的学习和修正 学会设计模式，了解 RESTful 接口规范，了解命名规范，注释，函数大小等等太多的东西都是书写出整洁代码必不可少的知识，我们该怎么办？ 还记得小时候写作文的词藻不够用，老师让摘抄好文好句。如果程序写的不够整洁，我们可以慢慢学习和模仿好的写法与设计，慢慢改善和积累，有朝一日肯定能写出高分作文的 不做破窗效应第一人不要说现在的代码很烂了，没必要再改善了，如果你是这样的心态，即便一个全新的项目开始让你去做，你也很可能会成为第一个打碎玻璃，带来破窗效应的人。 如果严重一点说，大家都知道你写的代码带给别人的是一种负担，你可能很难有开始一个全新项目的机会了 如果同事因改善你的代码带来了一些意外的影响，请你不要抱怨甩锅，这些改善就是修复玻璃的开始，终将会给团队带来极大的好处 总结编写整洁代码的路途漫漫，我们一起求索，推荐大家看下面这两本书，你一定有有自己的发现，让我们悉心照料我们写的每一行代码 《代码整洁之道》 《阿里巴巴Java开发手册》 灵魂追问 工作上你接到过什么奇葩要求？ 工作中遇到了哪些无奈或者你觉得XX的事？ 你是怎么应对那些不好的问题的？ 欢迎在留言区讨论，你们项目中的情况，你是怎么看待代码整洁这个问题的","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"读书笔记","slug":"Life/读书笔记","permalink":"https://dayarch.top/categories/Life/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://dayarch.top/tags/IntelliJ-IDEA/"}]},{"title":"MySQL group_concat 函数详解","slug":"Mysql-group-concat-函数详解","date":"2020-02-03T13:03:27.000Z","updated":"2020-02-03T13:14:01.495Z","comments":true,"path":"/p/mysql-group-concat-function-usage.html","link":"","permalink":"https://dayarch.top/p/mysql-group-concat-function-usage.html","excerpt":"上一篇文章 跨表更新，看到自己写的SQL像个憨憨 写了关于跨表个更新的内容。一年过的很快，文中后来的两位员工 馮大 和 馮二 也要面对无情的 KPI 考核了，他们工作干的很不错，performance 分别是 4 和 5 新需求来了，静悄悄的来了！！！ 领导想要查看每个 performance 下都有谁，同时要求将这些人的名称要逗号拼接成一个字符串，也就是说要得到下面的结果： 要将结果集中某个指定的列进行字符串拼接，这要怎么做呢？主角闪亮✨登场 GROUP_CONCAT(expr) 在 Mysql 官方文档 中，该函数被放在聚合函数章节，如果你要按照指定字段分组拼接，就要配合关键","text":"上一篇文章 跨表更新，看到自己写的SQL像个憨憨 写了关于跨表个更新的内容。一年过的很快，文中后来的两位员工 馮大 和 馮二 也要面对无情的 KPI 考核了，他们工作干的很不错，performance 分别是 4 和 5 新需求来了，静悄悄的来了！！！ 领导想要查看每个 performance 下都有谁，同时要求将这些人的名称要逗号拼接成一个字符串，也就是说要得到下面的结果： 要将结果集中某个指定的列进行字符串拼接，这要怎么做呢？主角闪亮✨登场 GROUP_CONCAT(expr)在 Mysql 官方文档 中，该函数被放在聚合函数章节，如果你要按照指定字段分组拼接，就要配合关键字 GROUP BY 来使用的 定义 该函数返回一个字符串结果，该字符串结果是通过分组串联的非NULL值。如果没有非NULL值，则返回NULL。完整语法如下： 1234GROUP_CONCAT([DISTINCT] expr [,expr ...] [ORDER BY &#123;unsigned_integer | col_name | expr&#125; [ASC | DESC] [,col_name ...]] [SEPARATOR str_val]) What? 这个语法看着太复杂了吧，别着急，下面会用例子慢慢说明逐一验证滴 使用案例先完成文章开头的需求： 123SELECT performance, GROUP_CONCAT(employee_name) AS employeesFROM employeesGROUP BY performance; zou是这个结果： 到这里，领导给过来的需求就完成了😜 客官请留步，您点的菜还没上完呢…… 我们是国际化的团队，我们的家乡遍布五湖四海 领导想关怀一下员工，要查看公司全部员工的家乡都有哪些地方。员工们可能来自同一个地方，所以要将结果集去重复，DISTINCT 关键字就派上用场了 12SELECT GROUP_CONCAT(DISTINCT home_town)FROM employees; 来看结果： 领导的关怀遍布五湖四海啊…… 文案要改了，领导的关怀是遍布四海五湖的, 那么 ORDER BY 关键字就派上用场了 1234SELECT GROUP_CONCAT(DISTINCT home_town ORDER BY home_town DESC) AS '领导关怀地区'FROM employees;-- 没我这么起变量的哈，还是汉语，我看你是疯了 这里你看到 GROUP_CONCAT 函数拼接字符串默认的分隔符是逗号 ,, 领导不开心，逗号么的感情，要用❕才能体现出关怀的强烈， SEPARATOR 关键字就派上用场了 分组拼接的值之间默认分隔符是逗号（，）。要明确指定分隔符，需要使用 SEPARATOR 关键字，紧跟其后的是你想设置的分隔符。要完全消除分隔符，就在 SEPARATOR 关键字后面写 ‘’ 就好了 12SELECT GROUP_CONCAT(DISTINCT home_town ORDER BY home_town DESC SEPARATOR '!') AS '领导关怀地区'FROM employees; 12SELECT GROUP_CONCAT(DISTINCT home_town SEPARATOR '') AS '领导关怀地区'FROM employees; 这关怀到位了吧，你品，你细品！！！ 领导的关怀能力也有限，拼接的字符串默认的最大长度是1024个字符，可以通过下面语句查看当前限制是多少： 1show variables like 'group_concat_max_len'; 领导的能力可是飘忽不定的，所以我们可以灵活的设置这个值 1SET [GLOBAL | SESSION] group_concat_max_len = val; SESSION: 在当前对话中生效 GLOBAL：全局都生效 该语句在执行后，MySQL重启之前一直有作用，一旦重启 MySQL，则会恢复默认值 有时候 GROUP_CONCAT() 还要搭配 CONCAT_WS() 发挥出一点点威力，举个简单的例子 将消费者的名和姓用逗号进行分隔，然后再用 ; 进行分隔 123456SELECT GROUP_CONCAT( CONCAT_WS(', ', contactLastName, contactFirstName) SEPARATOR ';')FROM customers; 这里是 CONCAT_WS()函数用法, 很简单，请自行查看吧…… 注意⚠️GROUP_CONCAT（）函数返回单个字符串，而不是值列表。这意味着我们不能在 IN 运算符中使用GROUP_CONCAT（）函数的结果，例如，在子查询中， 像这样： 123456SELECT id, nameFROM table_nameWHERE id IN GROUP_CONCAT(id); 总结在许多情况下，我们都可以应用GROUP_CONCAT（）函数产生出有用的结果，同时也可以结合其他函数发挥出更大的威力. 单招学会了，就要学会连招 combo 了 如果你也像我一样刚知道这个知识点，还请点个「在看」 如果你早都知道这个小儿科内容，还请留言送上「嘘声」","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"数据库-持久层-SQL","slug":"Coding/数据库-持久层-SQL","permalink":"https://dayarch.top/categories/Coding/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%8C%81%E4%B9%85%E5%B1%82-SQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dayarch.top/tags/MySQL/"}]},{"title":"跨表更新，看到自己写的SQL像个憨憨","slug":"跨表更新，看到自己写的SQL像个憨憨","date":"2020-01-22T02:09:02.000Z","updated":"2020-02-07T03:12:30.203Z","comments":true,"path":"/p/mysql-cross-table-update.html","link":"","permalink":"https://dayarch.top/p/mysql-cross-table-update.html","excerpt":"有点 SQL 基础的朋友肯定听过 「跨表查询」，那啥是跨表更新啊？ 背景 项目新导入了一批人员数据，这些人的有的部门名称发生了变化，有的联系方式发生了变化，暂且称该表为 t_dept_members, 系统中有另外一张表 t_user_info 记录了人员信息。要求将 t_dept_members 中有变化的信息更新到 t_user 表中，这个需求就是「跨表更新」啦 憨B SQL 直接被秒杀 不带脑子出门的就写出了下面的 SQL 看到身后 DBA 小段总在修仙，想着让他帮润色一下😜，于是发给了他，然后甩手回来就是这个样子： ​ 看到这个 SQL 语句我都惊呆了，还能","text":"有点 SQL 基础的朋友肯定听过 「跨表查询」，那啥是跨表更新啊？ 背景项目新导入了一批人员数据，这些人的有的部门名称发生了变化，有的联系方式发生了变化，暂且称该表为 t_dept_members, 系统中有另外一张表 t_user_info 记录了人员信息。要求将 t_dept_members 中有变化的信息更新到 t_user 表中，这个需求就是「跨表更新」啦 憨B SQL 直接被秒杀不带脑子出门的就写出了下面的 SQL 看到身后 DBA 小段总在修仙，想着让他帮润色一下😜，于是发给了他，然后甩手回来就是这个样子： ​ 看到这个 SQL 语句我都惊呆了，还能这样写，在无情的嘲笑下，一声 KO 我直接倒下。死也得死的明白，咱得查查这是咋回事啊 Mysql Update Join我们经常使用 join 查询表中具有（在 INNER JOIN 情况下）或可能没有（在 LEFT JOIN 情况下）另一个表中匹配行的表中的行。 同样，在 MySQL 中, 我们也可以在 UPDATE 语句中使用 JOIN 子句执行跨表更新，语法就是这样： 12345UPDATE T1, T2,[INNER JOIN | LEFT JOIN] T1 ON T1.C1 = T2. C1SET T1.C2 = T2.C2, T2.C3 = exprWHERE condition 我们还是详细的说明一下上面的语法： 首先，在 UPDATE 子句之后，指定主表（T1）和希望主表联接到的表（T2）。请注意，必须在UPDATE 子句之后至少指定一个表 接下来，指定你要使用的联接类型，即 INNER JOIN 或 LEFT JOIN 以及联接谓词。 JOIN子句必须出现在 UPDATE 子句之后（这个大家都是知道的哈） 然后，将新值分配给要更新的 T1或 T2 表中的列 最后，在 WHERE 子句中指定一个条件以将行限制为要更新的行 如果你遵循 update 语法，你会发现有另外一种语法也可以完成跨表更新 1234UPDATE T1, T2SET T1.c2 = T2.c2, T2.c3 = exprWHERE T1.c1 = T2.c1 AND condition 上面的语法其实隐式使用了 inner join 关键字，完全等同于下面的样子： 12345UPDATE T1,T2INNER JOIN T2 ON T1.C1 = T2.C1SET T1.C2 = T2.C2, T2.C3 = exprWHERE condition 个人建议还是加上 inner join 关键字吧，这样可读性更好，尽享丝滑，你觉得呢？ 我摸鱼看到的，觉得是灵魂翻译 谈太廉，秀你码 （Talk is cheap，show me the code） Update Join 例子年底了，又到了评绩效的时候了，就是那个叫 KPI 的东东（你们有吗），听说要根据 KPI 调工资了。有两张表 第一张表「employees-员工表」 建表语句如下： 12345678910create table employees( employee_id bigint auto_increment comment '员工ID，主键', employee_name varchar(50) null comment '员工名称', performance int(4) null comment '绩效分数 1，2，3，4，5', salary float null comment '员工薪水', constraint employees_pk primary key (employee_id))comment '员工表'; 第二张表「merits-绩效字典表」 建表语句如下： 123456create table merits( performance int(4) null, percentage float null)comment '绩效字典表'; 先生成一些模拟数据 1234567891011121314151617-- 绩效字典初始化数据INSERT INTO merits(performance, percentage)VALUES (1, 0), (2, 0.01), (3, 0.03), (4, 0.05), (5, 0.08);-- 员工表初始化数据INSERT INTO employees(employee_name, performance, salary)VALUES ('拱哥', 1, 1000), ('小段总', 3, 20000), ('大人', 4, 18000), ('司令', 5, 28000), ('老六', 2, 10000), ('罗蒙', 3, 20000); 调薪规则： 原有薪资 + （原有薪资 * 当前绩效对应的调薪百分比） 按照调薪规则写 update 语句： 1234UPDATE employees INNER JOIN merits ON employees.performance = merits.performanceSET salary = salary + salary * percentage; 拱哥绩效不好，没给涨工资…… 三横一竖一咕嘎，四个小猪🐷来吃zha，咕嘎咕嘎又来俩 临近年底，公司又来了两位新同事, 但是公司年度绩效已经评完，所以新员工绩效为 NULL 123INSERT INTO employees(employee_name, performance, salary)VALUES ('馮大', NULL, 8000), ('馮二', NULL, 5000); 新员工工作干的不错，也要 1.5% 涨点工资的。如果我们还是用 UPDATE INNER JOIN，按照上面的更新语句是不可能完成的，因为条件等式不成立，这是我们就要用到 UPDATE LEFT JOIN 了 12345UPDATE employees LEFT JOIN merits ON employees.performance = merits.performanceSET salary = salary + salary * 0.015WHERE merits.percentage IS NULL; 到这里，新员工的涨薪工作也做完，拱哥由于知识点了解不透彻，灰溜溜的回家过年","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"数据库-持久层-SQL","slug":"Coding/数据库-持久层-SQL","permalink":"https://dayarch.top/categories/Coding/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%8C%81%E4%B9%85%E5%B1%82-SQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://dayarch.top/tags/MySQL/"}]},{"title":"微信上线了10款默认新表情","slug":"微信上线了10款默认新表情","date":"2020-01-14T07:33:22.000Z","updated":"2020-01-19T14:17:14.057Z","comments":true,"path":"/p/wechat-new-expression.html","link":"","permalink":"https://dayarch.top/p/wechat-new-expression.html","excerpt":"微信新增表情 微信新增十款默认表情！ 微信新增十款默认表情！ 微信新增十款默认表情！ 微信今日悄然上线了十款新默认表情， 其中包含了 \b 1. 吃瓜 2. 加油 3. 汗 4. 天啊 5. Emm 6. 社会社会 7. 旺柴 8. 好的 9. 打脸 10. 哇 感觉比用了表情包还激动。据悉，目前这十款新默认表情正在进行灰度测试，部分微信用户可能无法正常显示 一图胜千言，对于喜欢使用表情的你，快快打开你的微信看看吧","text":"微信新增表情微信新增十款默认表情！微信新增十款默认表情！微信新增十款默认表情！ 微信今日悄然上线了十款新默认表情， 其中包含了\b 吃瓜 加油 汗 天啊 Emm 社会社会 旺柴 好的 打脸 哇 感觉比用了表情包还激动。据悉，目前这十款新默认表情正在进行灰度测试，部分微信用户可能无法正常显示 一图胜千言，对于喜欢使用表情的你，快快打开你的微信看看吧","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"其他","slug":"Life/其他","permalink":"https://dayarch.top/categories/Life/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://dayarch.top/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"表情","slug":"表情","permalink":"https://dayarch.top/tags/%E8%A1%A8%E6%83%85/"}]},{"title":"2019归零，2020走你","slug":"2019年总结","date":"2020-01-10T05:35:55.000Z","updated":"2020-02-10T12:07:59.784Z","comments":true,"path":"/p/2019-summary.html","link":"","permalink":"https://dayarch.top/p/2019-summary.html","excerpt":"作为生长在内蒙的，不会套马的，酒精过敏的，不吃羊肉的，也不魁梧的奇葩，单曲循环听着腾格尔大爷的翻唱歌曲「可能否」，还是开始写了 2019 年总结，这个总结比 2002 😆 年来的更晚一些，因为在等待 2019 年末的一个 PMP(拍马屁)的成绩，赶不上各个平台的总结比赛了，写下来给自己个答复 年初的一次旅行之后，回来倍感惶恐，总觉得应该做点什么继续充实自己的生活。写博客记录和维护公众号的想法也就随之浮现在脑海中 翻看历史记录，在 2015 年就已经尝试搭建自己的博客了，奈何没有坚持分享，中途夭折。「种一棵树最好的时间是十年前，其次是现在」。这一刻，我要种一棵树，陪她长大，我变老，她茁壮","text":"作为生长在内蒙的，不会套马的，酒精过敏的，不吃羊肉的，也不魁梧的奇葩，单曲循环听着腾格尔大爷的翻唱歌曲「可能否」，还是开始写了 2019 年总结，这个总结比 2002 😆 年来的更晚一些，因为在等待 2019 年末的一个 PMP(拍马屁)的成绩，赶不上各个平台的总结比赛了，写下来给自己个答复 年初的一次旅行之后，回来倍感惶恐，总觉得应该做点什么继续充实自己的生活。写博客记录和维护公众号的想法也就随之浮现在脑海中 翻看历史记录，在 2015 年就已经尝试搭建自己的博客了，奈何没有坚持分享，中途夭折。「种一棵树最好的时间是十年前，其次是现在」。这一刻，我要种一棵树，陪她长大，我变老，她茁壮长青 公众号与博客磕磕碰碰一点点摸索着完成了公众号的注册「日拱一兵」。日拱一卒，功不唐捐，这个名字真是非常质朴了，奈何日拱一卒被注册了，但幸运的是日拱一兵没有被注册，否则我就得「車/馬/炮」的尝试下去了，如果到了日拱一 pao的地步我应该就放弃这个 ID 了吧 😂 搜查肚子里有限的墨水，2019 年 5 月 22 号，我战战兢兢又满怀期待的发布了第一篇文章如何设计好的 RESTful API。我像做传销的一样，先从亲朋好友开始坑，让他们关注评论，现在一看已经有了 17 个在看，他们一定贡献很多 😜 2019 年 7 月 11 日，突然收到一个赞赏通知，开始我以为是朋友的安慰，反复确认后，才发现这就是读者朋友的赞赏，那一刻我觉得我是百万富翁，怀着无比激动的心情回复「我会努力输出高质量原创内容」 生孩子容易，养育孩子难，不关注粉丝的增长一定是假的。我也需要小小的成就感来驱动，一天下来，每增长一个粉丝都使我足够兴奋，第二天起床又焦虑的期盼第二个粉丝的到来，就这样朝朝暮暮…… 个人博客重新运营了起来，在维护过程中差点迷失在定制炫酷的效果中，幸亏没有走火如魔，回归到了博文内容本质以及博客功能增强等，作为后端程序猿的我，也为主题功能贡献了个 PR，还请各位大声嘲笑 住的离公司很近，无聊的时候就可以跑到公司写点东西静静心，不到一年写了 39 篇原创文章，不算代码，累计字数将近 10 万字，长度不到地球一周😝 信仰为了做好这些内容，我为我的思想注入两条信仰: 你有一个思想，我有一个思想，我们交换后，一个人就有了两个思想这个信仰让我勇于与他人交流，进行思想碰撞，甚至产生 1+1&gt;2 的效果，乐于分享也让我收获颇多快乐，你会发现，每个个体的思想真的很奇妙If you can NOT explain it simply, you do NOT understand it well enough技术有时会枯燥，所以本着将复杂问题简单化，将抽象问题图形化的方式来输出文章。在讲解的过程中也加深了我对问题的理解层次 阅读2019 年读 30 多本杂书，已经放到了博客书架，遗憾的是没怎么写完整书评，我热衷于看纸质书籍，都是边读边写边画了，这里仅仅说几个印象深刻的感悟 入一行，先别惦记着能赚钱，先学着让自己值钱，变内行人。没有哪个行业的钱是好赚的，学习是让自己快速增值的最好途径。让人迷茫的原因只有一个，那就是本该拼搏的年纪，却想得太多，做得太少——摘自「褚时健传」 心理学相关的书解读了我日常一些疯狂的思想和行为，如果没有他们的解读，我可能觉得我是个变态😂，现在心安了许多 你的灯还亮着吗？始终让我带着追问去思考问题，每篇公众号推文的「灵魂追问」环节的灵感也来源于此 读书只为取悦自己 工作2019 年在工作上整体节奏依然平稳。和伙伴们并肩战斗，多个产品线也如期上线。很意外申请下来一个专利「证件文字信息获取方法、装置以及电子设备」，同时有一篇文章入选公司技术期刊。请允许我骄傲一秒钟 骄傲结束……😂 相识，幸运的起点业余时间为 Spring4All 社区 贡献翻译内容，慢慢结识了程序猿 DD 和 泥瓦匠 BYSocket，被前辈的态度折服，更被一些故事感动。他们自然是我学习和追赶的榜样 维护个人博客和公众号少不了并肩战斗的伙伴，乱敲代码，码农小胖哥，辉哥，锅外的大佬，二师兄等，我和群里小伙伴无数次的探讨方向和修补改进方案等，增长了见识同时也坚定了做好的态度和信念 认识了各大网站的运营小姐姐，小哥哥，偶尔发的文章能被翻牌到首页「侍寝」着实幸运，我亲爱的小伙伴和朋友们，感谢与你相遇，更感恩相遇和相知🙏 PMPPMP(Project Management Professional)，俗称「拍马屁」，和「别摸我」有异曲同工之处😂。毕业后就没考过试，感觉前 20 多年的技能包快丢没了，看到朋友有拿到PMP 证书的，恰逢公司还给报销部分费用(这很关键)，决定尝试一遭，2019 年 9 月报名，12 月 7 日考试，2020 年 1 月 17 日拿到结果，5A 通过考试，顺利拿到纪念版红色证书。 考试本身感觉没什么意义，但是感觉学习过程的思维，思考模式以及一些软技能还是值得长期深入思考琢磨的。有兴趣的朋友咱们聊一聊 运动整个一年还是保持了相对规律的运动节奏，基本一周一场羽毛球，Keep 晨练(早晨练一会瑜伽拉伸一下筋骨感觉一天都轻松了许多)。每天多几秒的累加训练，平板支撑（plank）可以做到坚持 12 分钟。 以为自己要起飞，买了健腹轮，核心力量还是不足，腰部受伤，一下回到解放前。目前已经恢复训练了。除了指定季节的过敏性鼻炎外(有良方，还请伸出援助之手)，身体基本上没什么问题。 鸡汤鸡汤不喝不行，但喝多了我认为会中毒，我找到了我的专属鸡汤，比如下面这款味道醇香的鸡汤，喝过之后让我飘飘欲仙 还有这稍微发涩的鸡汤，喝过之后回味无穷啊😂 鸡汤味道不同，都很补人。得到肯定，保持节奏继续前进；获得批评，总结反思加以提高 小成果 2019 至此归零……，「幸运」和「踏实」 2020 走你不敢憧憬太多，先奖励自己一双羽毛球鞋吧，球场不受伤，生活不感伤，腹肌再向下挪两块，全新呵护这颗 2019 年种下的树，脚踏实地…… 单曲还在循环，写到这什么心情呢？看看这首歌的评论吧，就是这种撞南墙的心态吧 南墙撞的还是挺疼，写到这吧，感谢看到这里的帅哥美女们，诚实的为自己拉上一票，喜欢的话给个赞，分享，关注(奢求有点多)，背后创作不易，坚持做优而美的技术公众号。致敬朋友，干杯🍺 (这是饮料，我酒精过敏) 真的到这里了，我要排版了…..","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"其他","slug":"Life/其他","permalink":"https://dayarch.top/categories/Life/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://dayarch.top/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"小小TODO也有大道理","slug":"小小TODO也有大道理","date":"2020-01-09T02:50:07.000Z","updated":"2020-02-07T02:31:08.756Z","comments":true,"path":"/p/how-to-use-todo-feature.html","link":"","permalink":"https://dayarch.top/p/how-to-use-todo-feature.html","excerpt":"前言 有时，我们需要标记部分代码以供将来参考，比如: 优化，改进，可能的更改，要讨论的问题等。 通常我们会在代码中加入如下的标记表示待办: 1 //TODO 我将要在这里做 xxx 你这样做，别人也会这样做。一时间，项目中可能会存在大量的 TODO，当你搜寻你的 TODO 时也就变得非常麻烦，如同石沉大海，也就失去了这个标记的意义。 IntelliJ IDEA允许我们添加特殊类型的注释，使得这些注释在编辑器中突出显示，它们被索引，并在 TODO 工具窗口 中列出。这样，我们就容易追踪自己的 TODO 了。 默认的 TODO 默认情况下，IntelliJ IDEA识别两种模式：","text":"前言有时，我们需要标记部分代码以供将来参考，比如: 优化，改进，可能的更改，要讨论的问题等。 通常我们会在代码中加入如下的标记表示待办: 1//TODO 我将要在这里做 xxx 你这样做，别人也会这样做。一时间，项目中可能会存在大量的 TODO，当你搜寻你的 TODO 时也就变得非常麻烦，如同石沉大海，也就失去了这个标记的意义。 IntelliJ IDEA允许我们添加特殊类型的注释，使得这些注释在编辑器中突出显示，它们被索引，并在 TODO 工具窗口 中列出。这样，我们就容易追踪自己的 TODO 了。 默认的 TODO默认情况下，IntelliJ IDEA识别两种模式：小写和大写的 TODO 和 FIXME 这些模式可在任何受支持文件类型的行注释和块注释内部使用。我们可以根据需要修改默认模式或添加自己的模式 如上图，我们可以创建多行的 TODO (类似 Spring Boot 中的 YAML 配置多个值)，需要缩进第一行之后的注释行。如果没有缩进，则将行视为常规注释行 要禁用多行 TODO 项目，使用快捷键 ⌘ + , 打开 Preferences， 搜索 TODO (Editor | TODO), 你会看到如下界面 要查看系统中的所有 TODO，请打开 TODO 工具窗口 (快捷键 ⌘ + 6 )。切换选项查看 TODO 范围: 从当前项目中的所有文件 仅基于当前文件的范围 指定范围的文件 活动的变更列表 到这里 Intellij IDEA 默认提供的 TODO 就介绍完了，为了能更快的找到我们自己的 TODO，我们就需要进行自定义 自定义 TODO重新打开 TODO 位置，新增 TODO item，这里新增 optimize，用于标识待优化内容 添加个过滤器，用于 TODO 的分组 随便添加一个优化备注，通过以上介绍的功能，快速定位到我们自己的 TODO 如果你的待办事项通常是相对固定的描述，你也可以配合 Live Template 快速生成 TODO 内容 总结当团队规模很大，你又同时有很多待办的时候，TODO 特性可以帮助我们做标识，自定义 TODO 可以帮我们快速定位，我们可以充分利用这个特性，但是 定期清理 TODO 灵魂追问 你觉得项目中代码有哪些不规范/不够整洁的地方？(欢迎到博客下方留言讨论)","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"安全-协议-规范","slug":"Coding/安全-协议-规范","permalink":"https://dayarch.top/categories/Coding/%E5%AE%89%E5%85%A8-%E5%8D%8F%E8%AE%AE-%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://dayarch.top/tags/IntelliJ-IDEA/"}]},{"title":"在Spring Boot启动时执行代码的几种方法","slug":"在Spring-Boot启动时执行代码的几种方法","date":"2019-12-25T08:13:15.000Z","updated":"2019-12-26T06:43:01.889Z","comments":true,"path":"/p/spring-boot-execute-on-startup.html","link":"","permalink":"https://dayarch.top/p/spring-boot-execute-on-startup.html","excerpt":"前言 有时候我们需要在应用启动时执行一些代码片段，这些片段可能是仅仅是为了记录 log，也可能是在启动时检查与安装证书 ，诸如上述业务要求我们可能会经常碰到 Spring Boot 提供了至少 5 种方式用于在应用启动时执行代码。我们应该如何选择？本文将会逐步解释与分析这几种不同方式 CommandLineRunner CommandLineRunner 是一个接口，通过实现它，我们可以在 Spring 应用成功启动之后 执行一些代码片段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Slf4j @Component @Order(2) public cl","text":"前言有时候我们需要在应用启动时执行一些代码片段，这些片段可能是仅仅是为了记录 log，也可能是在启动时检查与安装证书 ，诸如上述业务要求我们可能会经常碰到 Spring Boot 提供了至少 5 种方式用于在应用启动时执行代码。我们应该如何选择？本文将会逐步解释与分析这几种不同方式 CommandLineRunnerCommandLineRunner 是一个接口，通过实现它，我们可以在 Spring 应用成功启动之后 执行一些代码片段 123456789101112131415@Slf4j@Component@Order(2)public class MyCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; log.info(\"MyCommandLineRunner order is 2\"); if (args.length &gt; 0)&#123; for (int i = 0; i &lt; args.length; i++) &#123; log.info(\"MyCommandLineRunner current parameter is: &#123;&#125;\", args[i]); &#125; &#125; &#125;&#125; 当 Spring Boot 在应用上下文中找到 CommandLineRunner bean，它将会在应用成功启动之后调用 run() 方法，并传递用于启动应用程序的命令行参数 通过如下 maven 命令生成 jar 包: 1mvn clean package 通过终端命令启动应用，并传递参数: 1java -jar springboot-application-startup-0.0.1-SNAPSHOT.jar --foo=bar --name=rgyb 查看运行结果: 到这里我们可以看出几个问题: 命令行传入的参数并没有被解析，而只是显示出我们传入的字符串内容 --foo=bar，--name=rgyb，我们可以通过 ApplicationRunner 解析，我们稍后看 在重写的 run() 方法上有 throws Exception 标记，Spring Boot 会将 CommandLineRunner 作为应用启动的一部分，如果运行 run() 方法时抛出 Exception，应用将会终止启动 我们在类上添加了 @Order(2) 注解，当有多个 CommandLineRunner 时，将会按照 @Order 注解中的数字从小到大排序 (数字当然也可以用复数) ⚠️不要使用 @Order 太多看到 order 这个 “黑科技” 我们会觉得它可以非常方便将启动逻辑按照指定顺序执行，但如果你这么写，说明多个代码片段是有相互依赖关系的，为了让我们的代码更好维护，我们应该减少这种依赖使用 小结如果我们只是想简单的获取以空格分隔的命令行参数，那 MyCommandLineRunner 就足够使用了 ApplicationRunner上面提到，通过命令行启动并传递参数，MyCommandLineRunner 不能解析参数，如果要解析参数，那我们就要用到 ApplicationRunner 参数了 1234567891011@Component@Slf4j@Order(1)public class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; log.info(\"MyApplicationRunner order is 1\"); log.info(\"MyApplicationRunner Current parameter is &#123;&#125;:\", args.getOptionValues(\"foo\")); &#125;&#125; 重新打 jar 包，运行如下命令: 1java -jar springboot-application-startup-0.0.1-SNAPSHOT.jar --foo=bar,rgyb 运行结果如下: 到这里我们可以看出: 同 MyCommandLineRunner 相似，但 ApplicationRunner 可以通过 run 方法的 ApplicationArguments 对象解析出命令行参数，并且每个参数可以有多个值在里面，因为 getOptionValues 方法返回 List 数组 在重写的 run() 方法上有 throws Exception 标记，Spring Boot 会将 CommandLineRunner 作为应用启动的一部分，如果运行 run() 方法时抛出 Exception，应用将会终止启动 ApplicationRunner 也可以使用 @Order 注解进行排序，从启动结果来看，它与 CommandLineRunner 共享 order 的顺序，稍后我们通过源码来验证这个结论 小结如果我们想获取复杂的命令行参数时，我们可以使用 ApplicationRunner ApplicationListener如果我们不需要获取命令行参数时，我们可以将启动逻辑绑定到 Spring 的 ApplicationReadyEvent 上 12345678910@Slf4j@Component@Order(0)public class MyApplicationListener implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123; @Override public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) &#123; log.info(\"MyApplicationListener is started up\"); &#125;&#125; 运行程序查看结果: 到这我们可以看出: ApplicationReadyEvent 当且仅当 在应用程序就绪之后才被触发，甚至是说上面的 Listener 要在本文说的所有解决方案都执行了之后才会被触发，最终结论请稍后看 代码中我用 Order(0) 来标记，显然 ApplicationListener 也是可以用该注解进行排序的，按数字大小排序，应该是最先执行。但是，这个顺序仅用于同类型的 ApplicationListener 之间的排序，与前面提到的 ApplicationRunners 和 CommandLineRunners 的排序并不共享 小结如果我们不需要获取命令行参数，我们可以通过 ApplicationListener&lt;ApplicationReadyEvent&gt; 创建一些全局的启动逻辑，我们还可以通过它获取 Spring Boot 支持的 configuration properties 环境变量参数 如果你看过我之前写的 Spring Bean 生命周期三部曲: Spring Bean 生命周期之缘起 Spring Bean 生命周期之缘尽 Spring Aware 到底是什么？ 那么你会对下面两种方式非常熟悉了 @PostConstruct创建启动逻辑的另一种简单解决方案是提供一种在 bean 创建期间由 Spring 调用的初始化方法。我们要做的就只是将 @PostConstruct 注解添加到方法中： 12345678910@Component@Slf4j@DependsOn(\"myApplicationListener\")public class MyPostConstructBean &#123; @PostConstruct public void testPostConstruct()&#123; log.info(\"MyPostConstructBean\"); &#125;&#125; 查看运行结果: 从上面运行结果可以看出: Spring 创建完 bean之后 (在启动之前)，便会立即调用 @PostConstruct 注解标记的方法，因此我们无法使用 @Order 注解对其进行自由排序，因为它可能依赖于 @Autowired 插入到我们 bean 中的其他 Spring bean。 相反，它将在依赖于它的所有 bean 被初始化之后被调用，如果要添加人为的依赖关系并由此创建一个排序，则可以使用 @DependsOn 注解（虽然可以排序，但是不建议使用，理由和 @Order 一样） 小结@PostConstruct 方法固有地绑定到现有的 Spring bean，因此应仅将其用于此单个 bean 的初始化逻辑； InitializingBean与 @PostConstruct 解决方案非常相似，我们可以实现 InitializingBean 接口，并让 Spring 调用某个初始化方法: 12345678910@Component@Slf4jpublic class MyInitializingBean implements InitializingBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; log.info(\"MyInitializingBean.afterPropertiesSet()\"); &#125;&#125; 查看运行结果: 从上面的运行结果中，我们得到了和 @PostConstruct 一样的效果，但二者还是有差别的 ⚠️ @PostConstruct 和 afterPropertiesSet 区别 afterPropertiesSet，顾名思义「在属性设置之后」，调用该方法时，该 bean 的所有属性已经被 Spring 填充。如果我们在某些属性上使用 @Autowired（常规操作应该使用构造函数注入），那么 Spring 将在调用afterPropertiesSet 之前将 bean 注入这些属性。但 @PostConstruct 并没有这些属性填充限制 所以 InitializingBean.afterPropertiesSet 解决方案比使用 @PostConstruct 更安全，因为如果我们依赖尚未自动注入的 @Autowired 字段，则 @PostConstruct 方法可能会遇到 NullPointerExceptions 小结如果我们使用构造函数注入，则这两种解决方案都是等效的 源码分析请打开你的 IDE (重点代码已标记注释): MyCommandLineRunner 和 ApplicationRunner 是在何时被调用的呢？ 打开 SpringApplication.java 类，里面有 callRunners 方法 123456789101112131415161718192021private void callRunners(ApplicationContext context, ApplicationArguments args) &#123; List&lt;Object&gt; runners = new ArrayList&lt;&gt;(); //从上下文获取 ApplicationRunner 类型的 bean runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); //从上下文获取 CommandLineRunner 类型的 bean runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); //对二者进行排序，这也就是为什么二者的 order 是可以共享的了 AnnotationAwareOrderComparator.sort(runners); //遍历对其进行调用 for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123; if (runner instanceof ApplicationRunner) &#123; callRunner((ApplicationRunner) runner, args); &#125; if (runner instanceof CommandLineRunner) &#123; callRunner((CommandLineRunner) runner, args); &#125; &#125;&#125; 强烈建议完整看一下 SpringApplication.java 的全部代码，Spring Boot 启动过程及原理都可以从这个类中找到一些答案 灵魂追问 上面程序运行结果， afterPropertiesSet 方法调用先于 @PostConstruct 方法，但这和我们在 Spring Bean 生命周期之缘起 中的调用顺序恰恰相反，你知道为什么吗？ MyPostConstructBean 通过 @DependsOn(&quot;myApplicationListener&quot;) 依赖了 MyApplicationListener，为什么调用结果前者先与后者呢？ 为什么不建议 @Autowired 形式依赖注入 在写 Spring Bean 生命周期时就有朋友问我与之相关的问题，显然他们在概念上有一些含混，所以，仔细理解上面的问题将会帮助你加深对 Spring Bean 生命周期的理解 Spring Boot应用启动执行代码概览图最后画一张图用来总结这几种方式","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Bean","slug":"Spring-Bean","permalink":"https://dayarch.top/tags/Spring-Bean/"},{"name":"生命周期","slug":"生命周期","permalink":"https://dayarch.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"Spring Boot @ConfigurationProperties 注解最强使用详解","slug":"Spring-Boot-ConfigurationProperties-注解最强使用详解","date":"2019-12-23T13:43:55.000Z","updated":"2019-12-23T13:56:35.162Z","comments":true,"path":"/p/spring-boot-configurationProperties-usage.html","link":"","permalink":"https://dayarch.top/p/spring-boot-configurationProperties-usage.html","excerpt":"前言 在编写项目代码时，我们要求更灵活的配置，更好的模块化整合。在 Spring Boot 项目中，为满足以上要求，我们将大量的参数配置在 application.properties 或 application.yml 文件中，通过 @ConfigurationProperties 注解，我们可以方便的获取这些参数值 使用 @ConfigurationProperties 配置模块 假设我们正在搭建一个发送邮件的模块。在本地测试，我们不想该模块真的发送邮件，所以我们需要一个参数来「开关」 disable 这个功能。另外，我们希望为这些邮件配置一个默认的主题，这样，当我们查看邮件收件箱，通过","text":"前言在编写项目代码时，我们要求更灵活的配置，更好的模块化整合。在 Spring Boot 项目中，为满足以上要求，我们将大量的参数配置在 application.properties 或 application.yml 文件中，通过 @ConfigurationProperties 注解，我们可以方便的获取这些参数值 使用 @ConfigurationProperties 配置模块假设我们正在搭建一个发送邮件的模块。在本地测试，我们不想该模块真的发送邮件，所以我们需要一个参数来「开关」 disable 这个功能。另外，我们希望为这些邮件配置一个默认的主题，这样，当我们查看邮件收件箱，通过邮件主题可以快速判断出这是测试邮件 在 application.properties 文件中创建这些参数: 我们可以使用 @Value 注解或着使用 Spring Environment bean 访问这些属性，是这种注入配置方式有时显得很笨重。我们将使用更安全的方式(@ConfigurationProperties )来获取这些属性 @ConfigurationProperties 的基本用法非常简单:我们为每个要捕获的外部属性提供一个带有字段的类。请注意以下几点: 前缀定义了哪些外部属性将绑定到类的字段上 根据 Spring Boot 宽松的绑定规则，类的属性名称必须与外部属性的名称匹配 我们可以简单地用一个值初始化一个字段来定义一个默认值 类本身可以是包私有的 类的字段必须有公共 setter 方法 Spring 宽松绑定规则 (relaxed binding)Spring使用一些宽松的绑定属性规则。因此，以下变体都将绑定到 hostName 属性上: 如果我们将 MailModuleProperties 类型的 bean 注入到另一个 bean 中，这个 bean 现在可以以类型安全的方式访问那些外部配置参数的值。 但是，我们仍然需要让 Spring 知道我们的 @ConfigurationProperties 类存在，以便将其加载到应用程序上下文中( 面试还不知道 BeanFactory 和 ApplicationContext 的区别？ 激活 @ConfigurationProperties对于 Spring Boot，创建一个 MailModuleProperties 类型的 bean，我们可以通过下面几种方式将其添加到应用上下文中 首先，我们可以通过添加 @Component 注解让 Component Scan 扫描到 很显然，只有当类所在的包被 Spring @ComponentScan 注解扫描到才会生效，默认情况下，该注解会扫描在主应用类下的所有包结构 我们也可以通过 Spring 的 Java Configuration 特性实现同样的效果: 只要 MailModuleConfiguration 类被 Spring Boot 应用扫描到，我们就可以在应用上下文中访问 MailModuleProperties bean 我们还可以使用 @EnableConfigurationProperties 注解让我们的类被 Spring Boot 所知道，在该注解中其实是用了@Import(EnableConfigurationPropertiesImportSelector.class) 实现，大家可以看一下 激活一个 @ConfigurationProperties 类的最佳方式是什么？所有上述方法都同样有效。然而，我建议模块化你的应用程序，并让每个模块提供自己的@ConfigurationProperties 类，只提供它需要的属性，就像我们在上面的代码中对邮件模块所做的那样。这使得在不影响其他模块的情况下重构一个模块中的属性变得容易。 因此，我不建议在应用程序类本身上使用 @EnableConfigurationProperties，如许多其他教程中所示，是在特定于模块的 @Configuration 类上使用@EnableConfigurationProperties，该类也可以利用包私有的可见性对应用程序的其余部分隐藏属性。 无法转换的属性如果我们在 application.properties 属性上定义的属性不能被正确的解析会发生什么？假如我们为原本应该为布尔值的属性提供的值为 ‘foo’: 默认情况下，Spring Boot 将会启动失败，并抛出异常: 123456Failed to bind properties under 'myapp.mail.enabled' to java.lang.Boolean: Property: myapp.mail.enabled Value: foo Origin: class path resource [application.properties]:1:20 Reason: failed to convert java.lang.String to java.lang.Boolean 当我们为属性配置错误的值时，而又不希望 Spring Boot 应用启动失败，我们可以设置 ignoreInvalidFields 属性为 true (默认为 false) 这样，Spring Boot 将会设置 enabled 字段为我们在 Java 代码里设定好的默认值。如果我们没有设置默认值，enabled 将为 null，因为这里定义的是 boolean 的包装类 Boolean 未知的属性和上面的情况有些相反，如果我们在 application.properties 文件提供了 MailModuleProperties 类不知道的属性会发生什么？ 默认情况下，Spring Boot 会忽略那些不能绑定到 @ConfigurationProperties 类字段的属性 然而，当配置文件中有一个属性实际上没有绑定到 @ConfigurationProperties 类时，我们可能希望启动失败。也许我们以前使用过这个配置属性，但是它已经被删除了，这种情况我们希望被触发告知手动从 application.properties 删除这个属性 为了实现上述情况，我们仅需要将 ignoreUnknownFields 属性设置为 false (默认是 true) 现在，应用启动时，控制台会反馈我们异常信息 123456Binding to target [Bindable@cf65451 type = com.example.configurationproperties.properties.MailModuleProperties, value = 'provided', annotations = array&lt;Annotation&gt;[@org.springframework.boot.context.properties.ConfigurationProperties(value=myapp.mail, prefix=myapp.mail, ignoreInvalidFields=false, ignoreUnknownFields=false)]] failed: Property: myapp.mail.unknown-property Value: foo Origin: class path resource [application.properties]:3:29 Reason: The elements [myapp.mail.unknown-property] were left unbound. 弃用警告⚠️(Deprecation Warning) ignoreUnknownFields 在未来 Spring Boot 的版本中会被标记为 deprecated，因为我们可能有两个带有 @ConfigurationProperties 的类，同时绑定到了同一个命名空间 (namespace) 上，其中一个类可能知道某个属性，另一个类却不知道某个属性，这样就会导致启动失败 启动时校验 @ConfigurationProperties如果我们希望配置参数在传入到应用中时有效的，我们可以通过在字段上添加 bean validation 注解，同时在类上添加 @Validated 注解 如果我们忘记在 application.properties 文件设置 enabled 属性，并且设置 defaultSubject 为空 应用启动时，我们将会得到 BindValidationException 123456789Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'myapp.mail' to com.example.configurationproperties.properties.MailModuleProperties failed: Property: myapp.mail.enabled Value: null Reason: must not be null Property: myapp.mail.defaultSubject Value: null Reason: must not be empty 当然这些默认的验证注解不能满足你的验证要求，我们也可以自定义注解 如果你的验证逻辑很特殊，我们可以实现一个方法，并用 @PostConstruct 标记，如果验证失败，方法抛出异常即可, 关于 @PostConstruct，可以查看 Spring Bean 的生命周期之缘起 复杂属性类型多数情况，我们传递给应用的参数是基本的字符串或数字。但是，有时我们需要传递诸如 List 的数据类型 List 和 Set假如，我们为邮件模块提供了一个 SMTP 服务的列表，我们可以添加该属性到 MailModuleProperties 类中 我们有两种方式让 Spring Boot 自动填充该 list 属性 application.properties在 application.properties 文件中以数组形式书写 application.ymlYAML 本身支持 list 类型，所以可以在 application.yml 文件中添加: set 集合也是这种方式的配置方式，不再重复书写。另外YAML 是更好的阅读方式，层次分明，所以在实际应用中更推荐大家使用该种方式做数据配置 DurationSpring Boot 内置支持从配置参数中解析 durations (持续时间)，官网文档 给出了明确的说明 我们既可以配置毫秒数数值，也可配置带有单位的文本: 官网上已明确说明，配置 duration 不写单位，默认按照毫秒来指定，我们也可已通过 @DurationUnit 来指定单位: 常用单位如下: ns for nanoseconds (纳秒) us for microseconds (微秒) ms for milliseconds (毫秒) s for seconds (秒) m for minutes (分) h for hours (时) d for days (天) DataSize与 Duration 的用法一毛一样，默认单位是 byte (字节)，可以通过 @DataSizeUnit 单位指定: 添加配置 但是，我测试的时候打印出来结果都是以 B (bytes) 来显示 常见单位如下: B for bytes KB for kilobytes MB for megabytes GB for gigabytes TB for terabytes 自定义类型有些情况，我们想解析配置参数到我们自定义的对象类型上，假设，我们我们设置最大包裹重量: 在 MailModuleProperties 中添加 Weight 属性 我们可以模仿 DataSize 和 Duration 创造自己的 converter (转换器) 将其注册到 Spring Boot 上下文中 @ConfigurationPropertiesBinding 注解是让 Spring Boot 知道使用该转换器做数据绑定 使用 Spring Boot Configuration Processor 完成自动补全我们向项目中添加依赖: Maven Gradle 重新 build 项目之后，configuration processor 会为我们创建一个 JSON 文件: 这样，当我们在 application.properties 和 application.yml 中写配置的时候会有自动提醒: 标记配置属性为 Deprecatedconfiguration processor 允许我们标记某一个属性为 deprecated 我们可以通过添加 @DeprecatedConfigurationProperty 注解到字段的 getter 方法上，来标示该字段为 deprecated，重新 build 项目，看看 JSON 文件发生了什么？ 当我们再编写配置文件时，已经给出了明确 deprecated 提示: 总结Spring Boot 的 @ConfigurationProperties 注解在绑定类型安全的 Java Bean 时是非常强大的，我们可以配合其注解属性和 @DeprecatedConfigurationProperty 注解获取到更友好的编程方式，同时这样让我们的配置更加模块化。 附加说明以为 @ConfigurationProperties 注解满足我们的全部需要了吗？其实不然，Spring 官网明确给出了该注解和 @Value 注解的对比: 如果使用 SpEL 表达式，我们只能选择 @Value 注解 另外我之前在阅读 RabbitMQ 源码时，发现 RabbitProperties 类充分的利用了 @ConfigurationProperties 注解特性: deprecated Duration Enum 嵌套属性 感觉自己后知后觉，最近在思考，为什么小时候要阅读和背诵古诗词，文言文等经典，因为这样写文章就可以轻松熟练的引用经典。技术也一样，各种框架的源码就是学生时代的古诗词和文言文，我们要多多查看阅读，甚至背诵编程思想，这样就可以写出越来越优雅的代码 关于 @ConfigurationProperties 注解的使用，这里推荐 RabbitMQ Github 源码，只需看这一个类就可以，知道怎样充分利用这个注解. Demo 代码获取，回复公众号「demo」，打开链接查看对应的子文件夹即可","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"Spring Aware 到底是什么？","slug":"Spring-Aware-到底是什么？","date":"2019-12-22T11:20:52.000Z","updated":"2019-12-23T13:57:39.955Z","comments":true,"path":"/p/spring-aware.html","link":"","permalink":"https://dayarch.top/p/spring-aware.html","excerpt":"通过如下前序两篇文章: 1. Spring Bean 生命周期之缘起 2. Spring Bean 生命周期之缘尽 我们了解了 Spring Bean 的生命周期核心内容，bean 是如何被初始化变为 Ready for Use 的状态，当资源被回收时又是如何被 destroy 的，但 Spring Bean Life Cycle图并未被全部点亮，这篇文章将点亮剩余内容，同时说说你常见的 XxxxAware 接口 为什么要说 Spring Bean 生命周期又说 Aware 呢？下来点亮剩下内容你也许就明白了： 1. 在 Spring Bean Ready for Us","text":"通过如下前序两篇文章: Spring Bean 生命周期之缘起 Spring Bean 生命周期之缘尽我们了解了 Spring Bean 的生命周期核心内容，bean 是如何被初始化变为 Ready for Use 的状态，当资源被回收时又是如何被 destroy 的，但 Spring Bean Life Cycle图并未被全部点亮，这篇文章将点亮剩余内容，同时说说你常见的 XxxxAware 接口 为什么要说 Spring Bean 生命周期又说 Aware 呢？下来点亮剩下内容你也许就明白了： 在 Spring Bean Ready for Use之前的起源当然是要调用构造器，所以 Constructor 毋庸置疑是创建 Spring Bean 的第一步 通过 Setter 方法完成依赖注入，SDI （Setter Dependency Injection） 依赖注入一旦结束，BeanNameAware.setBeanName() 会被调用，它设置该 bean 在 Bean Factory 中的名称 接下来调用 BeanClassLoaderAware.setBeanClassLoader()，为 bean 实例提供类加载器，我们知道所有类都是要通过类加载器加载到上下文的，关于类的加载机制/双亲委派模型（大厂都爱问的面试题）内容会在后续给出来，让你透彻的了解 然后 BeanFactoryAware.setBeanFactory() 会被调用为 bean 实例提供其所拥有的 factory 关于 1、2 两点我要额外多说一些内容，请看下面代码： 这里，我们尝试通过构造器访问自动注入的 field Environment env，当构造器被调用时，Spring Bean 还没被完全初始化，这就会导致 NullPointerExceptions；我们变换一下方式： 这种方式，Environment 实例被安全注入之后才调用 @PostConstruct标记的方法，这样就不会抛出 NullPointerException 了。 这会回看周期图，有没有豁然开朗？ 等所有 Spring Bean 都完成依赖注入（周期图中的 Setter Methods 部分）再使用 bean 的引用才是安全的方式， 后续会有一个章节专门说一说面试经常被问起的 Spring 有几种依赖注入方式的尴尬问题，请关注后续文章 到这里终于可以说一说 Aware 了，且看 AwareAware 是 Spring 中的一个根接口，继承该接口的子接口有很多，比如周期图中的那三个 Aware，但是该接口没有任何方法，所以大家可以把它理解成一个标记接口： Aware 翻译过来可以理解为”察觉的；注意到的；感知的” ，XxxxAware 也就是对….感知的，没有 Aware 就是无感知的吗？对喽 Spring 的依赖注入最大亮点就是所有的 Bean 对 Spring 容器的存在是没有意识的，拿 Spring Bean 生命周期之缘起 文章中“小学生入少先队”为例子说明，小学生还是那个小学生，加入少先队还是加入共青团只不过规则不一样罢了但是在实际项目中，我们不可避免的要用到 Spring 容器本身提供的资源（难免要有事情需要少先队组织的帮助），这时候要让 Bean 主动意识到 Spring 容器的存在，才能调用 Spring 所提供的资源，这就是 Spring Aware. 其实 Spring Aware 是 Spring 设计为框架内部使用的，若使用了，你的 Bean 将会和 Spring 框架耦合，所以自己不单独使用，但是在读框架源码时希望你不再模糊. 常见的 Spring Aware 接口 Aware子接口 描述 BeanNameAware 获取容器中 Bean 的名称 BeanFactoryAware 获取当前 BeanFactory ，这样可以调用容器的服务 ApplicationContextAware 同上，在BeanFactory 和 ApplicationContext 的区别 中已明确说明 MessageSourceAware 获取 Message Source 相关文本信息 ApplicationEventPublisherAware 发布事件 ResourceLoaderAware 获取资源加载器，这样获取外部资源文件 来看类关系图： 当然不止以上这些 Aware， 通常使用 Spring Aware 的目的是为了让 Bean 获得 Spring 容器的服务。 代码示例BeanNameAware自定义 bean 实现 BeanNameAware 注册 bean 运行 和预想一样，Bean Name 输出结果为 myCustomBeanName，如果移除掉 @Bean 注解的 name 属性， 输出结果为 getMyBeanName 总结在大多数情况下，我们应该避免使用任何 Aware 接口，除非我们需要它们。实现这些接口会将代码耦合到Spring框架，但是希望看过本节内容之后阅读框架源码思维更加清晰 灵魂追问 框架中有哪些经典的 Aware 应用？ 到现在你能很好的理解 Spring Bean 的生命周期吗？ Demo代码涉及到 Spring Bean 生命周期的测试代码由于内容较多，没有写在此处，关注公众号并回复 「demo」获取相关代码，请自行尝试运行结果","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Aware","slug":"Spring-Aware","permalink":"https://dayarch.top/tags/Spring-Aware/"},{"name":"Spring Bean","slug":"Spring-Bean","permalink":"https://dayarch.top/tags/Spring-Bean/"},{"name":"生命周期","slug":"生命周期","permalink":"https://dayarch.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"Spring Bean生命周期之缘尽","slug":"Spring-Bean生命周期之缘尽","date":"2019-12-21T09:23:42.000Z","updated":"2019-12-21T10:12:36.099Z","comments":true,"path":"/p/spring-bean-lifecycle-destroy.html","link":"","permalink":"https://dayarch.top/p/spring-bean-lifecycle-destroy.html","excerpt":"上一篇文章 Spring Bean 生命周期之缘起 说明了我是谁？ 和 我从哪里来? 的两大哲学问题，今天我们要讨论一下终极哲学我要到哪里去？ 初始化 Spring Bean 有三种方式： 1. @PostConstruct 2. InitializingBean.afterPropertiesSet() 3. init-method 销毁 Spring Bean 同样有三种方式： 1. @PreDestroy 2. DisposableBean.destroy() 3. destroy-method 正所谓，天对地，雨对风； @PostConstruct 对 @Pre","text":"上一篇文章 Spring Bean 生命周期之缘起 说明了我是谁？ 和 我从哪里来? 的两大哲学问题，今天我们要讨论一下终极哲学我要到哪里去？ 初始化 Spring Bean 有三种方式： @PostConstruct InitializingBean.afterPropertiesSet() init-method 销毁 Spring Bean 同样有三种方式： @PreDestroy DisposableBean.destroy() destroy-method 正所谓，天对地，雨对风； @PostConstruct 对 @PreDestroy；InitializingBean.afterPropertiesSet() 对 DisposableBean.destroy()； init-method 对 destroy-method；雷隐隐，雾蒙蒙；山花对海树，赤日对苍穹；平仄平仄平平仄，仄平仄平仄仄平，仄仄平…… 感觉讲到这没必要讲下去了，一切清晰明了，但我还有话要说 当 Spring Ioc 容器要移除 bean 时，销毁相关回调方法将会被执行，这么做的目的时释放被 bean 持有的资源，或者去执行一些终极任务. 当 ApplicationContext 调用 registerShutdownHook 方法时，这些销毁方法就会被触发，但一般正常的业务中很少会用到这些方法 接下来具体的展示一下三种方法的使用方式 三种销毁 Spring Bean 的方式DisposableBeanSpring 为我们提供了 DisposableBean 接口 我们可以通过实现 DisposableBean 接口，在其唯一方法 destroy 内完成 bean 销毁的工作，但是 Spring Framework 官方并不建议我们通过这种方法来销毁 bean，这同样是一种强耦合的方式，我们看到框架层面才会用到这个方法。 @PreDestroy这种方式是 Spring 非常提倡的一种方式，我们通常将其标记在方法上即可，通常习惯将这个方法起名为 destory() destroy-method同样是两种方式，第一种方式： 第二种方式 以上三种 Bean 的销毁方式也是可以组合使用的，那么组合在一起的调用顺序是什么呢？ 首先 @PreDestroy 会被调用 其次 DisposableBean.destroy() 会被调用 最后调用通过 XML 配置的 destroy-method 方法或通过设置 @Bean 注解 设置 destroyMethod 属性的方法 用图示来说明一下调用顺序 这个调用顺序也不难记忆 PreDestroy (P)，destroy (D)，destroy-method (D) —&gt; PDD （那个3亿人都在 pin 的那个 APP 名称，目前 3 亿人中没有我） 再来看看 Spring Bean 生命周期图，我们已经点亮了核心部分： 我们要注意，在销毁的过程并没有类似 BeanPostProcess 那中切面的思想，这里要注意到区别。 灵魂追问 在阅读框架源码时，哪些地方用到了 bean 的销毁方法？ 还没有被点亮的地方，你认为还有哪些内容没有做？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Bean","slug":"Spring-Bean","permalink":"https://dayarch.top/tags/Spring-Bean/"},{"name":"生命周期","slug":"生命周期","permalink":"https://dayarch.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"Spring Bean生命周期之缘起","slug":"Spring-Bean生命周期之缘起","date":"2019-12-20T01:04:56.000Z","updated":"2019-12-21T10:12:29.078Z","comments":true,"path":"/p/spring-bean-lifecycle-creation.html","link":"","permalink":"https://dayarch.top/p/spring-bean-lifecycle-creation.html","excerpt":"Spring bean 的生命周期很容易理解。实例化 bean 时，可能需要执行一些初始化以使其进入可用 （Ready for Use）状态。类似地，当不再需要 bean 并将其从容器中移除时，可能需要进行一些清理，这就是它的生命周期 上一篇文章 面试还不知道BeanFactory和ApplicationContext的区别？ 中说明了接口 Beanfactory 和 Applicationcontext 可以通过 T getBean(String name, Class requiredType) 方法从 Spring 容器中获取bean，区别是，前者是懒加载形式，后者是预加载的形式","text":"Spring bean 的生命周期很容易理解。实例化 bean 时，可能需要执行一些初始化以使其进入可用 （Ready for Use）状态。类似地，当不再需要 bean 并将其从容器中移除时，可能需要进行一些清理，这就是它的生命周期 上一篇文章 面试还不知道BeanFactory和ApplicationContext的区别？ 中说明了接口 Beanfactory 和 Applicationcontext 可以通过 T getBean(String name, Class&lt;T&gt; requiredType) 方法从 Spring 容器中获取bean，区别是，前者是懒加载形式，后者是预加载的形式。那么问题来了： 这些 Spring Beans 是怎么生成出来的呢？ 在正式回答这个问题之前，先解答一些有关 Java Bean， Spring Bean 和 Spring IoC 容器这些概念性的疑惑，我希望通过下面这个例子形象说明这些问题： 小学生 （Java Bean）通过提交资料申请（元数据配置）加入了少先队（Spring Ioc 容器），学习了一些精神与规定之后，变成了少先队员（Spring Bean） 从这里可以看出，Java Bean 和 Spring Bean 都是具有特定功能的对象，小学生还是那个小学生，只不过加入了少先队之后有了新的身份，新的身份要按照组织 （Spring Ioc）的规定履行特定义务 来看下图加深一下了解 首先要有容器，实例化 Spring Ioc 容器是非常简单的，接口 org.springframework.context.ApplicationContext 表示Spring IoC容器，负责实例化，配置和组装上述 bean。 容器通过读取配置元数据获取有关要实例化，配置和组装的对象的指令。 配置元数据通常以XML，Java 注解或代码的形式表示。 它允许你自己表达组成应用程序的对象以及这些对象之间丰富的相互依赖性，比如这样： 1ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"spring.xml\", \"spring1.xml\"&#125;); 有了容器，我们需要做哪些处理，使其内部对象变为 Ready for Use 的状态? 我们需要通过 Spring 容器实例化它们，Spring 为我们提供了三种方式： 三种初始化方式InitializingBeanSpring 为我们提供了 InitializingBean 接口 123public interface InitializingBean &#123; void afterPropertiesSet() throws Exception;&#125; 我们可以通过实现 InitializingBean 接口，在其唯一方法 afterPropertiesSet 内完成实例化的工作，但是 Spring Framework 官方并不建议我们通过这种方法来完成 Bean 的实例化，这是一种强耦合的方式，我们看到框架层面才会用到这个方法。 @PostConstruct这种方式是 Spring 非常提倡的一种方式，我们通常将其标记在方法上即可，通常习惯将这个方法起名为 init() 1234@PostConstructpublic void init() &#123; System.out.println(\"Inside init() method...\");&#125; init-method你应该见过这种初始化方式： 12345678910111213public class MyClass &#123; public void init() &#123; // perform post-creation logic here &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = \"init\") public MyClass myclass() &#123; return new MyClass (); &#125;&#125; 你也应该见过这种配置方式： 1&lt;bean id=\"myClass\" class=\"com.demo.MyClass\" init-method=\"init\"/&gt; 没错，这只是同样功能的不同实现方式罢了以上就是三种初始化 Spring Beans 的方式，我们在框架中看到过三种方式在组合使用，那么组合使用的调用顺序是什么呢？ 首先@PostConstruct 会被最先调用 其次 InitializingBean.afterPropertiesSet() 方法将会被调用 最后调用通过 XML 配置的 init-method 方法或通过设置 @Bean 注解 设置 initMethod 属性的方法 了解了这些，你也就了解了 Spring Bean 是怎么来的了 通过图示来说明一下： 这个调用顺序很难记忆吗吗？ PostConstruct (P)，afterPropertiesSet (A)，init-method (I) —&gt; PAI （圆周率π） BeanPostProcessorBeanPostProcessor 接口，大家也应该有印象，里面只有两个方法： 12345public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException; Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;&#125; 看方法名，BeforeInitialization 和 AfterInitialization，我们应该猜得出，这是在上述三种方式的前和后，算是一种全局的切面思想，我们经常会使用 postProcessAfterInitialization 方法，通过读取 Bean 的注解完成一些后续逻辑编写与属性的设定，现在 Ready for Use之前是这样： 在 Ready for Use 之前，了解这些内容，已可以基本满足日常的工作内容，但这并不是 Ready for Use 的全部内容，Spring Bean 整个生命周期的流程应该是这样的，后续文章会逐步点亮： 灵魂追问 了解了 Spring Bean 是怎么来的？那它是怎么没的呢？什么时候需要销毁他们呢？ Spring 框架中 XxxxAware，这些类有什么作用，能在 Ready for Use 之前有用处吗？ 你日常的工作中有充分利用今天说明的这些内容吗？懂得这些会大大方便你的编程 补充说明 虽然当下流行以注解声明方式进行编程，甚至高版本 Spring 会将一些方法标记为过时，但文章说明依旧会使用 XMLBeanFactory 这类方法，包括 XML 配置。这样做，只不过为了更清晰的说明问题。 另外将 Spring Bean 声明周期的讲解，进行拆分，是为了让大家有独立的思考空间，带着问题去思考、时间，而不是被动的填充，最终串联起自己的学习网络，这样理解的更深刻，具体请看之前写的文章 程序猿为什么要看源码, 后续内容请持续关注","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Bean","slug":"Spring-Bean","permalink":"https://dayarch.top/tags/Spring-Bean/"},{"name":"生命周期","slug":"生命周期","permalink":"https://dayarch.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"面试还不知道BeanFactory和ApplicationContext的区别？","slug":"面试还不知道BeanFactory和ApplicationContext的区别？","date":"2019-12-19T13:37:30.000Z","updated":"2019-12-19T13:45:38.771Z","comments":true,"path":"/p/difference-between-beanfactory-and-applicationcontext.html","link":"","permalink":"https://dayarch.top/p/difference-between-beanfactory-and-applicationcontext.html","excerpt":"前言 接口 BeanFactory 和 ApplicationContext 都是用来从容器中获取 Spring beans 的，但是，他们二者有很大不同 我看到过很多问 BeanFactory 和 ApplicationContext 不同点的问题，考虑到这，我应该使用前者还是后者从 Spring 容器中获取 beans 呢？请向下看 什么是 Spring Bean 这是一个非常简单而又很复杂的问题，通常来说，Spring beans 就是被 Spring 容器所管理的 Java 对象，来看一个简单的例子 1 2 3 4 5 6 7 8 9 10 package com.zolta","text":"前言 接口 BeanFactory 和 ApplicationContext 都是用来从容器中获取 Spring beans 的，但是，他们二者有很大不同 我看到过很多问 BeanFactory 和 ApplicationContext 不同点的问题，考虑到这，我应该使用前者还是后者从 Spring 容器中获取 beans 呢？请向下看 什么是 Spring Bean这是一个非常简单而又很复杂的问题，通常来说，Spring beans 就是被 Spring 容器所管理的 Java 对象，来看一个简单的例子 12345678910package com.zoltanraffai; public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"My Message : \" + message); &#125; &#125; 在基于 XML 的配置中， beans.xml 为 Spring 容器管理 bean 提供元数据 什么是 Spring 容器Spring 容器负责实例化，配置和装配 Spring beans，下面来看如何为 IoC 容器配置我们的 HelloWorld POJO 123456789&lt;?xml version = \"1.0\" encoding = \"UTF-8\"?&gt;&lt;beans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id = \"helloWorld\" class = \"com.zoltanraffai.HelloWorld\"&gt; &lt;property name = \"message\" value = \"Hello World!\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 现在，它已经被 Spring 容器管理了，接下来的问题是：我们怎样获取它？ BeanFactory 和 ApplicationContext 的不同点BeanFactory 接口这是一个用来访问 Spring 容器的 root 接口，要访问 Spring 容器，我们将使用 Spring 依赖注入功能，使用 BeanFactory 接口和它的子接口 特性： Bean 的实例化/串联通常情况，BeanFactory 的实现是使用懒加载的方式，这意味着 beans 只有在我们通过 getBean() 方法直接调用它们时才进行实例化实现 BeanFactory 最常用的 API 是 XMLBeanFactory这里是如何通过 BeanFactory 获取一个 bean 的例子： 1234567891011package com.zoltanraffai; import org.springframework.core.io.ClassPathResource; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.xml.XmlBeanFactory; public class HelloWorldApp&#123; public static void main(String[] args) &#123; XmlBeanFactory factory = new XmlBeanFactory (new ClassPathResource(\"beans.xml\")); HelloWorld obj = (HelloWorld) factory.getBean(\"helloWorld\"); obj.getMessage(); &#125;&#125; ApplicationContext 接口ApplicationContext 是 Spring 应用程序中的中央接口，用于向应用程序提供配置信息它继承了 BeanFactory 接口，所以 ApplicationContext 包含 BeanFactory 的所有功能以及更多功能！它的主要功能是支持大型的业务应用的创建 特性： Bean instantiation/wiring Bean 的实例化/串联 自动的 BeanPostProcessor 注册 自动的 BeanFactoryPostProcessor 注册 方便的 MessageSource 访问（i18n） ApplicationEvent 的发布 与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化 这里是 ApplicationContext 的使用例子： 1234567891011package com.zoltanraffai; import org.springframework.core.io.ClassPathResource; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.xml.XmlBeanFactory; public class HelloWorldApp&#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"beans.xml\"); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); &#125;&#125; 总结ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。但是也有一些限制情形，比如移动应用内存消耗比较严苛，在那些情景中，使用更轻量级的 BeanFactory 是更合理的。然而，在大多数企业级的应用中，ApplicationContext 是你的首选。 灵魂追问 如何使用 BeanPostProcessor 和 BeanFactoryPostProcessor ？ 你了解 Spring Bean 的生命周期吗？了解了这些对与 bean 的使用将有非常大的帮助.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"面试","slug":"面试","permalink":"https://dayarch.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Java equals 和 hashCode 面试那点事","slug":"Java-equals-和-hashCode-面试那点事","date":"2019-12-17T12:41:51.000Z","updated":"2019-12-22T11:48:22.310Z","comments":true,"path":"/p/java-equals-hashcode.html","link":"","permalink":"https://dayarch.top/p/java-equals-hashcode.html","excerpt":"前言 上一篇文章 如何妙用 Spring 数据绑定？ ，灵魂追问 环节留下了一个有关 equals 和 hashcode 问题 。基础面试经常会碰到与之相关的问题，这不是一个复杂的问题，但很多朋友都苦于说明他们二者的关系和约束，于是写本文做单独说明，本篇文章将循序渐进 ( 通过举例，让记忆与理解更轻松 ) 说明这些让你有些苦恼的问题，Let’s go ……. 面试问题 1. Java 里面有了 == 运算符，为什么还需要 equals ？ == 比较的是对象地址，equals 比较的是对象值 先来看一看 Object 类中 equals 方法: 1 2 3 public boole","text":"前言上一篇文章 如何妙用 Spring 数据绑定？ ，灵魂追问 环节留下了一个有关 equals 和 hashcode 问题 。基础面试经常会碰到与之相关的问题，这不是一个复杂的问题，但很多朋友都苦于说明他们二者的关系和约束，于是写本文做单独说明，本篇文章将循序渐进 ( 通过举例，让记忆与理解更轻松 ) 说明这些让你有些苦恼的问题，Let’s go ……. 面试问题1. Java 里面有了 == 运算符，为什么还需要 equals ？ == 比较的是对象地址，equals 比较的是对象值 先来看一看 Object 类中 equals 方法: 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 我们看到 equals 方法同样是通过 == 比较对象地址，并没有帮我们比较值。Java 世界中 Object 绝对是”老祖宗” 的存在，== 号我们没办法改变或重写。但 equals 是方法，这就给了我们重写 equals 方法的可能，让我们实现其对值的比较: 1234@Overridepublic boolean equals(Object obj) &#123; //重写逻辑&#125; 新买的电脑，每个电脑都有唯一的序列号，通常情况下，两个一模一样的电脑放在面前，你会说由于序列号不一样，这两个电脑不一样吗？ 如果我们要说两个电脑一样，通常是比较其「品牌/尺寸/配置 」(值) ，比如这样: 1234@Overridepublic boolean equals(Object obj) &#123; return 品牌相等 &amp;&amp; 尺寸相等 &amp;&amp; 配置相等&#125; 当遇到如上场景时，我们就需要重写 equals 方法。这就解释了 Java 世界为什么有了 == 还有equals 这个问题了. 2. equals相等 和 hashcode 相等问题关于二者，你经常会碰到下面的两个问题: 两个对象 equals 相等，那他们 hashCode 相等吗？ 两个对象 hashCode 相等，那他们 equals 相等吗？ 为了说明上面两个问题的结论，这里举一个不太恰当的例子，只为方便记忆，我们将 equals 比作一个单词的拼写；hashCode 比作一个单词的发音，在相同语境下: sea / sea 「大海」，两个单词拼写一样，所以 equals 相等，他们读音 /siː/ 也一样，所以 hashCode 就相等，这就回答了第一个问题: 两个对象 equals 相等，那他们 hashCode 一定也相等 sea / see 「大海/看」，两个单词的读音 /siː/ 一样，显然单词是不一样的，这就回答了第二个问题: 两个对象 hashCode 相等，那他们 equals 不一定相等 查看 Object 类的 hashCode 方法: 1public native int hashCode(); 继续查看该方法的注释，明确写明关于该方法的约束 其实在这个结果的背后，还有的是关于重写 equals 方法的约束 3. 重写 equals 有哪些约束？关于重写 equals 方法的约束，同样在该方法的注释中写的很清楚了，我在这里再说明一下: 赤橙红绿青蓝紫，七彩以色列；哆来咪发唆拉西, 一曲安哥拉 ，这些规则不是用来背诵的，只是在你需要重写 equals 方法时，打开 JDK 查看该方法，按照准则重写就好 4. 什么时候需要我们重写 hashCode？为了比较值，我们重写 equals 方法，那什么时候又需要重写 hashCode 方法呢？ 通常只要我们重写 equals 方法就要重写 hashCode 方法 为什么会有这样的约束呢？按照上面讲的原则，两个对象 equals 相等，那他们的 hashCode 一定也相等。如果我们只重写 equals 方法而不重写 hashCode 方法，看看会发生什么，举个例子来看: 定义学生类，并通过 IDE 只帮我们生成 equals 方法: 123456789101112131415public class Student &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125;&#125; 编写测试代码: 12345678910111213141516171819Student student1 = new Student();student1.setName(\"日拱一兵\");student1.setAge(18);Student student2 = new Student();student2.setName(\"日拱一兵\");student2.setAge(18);System.out.println(\"student1.equals(student2)的结果是：\" + student1.equals(student2));Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();students.add(student1);students.add(student2);System.out.println(\"Student Set 集合长度是：\" + students.size());Map&lt;Student, java.lang.String&gt; map = new HashMap&lt;Student, java.lang.String&gt;();map.put(student1, \"student1\");map.put(student2, \"student2\");System.out.println(\"Student Map 集合长度是：\" + map.keySet().size()); 查看运行结果: 123student1.equals(student2)的结果是：trueStudent Set 集合长度是：2Student Map 集合长度是：2 很显然，按照集合 Set 和 Map 加入元素的标准来看，student1 和 student2 是两个对象，因为在调用他们的 put (Set add 方法的背后也是 HashMap 的 put)方法时， 会先判断 hash 值是否相等，这个小伙伴们打开 JDK 自行查看吧 所以我们继续重写 Student 类的 hashCode 方法: 1234@Overridepublic int hashCode() &#123; return Objects.hash(name, age);&#125; 重新运行上面的测试，查看结果: 123student1.equals(student2)的结果是：trueStudent Set 集合长度是：1Student Map 集合长度是：1 得到我们预期的结果，这也就是为什么通常我们重写 equals 方法为什么最好也重写 hashCode 方法的原因 如果你在使用 Lombok，不知道你是否注意到 Lombok 只有一个 @EqualsAndHashCode 注解，而没有拆分成 @Equals 和 @HashCode 两个注解，想了解更多 Lombok 的内容，也可以查看我之前写的文章 Lomok 使用详解 另外通过 IDE 快捷键生成重写方法时，你也会看到这两个方法放在一起，而不是像 getter 和 setter 那样分开 以上两点都是隐形的规范约束，希望大家也严格遵守这个规范，以防带来不必要的麻烦，记忆的方式有多样，如果记不住这个文字约束，脑海中记住上面的图你也就懂了 5. 重写 hashCode 为什么总有 31 这个数字？细心的朋友可能注意到，我上面重写 hashCode的方法很简答， 就是用了 Objects.hash 方法，进去查看里面的方法: 1234567891011public static int hashCode(Object a[]) &#123; if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result;&#125; 这里通过 31 来计算对象 hash 值 在 如何妙用 Spring 数据绑定？ 文章末尾提到的在 HandlerMethodArgumentResolverComposite 类中有这样一个成员变量: 12private final Map&lt;MethodParameter, HandlerMethodArgumentResolver&gt; argumentResolverCache = new ConcurrentHashMap&lt;MethodParameter, HandlerMethodArgumentResolver&gt;(256); Map 的 key 是 MethodParameter ，根据我们上面的分析，这个类一定也会重写 equals 和 hashCode 方法，进去查看发现，hashCode 的计算也用到了 31 这个数字 12345678910111213141516@Overridepublic boolean equals(Object other) &#123; if (this == other) &#123; return true; &#125; if (!(other instanceof MethodParameter)) &#123; return false; &#125; MethodParameter otherParam = (MethodParameter) other; return (this.parameterIndex == otherParam.parameterIndex &amp;&amp; getMember().equals(otherParam.getMember()));&#125;@Overridepublic int hashCode() &#123; return (getMember().hashCode() * 31 + this.parameterIndex);&#125; 为什么计算 hash 值要用到 31 这个数字呢？我在网上看到一篇不错的文章，分享给大家，作为科普，可以简单查看一下:String hashCode 方法为什么选择数字31作为乘子 总结如果还对equals 和 hashCode 关系及约束含混，我们只需要按照上述步骤逐步回忆即可，更好的是直接查看 JDK 源码；另外拿出实际的例子来反推验证是非常好的办法。如果你还有相关疑问，也可以留言探讨. 灵魂追问 Thread 类就没有重写 equals 方法，你还知道哪些情况没必要重写 equals 方法吗？ 从上面 HandlerMethodArgumentResolverComposite 类中定义的 Map 成员变量，你注意到哪些知识点，比如 final，ConcurrentHashMap，初识容量，为什么要这样写？你能解释出原因吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://dayarch.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Spring 数据绑定剖析","slug":"Spring-数据绑定剖析","date":"2019-12-12T11:59:04.000Z","updated":"2019-12-16T04:30:41.731Z","comments":true,"path":"/p/spring-data-binding-mechanism.html","link":"","permalink":"https://dayarch.top/p/spring-data-binding-mechanism.html","excerpt":"前言 在剖析完 「Spring Boot 统一数据格式是怎么实现的？ 」文章之后，一直觉得有必要说明一下 Spring’s Data Binding Mechanism 「Spring 数据绑定机制」。 默认情况下，Spring 只知道如何转换简单数据类型。比如我们提交的 int、String 或 boolean类型的请求数据，它会自动绑定到与之对应的 Java 类型。但在实际项目中，远远不够，因为我们可能需要绑定更复杂的对象类型。 我们需要了解 Spring 数据绑定机制，这样我们就可以更灵活的做全局配置或自定义配置，进而让我们的 RESTful API 更简洁，可读性也更好。本文依旧先","text":"前言在剖析完 「Spring Boot 统一数据格式是怎么实现的？ 」文章之后，一直觉得有必要说明一下 Spring’s Data Binding Mechanism 「Spring 数据绑定机制」。 默认情况下，Spring 只知道如何转换简单数据类型。比如我们提交的 int、String 或 boolean类型的请求数据，它会自动绑定到与之对应的 Java 类型。但在实际项目中，远远不够，因为我们可能需要绑定更复杂的对象类型。 我们需要了解 Spring 数据绑定机制，这样我们就可以更灵活的做全局配置或自定义配置，进而让我们的 RESTful API 更简洁，可读性也更好。本文依旧先通过示例代码说明实现，然后进行源码分析，带领大家了解这个机制是如何生效的，知其所以然， Let’s go…… Spring 数据绑定日期绑定先来看下面一小段代码 1234567891011@RestController@RequestMapping(\"/bindings/\")@Slf4jpublic class BindingController &#123; @GetMapping(\"/&#123;date&#125;\") public void getSpecificDateInfo(@PathVariable LocalDateTime date) &#123; log.info(date.toString()); &#125;&#125; 当我们用 Postman 请求这个 API 1http://localhost:8080/rgyb/bindings/2019-12-10 12:00:00 如我们所料，抛出数据类型转换异常因为 Spring 默认不支持将 String 类型的请求参数转换为 LocalDateTime 类型，所以我们需要自定义 converter 「转换器」完整整个转换过程 自定义转换器 StringToLocalDateTimeConverter，使其实现 org.springframework.core.convert.converter.Converter&lt;S, T&gt; 接口，在重写的 convert 方法中实现我们自定义的转换逻辑 1234567public class StringToLocalDateTimeConverter implements Converter&lt;String, LocalDateTime&gt; &#123; @Override public LocalDateTime convert(String s) &#123; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\", Locale.CHINESE); return LocalDateTime.parse(s, formatter); &#125;&#125; 将转换器注册到上下文中: 1234567@Configurationpublic class UnifiedReturnConfig implements WebMvcConfigurer &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new StringToLocalDateTimeConverter()); &#125;&#125; 重新访问上面链接，查看控制台，按照预期得到相应转换结果: 1c.e.unifiedreturn.api.BindingController : 2019-12-10T12:00 知道了这个，比如我们常用的枚举类型也可以应用这种方式做数据绑定 枚举类型绑定同样的套路，自定义转换器 1234567public class StringToEnumConverter implements Converter&lt;String, Modes&gt; &#123; @Override public Modes convert(String s) &#123; return Modes.valueOf(s); &#125;&#125; 将其添加至上下文，请小伙伴们自行尝试吧，知道了这个，我们再也不用在 RESTful API 内部做数据转换了，我们做到了全局控制，同时让整个 API 看起来更加清晰简洁 绑定对象在某些情况下，我们希望将数据绑定到对象，这时我们可能马上联想起来使用 @RequestBody 注解，该注解通常用于获取 POST 请求体，并将其转换相应的数据对象 在实际业务场景中，除了请求体中的数据，我们同样需要请求头中的数据，比如 token ，token 中包含当前登陆用户的信息，每一次 RESTful 请求我们都需要从 header 中获取 token 数据处理实际业务，这种场景，上文提到的 Converter 以及 @RequestBody 显然不能满足我们的需求，此时我们就要换另一种解决方案 : HandlerMethodArgumentResolver 首先我们需要自定义一个注解 LoginUser (运行时生效，作用于参数上) 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.PARAMETER)public @interface LoginUser &#123;&#125; 然后自定义 LoginUserArgumentResolver ，使其实现 HandlerMethodArgumentResolver 接口 1234567891011121314151617181920212223242526public class LoginUserArgumentResolver implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter methodParameter) &#123; //判断参数是否有自定义注解 LoginUser 修饰 return methodParameter.hasParameterAnnotation(LoginUser.class); &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest(); LoginUserVo loginUserVo = new LoginUserVo(); String token = request.getHeader(\"token\"); if (Strings.isNotBlank(token))&#123; //通常这里需要编写 token 解析逻辑，并将其放到 LoginUserVo 对象中 //logic &#125; //在此为了快速简洁的做演示说明，省略掉解析 token 部分，直接从 header 指定 key 中获取数据 loginUserVo.setId(Long.valueOf(request.getHeader(\"userId\"))); loginUserVo.setName(request.getHeader(\"userName\")); return loginUserVo; &#125;&#125; 依旧将自定义的 LoginUserArgumentResolver 添加到上下文中 1234@Overridepublic void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123; resolvers.add(new LoginUserArgumentResolver());&#125; 编写 API: 1234@GetMapping(\"/id\")public void getLoginUserInfo(@LoginUser LoginUserVo loginUserVo) &#123; log.info(loginUserVo.toString());&#125; 通过 Postman 请求，在 header 中设置好相应的 K-V，如下图 1http://localhost:8080/rgyb/bindings/id 发送请求，查看控制台，得到预期结果 1c.e.unifiedreturn.api.BindingController : LoginUserVo(id=111111, name=rgyb) 相信到这里，你已经了解了基本的使用，接下来我们进行源码分析，透过现象看本质 (希望可以打开 IDE 跟着步骤查看) Spring 数据绑定源码分析首先我们需要了解我们自定义的 LoginUserArgumentResolver 是如何被加载到上下文中的，在你看过 HttpMessageConverter转换原理解析 和 Springboot返回统一JSON数据格式是怎么实现的？后，你也许已经有了眉目，同加载 MessageConverter 如出一辙，在 RequestMappingHandlerAdapter 类中，同样有添加 ArgumentResolver 的方法，该方法会把系统内置的 resolver 和用户自定义的 resolver 都加载到上下文中，关键代码展示如下: 1234567891011121314151617private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), false)); //其他内置 resolver resolvers.add(new RequestResponseBodyMethodProcessor(this.getMessageConverters(), this.requestResponseBodyAdvice)); ... ... if (this.getCustomArgumentResolvers() != null) &#123; resolvers.addAll(this.getCustomArgumentResolvers()); &#125; ... ... return resolvers;&#125; 在 HttpMessageConverter转换原理解析 文章中有一段调用栈跟踪，我再次粘贴在此处，并用红框做出标记，其实我们在分析 messageConverter 时已经悄悄的路过了我们本节要说的内容 我们进入相应的类中瞧一瞧: 到这里你应该猛的了解这背后的道理了吧 接下来，我们来验证我们天天用的 @RequestBody 注解是不是这个套路呢？处理该注解的类是 RequestResponseBodyMethodProcessor，查看其类图，发现其依旧实现了 HandlerMethodArgumentResolver 接口 打开该类，你会看到下图代码，重点地方我已标记出来 整体处理流程如出一辙，只不过在里面调用了 messageConverter 来解析 JSON 数据。 总结本文说的 Converter 和 ArgumentResolver 以及在 Spring MVC 中常用的 @InitBinder 注解整体过程都如出一辙，大家都可以按照这个思路来查看具体的实现。另外，在我们完成日常编码工作时，都可以从 Spring 现有的处理方式中摸索到一些解决方案，但前提是你了解 Spring 底层的一些调用过程 最后希望小伙伴打开 IDE 切实查看相应代码，你一定还会有新发现，我们可以一起探讨。本文代码已上传，公众号回复「demo」，打开链接查看 「spring-boot-unified-return」文件夹内容即可，也可以顺路回顾以前 Spring Boot 统一返回格式的代码实现 灵魂追问 如上图所示，在追中源码时，发现HandlerMethodArgumentResolverComposite 是 HandlerMethodArgumentResolver 的实现类之一，其中有一个 Map 类型的成员变量，通常我们使用 Map，key 的类型多数为 String 类型，但看到这个 Map 中有这样的 key 你马上想到的是什么？基础面试经常会问 equals 和 hashcode 的问题，下一篇文章会借着这个类来分析说明一下你总困惑的这件小事 对于 Spring Boot 的整个调用过程，你能描述出整体流程吗？ Spring 内置多少个 Resolver？你可以跟踪调试获取到","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"Spring Data Binding","slug":"Spring-Data-Binding","permalink":"https://dayarch.top/tags/Spring-Data-Binding/"}]},{"title":"Lombok 使用教程详解","slug":"Lombok-使用教程详解","date":"2019-11-25T05:34:12.000Z","updated":"2019-11-25T05:41:24.129Z","comments":true,"path":"/p/lombok-usage.html","link":"","permalink":"https://dayarch.top/p/lombok-usage.html","excerpt":"前言 在 Java 应用程序中存在许多重复相似的、生成之后几乎不对其做更改的代码，但是我们还不得不花费很多精力编写它们来满足 Java 的编译需求 比如，在 Java 应用程序开发中，我们几乎要为所有 Bean 的成员变量添加 get() ,set() 等方法，这些相对固定但又不得不编写的代码浪费程序员很多精力，同时让类内容看着更杂乱，我们希望将有限的精力关注在更重要的地方。 Lombok 已经诞生很久了，甚至在 Spring Boot Initalizr 中都已加入了 Lombok 选项， 这里我们将 Lombok 做一下详细说明: Lombok 官网的介绍：Project Lom","text":"前言在 Java 应用程序中存在许多重复相似的、生成之后几乎不对其做更改的代码，但是我们还不得不花费很多精力编写它们来满足 Java 的编译需求 比如，在 Java 应用程序开发中，我们几乎要为所有 Bean 的成员变量添加 get() ,set() 等方法，这些相对固定但又不得不编写的代码浪费程序员很多精力，同时让类内容看着更杂乱，我们希望将有限的精力关注在更重要的地方。 Lombok 已经诞生很久了，甚至在 Spring Boot Initalizr 中都已加入了 Lombok 选项， 这里我们将 Lombok 做一下详细说明: Lombok 官网的介绍：Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again. Early access to future java features such as val, and much more. 直白的说： Lombok 是一种 Java™ 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注解实现这一目的，且看: Bean 的对比传统的 POJO 类是这样的 通过Lombok改造后的 POJO 类是这样的 一眼可以观察出来我们在编写 Employee 这个类的时候通过 @Data 注解就已经实现了所有成员变量的 get() 与 set() 方法等，同时 Employee 类看起来更加清晰简洁。Lombok 的神奇之处不止这些，丰富的注解满足了我们开发的多数需求。 Lombok的安装查看下图，@Data的实现，我们发现这个注解是应用在编译阶段的 这和我们大多数使用的注解，如 Spring 的注解（在运行时，通过反射来实现业务逻辑）是有很大差别的，如Spring 的@RestController 注解 一个更直接的体现就是，普通的包在引用之后一般的 IDE 都能够自动识别语法，但是 Lombok 的这些注解，一般的 IDE 都无法自动识别，因此如果要使用 Lombok 的话还需要配合安装相应的插件来支持 IDE 的编译，防止IDE 的自动检查报错，下面以 IntelliJ IDEA 举例安装插件。 在Repositories中搜索Lombok，安装后重启IDE即可 在Maven或Gradle工程中添加依赖 至此我们就可以应用 Lombok 提供的注解干些事情了。 Lombok注解详解Lombok官网提供了许多注解，但是 “劲酒虽好，可不要贪杯哦”，接下来逐一讲解官网推荐使用的注解(有些注解和原有Java编写方式没太大差别的也没有在此处列举，如@ Synchronized等) @Getter和@Setter该注解可应用在类或成员变量之上，和我们预想的一样，@Getter 和 @Setter 就是为成员变量自动生成 get 和 set 方法，默认生成访问权限为 public 方法，当然我们也可以指定访问权限 protected 等，如下图： 成员变量name指定生成set方法，并且访问权限为protected；boolean类型的成员变量 female 只生成get方法，并修改方法名称为 isFemale()。当把该注解应用在类上，默认为所有非静态成员变量生成 get 和 set 方法，也可以通过 AccessLevel.NONE 手动禁止生成get或set方法，如下图： @ToString该注解需应用在类上，为我们生成 Object 的 toString 方法，而该注解里面的几个属性能更加丰富我们想要的内容, exclude 属性禁止在 toString 方法中使用某字段，而of属性可以指定需要使用的字段，如下图： 查看编译后的Employee.class得到我们预期的结果，如下图 @EqualsAndHashCode该注解需应用在类上，使用该注解，lombok会为我们生成 equals(Object other) 和 hashcode() 方法，包括所有非静态属性和非transient的属性，同样该注解也可以通过 exclude 属性排除某些字段，of 属性指定某些字段，也可以通过 callSuper 属性在重写的方法中使用父类的字段，这样我们可以更灵活的定义bean的比对，如下图： 查看编译后的Employee.class文件，如下图： @NonNull该注解需应用在方法或构造器的参数上或属性上，用来判断参数的合法性，默认抛出 NullPointerException 异常 查看NonNullExample.class文件，会为我们抛出空指针异常，如下图： 当然我们可以通过指定异常类型抛出其他异常，lombok.nonNull.exceptionType = [NullPointerException | IllegalArgumentException] , 为实现此功能我们需要在项目的根目录新建lombok.config文件： 重新编译NonNullExample类，已经为我们抛出非法参数异常： @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor以上三个注解分别为我们生成无参构造器，指定参数构造器和包含所有参数的构造器，默认情况下，@RequiredArgsConstructor, @AllArgsConstructor 生成的构造器会对所有标记 @NonNull 的属性做非空校验。 无参构造器很好理解，我们主要看看后两种，先看 @RequiredArgsConstructor 从上图中我们可以看出， @RequiredArgsConstructor 注解生成有参数构造器时只会包含有 final 和 @NonNull 标识的 field，同时我们可以指定 staticName 通过生成静态方法来构造对象 查看Employee.class文件 当我们把 staticName 属性去掉我们来看遍以后的文件: 相信你已经注意到细节 @AllArgsConstructor 就更简单了，请大家自行查看吧 @Data介绍了以上的注解，再来介绍 @Data 就非常容易懂了，@Data 注解应用在类上，是@ToString, @EqualsAndHashCode, @Getter / @Setter 和 @RequiredArgsConstructor合力的体现，如下图： @Builder函数式编程或者说流式的操作越来越流行，应用在大多数语言中，让程序更具更简介，可读性更高，编写更连贯，@Builder就带来了这个功能，生成一系列的builder API，该注解也需要应用在类上，看下面的例子就会更加清晰明了。 编译后的Employee.class文件如下： 妈妈再也不用担心我 set 值那么麻烦了，流式操作搞定： @Log该注解需要应用到类上，在编写服务层，需要添加一些日志，以便定位问题，我们通常会定义一个静态常量Logger，然后应用到我们想日志的地方，现在一个注解就可以实现： 查看class文件，和我们预想的一样： Log有很多变种，CommonLog，Log4j，Log4j2，Slf4j等，lombok依旧良好的通过变种注解做良好的支持： 我实际使用的是 @Slf4j 注解 val熟悉 Javascript 的同学都知道，var 可以定义任何类型的变量，而在 java 的实现中我们需要指定具体变量的类型，而 val 让我们摆脱指定，编译之后就精准匹配上类型，默认是 final 类型，就像 java8 的函数式表达式，()-&gt;System.out.println(“hello lombok”); 就可以解析到Runnable函数式接口。 查看解析后的class文件： @Cleanup当我们对流进行操作，我们通常需要调用 close 方法来关闭或结束某资源，而 @Cleanup 注解可以帮助我们调用 close 方法，并且放到 try/finally 处理块中，如下图： 编译后的class文件如下，我们发现被try/finally包围处理，并调用了流的close方法 其实在 JDK1.7 之后就有了 try-with-resource，不用我们显式的关闭流，这个请大家自行看吧 总结Lombok的基本操作流程是这样的： 定义编译期的注解 利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器 利用tools.jar的javac api处理AST(抽象语法树) 将功能注册进jar包 Lombok 当然还有很多注解，我推荐使用以上就足够了，这个工具是带来便利的，而不能被其捆绑，“弱水三千只取一瓢饮，代码千万需抓重点看”，Lombok 能让我更加专注有效代码排除意义微小的障眼代码（get，set等），另外Lombok生成的代码还能像使用工具类一样方便（@Builder）。 更多内容请查看官网：https://www.projectlombok.org/ 灵魂追问 为什么只有一个整体 @EqualsAndHashCode 注解？而不是 @Equals 和 @HashCode？这涉及到一个规范哦 如果把三种构造器方式同时应用又加上了 @Builder 注解，会发生什么？ 你的灯还亮着吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"https://dayarch.top/tags/Lombok/"}]},{"title":"SDKMAN 统一灵活管理多版本Java","slug":"多版本Java统一灵活管理","date":"2019-11-14T00:51:02.000Z","updated":"2019-11-14T01:24:50.504Z","comments":true,"path":"/p/multiple-java-management.html","link":"","permalink":"https://dayarch.top/p/multiple-java-management.html","excerpt":"近两年，Java 版本升级频繁，感觉刚刚掌握 Java8，写本文时，已听到 java14 的消息，无论是尝鲜新特性(Java12 中超级香的一个功能)，还是由于项目升级/兼容需要，我们可能都要面临管理多个 Java 版本的情 另外 Oracle 自 Java11 开始，更改了用户协议，任何商用都会收费。在写本文时，得到消息「微软宣布加入 OpenJDK」，打不过就选择 OpenJDK。随便 G 一下，当个故事了解就可以 配置单个 Java 环境变量本身没什么技术含量可言，但当需要管理多个 Java 版本，重复配置环境变量显然是非常枯燥的，按照传统的配置方式我们又不能灵活的切换 Java 版","text":"近两年，Java 版本升级频繁，感觉刚刚掌握 Java8，写本文时，已听到 java14 的消息，无论是尝鲜新特性(Java12 中超级香的一个功能)，还是由于项目升级/兼容需要，我们可能都要面临管理多个 Java 版本的情 另外 Oracle 自 Java11 开始，更改了用户协议，任何商用都会收费。在写本文时，得到消息「微软宣布加入 OpenJDK」，打不过就选择 OpenJDK。随便 G 一下，当个故事了解就可以 配置单个 Java 环境变量本身没什么技术含量可言，但当需要管理多个 Java 版本，重复配置环境变量显然是非常枯燥的，按照传统的配置方式我们又不能灵活的切换 Java 版本 那要如何轻松管理与使用多个版本 Java？ 多版本 Java 管理显然我们不是第一个有这种困境的人，我所知道的现有方案有三种: Jabba jenv sdkman 本文主要说明如何通过 sdkman 打破我们面临的困境，帮助我们灵活配置与使用 Java sdkman 介绍SDKMAN 是一个用于在大多数基于 Unix 系统上管理 多个软件开发工具包 (Java, Groovy, Scala, Kotlin and Ceylon. Ant, Gradle 等) 的并行版本的工具 。 它提供了一个方便的命令行接口 (CLI) 和 API，用于安装、切换、删除和列出候选对象。本文主要通过管理 Java 来说明 sdkman 的使用 sdkman 安装在类 unix 平台上安装 sdkman 非常容易。它可以顺利的安装在Mac OSX、Linux、WLS、Cygwin、Solaris和FreeBSD 上，同时还支持Bash和 ZSH shell。 只需打开一个新终端机并输入: 1$ curl -s \"https://get.sdkman.io\" | bash 按照相应的指令提示，完成相应的操作后继续输入: 1$ source \"$HOME/.sdkman/bin/sdkman-init.sh\" 到这里我们就可以验证 sdk 的安装版本了: 1$ sdk version 上图红色框标记显示我当前 sdkman 的版本，每次执行 sdk version 命令时，都会检查是否会有新版本，如果要更新输入 y 就可以 有些系统发行版本不包含 zip 和 unzip，如果安装时遇到相关错误，可以输入如下命令安装 zip 和 unzip 1$ sudo apt-get install zip unzip 从上面的安装命令上可以看出，sdkman 默认的安装路径是在$HOME/.sdkman 下，我们也可以自定义安装路径，只需要指定 SDKMAN_DIR 变量值就好了: 1$ export SDKMAN_DIR=\"/usr/local/sdkman\" &amp;&amp; curl -s \"https://get.sdkman.io\" | bash 到这里 sdkman 的安装就结束了，我们来看看如何使用 sdkman 使用教程命令行下学习一个新玩意当然是查看它的 help 命令，输入: 1$ sdkman help 感觉上图按颜色区分内容后，sdkman 的使用说明也就结束了，我们按照上面的图来详细说明一下使用教程 sdk list先来输入: 1$ sdk list 绿色的标记就是 sdkman 集成的所有可用的 candidate，通过按回车「enter」按键，会看到更多可用 candidate 我们指定 candidate，输入: 1$ sdk list java 从上图中可以看到所有 java 可用的版本 version，以及标识 indentifier，以及状态 status，我已经安装了 java 12 和 11 有了这些信息做铺垫，我们可以安装任意 sdkman 内置的软件开发包了，继续以 java 为例 sdk install回看 sdkman help 命令的输出，使用 install 命令，我们再安装一个 Java 最新 13.0.1.j9 版本 从上图你可以看出，绿色标记的内容是 list 命令结果中的 version 值，但是报错不可用，输入indentifier 编号才能正常下载，这里需要注意 安装完后，status 就会编程 installed 状态 sdk current当安装多个版本的 java 时，我们输入下面命令获取当前正在用 candidate 的版本 1$ sdk current java sdk use了解了当前使用版本，如果我们想切换到其他版本, 可以输入: 1$ sdk use java 12.0.2.j9-adpt 注意⚠️: 这里同样是指定的 indentifier 的值 sdk default如果我们想指定某个版本为默认版本，可以输入: 1$ sdk default java jdk1.8.0_162.jdk 注意⚠️: 这里同样是指定的 indentifier 的值 sdk uninstall当我们想卸载某个版本可以输入: 1$ sdk uninstall java 12.0.2.j9-adpt 注意⚠️: 这里同样是指定的 indentifier 的值 sdk upgrade如果我们想升级某个 candidate，可以输入: 1$ sdk upgrade java sdk flush使用 sdkman 时间变长也会慢慢产生很多缓存内容，我们可以输入清理广播消息: 1$ sdk flush broadcast 清理下载的 sdk 二进制文件(长时间使用后清理，可以节省出很多空间): 1$ sdk flush archives 清理临时文件内容: 1$ sdk flush temp 到这里 sdkman 的基本使用就已经介绍完了，其实这些命令都不用急，想不起来的时候执行 sdk help 来临时查看一下就好 sdkman 卸载如果我们不喜欢 sdkman 了，我们也可以轻松的卸载掉它: 12$ tar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman$ rm -rf ~/.sdkman 最后打开你的 .bashrc、.bash_profile 和/或者 .profile，找到并删除下面这几行。 12#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!![[ -s \"/home/dudette/.sdkman/bin/sdkman-init.sh\" ]] &amp;&amp; source \"/home/dudette/.sdkman/bin/sdkman-init.sh\" 我用的 zshrc，找到 .zshrc 文件删除掉上面内容即可 到这里基于 Unix 系统的，有关 sdkman 的安装，使用及下载都已经介绍完了，可以上手试一试了，相信很多小伙伴用的是 Windows，除了 jenv， sdkman 和 Jabba 都有 windows 用户的解决方案: sdkman windows 解决方案在 sdkman 官网首页同样为 windows 用户提供了解决方案，小伙伴们找到如下位置查看即可 我看了一下过程，也是很简单，由于手头没有 windows 电脑，这个请小伙伴们自行尝试吧，有问题欢迎留言 灵魂追问 你现在用的 Java 版本是多少？ 有跟随新版本尝试更多新特性吗？ 你的灯还亮着吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://dayarch.top/tags/JDK/"}]},{"title":"HttpMessageConverter转换原理解析","slug":"HttpMessageConverter转换原理解析","date":"2019-11-07T10:15:50.000Z","updated":"2019-11-08T09:01:22.470Z","comments":true,"path":"/p/spring-boot-messageconverter.html","link":"","permalink":"https://dayarch.top/p/spring-boot-messageconverter.html","excerpt":"Java Web 人员经常要设计 RESTful API（如何设计好的RESTful API），通过 json 数据进行交互。那么前端传入的 json 数据如何被解析成 Java 对象作为 API入参，API 返回结果又如何将 Java 对象解析成 json 格式数据返回给前端，其实在整个数据流转过程中，HttpMessageConverter 起到了重要作用；另外在转换的过程我们可以加入哪些定制化内容？ HttpMessageConverter 介绍 org.springframework.http.converter.HttpMessageConverter 是一个策略接口，接口说明如下","text":"Java Web 人员经常要设计 RESTful API（如何设计好的RESTful API），通过 json 数据进行交互。那么前端传入的 json 数据如何被解析成 Java 对象作为 API入参，API 返回结果又如何将 Java 对象解析成 json 格式数据返回给前端，其实在整个数据流转过程中，HttpMessageConverter 起到了重要作用；另外在转换的过程我们可以加入哪些定制化内容？ HttpMessageConverter 介绍org.springframework.http.converter.HttpMessageConverter 是一个策略接口，接口说明如下： Strategy interface that specifies a converter that can convert from and to HTTP requests and responses. 简单说就是 HTTP request (请求)和response (响应)的转换器。该接口有只有5个方法，简单来说就是获取支持的 MediaType（application/json之类），接收到请求时判断是否能读（canRead），能读则读（read）；返回结果时判断是否能写（canWrite），能写则写（write）。这几个方法先有个印象即可： 12345boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType);boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType);List&lt;MediaType&gt; getSupportedMediaTypes();T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;void write(T t, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException; 缺省配置我们写 Demo 没有配置任何 MessageConverter，但是数据前后传递依旧好用，是因为 SpringMVC 启动时会自动配置一些HttpMessageConverter，在 WebMvcConfigurationSupport 类中添加了缺省 MessageConverter： 12345678910111213141516171819202122232425262728293031protected final void addDefaultHttpMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) &#123; StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(); stringConverter.setWriteAcceptCharset(false); messageConverters.add(new ByteArrayHttpMessageConverter()); messageConverters.add(stringConverter); messageConverters.add(new ResourceHttpMessageConverter()); messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;()); messageConverters.add(new AllEncompassingFormHttpMessageConverter()); if (romePresent) &#123; messageConverters.add(new AtomFeedHttpMessageConverter()); messageConverters.add(new RssChannelHttpMessageConverter()); &#125; if (jackson2XmlPresent) &#123; ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.xml().applicationContext(this.applicationContext).build(); messageConverters.add(new MappingJackson2XmlHttpMessageConverter(objectMapper)); &#125; else if (jaxb2Present) &#123; messageConverters.add(new Jaxb2RootElementHttpMessageConverter()); &#125; if (jackson2Present) &#123; ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json().applicationContext(this.applicationContext).build(); messageConverters.add(new MappingJackson2HttpMessageConverter(objectMapper)); &#125; else if (gsonPresent) &#123; messageConverters.add(new GsonHttpMessageConverter()); &#125; &#125; 我们看到很熟悉的 MappingJackson2HttpMessageConverter ，如果我们引入 jackson 相关包，Spring 就会为我们添加该 MessageConverter，但是我们通常在搭建框架的时候还是会手动添加配置 MappingJackson2HttpMessageConverter，为什么？ 先思考一下： 当我们配置了自己的 MessageConverter， SpringMVC 启动过程就不会调用 addDefaultHttpMessageConverters 方法，且看下面代码 if 条件，这样做也是为了定制化我们自己的 MessageConverter 1234567891011protected final List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; if (this.messageConverters == null) &#123; this.messageConverters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(); configureMessageConverters(this.messageConverters); if (this.messageConverters.isEmpty()) &#123; addDefaultHttpMessageConverters(this.messageConverters); &#125; extendMessageConverters(this.messageConverters); &#125; return this.messageConverters; &#125; 类关系图在此处仅列出 MappingJackson2HttpMessageConverter 和 StringHttpMessageConverter 两个转换器，我们发现， 前者实现了 GenericHttpMessageConverter 接口, 而后者却没有，留有这个关键印象，这是数据流转过程中关键逻辑判断 数据流转解析数据的请求和响应都要经过 DispatcherServlet 类的 doDispatch(HttpServletRequest request, HttpServletResponse response) 方法的处理 请求过程解析看 doDispatch 方法中的关键代码： 1234567// 这里的 Adapter 实际上是 RequestMappingHandlerAdapterHandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;// 实际处理的handlermv = ha.handle(processedRequest, response, mappedHandler.getHandler()); mappedHandler.applyPostHandle(processedRequest, response, mv); 从进入handle之后我先将调用栈粘贴在此处，希望小伙伴可以按照调用栈路线动手跟踪尝试： 123456789101112readWithMessageConverters:192, AbstractMessageConverterMethodArgumentResolver (org.springframework.web.servlet.mvc.method.annotation)readWithMessageConverters:150, RequestResponseBodyMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)resolveArgument:128, RequestResponseBodyMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)resolveArgument:121, HandlerMethodArgumentResolverComposite (org.springframework.web.method.support)getMethodArgumentValues:158, InvocableHandlerMethod (org.springframework.web.method.support)invokeForRequest:128, InvocableHandlerMethod (org.springframework.web.method.support) // 下面的调用栈重点关注，处理请求和返回值的分叉口就在这里invokeAndHandle:97, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation)invokeHandlerMethod:849, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)handleInternal:760, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)handle:85, AbstractHandlerMethodAdapter (org.springframework.web.servlet.mvc.method)doDispatch:967, DispatcherServlet (org.springframework.web.servlet) 这里重点说明调用栈最顶层 readWithMessageConverters 方法中内容： 1234567891011121314151617181920212223242526272829303132333435363738// 遍历 messageConvertersfor (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123; Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(); // 上文类关系图处要重点记住的地方，主要判断 MappingJackson2HttpMessageConverter 是否是 GenericHttpMessageConverter 类型 if (converter instanceof GenericHttpMessageConverter) &#123; GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter; if (genericConverter.canRead(targetType, contextClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = genericConverter.read(targetType, contextClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125; else if (targetClass != null) &#123; if (converter.canRead(targetClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125;&#125; 然后就判断是否canRead，能读就read，最终走到下面代码处将输入的内容反序列化出来： 1234567891011121314151617181920212223242526272829protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException &#123; try (JsonParser p = p0) &#123; Object result; JsonToken t = _initForReading(p); if (t == JsonToken.VALUE_NULL) &#123; // Ask JsonDeserializer what 'null value' to use: DeserializationContext ctxt = createDeserializationContext(p, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); &#125; else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) &#123; result = null; &#125; else &#123; DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(p, cfg); JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) &#123; result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser); &#125; else &#123; result = deser.deserialize(p, ctxt); &#125; ctxt.checkUnresolvedObjectId(); &#125; // Need to consume the token too p.clearCurrentToken(); return result; &#125; &#125; 到这里从请求中解析参数过程就到此结束了，趁热打铁来看将响应结果返回给前端的过程 返回过程解析在上面调用栈请求和返回结果分叉口处同样处理返回的内容： 12345writeWithMessageConverters:224, AbstractMessageConverterMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)handleReturnValue:174, RequestResponseBodyMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)handleReturnValue:81, HandlerMethodReturnValueHandlerComposite (org.springframework.web.method.support)// 分叉口invokeAndHandle:113, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation) 重点关注调用栈顶层内容，是不是很熟悉的样子，完全一样的逻辑, 判断是否能写canWrite，能写则write： 12345678910111213141516171819202122232425262728293031323334for (HttpMessageConverter&lt;?&gt; messageConverter : this.messageConverters) &#123; if (messageConverter instanceof GenericHttpMessageConverter) &#123; if (((GenericHttpMessageConverter) messageConverter).canWrite( declaredType, valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); if (outputValue != null) &#123; addContentDispositionHeader(inputMessage, outputMessage); ((GenericHttpMessageConverter) messageConverter).write( outputValue, declaredType, selectedMediaType, outputMessage); if (logger.isDebugEnabled()) &#123; logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\"); &#125; &#125; return; &#125; &#125; else if (messageConverter.canWrite(valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); if (outputValue != null) &#123; addContentDispositionHeader(inputMessage, outputMessage); ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage); if (logger.isDebugEnabled()) &#123; logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\"); &#125; &#125; return; &#125;&#125; 我们看到有这样一行代码： 123outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); 我们在设计 RESTful API 接口的时候通常会将返回的数据封装成统一格式，通常我们会实现 ResponseBodyAdvice 接口来处理所有 API 的返回值，在真正 write 之前将数据进行统一的封装 12345678910111213141516171819@RestControllerAdvice()public class CommonResultResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123; @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return true; &#125; @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (body instanceof CommonResult) &#123; return body; &#125; return new CommonResult&lt;Object&gt;(body); &#125;&#125; 整个处理流程就是这样，整个实现过程细节还需小伙伴自行追踪发现，文章开头我们说过 添加自己的 MessageConverter 能更好的满足我们的定制化，都有哪些可以定制的呢？ 定制化空值处理请求和返回的数据有很多空值，这些值有时候并没有实际意义，我们可以过滤掉和不返回，或设置成默认值。比如通过重写 getObjectMapper 方法，将返回结果的空值不进行序列化： 1234567converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); return super.getObjectMapper(); &#125;&#125; XSS 脚本攻击为了保证输入的数据更安全，防止 XSS 脚本攻击，我们可以添加自定义反序列化器： 1234567891011121314//对应无法直接返回String类型converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); // XSS 脚本过滤 SimpleModule simpleModule = new SimpleModule(); simpleModule.addDeserializer(String.class, new StringXssDeserializer()); super.getObjectMapper().registerModule(simpleModule); return super.getObjectMapper(); &#125;&#125; 细节分析canRead 和 canWrite 的判断逻辑是什么呢？ 请看下图： 客户端 Request Header 中设置好 Content-Type（传入的数据格式）和Accept（接收的数据格式），根据配置好的MessageConverter来判断是否 canRead 或 canWrite，然后决定 response.body 的 Content-Type 的第一要素是对应的request.headers.Accept 属性的值，又叫做 MediaType。如果服务端支持这个 Accept，那么应该按照这个 Accept 来确定返回response.body 对应的格式，同时把 response.headers.Content-Type 设置成自己支持的符合那个 Accept 的 MediaType 总结与思考站在上帝视角看，整个流程可以按照下图进行概括，请求报文先转换成 HttpInputMessage, 然后再通过 HttpMessageConverter 将其转换成 SpringMVC 的 java 对象，反之亦然。 将各种常用 HttpMessageConverter 支持的MediaType 和 JavaType 以及对应关系总结在此处： 类名 支持的JavaType 支持的MediaType ByteArrayHttpMessageConverter byte[] application/octet-stream, */* StringHttpMessageConverter String text/plain, */* MappingJackson2HttpMessageConverter Object application/json, application/*+json AllEncompassingFormHttpMessageConverter Map&lt;K, List&lt;?&gt;&gt; application/x-www-form-urlencoded, multipart/form-data SourceHttpMessageConverter Source application/xml, text/xml, application/*+xml 最后思考这样一个问题：为什么 HttpMessageConverter 在写的过程中，先判断 canWrite 后判断是否有 responseBodyAdvice 的数据封装呢？ 如果先进行 responseBodyAdvice 的数据封装后判断 canWrite 会怎样呢？ 提高效率工具依旧介绍写该文章用到的一些好的工具 processonProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作，同时您可以把作品分享给团队成员或好友，无论何时何地大家都可以对作品进行编辑、阅读和评论 SequenceDiagramSequenceDiagram 是 IntelliJ IDEA 的一个插件，有了这个插件，你可以 生成简单序列图。 单击图形形状来导航代码。 从图中删除类。 将图表导出为图像。 通过“设置”&gt;“其他设置”&gt;“序列”从图表中排除类 方便快速的定位方法和理解类的调用过程","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"HTTP","slug":"HTTP","permalink":"https://dayarch.top/tags/HTTP/"},{"name":"MessageConverter","slug":"MessageConverter","permalink":"https://dayarch.top/tags/MessageConverter/"}]},{"title":"Java12 Collectors.teeing 的使用详解","slug":"Java12-Collectors-teeing-的使用详解","date":"2019-11-05T08:43:32.000Z","updated":"2019-11-07T06:36:13.203Z","comments":true,"path":"/p/jdk12-collectors-teeing-api-usage.html","link":"","permalink":"https://dayarch.top/p/jdk12-collectors-teeing-api-usage.html","excerpt":"前言 在 Java 12 里面有个非常好用但在官方 JEP 没有公布的功能，因为它只是 Collector 中的一个小改动，它的作用是 merge 两个 collector 的结果，这句话显得很抽象，老规矩，我们先来看个图: 管道改造经常会用这个小东西，通常我们叫它「三通」，它的主要作用就是将 downstream1 和 downstream2 的流入合并，然后从 merger 流出 有了这个形象的说明我们就进入正题吧 Collectors.teeing 上面提到的小功能就是 Collectors.teeing API, 先来看一下 JDK 关于该 API 的说明，看着觉得难受的直接忽","text":"前言在 Java 12 里面有个非常好用但在官方 JEP 没有公布的功能，因为它只是 Collector 中的一个小改动，它的作用是 merge 两个 collector 的结果，这句话显得很抽象，老规矩，我们先来看个图: 管道改造经常会用这个小东西，通常我们叫它「三通」，它的主要作用就是将 downstream1 和 downstream2 的流入合并，然后从 merger 流出 有了这个形象的说明我们就进入正题吧 Collectors.teeing上面提到的小功能就是 Collectors.teeing API, 先来看一下 JDK 关于该 API 的说明，看着觉得难受的直接忽略，继续向下看例子就好了: 1234567891011121314151617181920212223242526272829303132333435363738/** * Returns a &#123;@code Collector&#125; that is a composite of two downstream collectors. * Every element passed to the resulting collector is processed by both downstream * collectors, then their results are merged using the specified merge function * into the final result. * * &lt;p&gt;The resulting collector functions do the following: * * &lt;ul&gt; * &lt;li&gt;supplier: creates a result container that contains result containers * obtained by calling each collector's supplier * &lt;li&gt;accumulator: calls each collector's accumulator with its result container * and the input element * &lt;li&gt;combiner: calls each collector's combiner with two result containers * &lt;li&gt;finisher: calls each collector's finisher with its result container, * then calls the supplied merger and returns its result. * &lt;/ul&gt; * * &lt;p&gt;The resulting collector is &#123;@link Collector.Characteristics#UNORDERED&#125; if both downstream * collectors are unordered and &#123;@link Collector.Characteristics#CONCURRENT&#125; if both downstream * collectors are concurrent. * * @param &lt;T&gt; the type of the input elements * @param &lt;R1&gt; the result type of the first collector * @param &lt;R2&gt; the result type of the second collector * @param &lt;R&gt; the final result type * @param downstream1 the first downstream collector * @param downstream2 the second downstream collector * @param merger the function which merges two results into the single one * @return a &#123;@code Collector&#125; which aggregates the results of two supplied collectors. * @since 12 */public static &lt;T, R1, R2, R&gt;Collector&lt;T, ?, R&gt; teeing(Collector&lt;? super T, ?, R1&gt; downstream1, Collector&lt;? super T, ?, R2&gt; downstream2, BiFunction&lt;? super R1, ? super R2, R&gt; merger) &#123; return teeing0(downstream1, downstream2, merger);&#125; API 描述重的一句话非常关键: Every element passed to the resulting collector is processed by both downstream collectors 结合「三通图」来说明就是，集合中每一个要被传入 merger 的元素都会经过 downstream1 和 downstream2 的加工处理 其中 merger 类型是 BiFunction，也就是说接收两个参数，并输出一个值，请看它的 apply 方法 123456789101112@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123; /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u);&#125; 至于可以如何处理，我们来看一些例子吧 例子为了更好的说明 teeing 的使用，列举了四个例子，看过这四个例子再回看上面的 API 说明，相信你会柳暗花明了 计数和累加先来看一个经典的问题，给定的数字集合，需要映射整数流中的元素数量和它们的和 12345678910111213141516class CountSum &#123; private final Long count; private final Integer sum; public CountSum(Long count, Integer sum) &#123; this.count = count; this.sum = sum; &#125; @Override public String toString() &#123; return \"CountSum&#123;\" + \"count=\" + count + \", sum=\" + sum + '&#125;'; &#125;&#125; 通过 Collectors.teeing 处理 1234567CountSum countsum = Stream.of(2, 11, 1, 5, 7, 8, 12) .collect(Collectors.teeing( counting(), summingInt(e -&gt; e), CountSum::new));System.out.println(countsum.toString()); downstream1 通过 Collectors 的静态方法 counting 进行集合计数 downstream2 通过 Collectors 的静态方法 summingInt 进行集合元素值的累加 merger 通过 CountSum 构造器收集结果 运行结果: CountSum{count=7, sum=46} 我们通过 teeing 一次性得到我们想要的结果，继续向下看其他例子: 最大值与最小值通过给定的集合， 一次性计算出集合的最大值与最小值，同样新建一个类 MinMax，并创建构造器用于 merger 收集结果 12345678910111213141516class MinMax &#123; private final Integer min; private final Integer max; public MinMax(Integer min, Integer max) &#123; this.min = min; this.max = max; &#125; @Override public String toString() &#123; return \"MinMax&#123;\" + \"min=\" + min + \", max=\" + max + '&#125;'; &#125;&#125; 通过 teeing API 计算结果: 1234567MinMax minmax = Stream.of(2, 11, 1, 5, 7, 8, 12) .collect(Collectors.teeing( minBy(Comparator.naturalOrder()), maxBy(Comparator.naturalOrder()), (Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) -&gt; new MinMax(a.orElse(Integer.MIN_VALUE), b.orElse(Integer.MAX_VALUE))));System.out.println(minmax.toString()); downstream1 通过 Collectors 的静态方法 minBy，通过 Comparator 比较器按照自然排序找到最小值 downstream2 通过 Collectors 的静态方法 maxBy，通过 Comparator 比较器按照自然排序找到最大值 merger 通过 MinMax 构造器收集结果，只不过为了应对 NPE，将 BiFunction 的两个入参经过 Optional 处理 运行结果: MinMax{min=1, max=12} 为了验证一下 Optional，我们将集合中添加一个 null 元素，并修改一下排序规则来看一下排序结果: 12345MinMax minmax = Stream.of(null, 2, 11, 1, 5, 7, 8, 12) .collect(Collectors.teeing( minBy(Comparator.nullsFirst(Comparator.naturalOrder())), maxBy(Comparator.nullsLast(Comparator.naturalOrder())), (Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) -&gt; new MinMax(a.orElse(Integer.MIN_VALUE), b.orElse(Integer.MAX_VALUE)))); downstream1 处理规则是将 null 放在排序的最前面 downstream2 处理规则是将 null 放在排序的最后面 merger 处理时，都会执行 optional.orElse 方法，分别输出最小值与最大值 运行结果: MinMax{min=-2147483648, max=2147483647} 瓜的总重和单个重量接下来举一个更贴合实际的操作对象的例子 1234567891011121314151617181920212223242526272829303132333435// 定义瓜的类型和重量class Melon &#123; private final String type; private final int weight; public Melon(String type, int weight) &#123; this.type = type; this.weight = weight; &#125; public String getType() &#123; return type; &#125; public int getWeight() &#123; return weight; &#125;&#125;// 总重和单个重量列表class WeightsAndTotal &#123; private final int totalWeight; private final List&lt;Integer&gt; weights; public WeightsAndTotal(int totalWeight, List&lt;Integer&gt; weights) &#123; this.totalWeight = totalWeight; this.weights = weights; &#125; @Override public String toString() &#123; return \"WeightsAndTotal&#123;\" + \"totalWeight=\" + totalWeight + \", weights=\" + weights + '&#125;'; &#125;&#125; 通过 teeing API 计算总重量和单个列表重量 123456789101112131415List&lt;Melon&gt; melons = Arrays.asList(new Melon(\"Crenshaw\", 1200), new Melon(\"Gac\", 3000), new Melon(\"Hemi\", 2600), new Melon(\"Hemi\", 1600), new Melon(\"Gac\", 1200), new Melon(\"Apollo\", 2600), new Melon(\"Horned\", 1700), new Melon(\"Gac\", 3000), new Melon(\"Hemi\", 2600));WeightsAndTotal weightsAndTotal = melons.stream() .collect(Collectors.teeing( summingInt(Melon::getWeight), mapping(m -&gt; m.getWeight(), toList()), WeightsAndTotal::new));System.out.println(weightsAndTotal.toString()); downstream1 通过 Collectors 的静态方法 summingInt 做重量累加 downstream2 通过 Collectors 的静态方法 mapping 提取出瓜的重量，并通过流的终结操作 toList() 获取结果 merger 通过 WeightsAndTotal 构造器获取结果 运行结果: WeightsAndTotal{totalWeight=19500, weights=[1200, 3000, 2600, 1600, 1200, 2600, 1700, 3000, 2600]} 继续一个更贴合实际的例子吧: 预约人员列表和预约人数12345678910111213141516171819202122232425262728293031323334353637383940class Guest &#123; private String name; private boolean participating; private Integer participantsNumber; public Guest(String name, boolean participating, Integer participantsNumber) &#123; this.name = name; this.participating = participating; this.participantsNumber = participantsNumber; &#125; public boolean isParticipating() &#123; return participating; &#125; public Integer getParticipantsNumber() &#123; return participantsNumber; &#125; public String getName() &#123; return name; &#125;&#125;class EventParticipation &#123; private List&lt;String&gt; guestNameList; private Integer totalNumberOfParticipants; public EventParticipation(List&lt;String&gt; guestNameList, Integer totalNumberOfParticipants) &#123; this.guestNameList = guestNameList; this.totalNumberOfParticipants = totalNumberOfParticipants; &#125; @Override public String toString() &#123; return \"EventParticipation &#123; \" + \"guests = \" + guestNameList + \", total number of participants = \" + totalNumberOfParticipants + \" &#125;\"; &#125;&#125; 通过 teeing API 处理 12345678910var result = Stream.of( new Guest(\"Marco\", true, 3), new Guest(\"David\", false, 2), new Guest(\"Roger\",true, 6)) .collect(Collectors.teeing( Collectors.filtering(Guest::isParticipating, Collectors.mapping(Guest::getName, Collectors.toList())), Collectors.summingInt(Guest::getParticipantsNumber), EventParticipation::new ));System.out.println(result); downstream1 通过 filtering 方法过滤出确定参加的人，并 mapping 出他们的姓名，最终放到 toList 集合中 downstream2 通过 summingInt 方法计数累加 merger 通过 EventParticipation 构造器收集结果 其中我们定义了 var result 来收集结果，并没有指定类型，这个语法糖也加速了我们编程的效率 运行结果: EventParticipation { guests = [Marco, Roger], total number of participants = 11 } 总结其实 teeing API 就是灵活应用 Collectors 里面定义的静态方法，将集合元素通过 downstream1 和 downstream2 进行处理，最终通过 merger 收集起来，当项目中有同时获取两个收集结果时，是时候应用我们的 teeing API 了 灵魂追问 Collectors 里面的静态方法你应用的熟练吗？ 项目中你们在用 JDK 的版本是多少？ Lambda 的使用熟练吗？ 你的灯还亮着吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"JDK源码","slug":"JDK源码","permalink":"https://dayarch.top/tags/JDK%E6%BA%90%E7%A0%81/"}]},{"title":"Java并发死锁解决思路","slug":"Java并发死锁解决思路","date":"2019-10-18T06:01:20.000Z","updated":"2019-12-31T03:09:05.244Z","comments":true,"path":"/p/java-concurrency-dead-lock.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-dead-lock.html","excerpt":"写在前面 上一篇文章共享资源那么多，如何用一把锁保护多个资源？ 文章我们谈到了银行转账经典案例，其中有两个问题: 1. 单纯的用 synchronized 方法起不到保护作用(不能保护 target) 2. 用 Account.class 锁方案，锁的粒度又过大，导致涉及到账户的所有操作(取款，转账，修改密码等)都会变成串行操作 如何解决这两个问题呢？咱们先换好衣服穿越回到过去寻找一下钱庄，一起透过现象看本质，dengdeng deng……. 来到钱庄，告诉柜员你要给铁蛋儿转 100 铜钱，这时柜员转身在墙上寻找你和铁蛋儿的账本，此时柜员可能面临三种情况: 1. 理想状态:","text":"写在前面上一篇文章共享资源那么多，如何用一把锁保护多个资源？ 文章我们谈到了银行转账经典案例，其中有两个问题: 单纯的用 synchronized 方法起不到保护作用(不能保护 target) 用 Account.class 锁方案，锁的粒度又过大，导致涉及到账户的所有操作(取款，转账，修改密码等)都会变成串行操作 如何解决这两个问题呢？咱们先换好衣服穿越回到过去寻找一下钱庄，一起透过现象看本质，dengdeng deng……. 来到钱庄，告诉柜员你要给铁蛋儿转 100 铜钱，这时柜员转身在墙上寻找你和铁蛋儿的账本，此时柜员可能面临三种情况: 理想状态: 你和铁蛋儿的账本都是空闲状态，一起拿回来，在你的账本上减 100 铜钱，在铁蛋儿账本上加 100 铜钱，柜员转身将账本挂回到墙上，完成你的业务 尴尬状态: 你的账本在，铁蛋儿的账本被其他柜员拿出去给别人转账，你要等待其他柜员把铁蛋儿的账本归还 抓狂状态: 你的账本不在，铁蛋儿的账本也不在，你只能等待两个账本都归还 放慢柜员的取账本操作，他一定是先拿到你的账本，然后再去拿铁蛋儿的账本，两个账本都拿到(理想状态)之后才能完成转账，用程序模型来描述一下这个拿取账本的过程: 我们继续用程序代码描述一下上面这个模型: 12345678910111213141516class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; // 锁定转出账户 synchronized(this) &#123; // 锁定转入账户 synchronized(target) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; &#125; 这个解决方案看起来很完美，解决了文章开头说的两个问题，但真是这样吗？ 我们刚刚说过的理想状态是钱庄只有一个柜员(既单线程)。随着钱庄规模变大，墙上早已挂了非常多个账本，钱庄为了应对繁忙的业务，开通了多个窗口，此时有多个柜员(多线程)处理钱庄业务。 柜员 1 正在办理给铁蛋儿转账的业务，但只拿到了你的账本；柜员 2 正在办理铁蛋儿给你转账的业务，但只拿到了铁蛋儿的账本，此时双方出现了尴尬状态，两位柜员都在等待对方归还账本为当前客户办理转账业务。 现实中柜员会沟通，喊出一嗓子 老铁，铁蛋儿的账本先给我用一下，用完还给你，但程序却没这么智能，synchronized 内置锁非常执着，它会告诉你「死等」的道理，最终出现死锁 Java 有了 synchronized 内置锁，还发明了显示锁 Lock，是不是就为了治一治 synchronized 「死等」的执着呢？😏 解决方案如何解决上面的问题呢？正所谓知己知彼方能百战不殆，我们要先了解什么情况会发生死锁，才能知道如何避免死锁，很幸运我们可以站在巨人的肩膀上看待问题 Coffman 总结出了四个条件说明可以发生死锁的情形: Coffman 条件互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不可剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P1，P2，···，Pn}中的 P1 正在等待一个 P2 占用的资源；P2 正在等待 P3 占用的资源，……，Pn 正在等待已被 P0 占用的资源。 这几个条件很好理解，其中「互斥条件」是并发编程的根基，这个条件没办法改变。但其他三个条件都有改变的可能，也就是说破坏另外三个条件就不会出现上面说到的死锁问题 破坏请求和保持条件每个柜员都可以取放账本，很容易出现互相等待的情况。要想破坏请求和保持条件，就要一次性拿到所有资源。 作为程序猿你一定听过这句话: 任何软件工程遇到的问题都可以通过增加一个中间层来解决 我们不允许柜员都可以取放账本，账本要由单独的账本管理员来管理 也就是说账本管理员拿取账本是临界区，如果只拿到其中之一的账本，那么不会给柜员，而是等待柜员下一次询问是否两个账本都在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Account &#123; //单例的账本管理员 private AccountBookManager accountBookManager; private int balance; public void transfer(Account target, int amt)&#123; // 一次性申请转出账户和转入账户，直到成功 while(accountBookManager.getAllRequiredAccountBook(this, target)); try&#123; // 锁定转出账户 synchronized(this)&#123; // 锁定转入账户 synchronized(target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; finally &#123; accountBookManager.releaseObtainedAccountBook(this, target); &#125; &#125;&#125;public class AccountBookManager &#123; List&lt;Object&gt; accounts = new ArrayList&lt;&gt;(2); synchronized boolean getAllRequiredAccountBook( Object from, Object to)&#123; if(accounts.contains(from) || accounts.contains(to))&#123; return false; &#125; else&#123; accounts.add(from); accounts.add(to); return true; &#125; &#125; // 归还资源 synchronized void releaseObtainedAccountBook(Object from, Object to)&#123; accounts.remove(from); accounts.remove(to); &#125;&#125; 破坏不可剥夺条件上面已经给了你小小的提示，为了解决内置锁的执着，Java 显示锁支持通知(notify/notifyall)和等待(wait)，也就是说该功能可以实现喊一嗓子 老铁，铁蛋儿的账本先给我用一下，用完还给你 的功能，这个后续将到 Java SDK 相关内容时会做说明 破坏环路等待条件破坏环路等待条件也很简单，我们只需要将资源序号大小排序获取就会解决这个问题，将环路拆除 继续用代码来说明: 123456789101112131415161718192021222324class Account &#123; private int id; private int balance; // 转账 void transfer(Account target, int amt)&#123; Account smaller = this Account larger = target; // 排序 if (this.id &gt; target.id) &#123; smaller = target; larger = this; &#125; // 锁定序号小的账户 synchronized(smaller)&#123; // 锁定序号大的账户 synchronized(larger)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; &#125; 当 smaller 被占用时，其他线程就会被阻塞，也就不会存在死锁了. 附加说明在实际业务中，关于 Account 都会是数据库对象，我们可以通过事务或数据库的乐观锁来解决的。另外分布式系统中，账本管理员这个角色的处理也可能会用 redis 分布式锁来解决. 在处理破坏请求和保持条件时，我们使用的是 while 循环方式来不断请求锁的时候，在实际业务中，我们会有 timeout 的设置，防止无休止的浪费 CPU 使用率 另外大家可以尝试使用阿里开源工具 Arthas 来查看 CPU 使用率，线程等相关问题，github 上有明确的说明 总结计算机的计算能力远远超过人类，但是他的智慧还需要有带提高，当看待并发问题时，我们往往认为人类的最基本沟通计算机也可以做到，其实不然，还是那句话，编写并发程序，要站在计算机的角度来看待问题 粗粒度锁我们不提倡，所以会使用细粒度锁，但使用细粒度锁的时候，我们要严格按照 Coffman 的四大条件来逐条判断，这样再应用我们这几个解决方案来解决就好了 灵魂追问 破坏请求和保持条件时，处理能力的瓶颈在账本管理员那里，那你觉得这种处理方式会提高并发量吗？ 破坏请求保持条件的方法和破坏环路等待的方法，你觉得那种方式更好 破坏请求和保持条件时，如果代码换成下面的样子会发生什么？ 12345678910111213141516171819public void transfer(Account target, int amt)&#123; // 一次性申请转出账户和转入账户，直到成功 while(accountBookManager.getAllRequiredAccountBook(this, target))&#123;&#125; try&#123; // 锁定转出账户 synchronized(this)&#123; // 锁定转入账户 synchronized(target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; finally &#123; accountBookManager.releaseObtainedAccountBook(this, target); &#125; &#125;&#125; 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"死锁","slug":"死锁","permalink":"https://dayarch.top/tags/%E6%AD%BB%E9%94%81/"},{"name":"锁粒度","slug":"锁粒度","permalink":"https://dayarch.top/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"}]},{"title":"Spring Boot 自定义starter 全面教程","slug":"Spring-Boot-自定义starter-全面教程","date":"2019-10-15T11:35:53.000Z","updated":"2019-11-07T06:24:19.750Z","comments":true,"path":"/p/spring-boot-starter-custom.html","link":"","permalink":"https://dayarch.top/p/spring-boot-starter-custom.html","excerpt":"写在前面 我们每次构建一个 Spring 应用程序时，我们都不希望从头开始实现具有「横切关注点」的内容；相反，我们希望一次性实现这些功能，并根据需要将它们包含到任何我们要构建的应用程序中 横切关注点 横切关注点: 指的是一些具有横越多个模块的行为 (来自维基百科的介绍) 说白了就是多个项目或模块都可以用到的内容，比如一个 SDK 在Spring Boot中，用于表示提供这种横切关注点的模块的术语是 starter，通过依赖 starter 可以轻松使用其包含的一些功能特性，无论你的工作中是否会构建自己的 starter，你都要具有构建 「starter」的思想，本文将结合 Spring","text":"写在前面我们每次构建一个 Spring 应用程序时，我们都不希望从头开始实现具有「横切关注点」的内容；相反，我们希望一次性实现这些功能，并根据需要将它们包含到任何我们要构建的应用程序中 横切关注点 横切关注点: 指的是一些具有横越多个模块的行为 (来自维基百科的介绍) 说白了就是多个项目或模块都可以用到的内容，比如一个 SDK 在Spring Boot中，用于表示提供这种横切关注点的模块的术语是 starter，通过依赖 starter 可以轻松使用其包含的一些功能特性，无论你的工作中是否会构建自己的 starter，你都要具有构建 「starter」的思想，本文将结合 Spring Boot 官方标准构建一个简单的 starter 自定义 starter在我们深入了解如何自定义 starter 之前，为了更好的理解我们每一步在干什么，以及 starter 是如何起作用的，我们先从宏观角度来看 starter 的结构组成到底是什么样的 通常一个完整的 starter 需要包含下面两个组件: Auto-Configure Module Starter Module 如果你看下面这两个组件的解释有些抽象，大概了解一下，阅读完该文章回看这里就会豁然开朗了 Auto-Configure ModuleAuto-Configure Module (自动配置模块) 是包含自动配置类的 Maven 或 Gradle 模块。通过这种方式，我们可以构建可以自动贡献于应用程序上下文的模块，以及添加某个特性或提供对某个外部库的访问 Starter ModuleSpring Boot Starter 是一个 Maven 或 Gradle 模块，其唯一目的是提供 “启动” 某个特性所需的所有依赖项。可以包含一个或多个 Auto-Configure Module (自动配置模块)的依赖项，以及可能需要的任何其他依赖项。这样，在Spring 启动应用程序中，我们只需要添加这个 starter 依赖就可以使用其特性 ⚠️: Spring 官方参考手册建议将自动配置分离，并将每个自动配置启动到一个独立的 Maven 或 Gradle 模块中，从而将自动配置和依赖项管理分离开来。如果你没有建立一个供成千上万用户使用的开源库，也可以将二者合并到一个 module 中 You may combine the auto-configuration code and the dependency management in a single module if you do not need to separate those two concerns 命名来自 Spring 官方的 starter 都是 以 spring-boot-starter 开头，比如: spring-boot-starter-web spring-boot-starter-aop 如果我们自定义 starter 功能名称叫acme，那么我们的命名是这样的: acme-spring-boot-starter acme-spring-boot-autoconfigure 如果 starter 中用到了配置 keys，也要注意不要使用 Spring Boot 使用的命名空间，比如(server，management，spring) Parent Module 创建先来全局看一下项目结构:一级目录结构: 12345.├── pom.xml├── rgyb-spring-boot-autoconfigure├── rgyb-spring-boot-sample└── rgyb-spring-boot-starter 二级目录结构: 1234567891011.├── pom.xml├── rgyb-spring-boot-autoconfigure│ ├── pom.xml│ └── src├── rgyb-spring-boot-sample│ ├── pom.xml│ └── src└── rgyb-spring-boot-starter ├── pom.xml └── src 创建一个空的父亲 Maven Module，主要提供依赖管理，这样 SubModule 不用单独维护依赖版本号，来看 pom.xml 内容: 12345678910111213&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 添加其他全局依赖管理到这里，submodule默认不引入这些依赖，需要显式的指定 --&gt;&lt;/dependencyManagement&gt; Auto-Configure Module 构建新建类 GreetingAutoConfiguration 12345678@Configurationpublic class GreetingAutoConfiguration &#123; @Bean public GreetingService greetingService(GreetingProperties greetingProperties)&#123; return new GreetingService(greetingProperties.getMembers()); &#125;&#125; 我们用 @Configuration 注解标记类 GreetingAutoConfiguration，作为 starter 的入口点。这个配置包含了我们需要提供starter特性的所有 @Bean 定义，在本例中，为了简单阐述问题，我们只将 GreetingService Bean 添加到应用程序上下文 GreetingService 内容如下: 123456789@AllArgsConstructorpublic class GreetingService &#123; private List&lt;String&gt; members = new ArrayList&lt;&gt;(); public void sayHello()&#123; members.forEach(s -&gt; System.out.println(\"hello \" + s)); &#125;&#125; 在 resources 目录下新建文件 META-INF/spring.factories (如果目录 META-INF 不存在需要手工创建)，向文件写入内容: 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ top.dayarch.autoconfigure.GreetingAutoConfiguration Spring 启动时会在其 classpath 中所有的 spring.factoreis 文件，并加载里面的声明配置，GreetingAutoConfiguration 类就绪后，我们的 Spring Boot Starter 就有了一个自动激活的入口点 到这里这个 “不完全的 starter” 已经可以使用了。但因为它是自动激活的，为了个让其灵活可用，我们需要让其按照我们的意愿来激活使用，所以我们需要条件注解来帮忙 条件配置为类添加两个条件注解: 123456@Configuration@ConditionalOnProperty(value = \"rgyb.greeting.enable\", havingValue = \"true\")@ConditionalOnClass(DummyEmail.class)public class GreetingAutoConfiguration &#123; ...&#125; 通过使用 @ConditionalOnProperty 注解，我们告诉 Spring，只有属性 rgyb.greeting.enable 值被设置为 true 时，才将 GreetingAutoConfiguration (以及它声明的所有 bean ) 包含到应用程序上下文中 通过使用 @ConditionalOnClass 注解，我们告诉Spring 只有类 DummyEmail.class 存在于 classpath 时，才将 GreetingAutoConfiguration (以及它声明的所有 bean ) 包含到应用程序上下文中 多个条件是 and/与的关系，既只有满足全部条件时，才会加载 GreetingAutoConfiguration 如果你对条件注解的使用还不是很明确，可以查看我之前的文章: @Conditional注解，灵活配置 Spring Boot 配置属性管理上面使用了 @ConditionalOnProperty 注解，实际 starter 中可能有非常多的属性，所以我们需要将这些属性集中管理: 1234567891011121314@Data@ConfigurationProperties(prefix = \"rgyb.greeting\")public class GreetingProperties &#123; /** * GreetingProperties 开关 */ boolean enable = false; /** * 需要打招呼的成员列表 */ List&lt;String&gt; members = new ArrayList&lt;&gt;();&#125; 我们知道这些属性是要在 application.yml 中使用的，当我们需要使用这些属性时，为了让 IDE 给出更友好的提示，我们需要在 pom.xml 中添加依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这样当我们 mvn compile 时，会在生成一个名为 spring-configuration-metadata.json JSON 文件，文件内容如下: 生成的内容在接下来的内容中用到，且看 提升启动时间对于类路径上的每个自动配置类，Spring Boot 必须计算 @Conditional… 条件值，用于决定是否加载自动配置及其所需的所有类，根据 Spring 启动应用程序中 starter 的大小和数量，这可能是一个非常昂贵的操作，并且会影响启动时间，为了提升启动时间，我们需要在 pom.xml 中添加另外一个依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这个注解会生成一个名为 spring-autoconfigure-metadata.properties Property 文件，其内容如下: 这样，Spring Boot 在启动期间读取这些元数据，可以过滤出不满足条件的配置，而不必实际检查这些类，提升启动速度 到这里关于 Auto-Configure Module 就构建完了，我们需要继续完成 Starter Module 的构建 Starter Module 构建Starter Module 的构建很简单了，你可以认为它就是一个空 module，除了依赖 Auto-Configure Module，其唯一作用就是为了使用 starter 功能特性提供所有必须依赖，所以我们为 starter module 的 pom.xml 文件添加如下内容: 123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.dayarch.learnings&lt;/groupId&gt; &lt;artifactId&gt;rgyb-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 在此处添加其他必要依赖，保证starter可用 --&gt;&lt;/dependencies&gt; 同样在 resources 目录下新建文件 META-INF/spring.providers , 其内容如下: 1providers: rgyb-spring-boot-autoconfigure 该文件主要作用是说明 starter module 的依赖信息，多个依赖以逗号分隔就好，该文件不会影响 starter 的使用，可有可无 Starter Module 就可以这么简单，将两个 module 分别 mvn install 到本地 Maven Repository，接下来我们创建 sample module 引入这个 starter 依赖时就会从本地 Maven Repository 中拉取 创建 Sample Module我们可以通过 Spring Initializr 正常初始化一个 Spring Boot 项目 (rgyb-spring-boot-sample)，引入我们刚刚创建的 starter 依赖，在 sample pom.xml 中添加依赖: 12345&lt;dependency&gt; &lt;groupId&gt;top.dayarch.learnings&lt;/groupId&gt; &lt;artifactId&gt;rgyb-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 接下来配置 application.yml 属性 123456rgyb: greeting: enable: true members: - 李雷 - 韩梅梅 在我们配置 YAML 的时候，会出现下图的提示，这样会更友好，当然为了规范，属性描述最好也用英文描述，这里为了说明问题用了中文描述: 编写测试类我们编写测试用例: 1234567@Autowired(required = false)private GreetingService greetingService;@Testpublic void testGreeting() &#123; greetingService.sayHello();&#125; 测试结果如下: 12hello 李雷hello 韩梅梅 总结到这里完整的 starter 开发就结束了，希望大家了解其构建过程，目录结构及命名等标准，这样有相应的业务需求时都可以开发自己的 starter 被其他人应用起来 starter 开发好了，别人可以手动添加依赖引入 starter 的相关功能，那我们如何像 Spring Initializr 一样，通过下来菜单选择我们的 starter 呢，这样直接初始化好整个项目，接下来的文章我们会模仿 Spring Initializr 自定义我们自的 Initializr 知识点说明Dependency optinal 为什么 Auto-Configure Module 的 dependency 都是 optional = true 呢？这涉及到 Maven 传递性依赖的问题，详情请看 Maven 依赖传递性透彻理解 spring.factories Spring Boot 是如何加载这个文件并找到我们的配置类的下图是 Spring Boot 应用程序启动的调用栈的一部分，我添加了断点: 打开 SpringFactoriesLoader 类，映入眼帘的就是这个内容: 这两张图应该足够说明问题了，是 SPI 的一种加载方式，更细节的内容请大家自己去发现吧 实际案例这里推荐查看 mybatis-spring-boot-starter 这个非 Spring 官方的案例，从中我们: 模仿其目录结构 模仿其设计理念 模仿其编码规范 另外，本文的案例我已上传，公众号回复「demo」，打开链接，查看 customstarter 目录下内容即可 灵魂追问 在生成 spring-autoconfigure-metadata.properties 文件时，为什么 @ConditionalOnProperty 的内容没有被写进去 如果我们要将依赖上传至 remote central repository，你知道怎样搭建自己的 maven repository 吗？ 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"Starter","slug":"Starter","permalink":"https://dayarch.top/tags/Starter/"}]},{"title":"Maven 依赖传递性透彻理解","slug":"Maven-optional-依赖透彻理解","date":"2019-10-11T07:36:38.000Z","updated":"2019-11-07T06:36:38.010Z","comments":true,"path":"/p/maven-dependency-optional-transitive.html","link":"","permalink":"https://dayarch.top/p/maven-dependency-optional-transitive.html","excerpt":"写在前面 本来想写一篇「如何自定义Spring Boot Starter」，但是为了更好理解 Starter 的一些设计理念和其中的关键点，所以提前将一些细节内容单独提取出来讲解说明 在 Maven pom.xml 中，你经常会看到依赖项中有类似下面的代码: 1 2 3 4 5 6 7 sample.ProjectA Project-A 1.0 compile tru","text":"写在前面本来想写一篇「如何自定义Spring Boot Starter」，但是为了更好理解 Starter 的一些设计理念和其中的关键点，所以提前将一些细节内容单独提取出来讲解说明 在 Maven pom.xml 中，你经常会看到依赖项中有类似下面的代码: 1234567&lt;dependency&gt; &lt;groupId&gt;sample.ProjectA&lt;/groupId&gt; &lt;artifactId&gt;Project-A&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 这里的 &lt;optional&gt;true&lt;/optional&gt; 是什么意思呢？ optional 关键字的奥秘老规矩，画个图说明问题: 由于 project C 使用到了两个来自 project A 的类 (OptionalFeatureAClass) 和 project B 的类 (OptionalFeatureBClass). 如果 project C 没有依赖 packageA 和 packageB，那么编译将会失败。 project D 依赖 project C，但是对于 project D 来说，类 (OptionalFeatureAClass) 和类 (OptionalFeatureBClass) 是可选的特性，所以为了让最终的 war/ejb package 不包含不必要的依赖，使用&lt;optional&gt; 声明当前依赖是可选的, 默认情况下也不会被其他项目继承(好比 Java 中的 final 类，不能被其他类继承一样) 如果 project D 确实需要用到 project C 中的 OptionalFeatureAClass 怎么办呢？那我们就需要在 project D 的 pom.xml 中显式的添加声明 project A 依赖，继续看下图: Project D 需要用到 Project A 的 OptionalFeatureAClass，那么需要在 Project D 的 pom.xml 文件中显式的添加对 Project A 的依赖 到这也就很好理解为什么 Maven 为什么要设计 optional 关键字了，假设一个关于数据库持久化的项目(Project C), 为了适配更多类型的数据库持久化设计，比如 Mysql 持久化设计(Project A) 和 Oracle 持久化设计(Project B)，当我们的项目(Project D) 要用的 Project C 的持久化设计，不可能既引入 mysql 驱动又引入 oracle 驱动吧，所以我们要显式的指定一个，就是这个道理了 实际案例在 spring-boot-actuator pom.xml 文件中，有超过 20 个依赖是 optional 因为 Spring Boot 不可能将没必要的依赖也打包到你最终的 jar package 中，所以用到 spring boot actuator 的项目最终生成的 jar package 中不会包含这 20 多个依赖 jar，如果你要用到哪一个，显式的加入到你的项目就好了 在接下来的文章，自定义 Spring Boot Starter 也是这个策略，因为 starter 是包含特定功能为其他项目服务用的，类似本文的 Project C 的角色了，到这里你理解 optional 的奥秘了吗？ 反向应用如果 Project C 引入的依赖没有加 &lt;optional&gt;true&lt;/optional&gt;，Project D 又需要依赖 Project C，但只用到 Project A 的类怎么办呢？Maven 也是有解决办法的，使用 exclusion 关键字，不多说，上一段代码就懂了: 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.dayarch.demo&lt;/groupId&gt; &lt;artifactId&gt;Project-C&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;top.dayarch.demo&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 总结到这里，在你今后设计功能性依赖时，你应该明白怎样设计依赖关系了, 我这里推荐使用 optional 的形式，简单来说，你设计的依赖什么菜都有，想吃什么菜自己 “抱蔡明” 就好，接下来我们就模拟官方标准创建自定义的 starter…… 灵魂追问 有很多童鞋项目组用的构建工具时 Gradle，你知道 Gradle 中是怎样表示的吗？ 自定义 starter，你知道官方标准 starter 的结构是什么样的吗？ 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://dayarch.top/tags/Maven/"}]},{"title":"锁保护资源，synchronized方法就够了吗","slug":"锁保护资源，synchronized方法就够了吗","date":"2019-10-10T06:17:23.000Z","updated":"2020-03-04T03:43:42.706Z","comments":true,"path":"/p/java-concurrency-lock-resource.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-lock-resource.html","excerpt":"写在前面 上一篇文章原子性问题的宏观理解 带领大家了解了锁和资源的模型，有了这篇文章的铺垫，相信理解这一篇文章就非常轻松了 当我们要保护单个资源并对其进行修改其实很简单，只需按照下图分三步走 1. 创建受保护资源 R 的锁 2. 加锁进入临界区 3. 解锁走出临界区 上图的关键是「R1 的锁保护 R1」的指向关系是否正确 如果都是保护单个资源这样简单，程序猿的世界该有多美好，可惜并不是，通常我们需要保护多个资源 保护多个资源 保护多个没有关系的资源 如果多个资源没有关系，那就是保护一个资源模型的复制，同样非常简单，且看下图: 比如现实中银行取款和修改密码操作。 银行取","text":"写在前面上一篇文章原子性问题的宏观理解 带领大家了解了锁和资源的模型，有了这篇文章的铺垫，相信理解这一篇文章就非常轻松了 当我们要保护单个资源并对其进行修改其实很简单，只需按照下图分三步走 创建受保护资源 R 的锁 加锁进入临界区 解锁走出临界区 上图的关键是「R1 的锁保护 R1」的指向关系是否正确 如果都是保护单个资源这样简单，程序猿的世界该有多美好，可惜并不是，通常我们需要保护多个资源 保护多个资源保护多个没有关系的资源如果多个资源没有关系，那就是保护一个资源模型的复制，同样非常简单，且看下图: 比如现实中银行取款和修改密码操作。银行取款操作对应的资源是「余额」, 修改密码操作对应的资源是「密码」，余额和密码两个资源完全没有关系，所以各自用自家的锁保护自家的资源就好了 如果多个资源没有关系，程序猿的世界该有多美好，可惜并不是，我们保护的资源多数情况都有关联关系 保护多个关系的资源拿经典的银行转账案例来说明，账户 A 给账户 B 转账，账户 A 余额减少 100 元，账户 B 余额增加 100 元，这个操作要是原子性的，那么资源「A 余额」和资源「B 余额」就这样”有了关系”，先来看程序: 1234567891011class Account &#123; private int balance; // 转账 synchronized void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; 用 synchronized 直接保护 transfer 方法，然后操作资源「A 余额」和资源「B 余额」就可以了 ⚠️: 真的是这样吗？ 先停止向下看，在你的笔记本上按照文章开头的三步走来画个图看一看，是否和下图一样呢？ 我们通常容易忽略锁和资源的指向关系，我们想当然的用锁 this 来保护 target 资源了，也就没有起到保护作用 假设 A，B，C 账户初始余额都是 200 原，A 向 B 转账 100，B 向 C 转账 100 我们期盼最终的结果是:账户 A 余额: 100 元账户 B 余额: 200 元账户 C 余额: 300 元 假线程 1「A 向 B 转账」与线程 2「B 向 C 转账」两个操作同时执行，根据 JMM 模型可知，线程 1 和线程 2 读取线程 B 当前的余额都是 200 元: 线程 1 执行 transfer 方法锁定的是 A 的实例(A.this)，并没有锁定 B 的实例 线程 2 执行 transfer 方法锁定的是 B 的实例(B.this)，并没有锁定 C 的实例 所以线程 1 和线程 2 可以同时进入 transfer 临界区，上面你认为对的模型其实就会变成这个样子: 还记得 happens-before 规则 这篇文章提到的监视器锁规则和传递性规则吗？ 监视器锁规则 对一个锁的解锁 happens-before 于随后对这个锁的加锁 传递性规则如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C 资源 B.balance 存在于两个”临界区”中，所以这个”临界区”对 B.balance 来说形同虚设，也就不满足监视器锁规则，进而导致传递性规则也不生效，说白了，前序线程的更改结果对后一个线程不可见 这样最终导致: 账户 B 的余额可能是 100: 线程 1 写 B.balance 100(balance = 300) 先于 线程 2 写 B.balance(balance = 100)，也就是说线程 1 的结果会被线程 2 覆盖，导致最终账户 B 的余额为 100 账户 B 的余额可能是 300: 与上述情况相反，线程 1 写 B.balance 100(balance = 300) 后于 线程 2 写 B.balance(balance = 100)，也就是说线程 2 的结果线程 1 覆盖，导致最终账户 B 的余额为 300 就是不能得到我们理想结果 200，感觉生活无比的艰难，那怎么办呢？ 正确姿势上面的问题就是为资源创建的锁不能保护所有关联的资源，那我们就想办法解决这个问题，来看下面代码: 123456789101112class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; synchronized(Account.class) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; 我们将 this 锁变为 Account.class 锁，Account.class 是虚拟机加载 Account 类时创建的，肯定是唯一的(双亲委派模型解释了为何该对象是唯一的)， 所有 Account 对象都共享 Account.class, 也就是说，Account.class 锁能保护所有 Account 对象，我们将上面程序再用模型解释一下 总结到这里关于锁和资源的关系你应该了解的更加透彻了，单个资源和多个无关联资源的情形都很好处理，为各自资源创建相应的锁就好，如果多个资源有关联，为了让锁起到保护作用，我们需要将锁的粒度变大，比如将 this 锁变成了 Account.class 锁。 转账业务非常常见，并发量非常大，如果我们将锁的粒度都提升到 Account.class 这个级别(分久必合)，假设每次转账业务都很耗时，那么显然这个锁的性能是比较低的，所以接下来的文章，我们还会继续优化这个模型，选择合适的锁粒度，同时能保护多个有关联的资源， 我们的锁粒度虽然大，但是我们保障了账户的安全，所以并发编程可以先保证事情做对，遇到瓶颈了，慢慢优化改变相应的模型就好了，当然熟练理解这个模型以后，一步到位的并发编程模型当然是极好的…… 灵魂追问 还记得 happens-before 的几个原则吗？ 偏向锁，轻量锁，重量锁是不是和我们这节内容有异曲同工之处呢？ 提前想一下，我们如何来优化这个模型呢？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"},{"name":"锁","slug":"锁","permalink":"https://dayarch.top/tags/%E9%94%81/"}]},{"title":"EasyExcel读取Excel实际应用","slug":"EasyExcel读取Excel实际应用","date":"2019-10-07T10:32:34.000Z","updated":"2019-12-15T13:04:40.165Z","comments":true,"path":"/p/easyexcel-read.html","link":"","permalink":"https://dayarch.top/p/easyexcel-read.html","excerpt":"写在前面 Java 后端程序员应该会遇到读取 Excel 信息到 DB 等相关需求，脑海中可能突然间想起 Apache POI 这个技术解决方案，但是当 Excel 的数据量非常大的时候，你也许发现，POI 是将整个 Excel 的内容全部读出来放入到内存中，所以内存消耗非常严重，如果同时进行包含大数据量的 Excel 读操作，很容易造成内存溢出问题 但 EasyExcel 的出现很好的解决了 POI 相关问题，原本一个 3M 的 Excel 用 POI 需要100M左右内存, 而 EasyExcel 可以将其降低到几 M，同时再大的 Excel 都不会出现内存溢出的情况，因为是逐行读取 E","text":"写在前面Java 后端程序员应该会遇到读取 Excel 信息到 DB 等相关需求，脑海中可能突然间想起 Apache POI 这个技术解决方案，但是当 Excel 的数据量非常大的时候，你也许发现，POI 是将整个 Excel 的内容全部读出来放入到内存中，所以内存消耗非常严重，如果同时进行包含大数据量的 Excel 读操作，很容易造成内存溢出问题 但 EasyExcel 的出现很好的解决了 POI 相关问题，原本一个 3M 的 Excel 用 POI 需要100M左右内存, 而 EasyExcel 可以将其降低到几 M，同时再大的 Excel 都不会出现内存溢出的情况，因为是逐行读取 Excel 的内容 (老规矩，这里不用过分关心下图，脑海中有个印象即可，看完下面的用例再回看这个图，就很简单了) 另外 EasyExcel 在上层做了模型转换的封装，不需要 cell 等相关操作，让使用者更加简单和方便，且看 简单读假设我们 excel 中有以下内容: 我们需要新建 User 实体，同时为其添加成员变量 123456789101112131415@Datapublic class User &#123; /** * 姓名 */ @ExcelProperty(index = 0) private String name; /** * 年龄 */ @ExcelProperty(index = 1) private Integer age;&#125; 你也许关注到了 @ExcelProperty 注解，同时使用了 index 属性 (0 代表第一列，以此类推)，该注解同时支持以「列名」name 的方式匹配，比如: 12@ExcelProperty(\"姓名\")private String name; 按照 github 文档的说明: 不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配 如果读取的 Excel 模板信息列固定，这里建议以 index 的形式使用，因为如果用名字去匹配，名字重复，会导致只有一个字段读取到数据，所以 index 是更稳妥的方式 如果 Excel 模板的列 index 经常有变化，那还是选择 name 方式比较好，不用经常性修改实体的注解 index 数值 所以大家可以根据自己的情况自行选择 编写测试用例 12345@Testpublic void readExcel()&#123; String fileName = TestUtils.getPath() + \"excel\" + File.separator + \"users1.xlsx\"; EasyExcel.read(fileName, User.class, new UserExcelListener()).sheet().doRead();&#125; EasyExcel 类中重载了很多个 read 方法，这里不一一列举说明，请大家自行查看；同时 sheet 方法也可以指定 sheetNo，默认是第一个 sheet 的信息 上面代码的 new UserExcelListener() 异常醒目，这也是 EasyExcel 逐行读取 Excel 内容的关键所在，自定义 UserExcelListener 继承 AnalysisEventListener 123456789101112131415161718192021222324252627282930@Slf4jpublic class UserExcelListener extends AnalysisEventListener&lt;User&gt; &#123; /** * 批处理阈值 */ private static final int BATCH_COUNT = 2; List&lt;User&gt; list = new ArrayList&lt;User&gt;(BATCH_COUNT); @Override public void invoke(User user, AnalysisContext analysisContext) &#123; log.info(\"解析到一条数据:&#123;&#125;\", JSON.toJSONString(user)); list.add(user); if (list.size() &gt;= BATCH_COUNT) &#123; saveData(); list.clear(); &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; saveData(); log.info(\"所有数据解析完成！\"); &#125; private void saveData()&#123; log.info(\"&#123;&#125;条数据，开始存储数据库！\", list.size()); log.info(\"存储数据库成功！\"); &#125;&#125; 到这里请回看文章开头的 EasyExcel 原理图，invoke 方法逐行读取数据，对应的就是订阅者 1；doAfterAllAnalysed 方法对应的就是订阅者 2，这样你理解了吗？ 打印结果: 从这里可以看出，虽然是逐行解析数据，但我们可以自定义阈值，完成数据的批处理操作，可见 EasyExcel 操作的灵活性 自定义转换器这是最基本的数据读写，我们的业务数据通常不可能这么简单，有时甚至需要将其转换为程序可读的数据 性别信息转换比如 Excel 中新增「性别」列，其性别为男/女，我们需要将 Excel 中的性别信息转换成程序信息: 「1: 男；2:女」 首先在 User 实体中添加成员变量 gender: 12@ExcelProperty(index = 2)private Integer gender; EasyExcel 支持我们自定义 converter，将 excel 的内容转换为我们程序需要的信息，这里新建 GenderConverter，用来转换性别信息 123456789101112131415161718192021222324252627282930public class GenderConverter implements Converter&lt;Integer&gt; &#123; public static final String MALE = \"男\"; public static final String FEMALE = \"女\"; @Override public Class supportJavaTypeKey() &#123; return Integer.class; &#125; @Override public CellDataTypeEnum supportExcelTypeKey() &#123; return CellDataTypeEnum.STRING; &#125; @Override public Integer convertToJavaData(CellData cellData, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; String stringValue = cellData.getStringValue(); if (MALE.equals(stringValue))&#123; return 1; &#125;else &#123; return 2; &#125; &#125; @Override public CellData convertToExcelData(Integer integer, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; return null; &#125;&#125; 上面程序的 Converter 接口的泛型是指要转换的 Java 数据类型，与 supportJavaTypeKey 方法中的返回值类型一致 打开注解 @ExcelProperty 查看，该注解是支持自定义 Converter 的，所以我们为 User 实体添加 gender 成员变量，并指定 converter 12345/** * 性别 1：男；2：女 */@ExcelProperty(index = 2, converter = GenderConverter.class)private Integer gender; 来看运行结果: 数据按照我们预期做出了转换，从这里也可以看出，Converter 可以一次定义到处是用的便利性 日期信息转换日期信息也是我们常见的转换数据，比如 Excel 中新增「出生年月」列，我们要解析成 yyyy-MM-dd 格式，我们需要将其进行格式化，EasyExcel 通过 @DateTimeFormat 注解进行格式化 在 User 实体中添加成员变量 birth，同时应用 @DateTimeFormat 注解，按照要求做格式化 123456/** * 出生日期 */@ExcelProperty(index = 3)@DateTimeFormat(\"yyyy-MM-dd HH:mm:ss\")private String birth; 来看运行结果: 如果这里你指定 birth 的类型为 Date，试试看，你得到的结果是什么？ 到这里都是以测试的方式来编写程序代码，作为 Java Web 开发人员，尤其在目前主流 Spring Boot 的架构下，所以如何实现 Web 方式读取 Excel 的信息呢？ web 读简单 Web很简单，只是将测试用例的关键代码移动到 Controller 中即可，我们新建一个 UserController，在其添加 upload 方法 12345678910@RestController@RequestMapping(\"/users\")@Slf4jpublic class UserController &#123; @PostMapping(\"/upload\") public String upload(MultipartFile file) throws IOException &#123; EasyExcel.read(file.getInputStream(), User.class, new UserExcelListener()).sheet().doRead(); return \"success\"; &#125;&#125; 其实在写测试用例的时候你也许已经发现，listener 是以 new 的形式作为参数传入到 EasyExcel.read 方法中的，这是不符合 Spring IoC 的规则的，我们通常读取 Excel 数据之后都要针对读取的数据编写一些业务逻辑的，而业务逻辑通常又会写在 Service 层中，我们如何在 listener 中调用到我们的 service 代码呢？ *先不要向下看，你脑海中有哪些方案呢？ * 匿名内部类方式匿名内部类是最简单的方式，我们需要先新建 Service 层的信息:新建 IUser 接口: 123public interface IUser &#123; public boolean saveData(List&lt;User&gt; users);&#125; 新建 IUser 接口实现类 UserServiceImpl: 1234567891011@Service@Slf4jpublic class UserServiceImpl implements IUser &#123; @Override public boolean saveData(List&lt;User&gt; users) &#123; log.info(\"UserService &#123;&#125;条数据，开始存储数据库！\", users.size()); log.info(JSON.toJSONString(users)); log.info(\"UserService 存储数据库成功！\"); return true; &#125;&#125; 接下来，在 Controller 中注入 IUser: 12@Autowiredprivate IUser iUser; 修改 upload 方法，以匿名内部类重写 listener 方法的形式来实现: 12345678910111213141516171819202122232425262728293031@PostMapping(\"/uploadWithAnonyInnerClass\") public String uploadWithAnonyInnerClass(MultipartFile file) throws IOException &#123; EasyExcel.read(file.getInputStream(), User.class, new AnalysisEventListener&lt;User&gt;()&#123; /** * 批处理阈值 */ private static final int BATCH_COUNT = 2; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); @Override public void invoke(User user, AnalysisContext analysisContext) &#123; log.info(\"解析到一条数据:&#123;&#125;\", JSON.toJSONString(user)); list.add(user); if (list.size() &gt;= BATCH_COUNT) &#123; saveData(); list.clear(); &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; saveData(); log.info(\"所有数据解析完成！\"); &#125; private void saveData()&#123; iUser.saveData(list); &#125; &#125;).sheet().doRead(); return \"success\"; &#125; 查看结果: 这种实现方式，其实这只是将 listener 中的内容全部重写，并在 controller 中展现出来，当你看着这么臃肿的 controller 是不是非常难受？很显然这种方式不是我们的最佳编码实现 构造器传参在之前分析 SpringBoot 统一返回源码时，不知道你是否发现，Spring 底层源码多数以构造器的形式传参，所以我们可以将为 listener 添加有参构造器，将 Controller 中依赖注入的 IUser 以构造器的形式传入到 listener : 1234567891011121314@Slf4jpublic class UserExcelListener extends AnalysisEventListener&lt;User&gt; &#123; private IUser iUser; public UserExcelListener(IUser iUser)&#123; this.iUser = iUser; &#125; // 省略相应代码... private void saveData()&#123; iUser.saveData(list); //调用 userService 中的 saveData 方法 &#125; 更改 Controller 方法: 12345@PostMapping(\"/uploadWithConstructor\")public String uploadWithConstructor(MultipartFile file) throws IOException &#123; EasyExcel.read(file.getInputStream(), User.class, new UserExcelListener(iUser)).sheet().doRead(); return \"success\";&#125; 运行结果: 同上 这样更改后，controller 代码看着很清晰，但如果后续业务还有别的 Service 需要注入，我们难道要一直添加有参构造器吗？很明显，这种方式同样不是很灵活。 其实在使用匿名内部类的时候，你也许会想到，我们可以通过 Java8 lambda 的方式来解决这个问题 Lambda 传参为了解决构造器传参的痛点，同时我们又希望 listener 更具有通用性，没必要为每个 Excel 业务都新建一个 listener，因为 listener 都是逐行读取 Excel 数据，只需要将我们的业务逻辑代码传入给 listener 即可，所以我们需用到 Consumer&lt;T&gt; ，将其作为构造 listener 的参数。 新建一个工具类 ExcelDemoUtils，用来构造 listener: 12345678910111213141516171819202122232425262728293031323334353637383940public class ExcelDemoUtils &#123; /** * 指定阈值 * @param consumer * @param threshold * @param &lt;T&gt; * @return */ public static &lt;T&gt; AnalysisEventListener&lt;T&gt; getListener(Consumer&lt;List&lt;T&gt;&gt; consumer, int threshold) &#123; return new AnalysisEventListener&lt;T&gt;() &#123; private LinkedList&lt;T&gt; linkedList = new LinkedList&lt;T&gt;(); @Override public void invoke(T t, AnalysisContext analysisContext) &#123; linkedList.add(t); if (linkedList.size() == threshold)&#123; consumer.accept(linkedList); linkedList.clear(); &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; if (linkedList.size() &gt; 0)&#123; consumer.accept(linkedList); &#125; &#125; &#125;; &#125; /** * 不指定阈值，阈值默认为10 * @param consumer * @param &lt;T&gt; * @return */ public static &lt;T&gt; AnalysisEventListener&lt;T&gt; getListener(Consumer&lt;List&lt;T&gt;&gt; consumer)&#123; return getListener(consumer, 10); &#125; 我们看到，getListener 方法接收一个 Consumer&lt;List&lt;T&gt;&gt; 的参数，这样下面代码被调用时，我们的业务逻辑也就会被相应的执行了: 1consumer.accept(linkedList); 继续改造 Controller 方法: 123456789101112@PostMapping(\"/uploadWithLambda\")public String uploadWithLambda(MultipartFile file) throws IOException &#123; AnalysisEventListener&lt;User&gt; userAnalysisEventListener = ExcelDemoUtils.getListener(this.batchInsert(), 2); EasyExcel.read(file.getInputStream(), User.class, userAnalysisEventListener).sheet().doRead(); return \"success\";&#125;private Consumer&lt;List&lt;User&gt;&gt; batchInsert()&#123; //其他业务逻辑只需要添加到该方法中即可 return users -&gt; iUser.saveData(users);&#125; 运行结果: 同上 到这里，我们只需要将业务逻辑定制在 batchInsert 方法中: 满足 Controller RESTful API 的简洁性 listener 更加通用和灵活，它更多是扮演了抽象类的角色，具体的逻辑交给抽象方法的实现来完成 业务逻辑可扩展性也更好，逻辑更加清晰 总结到这里，关于如何使用 EasyExcel 读取 Excel 信息的基本使用方式已经介绍完了，还有很多细节内容没有讲，大家可以自行查阅 EasyExcel Github 文档去发现更多内容 除了读取 Excel 的读取，还有 Excel 的写入，如果需要将其写入到指定位置，配合 HuTool 的工具类 FileWriter 的使用是非常方便的，针对 EasyExcel 的使用，如果大家有什么问题，也欢迎到博客下方探讨 完整代码请在公众号回复「demo」，点开链接，查看「easyexceldemo」文件夹的内容即可 感谢非常感谢 EasyExcel 的作者 🌹🌹，让 Excel 的读写更加方便 灵魂追问 除了 Consumer，如果需要返回值的业务逻辑，需要用到哪个函数式接口呢？ 当出现复杂表头的时候要如何处理呢？ 将 DB 数据写入到 Excel 并下载，如何实现呢？ 从 EasyExcel 的设计上，你学到了什么，欢迎博客下方留言讨论 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"https://dayarch.top/tags/Excel/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"EasyExcel","slug":"EasyExcel","permalink":"https://dayarch.top/tags/EasyExcel/"},{"name":"POI","slug":"POI","permalink":"https://dayarch.top/tags/POI/"}]},{"title":"面试volatile关键字时，我们应该具备哪些谈资？","slug":"面试volatile关键字时，我们应该具备哪些谈资？","date":"2019-09-29T12:03:33.000Z","updated":"2020-03-04T03:43:49.265Z","comments":true,"path":"/p/java-concurrency-volatile.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-volatile.html","excerpt":"写在前面 在 可见性有序性，Happens-before来搞定 文章中，happens-before 的原则之一: volatile变量规则 对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读 按理说了解了这个规则，对 volatile 的使用就已经足够了，但是面试官可是喜欢刨根问到底的，为了更透彻的了解 volatile 的内存语义与读写语义，为了面试多一些谈资进而获得一些加分项，同时尽早填补前序文章留下的坑，于是乎这篇文章就这样尴尬的诞生了 happens-before 之 volatile 变量规则 下面的表格你还记得吗？","text":"写在前面在 可见性有序性，Happens-before来搞定 文章中，happens-before 的原则之一: volatile变量规则 对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读 按理说了解了这个规则，对 volatile 的使用就已经足够了，但是面试官可是喜欢刨根问到底的，为了更透彻的了解 volatile 的内存语义与读写语义，为了面试多一些谈资进而获得一些加分项，同时尽早填补前序文章留下的坑，于是乎这篇文章就这样尴尬的诞生了 happens-before 之 volatile 变量规则下面的表格你还记得吗？(是的，你记得😂) 能否重排序 第二个操作 第二个操作 第二个操作 第一个操作 普通读/写 volatile 读 volatile 写 普通读/写 - - NO volatile 读 NO NO NO volatile 写 - NO NO 上面的表格是 JMM 针对编译器定制的 volatile 重排序的规则，那 JMM 是怎样禁止重排序的呢？答案是内存屏障 内存屏障 (Memory Barriers / Fences)无论你听过这个名词与否都没关系，很简单，且看 为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序 这句话有点抽象，试着想象内存屏障是一面高墙，如果两个变量之间有这个屏障，那么他们就不能互换位置(重排序)了，变量有读(Load)有写(Store)，操作有前有后，JMM 就将内存屏障插入策略分为 4 种: 在每个 volatile 写操作的前面插入一个 StoreStore 屏障 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障 在每个 volatile 读操作的后面插入一个 LoadStore 屏障 1 和 2 用图形描述以及对应表格规则就是下面这个样子了: 3 和 4 用图形描述以及对应表格规则就是下面这个样子了: 其实图形也是表格内容的体现，只不过告诉大家内存屏障是如何禁止指令重排序的，所以大家只要牢记表格内容即可 一段程序的读写通常不会像上面两种情况这样简单，这些屏障组合起来如何使用呢？其实一点都不难，我们只需要将这些指令带入到文章开头的表格中，然后再按照程序顺序拼接指令就好了 来看一小段程序: 1234567891011121314public class VolatileBarrierExample &#123; private int a; private volatile int v1 = 1; private volatile int v2 = 2; void readAndWrite()&#123; int i = v1; //第一个volatile读 int j = v2; //第二个volatile读 a = i + j; //普通写 v1 = i + 1; //第一个volatile写 v2 = j * 2; //第二个volatile写 &#125;&#125; 将屏障指令带入到程序就是这个样子: 我们将上图分几个角度来看: 彩色是将屏障指令带入到程序中生成的全部内容，也就是编译器生成的「最稳妥」的方案 显然有很多屏障是重复多余的，右侧虚线框指向的屏障是可以被「优化」删除掉的屏障 到这里你应该了解了 volatile 是如何通过内存屏障保证程序不被”擅自”排序的，那 volatile 是如何保证可见性的呢？ volatile 写-读的内存语义回顾一下之前文章内容中的程序，假定线程 A 先执行 writer 方法，随后线程 B 执行 reader 方法，: 12345678910111213141516171819public class ReorderExample &#123; private int x = 0; private int y = 1; private volatile boolean flag = false; public void writer()&#123; x = 42; //1 y = 50; //2 flag = true; //3 &#125; public void reader()&#123; if (flag)&#123; //4 System.out.println(\"x:\" + x); //5 System.out.println(\"y:\" + y); //6 &#125; &#125;&#125; 到这里你是否还记得之前说过的 JMM，是的，你还记得😂，当线程 A 执行 writer 方法时，且看下图: 线程 A 将本地内存更改的变量写回到主内存中 volatile 读的内存语义:当读一个 volatile 变量时, JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 所以当线程 B 执行 reader 方法时，图形结构就变成了这个样子: 线程 B 本地内存变量无效，从主内存中读取变量到本地内存中，也就得到了线程 A 更改后的结果，这就是 volatile 是如何保证可见性的 如果你看过前面的文章你就不难理解上面的两张图了，综合起来说: 线程 A 写一个volatile变量, 实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了(其对共享变量所做修改的)消息 线程 B 读一个 volatile 变量,实质上是线程 B 接收了之前某个线程发出的(在写这个 volatile 变量之前对共享变量所做修改的)消息。 线程 A 写一个 volatile 变量, 随后线程 B 读这个 volatile 变量, 这个过程实质上是线程 A 通过主内存向线程B 发送消息。 到这里，面试 volatile 时，你应该有一些谈资了，同时也对 volatile 的语义有了更深层次的了解 彩蛋之前的文章提到过这样一句话: 从内存语义的角度来说, volatile 的写-读与锁的释放-获取有相同的内存效果；volatile 写和锁的释放有相同的内存语义; volatile 读与锁的获取有相同的内存语义 记住文中最后两张图， 当我们说到 synchronized 的时候，你就会猛的理解这句话的含义了, 感兴趣的可以自己先了解 synchronized 的写-读语义 接下来我们就聊一聊锁相关的内容了，敬请期待… 灵魂追问 如果 volatile 写之后直接 return，那还会生成 StoreLoad 指令吗？ synchronized 是怎样逐步被优化的？ 提高效率工具 tool.luhttps://tool.lu 是一款集成了非常多功能的在线工具，基本满足日常开发所需 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"},{"name":"volatile","slug":"volatile","permalink":"https://dayarch.top/tags/volatile/"}]},{"title":"解决原子性问题？你首先需要的是宏观理解","slug":"解决原子性问题？你首先需要的是宏观理解","date":"2019-09-19T02:05:31.000Z","updated":"2020-03-04T03:43:57.834Z","comments":true,"path":"/p/java-concurrency-atomic.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-atomic.html","excerpt":"上一篇文章 可见性有序性，Happens-before来搞定，解决了并发三大问题中的两个，今天我们就聊聊如何解决原子性问题 原子性问题的源头就是 线程切换，但在多核 CPU 的大背景下，不允许线程切换是不可能的，正所谓「魔高一尺，道高一丈」，新规矩来了: 互斥: 同一时刻只有一个线程执行 实际上，上面这句话的意思是: 对共享变量的修改是互斥的，也就是说线程 A 修改共享变量时其他线程不能修改，这就不存在操作被打断的问题了，那么如何实现互斥呢？ 锁 对并发有所了解的小伙伴马上就能想到 锁 这个概念，并且你的第一反应很可能就是使用 synchronized，这里列出来你常见的 syn","text":"上一篇文章 可见性有序性，Happens-before来搞定，解决了并发三大问题中的两个，今天我们就聊聊如何解决原子性问题 原子性问题的源头就是 线程切换，但在多核 CPU 的大背景下，不允许线程切换是不可能的，正所谓「魔高一尺，道高一丈」，新规矩来了: 互斥: 同一时刻只有一个线程执行 实际上，上面这句话的意思是: 对共享变量的修改是互斥的，也就是说线程 A 修改共享变量时其他线程不能修改，这就不存在操作被打断的问题了，那么如何实现互斥呢？ 锁对并发有所了解的小伙伴马上就能想到 锁 这个概念，并且你的第一反应很可能就是使用 synchronized，这里列出来你常见的 synchronized 的三种用法: 123456789101112131415161718public class ThreeSync &#123; private static final Object object = new Object(); public synchronized void normalSyncMethod()&#123; //临界区 &#125; public static synchronized void staticSyncMethod()&#123; //临界区 &#125; public void syncBlockMethod()&#123; synchronized (object)&#123; //临界区 &#125; &#125;&#125; 三种 synchronized 锁的内容有一些差别: 对于普通同步方法，锁的是当前实例对象，通常指 this 对于静态同步方法，锁的是当前类的 Class 对象，如 ThreeSync.class 对于同步方法块，锁的是 synchronized 括号内的对象 我特意在三种 synchronized 代码里面添加了「临界区」字样的注释，那什么是临界区呢？ 临界区: 我们把需要互斥执行的代码看成为临界区 说到这里，和大家串的知识都是表层认知，如何用锁保护有效的临界区才是关键，这直接关系到你是否会写出并发的 bug，了解过本章内容后，你会发现无论是隐式锁/内置锁 (synchronized) 还是显示锁 (Lock) 的使用都是在找寻这种关系，关系对了，一切就对了，且看 上面锁的三种方式都可以用下图来表达: 线程进入临界区之前，尝试加锁 lock()， 加锁成功，则进入临界区(对共享变量进行修改)，持有锁的线程执行完临界区代码后，执行 unlock()，释放锁。针对这个模型，大家经常用抢占厕所坑位来形容: 在学习 Java 早期我就是这样记忆与理解锁的，但落实到代码上，我们很容易忽略两点: 我们锁的是什么？ 我们保护的又是什么？ 将这两句话联合起来就是你的锁能否对临界区的资源起到保护的作用？所以我们要将上面的模型进一步细化 现实中，我们都知道自己的锁来锁自己需要保护的东西 ，这句话翻译成你的行动语言之后你已经明确知道了: 你锁的是什么 你保护的资源是什么 CPU 可不像我们大脑这么智能，我们要明确说明我们锁的是什么，我们要保护的资源是什么，它才会用锁保护我们想要保护的资源(共享变量) 拿上图来说，资源 R (共享变量) 就是我们要保护的资源，所以我们就要创建资源 R 的锁来保护资源 R，细心的朋友可能发现上图几个问题: LR 和 R 之间有明确的指向关系我们编写程序时，往往脑子中的模型是对的，但是忽略了这个指向关系，导致自己的锁不能起到保护资源 R 的作用(用别人家的锁保护自己家的东西或用自己家的锁保护别人家的东西)，最终引发并发 bug，所以在你勾画草图时，要明确找到这个关系 左图 LR 虚线指向了非共享变量我们写程序的时候很容易这么做，不确定哪个是要保护的资源，直接大杂烩，用 LR 将要保护的资源 R 和没必要保护的非共享变量一起保护起来了，举两个例子来说你就明白这么做的坏处了 编写串行程序时，是不建议 try…catch 整个方法的，这样如果出现问是很难定位的，道理一样，我们要用锁精确的锁住我们要保护的资源就够了，其他无意义的资源是不要锁的 锁保护的东西越多，临界区就越大，一个线程从走入临界区到走出临界区的时间就越长，这就让其他线程等待的时间越久，这样并发的效率就有所下降，其实这是涉及到锁粒度的问题，后续也都会做相关说明 作为程序猿还是简单拿代码说明一下心里比较踏实，且看: 123456789101112131415161718public class ValidLock &#123; private static final Object object = new Object(); private int count; public synchronized void badSync()&#123; //其他与共享变量count无关的业务逻辑 count++; &#125; public void goodSync()&#123; //其他与共享变量count无关的业务逻辑 synchronized (object)&#123; count++; &#125; &#125;&#125; 这里并不是说 synchronized 放在方法上不好，只是提醒大家用合适的锁的粒度才会更高效 在计数器程序例子中，我们会经常这么写: 123456789101112public class SafeCounter &#123; private int count; public synchronized void counter()&#123; count++; &#125; public synchronized int getCount()&#123; return count; &#125;&#125; 下图就是上面程序的模型展示: 这里我们锁的是 this，可以保护 this.count。但有些同学认为 getCount 方法没必要加 synchronized 关键字，因为是读的操作，不会对共享变量做修改，如果不加上 synchronized 关键字，就违背了我们上一篇文章 happens-before 规则中的监视器锁规则: 对一个锁的解锁 happens-before 于随后对这个锁的加锁也就是说对 count 的写很可能对 count 的读不可见，也就导致脏读 上面我们看到一个 this 锁是可以保护多个资源的，那用多个不同的锁保护一个资源可以吗？来看一段程序: 123456789101112public class UnsafeCounter &#123; private static int count; public synchronized void counter()&#123; count++; &#125; public static synchronized int calc()&#123; return count++; &#125;&#125; 睁大眼睛仔细看，一个锁的是 this，一个锁的是 UnsafeCounter.class, 他们都想保护共享变量 count，你觉得如何？下图就是行面程序的模型展示: 两个临界区是用两个不同的锁来保护的，所以临界区没有互斥关系，也就不能保护 count，所以这样加锁是无意义的 总结 解决原子性问题，就是要互斥，就是要保证中间状态对外不可见 锁是解决原子性问题的关键，明确知道我们锁的是什么，要保护的资源是什么，更重要的要知道你的锁能否保护这个受保护的资源(图中的箭头指向) 有效的临界区是一个入口和一个出口，多个临界区保护一个资源，也就是一个资源有多个并行的入口和多个出口，这就没有起到互斥的保护作用，临界区形同虚设 锁自己家门能保护资源就没必要锁整个小区，如果锁了整个小区，这严重影响其他业主的活动(锁粒度的问题) 本文以 synchronized 锁举例来说明如何解决原子性问题，主要是帮助大家建立宏观的理念，用于解决原子性问题，这样后续你看到无论什么锁，只要脑海中回想起本节说明的模型，你会发现都是换汤不换药，学习起来就非常轻松了. 到这里并发的三大问题 有序性，可见性，原子性都有了解决方案，这是远看并发，让大家有了宏观的概念；但面试和实战都是讲求细节的，接下来我们由远及近，逐步看并发的细节，顺带说明那些面试官经常会问到的问题 灵魂追问 多个锁锁一个资源一定会有问题吗？ 什么时候需要锁小区，而不能锁某一户呢？ 银行转账，两人互转和别人给自己转，用什么样的锁粒度合适呢？ 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 基础面试，为什么面试官总喜欢问String？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"},{"name":"锁","slug":"锁","permalink":"https://dayarch.top/tags/%E9%94%81/"}]},{"title":"有序性可见性，Happens-before来搞定","slug":"有序性可见性，Happens-before来搞定","date":"2019-09-12T10:24:22.000Z","updated":"2020-03-04T03:44:04.638Z","comments":true,"path":"/p/java-concurrency-happens-before-rule.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-happens-before-rule.html","excerpt":"写在前面 上一篇文章并发 Bug 之源有三，请睁大眼睛看清它们 谈到了可见性/原子性/有序性三个问题，这些问题通常违背我们的直觉和思考模式，也就导致了很多并发 Bug * 为了解决 CPU，内存，IO 的短板，增加了缓存，但这导致了可见性问题 * 编译器/处理器擅自优化 ( Java代码在编译后会变成 Java 字节码, 字节码被类加载器加载到 JVM 里, JVM 执行字节码, 最终需要转化为汇编指令在 CPU 上执行) ，导致有序性问题 初衷是好的，但引发了新问题，最有效的办法就禁止缓存和编译优化，问题虽然能解决，但「又回到最初的起点，呆呆地站在镜子前」是很尴尬的，我们程序的性能就","text":"写在前面上一篇文章并发 Bug 之源有三，请睁大眼睛看清它们 谈到了可见性/原子性/有序性三个问题，这些问题通常违背我们的直觉和思考模式，也就导致了很多并发 Bug 为了解决 CPU，内存，IO 的短板，增加了缓存，但这导致了可见性问题 编译器/处理器擅自优化 ( Java代码在编译后会变成 Java 字节码, 字节码被类加载器加载到 JVM 里, JVM 执行字节码, 最终需要转化为汇编指令在 CPU 上执行) ，导致有序性问题 初衷是好的，但引发了新问题，最有效的办法就禁止缓存和编译优化，问题虽然能解决，但「又回到最初的起点，呆呆地站在镜子前」是很尴尬的，我们程序的性能就堪忧了. 解决方案 作为我们程序猿不想写出 bug 影响 KPI，所以希望内存模型易于理解、易于编程。这就需要基于一个强内存模型来编写代码 作为编译器和处理器不想让外人说它处理速度很慢，所以希望内存模型对他们束缚越少越好，可以由他们擅自优化，这就需要基于一个弱内存模型 俗话说:「没有什么事是开会解决不了的，如果有，那就再开一次」😂 JSR-133 的专家们就有了新想法，既然不能完全禁止缓存和编译优化，那就按需禁用缓存和编译优化，按需就是要加一些约束，约束中就包括了上一篇文章简单提到过的 volatile，synchronized，final 三个关键字，同时还有你可能听过的 Happens-Before 原则(包含可见性和有序性的约束)，Happens-before 规则也是本章的主要内容 为了满足二者的强烈需求，照顾到双方的情绪，于是乎: JMM 就对程序猿说了一个善意的谎言: 「会严格遵守 Happpen-Befores 规则，不会重排序」让程序猿放心，私下却有自己的策略: 对于会改变程序执行结果的重排序,JMM要求编译器和处理器必须禁止这种重排序。 对于不会改变程序执行结果的重排序, JMM对编译器和处理器不做要求 (JMM允许这种重排序)。 我们来用个图说明一下: 这就是那个善意的谎言，虽是谎言，但还是照顾到了程序猿的利益，所以我们只需要了解 happens-before 规则就能得到保证 (图画了好久，不知道是否说明了谎言的所在😅，欢迎留言) Happens-beforeHappens-before 规则主要用来约束两个操作，两个操作之间具有 happens-before 关系, 并不意味着前一个操作必须要在后一个操作之前执行，happens-before 仅仅要求前一个操作(执行的结果)对后一个操作可见, (the first is visible to and ordered before the second) 说了这么多，先来看一小段代码带你逐步走进 Happen-Befores 原则，看看是怎样用该原则解决 可见性 和 有序性 的问题: 12345678910111213class ReorderExample &#123; int x = 0; boolean flag = false; public void writer() &#123; x = 42; //1 flag = true; //2 &#125; public void reader() &#123; if (flag) &#123; //3 System.out.println(x); //4 &#125; &#125;&#125; 假设 A 线程执行 writer 方法，B 线程执行 reader 方法，打印出来的 x 可能会是 0，上一篇文章说明过: 因为代码 1 和 2 没有数据依赖关系，所以可能被重排序 12flag = true; //2x = 42; //1 所以，线程 A 将 flag = true 写入但没有为 x 重新赋值时，线程 B 可能就已经打印了 x 是 0 那么为 flag 加上 volatile 关键字试一下: 1volatile boolean flag = false; 即便加上了 volatile 关键字，这个问题在 java1.5 之前还是没有解决，但 java1.5 和其之后的版本对 volatile 语义做了增强，问题得以解决，这就离不开 Happens-before 规则的约束了，总共有 6 个规则，且看 程序顺序性规则 一个线程中的每个操作, happens-before 于该线程中的任意后续操作第一感觉这个原则是一个在理想状态下的”废话”，并且和上面提到的会出现重排序的情况是矛盾的，注意这里是一个线程中的操作，其实隐含了「as-if-serial」语义: 说白了就是只要执行结果不被改变，无论怎么”排序”，都是对的 这个规则是一个基础规则，happens-before 是多线程的规则，所以要和其他规则约束在一起才能体现出它的顺序性，别着急，继续向下看 volatile变量规则 对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读 我将上面的程序添加两行代码作说明: 12345678910111213141516171819public class ReorderExample &#123; private int x = 0; private int y = 1; private volatile boolean flag = false; public void writer()&#123; x = 42; //1 y = 50; //2 flag = true; //3 &#125; public void reader()&#123; if (flag)&#123; //4 System.out.println(\"x:\" + x); //5 System.out.println(\"y:\" + y); //6 &#125; &#125;&#125; 这里涉及到了 volatile 的内存增强语义，先来看个表格: 能否重排序 第二个操作 第二个操作 第二个操作 第一个操作 普通读/写 volatile 读 volatile 写 普通读/写 - - NO volatile 读 NO NO NO volatile 写 - NO NO 从这个表格 最后一列 可以看出: 如果第二个操作为 volatile 写，不管第一个操作是什么，都不能重排序，这就确保了 volatile 写之前的操作不会被重排序到 volatile 写之后拿上面的代码来说，代码 1 和 2 不会被重排序到代码 3 的后面，但代码 1 和 2 可能被重排序 (没有依赖也不会影响到执行结果)，说到这里和 程序顺序性规则是不是就已经关联起来了呢？ 从这个表格的 倒数第二行 可以看出: 如果第一个操作为 volatile 读，不管第二个操作是什么，都不能重排序，这确保了 volatile 读之后的操作不会被重排序到 volatile 读之前拿上面的代码来说，代码 4 是读取 volatile 变量，代码 5 和 6 不会被重排序到代码 4 之前 volatile 内存语义的实现是应用到了 「内存屏障」，因为这完全够单独写一章的内容，这里为了不掩盖主角 Happens-before 的光环，保持理解 Happens-before 的连续性，先不做过多说明 到这里，看这个规则，貌似也没解决啥问题，因为它还要联合第三个规则才起作用 传递性规则 如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C直接上图说明一下上面的例子 从上图可以看出 x =42 和 y = 50 Happens-before flag = true, 这是规则 1 写变量(代码 3) flag=true Happens-before 读变量(代码 4) if(flag)，这是规则 2 根据规则 3传递性规则，x =42 Happens-before 读变量 if(flag) 谜案要揭晓了: 如果线程 B 读到了 flag 是 true，那么 x =42 和 y = 50 对线程 B 就一定可见了，这就是 Java1.5 的增强 (之前版本是可以普通变量写和 volatile 变量写的重排序的) 通常上面三个规则是一种联合约束，到这里你懂了吗？规则还没完，继续看 监视器锁规则 对一个锁的解锁 happens-before 于随后对这个锁的加锁 这个规则我觉得你应该最熟悉了，就是解释 synchronized 关键字的，来看 1234567891011121314151617public class SynchronizedExample &#123; private int x = 0; public void synBlock()&#123; // 1.加锁 synchronized (SynchronizedExample.class)&#123; x = 1; // 对x赋值 &#125; // 3.解锁 &#125; // 1.加锁 public synchronized void synMethod()&#123; x = 2; // 对x赋值 &#125; // 3. 解锁&#125; 先获取锁的线程，对 x 赋值之后释放锁，另外一个再获取锁，一定能看到对 x 赋值的改动，就是这么简单，请小伙伴用下面命令查看上面程序，看同步块和同步方法被转换成汇编指令有何不同？ 1javap -c -v SynchronizedExample 这和 synchronized 的语义相关，小伙伴可以先自行了解一下，锁的内容时会做详细说明 start()规则 如果线程 A 执行操作 ThreadB.start() (启动线程B), 那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作，也就是说，主线程 A 启动子线程 B 后，子线程 B 能看到主线程在启动子线程 B 前的操作，看个程序就秒懂了 123456789101112131415161718192021222324public class StartExample &#123; private int x = 0; private int y = 1; private boolean flag = false; public static void main(String[] args) throws InterruptedException &#123; StartExample startExample = new StartExample(); Thread thread1 = new Thread(startExample::writer, \"线程1\"); startExample.x = 10; startExample.y = 20; startExample.flag = true; thread1.start(); System.out.println(\"主线程结束\"); &#125; public void writer()&#123; System.out.println(\"x:\" + x ); System.out.println(\"y:\" + y ); System.out.println(\"flag:\" + flag ); &#125;&#125; 运行结果: 123456主线程结束x:10y:20flag:trueProcess finished with exit code 0 线程 1 看到了主线程调用 thread1.start() 之前的所有赋值结果，这里没有打印「主线程结束」，你知道为什么吗？这个守护线程知识有关系 join()规则 如果线程 A 执行操作 ThreadB.join() 并成功返回, 那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回，和 start 规则刚好相反，主线程 A 等待子线程 B 完成，当子线程 B 完成后，主线程能够看到子线程 B 的赋值操作，将程序做个小改动，你也会秒懂的 12345678910111213141516171819202122232425public class JoinExample &#123; private int x = 0; private int y = 1; private boolean flag = false; public static void main(String[] args) throws InterruptedException &#123; JoinExample joinExample = new JoinExample(); Thread thread1 = new Thread(joinExample::writer, \"线程1\"); thread1.start(); thread1.join(); System.out.println(\"x:\" + joinExample.x ); System.out.println(\"y:\" + joinExample.y ); System.out.println(\"flag:\" + joinExample.flag ); System.out.println(\"主线程结束\"); &#125; public void writer()&#123; this.x = 100; this.y = 200; this.flag = true; &#125;&#125; 运行结果: 123456x:100y:200flag:true主线程结束Process finished with exit code 0 「主线程结束」这几个字打印出来喽，依旧和线程何时退出有关系 总结 Happens-before 重点是解决前一个操作结果对后一个操作可见，相信到这里，你已经对 Happens-before 规则有所了解，这些规则解决了多线程编程的可见性与有序性问题，但还没有完全解决原子性问题(除了 synchronized) start 和 join 规则也是解决主线程与子线程通信的方式之一 从内存语义的角度来说, volatile 的写-读与锁的释放-获取有相同的内存效果；volatile 写和锁的释放有相同的内存语义; volatile 读与锁的获取有相同的内存语义，⚠️⚠️⚠️(敲黑板了) volatile 解决的是可见性问题，synchronized 解决的是原子性问题，这绝对不是一回事，后续文章也会说明 附加说明 个人博客会首发原创文章，如文章有密码保护，通过查看文章的创建日期，如果是 1 月份，请公众号回复当前月份数值即可，如回复「1」 多线程系列文章整体会按照我的大纲节奏来写，但是如果大家有什么疑问，也欢迎到我单独建立的多线程系列问题留言汇总 文章中留言，我会统一回复，如果共通疑问很多，我会插入相关章节单独做说明 并发文章的相关代码，我也会同步上传到代码库，公众号回复「demo」，点击链接，找到concurrency 子项目即可 如果文章对你有帮助，烦请小伙伴转发分享给更多朋友，我们一起进步 灵魂追问 同步块和同步方法在编译成 CPU 指令后有什么不同？ 线程有 Daemon(守护线程)和非 Daemon 线程，你知道线程的退出策略吗？ 关于 Happens-before 你还有哪些疑惑呢？ 提高效率工具 MarkDown 表格生成器本文的好多表格是从官网粘贴的，如何将其直接转换成 MD table 呢？那么 https://www.tablesgenerator.com/markdown_tables 就可以帮到你了，无论是生成 MD table，还是粘贴内容生成 table 和内容都是极好的，当然了不止 MD table，自己发现吧，更多工具，公众号回复 「工具」获得 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"},{"name":"Happens-before","slug":"Happens-before","permalink":"https://dayarch.top/tags/Happens-before/"}]},{"title":"并发编程三大问题","slug":"并发编程三大问题","date":"2019-09-04T08:31:34.000Z","updated":"2020-03-04T03:44:16.419Z","comments":true,"path":"/p/java-concurrency-three-questions.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-three-questions.html","excerpt":"写在前面 * 生活中你一定听说过——能者多劳 * 作为 Java 程序员，你一定听过——这个功能请求慢，能加一层缓存或优化一下 SQL 吗？ * 看过中国古代神话故事的也一定听过——天上一天，地上一年 一切设计来源于生活，上一章 学并发编程，透彻理解这三个核心是关键 中有讲过，作为”资本家”，你要尽可能的榨取 CPU，内存与 IO 的剩余价值，但三者完成任务的速度相差很大，CPU > 内存 > IO分，CPU 是天，那内存就是地，内存是天，那 IO 就是地，那怎样平衡三者，提升整体速度呢？ 1. CPU 增加缓存，还不止一层缓存，平衡内存的慢 2. CPU 能者多劳，通过分时","text":"写在前面 生活中你一定听说过——能者多劳 作为 Java 程序员，你一定听过——这个功能请求慢，能加一层缓存或优化一下 SQL 吗？ 看过中国古代神话故事的也一定听过——天上一天，地上一年 一切设计来源于生活，上一章 学并发编程，透彻理解这三个核心是关键 中有讲过，作为”资本家”，你要尽可能的榨取 CPU，内存与 IO 的剩余价值，但三者完成任务的速度相差很大，CPU &gt; 内存 &gt; IO分，CPU 是天，那内存就是地，内存是天，那 IO 就是地，那怎样平衡三者，提升整体速度呢？ CPU 增加缓存，还不止一层缓存，平衡内存的慢 CPU 能者多劳，通过分时复用，平衡 IO 的速度差异 优化编译指令 上面的方式貌似解决了木桶短板问题，但同时这种解决方案也伴随着产生新的可见性，原子性，和有序性的问题，且看 三大问题可见性一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性 谈到可见性，要先引出 JMM (Java Memory Model) 概念, 即 Java 内存模型，Java 内存模型规定，将所有的变量都存放在 主内存 中，当线程使用变量时，会把主内存里面的变量 复制 到自己的工作空间或者叫作 私有内存 ，线程读写变量时操作的是自己工作内存中的变量。 用 Git 的工作流程理解上面的描述就很简单了，Git 远程仓库就是主内存，Git 本地仓库就是自己的工作内存 文字描述有些抽象，我们来图解说明: 看这个场景: 主内存中有变量 x，初始值为 0 线程 A 要将 x 加 1，先将 x=0 拷贝到自己的私有内存中，然后更新 x 的值 线程 A 将更新后的 x 值回刷到主内存的时间是不固定的 刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x=2 就会编程 x=1 这就是线程可见性的问题 JMM 是一个抽象的概念，在实际实现中，线程的工作内存是这样的: 为了平衡内存/IO 短板，会在 CPU 上增加缓存，每个核都只有自己的一级缓存，甚至有一个所有 CPU 都共享的二级缓存，就是上图的样子了，都说这么设计是硬件同学留给软件同学的一个坑，但能否跳过去这个坑也是衡量软件同学是否走向 Java 进阶的关键指标吧…… 小提示从上图中你也可以看出，在 Java 中，所有的实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间共享，这些在后续文章中都称之为「共享变量」，局部变量，方法定义参数和异常处理器参数不会在线程之间共享，所以他们不会有内存可见性的问题，也就不受内存模型的影响 一句话，要想解决多线程可见性问题，所有线程都必须要刷取主内存中的变量怎么解决可见性问题呢？Java 关键字 volatile 帮你搞定，后续章节会分析…… 原子性原子（atom）指化学反应不可再分的基本微粒，原子性操作你应该能感受到其含义: 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 小品「钟点工」有一句非常经典的台词，要把大象装冰箱，总共分几步？ 来看一小段程序: 多线程情况下能得到我们期盼的 count = 20000 的值吗？ 也许有同学会认为，线程调用的 counter 方法只有一个 count++ 操作，是单一操作，所以是原子性的，非也。在线程第一讲中说过我们不能用高级语言思维来理解 CPU 的处理方式，count++ 转换成 CPU 指令则需要三步，通过下面命令解析出汇编指令等信息: 1javap -c UnsafeCounter 截取 counter 方法的汇编指令来看: 解释一下上面的指令，16 : 获取当前 count 值，并且放入栈顶19 : 将常量 1 放入栈顶20 : 将当前栈顶中两个值相加，并把结果放入栈顶21 : 把栈顶的结果再赋值给 count 由此可见，简单的 count++ 不是一步操作，被转换为汇编后就不具备原子性了，就好比大象装冰箱，其实要分三步: 第一步，把冰箱门打开；第二步，把大象放进去；第三步，把冰箱门带上 结合 JMM 结构图理解，说明一下为什么很难得到 count=20000 的结果: 多线程计数器，如何保证多个操作的原子性呢？最粗暴的方式是在方法上加 synchronized 关键字，比如这样: 问题是解决了，如果 synchronized 是万能良方，那么也许并发就没那么多事了，可以靠一个 synchronized 走天下了，事实并不是这样，synchronized 是独占锁 (同一时间只能有一个线程可以调用)，没有获取锁的线程会被阻塞；另外也会带来很多线程切换的上下文开销 所以 JDK 中就有了非阻塞 CAS (Compare and Swap) 算法实现的原子操作类 AtomicLong 等工具类，看过源码的同学也许会发现一个共同特点，所有原子类中都有下面这样一段代码: 1private static final Unsafe unsafe = Unsafe.getUnsafe(); 这个类是 JDK 的 rt.jar 包中的 Unsafe 类提供了 硬件级别 的原子性操作，类中的方法都是 native 修饰的，后面介绍原子类之前也会先说明这个类中的几个方法，这里先简单介绍有个印象即可。 有同学不理解我刚刚提到的线程上下文切换开销很大是什么意思，举 2个例子你就懂了: 你(CPU)在看两本书(两个线程)，看第一本书很短时间后要去看第二本书，看第二本书很短时间后又回看第一本书，并要精确的记得看到第几行，当初看到了什么(CPU 记住线程级别的信息)，当让你 “同时” 看 10 本甚至更多，切换的开销就很大了吧 综艺节目中有很多游戏，让你一边数钱，又要一边做其他的事，最终保证多样事情都做正确，大脑开销大不大，你试试就知道了😊 有序性生活中你问候他人「吃了吗你？」和「你吃了吗？」是一个意思，你写的是下面程序: 1234a = 1；b = 2;System.out.println(a);System.out.println(b); 编译器优化后可能就变成了这样: 1234b = 2;a = 1；System.out.println(a);System.out.println(b); 这个情况，编译器调整了语句顺序没什么影响，但编译器 擅自 优化顺序，就给我们埋下了雷，比如应用双重检查方式实现的单例 一切又很完美是不是，非也，问题出现在 instance = new Singleton();，这 1 行代码转换成了 CPU 指令后又变成了 3 个，我们理解 new 对象应该是这样的: 分配一块内存 M 在内存 M 上初始化 Singleton 对象 然后 M 的地址赋值给 instance 变量 但编译器擅自优化后可能就变成了这样: 分配一块内存 M 然后将 M 的地址赋值给 instance 变量 在内存 M 上初始化 Singleton 对象 首先 new 对象分了三步，给 CPU 留下了切换线程的机会；另外，编译器优化后的顺序可能导致问题的发生，来看: 线程 A 先执行 getInstance 方法，当执行到指令 2 时，恰好发生了线程切换 线程 B 刚进入到 getInstance 方法，判断 if 语句 instance 是否为空 线程 A 已经将 M 的地址赋值给了 instance 变量，所以线程 B 认为 instance 不为空 线程 B 直接 return instance 变量 CPU 切换回线程 A，线程 A 完成后续初始化内容 我们还是画个图说明一下: 如果线程 A 执行到第 2 步，线程切换，由于线程 A 没有把红色箭头执行完全，线程 B 就会得到一个未初始化完全的对象，访问 instance 成员变量的时候就可能发生 NPE，如果将变量 instance 用 volatile 或者 final 修饰(涉及到类的加载机制，可看我之前写的文章: 双亲委派模型：大厂高频面试题，轻松搞定)，问题就解决了. 总结你所看到的程序并不一定是编译器优化/编译后的 CPU 指令，大象装冰箱是是个程序，但其隐含三个步骤，学习并发编程，你要按照 CPU 的思维考虑问题，所以你需要深刻理解 可见性/原子性/有序性 ，这是产生并发 Bug 的源头 本节说明了三个问题，下面的文章也会逐个分析解决以上问题的办法，以及相对优的方案，请持续关注，另外关于并发的测试代码我都会按例上传到 github，公众号回复「demo」——&gt; concurrency 获取更多内容 灵魂追问 为什么用 final 修饰的变量就是线程安全的了呢？ 你会经常查看 CPU 汇编指令吗？ 如果让你写单例，你通常会采用哪种实现？ 提高效率工具 Material Theme UI这是一款 IDEA 的主题插件，安装后，选择 Material Palenight 主题，同时作出如下设置 设置完后，你的 IDEA 就是下面这样，引起极度舒适 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"},{"name":"可见性","slug":"可见性","permalink":"https://dayarch.top/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"},{"name":"原子性","slug":"原子性","permalink":"https://dayarch.top/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"},{"name":"有序性","slug":"有序性","permalink":"https://dayarch.top/tags/%E6%9C%89%E5%BA%8F%E6%80%A7/"}]},{"title":"Mybatis拦截器实现数据加密与解密","slug":"Mybatis拦截器实现数据加密与解密","date":"2019-09-02T00:40:51.000Z","updated":"2020-01-22T02:16:08.745Z","comments":true,"path":"/p/mybatis-interceptor-encrypt-decrypt.html","link":"","permalink":"https://dayarch.top/p/mybatis-interceptor-encrypt-decrypt.html","excerpt":"拦截器介绍 Mybatis Interceptor 在 Mybatis 中被当作 Plugin(插件)，不知道为什么，但确实是在 org.apache.ibatis.plugin 包下面 既然是拦截器，可以拦截哪些内容呢？试想一下…… 当程序写到持久层时，Mybatis 会 执行 指定 SQL 语句，并处理 请求参数 和 返回值。没错，Mybatis 拦截器可以帮助我们处理上述内容，请看官网的 Plugins 的片段, 内容不多 1 2 3 4 5 6 7 8 // 执行 Executor (update, query, flushStatements, commit, rollb","text":"拦截器介绍Mybatis Interceptor 在 Mybatis 中被当作 Plugin(插件)，不知道为什么，但确实是在 org.apache.ibatis.plugin 包下面 既然是拦截器，可以拦截哪些内容呢？试想一下…… 当程序写到持久层时，Mybatis 会 执行 指定 SQL 语句，并处理 请求参数 和 返回值。没错，Mybatis 拦截器可以帮助我们处理上述内容，请看官网的 Plugins 的片段, 内容不多 12345678// 执行Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)// 请求参数处理ParameterHandler (getParameterObject, setParameters)// 返回结果集处理ResultSetHandler (handleResultSets, handleOutputParameters)// SQL语句构建StatementHandler (prepare, parameterize, batch, update, query) 拦截器的使用如果需要实现自定义的拦截器，只需要实现 org.apache.ibatis.plugin.Interceptor 接口，该接口有三个方法： 12345Object intercept(Invocation invocation) throws Throwable;Object plugin(Object target);void setProperties(Properties properties); 我们要实现数据加密，进入数据库的字段不能是真实的数据，但是返回来的数据要真实可用，所以我们需要针对 Parameter 和 ResultSet 两种类型处理，同时为了更灵活的使用，我们需要自定义注解 自定义注解类注解，将注解放在实体类上 123456789/** * 需要加解密的类注解 */@Documented@Inherited@Target(&#123; ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface EncryptDecryptClass &#123;&#125; 字段注解，将注解放在实体字段上 12345678910/** * 加密字段注解 */@Documented@Inherited@Target(&#123; ElementType.FIELD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface EncryptDecryptField &#123;&#125; 有了这两个注解，我们可以在我们可以标记我们要处理的实体和实体中的字段 自定义参数处理拦截器参考官网，通过 @Intercepts 和 @Signature 的联合使用，指定 ParameterHandler.class 类型，同时通过 @Component 注解注入到容器中，即可在设置参数的时候进行拦截，通过自定义接口 IEncryptDecrypt, 根据 Field 的各种类型自定义加密解密算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Intercepts(&#123; @Signature(type = ParameterHandler.class, method = \"setParameters\", args = PreparedStatement.class),&#125;)@ConditionalOnProperty(value = \"domain.encrypt\", havingValue = \"true\")@Component@Slf4jpublic class ParammeterInterceptor implements Interceptor &#123; @Autowired private IEncryptDecrypt encryptDecrypt; @Override public Object intercept(Invocation invocation) throws Throwable &#123; log.info(\"拦截器ParamInterceptor\"); //拦截 ParameterHandler 的 setParameters 方法 动态设置参数 if (invocation.getTarget() instanceof ParameterHandler) &#123; ParameterHandler parameterHandler = (ParameterHandler) invocation.getTarget(); PreparedStatement ps = (PreparedStatement) invocation.getArgs()[0]; // 反射获取 BoundSql 对象，此对象包含生成的sql和sql的参数map映射 /*Field boundSqlField = parameterHandler.getClass().getDeclaredField(\"boundSql\"); boundSqlField.setAccessible(true); BoundSql boundSql = (BoundSql) boundSqlField.get(parameterHandler);*/ // 反射获取 参数对像 Field parameterField = parameterHandler.getClass().getDeclaredField(\"parameterObject\"); parameterField.setAccessible(true); Object parameterObject = parameterField.get(parameterHandler); if (Objects.nonNull(parameterObject))&#123; Class&lt;?&gt; parameterObjectClass = parameterObject.getClass(); EncryptDecryptClass encryptDecryptClass = AnnotationUtils.findAnnotation(parameterObjectClass, EncryptDecryptClass.class); if (Objects.nonNull(encryptDecryptClass))&#123; Field[] declaredFields = parameterObjectClass.getDeclaredFields(); final Object encrypt = encryptDecrypt.encrypt(declaredFields, parameterObject); &#125; &#125; &#125; return invocation.proceed(); &#125; @Override public Object plugin(Object o) &#123; return Plugin.wrap(o, this); &#125; @Override public void setProperties(Properties properties) &#123; &#125;&#125; 同样新建结果集拦截器 结果集拦截器与参数拦截器基本一样, 只不过类型指定为 ResultSetHandler.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Intercepts(&#123; @Signature(type = ResultSetHandler.class, method = \"handleResultSets\", args=&#123;Statement.class&#125;)&#125;)@ConditionalOnProperty(value = \"domain.decrypt\", havingValue = \"true\")@Component@Slf4jpublic class ResultInterceptor implements Interceptor &#123; @Autowired private IEncryptDecrypt encryptDecrypt; @Override public Object intercept(Invocation invocation) throws Throwable &#123; Object result = invocation.proceed(); if (Objects.isNull(result))&#123; return null; &#125; if (result instanceof ArrayList) &#123; ArrayList resultList = (ArrayList) result; if (CollectionUtils.isNotEmpty(resultList) &amp;&amp; needToDecrypt(resultList.get(0)))&#123; for (int i = 0; i &lt; resultList.size(); i++) &#123; encryptDecrypt.decrypt(resultList.get(i)); &#125; &#125; &#125;else &#123; if (needToDecrypt(result))&#123; encryptDecrypt.decrypt(result); &#125; &#125; return result; &#125; public boolean needToDecrypt(Object object)&#123; Class&lt;?&gt; objectClass = object.getClass(); EncryptDecryptClass encryptDecryptClass = AnnotationUtils.findAnnotation(objectClass, EncryptDecryptClass.class); if (Objects.nonNull(encryptDecryptClass))&#123; return true; &#125; return false; &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; @Override public void setProperties(Properties properties) &#123; &#125;&#125; 加密解密IEncryptDecrypt 接口定义了 加密和解密两个方法， 1234567891011121314151617181920public interface IEncryptDecrypt &#123; /** * 加密方法 * @param declaredFields 反射bean成员变量 * @param parameterObject Mybatis入参 * @param &lt;T&gt; * @return */ public &lt;T&gt; T encrypt(Field[] declaredFields, T parameterObject) throws IllegalAccessException; /** * 解密方法 * @param result Mybatis 返回值，需要判断是否是ArrayList类型 * @param &lt;T&gt; * @return */ public &lt;T&gt; T decrypt(T result) throws IllegalAccessException;&#125; 两个拦截器通过在 YAML 中配置属性，按条件注入，外加自定义加密解密算法，完成全局灵活的配置。核心代码已上传至 Github Demo 问题彩蛋也许应对当前的业务，看了该文章满足了当下需求，我们目前只看到了什么是 Mybatis 拦截器，怎样简单使用，拦截器的其他用法以及其他很多为什么都没有解决，关注公众号，回复“人迹罕至” 读完文章 「程序猿为什么要看源码」后 ，我不会满足眼前的这些基本应用，我会有诸多疑问， 我们日常写 CRUD 的业务，为什么 Executor 中只有 R(query) 和 U(update), 那么C(insert) 和 D(delete) 怎样处理的？ 自定义拦截器是以什么方式被执行的，执行顺序是什么？ 分页也是 Mybatis 拦截器的一种，带有分页的框架是怎样使用拦截器的呢？如 Mybatis Plus, PageHelper 虽然重写了 Inteceptor 接口的 public void setProperties(Properties properties) 方法，但是并没有写什么业务逻辑，这个方法能怎样使用？ ……后续文章也会通过读源码的方式逐步解析这些问题，当然你有相关问题也可以留言交流讨论 提高效率工具依旧推荐在写文章时用到的高效工具，后续相关工具也会在文章中陆续更新，请持续关注 MyBatis Log PluginMyBatis Log Plugin 是 Intelligj IDEA 的一个插件，用来从 Mybatis 输出的 log 中提取出当前调用的 SQL 语句，并将参数封装在 SQL 语句中组成完整的 SQL，这样，当我们调试的时候更加清晰方便，可以轻松定位是否 SQL 又问题 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"数据库-持久层-SQL","slug":"Coding/数据库-持久层-SQL","permalink":"https://dayarch.top/categories/Coding/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%8C%81%E4%B9%85%E5%B1%82-SQL/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://dayarch.top/tags/MyBatis/"}]},{"title":"Java String基础面试","slug":"Java String基础面试","date":"2019-08-31T03:57:49.000Z","updated":"2019-12-17T12:47:59.582Z","comments":true,"path":"/p/java-string-interview.html","link":"","permalink":"https://dayarch.top/p/java-string-interview.html","excerpt":"关于 Java String，这是面试的基础，但是还有很多童鞋不能说清楚，所以本文将简单而又透彻的说明一下那个让你迷惑的 String 在 Java 中，我们有两种方式创建一个字符串 1 2 String x = \"abc\"; String y = new String(\"abc\"); 你常见也常写第一种，很少见第二种，但面试还总问这类问题，双引号和构造器两种形式创建字符串到底有什么差别呢？ 先来看例子 例子 1 1 2 3 4 String a = \"abcd\"; String b = \"abcd\"; System.out.println(a == b); // T","text":"关于 Java String，这是面试的基础，但是还有很多童鞋不能说清楚，所以本文将简单而又透彻的说明一下那个让你迷惑的 String 在 Java 中，我们有两种方式创建一个字符串 12String x = \"abc\";String y = new String(\"abc\"); 你常见也常写第一种，很少见第二种，但面试还总问这类问题，双引号和构造器两种形式创建字符串到底有什么差别呢？ 先来看例子 例子 11234String a = \"abcd\";String b = \"abcd\";System.out.println(a == b); // TrueSystem.out.println(a.equals(b)); // True a == b 结果为 true，是因为 a 和 b 都指向 方法区(method area) 同一个字符串文字，内存引用是同一个 当多次创建相同的字符串文字时，只存储每个不同字符串值的一个副本。这个叫做字符串留驻/留用，Java 中所有编译期字符串常量都会被自动留驻 例子 21234String c = new String(\"abcd\");String d = new String(\"abcd\");System.out.println(c == d); // FalseSystem.out.println(c.equals(d)); // True c==d 结果为 false，因为 c 和 d 的引用指向堆中不同的对象，不同的对象肯定有不同的内存引用 举了两个例子，文字描述有点懵？我们来试图通过图形来理解上述两种情况: 也许你已经看看出来了，一个是在方法区，一个是在堆中，在 JVM 模型中这是两个不同的区域，也许你面试时也经常被问到吧，来看下图: 再次提醒一下，所有 new 的对象都会在 Heap 中，这样以后你就好区分了 运行期字符串留驻上面说的字符串留驻是在编译期，那么运行期可以吗？答案是肯定的，我们需要一个函数来帮忙 1234String c = new String(\"abcd\").intern();String d = new String(\"abcd\").intern();System.out.println(c == d); // Now trueSystem.out.println(c.equals(d)); // True 看到 c == d 结果为 true，你应该理解 intern (英文有拘留，软禁的意思)的作用了，通过调用 intern()方法，就好比把创建的字符串拘留在方法区一样了 在面试时甚至还会问你下面代码创建了几个对象: 1String d = new String(\"abcd\") 如果方法区已存在”abcd”, 那么只创建一个 new String 的对象 如果方法区没有”abcd”, 那么要创建两个对象，一个在方法区，一个在堆中 所以，正常情况下我们没必要使用构造器创建对象，因为这很可能会产生一个额外的没用的对象，但是有例外哦，我们下面说 12String s = \"abcd\";s = s.concat(\"ef\"); 当我们想在字符串 s 后面拼接字符”ef”时，会在堆中创建一个新的对象，并将 s 的引用指向新创建的对象，由于 String 创建的是不可变对象，所以 String 类中的所有方法都不会改变它自身，而是返回一个新的字符串(快打开你的 IDE，看看是否每个操作String 的方法最后都是返回有 return new String 字样)，到这里你也应该理解了一个道理: 如果我们需要一个字符串被修改，我们最好使用 StringBuffer 或者 StringBuilder，否则，由于每次操作字符串都会创建一个新的对象，而旧的对象不会有引用指向它，这样我们会浪费很多垃圾回收的时间 到这里还没完，你有没有想过为什么 String 会被设置/制造成 final？ 为什么 String 类被 final 修饰谈及这个问题我们需要一些倒推的或者相互约束思维来思考 字符串池的需求字符串池(String intern pool)是方法区域中的一个特殊存储区域。当创建一个字符串时，如果该字符串已经存在于池中，那么返回现有字符串的引用，而不是创建一个新对象。所以说，如果一个字符串是可变的，那么改变一个引用的值，将导致原本指向该值的引用获取到错误的值 缓存 hashcode字符串的hashcode在Java中经常使用。例如，在HashMap或HashSet中。不可变保证hashcode始终是相同的，这样就可以在不担心更改的情况下兑现它。这意味着，不需要每次使用hashcode时都计算它。这样更有效率。所以你会在 String 类中看到下面的成员变量的定义: 12/** Cache the hash code for the string */private int hash; // Default to 0 安全性String被广泛用作许多java类的参数，例如网络连接、打开文件等。如果字符串不是不可变的，连接或文件将被更改，这可能导致严重的安全威胁。该方法认为它连接到一台机器上，但实际上并没有。可变字符串也可能导致反射中的安全问题，因为参数是字符串。 不可变对象天生是线程安全的由于不可变对象不能被更改，所以它们可以在多个线程之间自由共享。这消除了同步的需求。 总之，出于效率和安全性的考虑，String 被设计为不可变的。这也是为什么在一般情况下，不可变类是首选的原因。 附加说明关于不可变对象和不可变引用总是有同学搞不清楚 1final User user = new User(); 上面的代码指的是 user 引用不能被更改指向内存的其他地址，但是由于 User 是可变对象，我们可以调用 user 的 setter 方法修改其属性 在String类中包含很多学问，包括你对JVM模型的理解，这也就是为什么面试官为什么喜欢问String，主要考察你的基本功 灵魂追问 String 和基本类型的包装类如 Integer 和 Long 都被 final 修饰，但为什么不建议作为 synchronized 同步块的参数适用呢？ 基本类型自动装箱你知道发生了什么吗？和上一个问题有关系 提高效率工具 Material Theme UI这是一款 IDEA 的主题插件，安装后，选择 Material Palenight 主题，同时作出如下设置 设置完后，你的 IDEA 就是下面这样，引起极度舒适 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dayarch.top/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JVM","slug":"JVM","permalink":"https://dayarch.top/tags/JVM/"}]},{"title":"并发编程三大核心","slug":"分工-同步-互斥是并发编程三大核心","date":"2019-08-28T12:29:07.000Z","updated":"2020-03-04T03:44:25.415Z","comments":true,"path":"/p/java-concurrency-core.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-core.html","excerpt":"写在前面 上一篇文章这次走进并发的世界，请不要错过 给大家带了并发编程的开胃菜，接下来我们逐步上正餐，在吃正餐之前，我还要引用那首诗词: 「横看成岭侧成峰，远近高低各不同」，远看看轮廓，近看看细节，不断切换思维或视角来学习 远看并发，并发编程可以抽象成三个核心问题: 分工、同步/协作、互斥 如果你已经工作了，那么你一定听说过或者正在应用敏捷开发模式来交付日常的工作任务，我们就用你熟悉的流程来解释这三个核心问题 分工 将当前 Sprint 的 Story 拆分成「合适」大小的 Task，并且安排给「合适」的 Team Member 去完成 这里面用了两个「合适」，将 Story 拆分","text":"写在前面上一篇文章这次走进并发的世界，请不要错过 给大家带了并发编程的开胃菜，接下来我们逐步上正餐，在吃正餐之前，我还要引用那首诗词: 「横看成岭侧成峰，远近高低各不同」，远看看轮廓，近看看细节，不断切换思维或视角来学习 远看并发，并发编程可以抽象成三个核心问题: 分工、同步/协作、互斥 如果你已经工作了，那么你一定听说过或者正在应用敏捷开发模式来交付日常的工作任务，我们就用你熟悉的流程来解释这三个核心问题 分工 将当前 Sprint 的 Story 拆分成「合适」大小的 Task，并且安排给「合适」的 Team Member 去完成 这里面用了两个「合适」，将 Story 拆分成大小适中，可完成的 Task 是非常重要的。拆分的粒度太粗，导致这个任务完成难度变高，耗时长，不易与其他人配合；拆分的粒度太细，又导致任务太多，不好管理与追踪，浪费精力和资源。(合适的线程才能更好的完成整块工作，当然一个线程可以轻松搞定的就没必要多线程)；安排给合适的人员去完成同样重要，UX-UE 问题交给后端人员处理，很显然是有问题的 (主线程应该做的事交给子线程显然是解决不了问题的，每个线程做正确的事才能发挥作用) 关于分工，常见的 Executor，生产者-消费者模式，Fork/Join 等，这都是分工思想的体现 同步/协作任务拆分完毕，我要等张三的任务，张三要等李四的任务，也就是说任务之间存在依赖关系，前面的任务执行完毕，后面的任务才可以执行，人高级在可以通过沟通反复确认，确保自己的任务可以开始执行。但面对程序，我们需要了解程序的沟通方式，一个线程执行完任务，如何通知后续线程执行 所有的同步/协作关系我们都可以用你最熟悉的 If-then-else 来表示: 12345if(前序任务完成)&#123; execute();&#125;else&#123; wait();&#125; 上面的代码就是说:当某个条件不满足时，线程需要等待；当某个条件满足时，线程需要被唤醒执行，线程之间的协作可能是主线程与子线程的协作，可能是子线程与子线程的合作， Java SDK 中 CountDownLatch 和 CyclicBarrier 就是用来解决线程协作问题的 互斥分工和同步强调的是性能，但是互斥是强调正确性，就是我们常常提到的「线程安全」，当多个线程同时访问一个共享变量/成员变量时，就可能发生不确定性，造成不确定性主要是有可见性、原子性、有序性这三大问题，而解决这些问题的核心就是互斥 互斥 同一时刻，只允许一个线程访问共享变量 来看下图，主干路就是共享变量，进入主干路一次只能有一辆车，这样你是否理解了呢？「天下大事，分久必合」 同样 Java SDK 也有很多互斥的解决方案，比如你马上就能想到 synchronized 关键字，Lock，ThreadLocal 等就是互斥的解决方案 总结资本家疯狂榨取劳动工人的剩余价值，获得最大收益。当你面对 CPU，内存，IO 这些劳动工人时，你就是那个资本家，你要思考如何充分榨取它们的价值 当一个工人能干的活，绝不让两个人来干(单线程能满足就没必要为了多线程)当多个工人干活时，就要让他们分工明确，合作顺畅，没矛盾 当任务很大时，由于 IO 干活慢，CPU 干活快，就没必要让 CPU 死等当前的 IO，转而去执行其他指令，这就是榨取剩余价值，如何最大限度的榨取其价值，这就涉及到后续的调优问题，比如多少线程合适等 分工是设计，同步和互斥是实现，没有好的设计也就没有好的实现，所以在分工阶段，强烈建议大家勾划草图，了解瓶颈所在，这样才会有更好的实现，后续章节的内容，我也会带领大家画草图，分析问题，逐步养成这个习惯 本章内容可以用下面的图来简单概括，叶子结点的内容我们会逐步点亮，现阶段不用过分关注(如果你上来就啃 JDK 源码，也许你会痛苦的迷失，并最终放弃你的进阶之路的) 理解三大核心问题，你要充分结合生活中的实际，程序中的并发问题，基本上都能在实际生活中找得到原型 下一篇文章的内容，我们就要聊聊，引起线程安全的三个问题:「可见性，原子性，有序性」，这涉及到 JMM 的一点内容，可以提前了解一下的，这样我们才能更好的碰撞 灵魂追问 工作中多线程编程的场景多吗？ 想到多线程，只会想到 synchronized 吗？ Java 并发包各个类，你有了解底层实现和设计理念吗？ 提高效率工具 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"分工","slug":"分工","permalink":"https://dayarch.top/tags/%E5%88%86%E5%B7%A5/"},{"name":"同步","slug":"同步","permalink":"https://dayarch.top/tags/%E5%90%8C%E6%AD%A5/"},{"name":"互斥","slug":"互斥","permalink":"https://dayarch.top/tags/%E4%BA%92%E6%96%A5/"},{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"}]},{"title":"并发编程之初探","slug":"并发编程之初探","date":"2019-08-25T11:45:08.000Z","updated":"2020-03-04T03:44:11.512Z","comments":true,"path":"/p/java-concurrency-metaphor.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-metaphor.html","excerpt":"写在前面 Java 有进阶，其名为并发，并发知识之大，一口吃不下。那好，请您多吃几口，又没说一顿吃完，细嚼慢咽才有味. 所有 Java 书籍都将并发编程放在其高级/进阶篇章中，其重要性不言而喻，学好并发也是自身走入高级行列的必备素质之一 并发/并行，进程/线程 这些概念总是显得过于抽象，因为这是与操作系统沟通用到的词汇，就像我们习惯了使用十进制算法，二进制和 16 进制就需要思维的切换；生活中，我们彼此总是不能互相理解，平静之后，我们知道要换位思考；程序的世界也一样，为了更好的理解问题，你也要站在操作系统的角度来思考问题，但当你尝试理解对方时，是违背自己认知习惯的，所以有些困难在所难免 生","text":"写在前面Java 有进阶，其名为并发，并发知识之大，一口吃不下。那好，请您多吃几口，又没说一顿吃完，细嚼慢咽才有味. 所有 Java 书籍都将并发编程放在其高级/进阶篇章中，其重要性不言而喻，学好并发也是自身走入高级行列的必备素质之一 并发/并行，进程/线程 这些概念总是显得过于抽象，因为这是与操作系统沟通用到的词汇，就像我们习惯了使用十进制算法，二进制和 16 进制就需要思维的切换；生活中，我们彼此总是不能互相理解，平静之后，我们知道要换位思考；程序的世界也一样，为了更好的理解问题，你也要站在操作系统的角度来思考问题，但当你尝试理解对方时，是违背自己认知习惯的，所以有些困难在所难免 生活中你一定说过「杀鸡焉用牛刀？」这句话，并发编程中的各种锁(内置锁/显示锁/偏向锁/轻量锁/重量锁/乐观锁/悲观锁)，看到眼花缭乱，有时候很小的问题却用了很重的锁，这是没有必要的；但是这些锁，没有最好的那个，只有最合适和更高效的那个 JUC (java.util.concurrent) 包随着 JDK 的版本升级内容也变的越来越多，面对琳琅满目的并发类，又有些无从下手，其实他们都有一定的联系，我们需要找到升级的主线，让其变得有迹可循. 谈及并发编程，我还是带有一丝惶恐: 如何将这些抽象的概念变得具象？ 如何将编程问题联系到生活实际? 如何在抽象和具象之间切换思维? 个人觉得这些都是学好并发编程的关键。所以关于并发编程的系列文章，我打算从以上几点出发，将技术问题以幽默风趣具象的方式落地 如何学并发「横看成岭侧成峰，远近高低各不同」，在之前的文章中多次引用了这段诗词，我们学习技术也要这样，远观看轮廓，近观看细节，从不同的角度看待问题，在后续的文章中，也希望大家不要将思维局限，尝试跳入/跳出，抽象/具象 郑重声明，接下来不是广告我希望和大家共同完成并发编程系列有更多的思想碰撞，希望大家在读这个系列的同时也阅读以下书籍逐步形成自己的知识体系，这里附上个人认为的最佳阅读顺序: 1.「Java并发编程实战」 该书籍是值得返回看的，第一遍不需要精度，主要是为了建立一个并发的思想，和关键术语的大致记忆，先阅读第 16 章也是极好的，理解 JMM 是实践并发编程的基础 2. 「码出高效」可直接阅读第七章「并发与多线程」，这个章节更好的将技术问题联系到了生活实际，有了「并发编程实战」的铺底，相信，看这个章节会更有感觉 3. 「Java并发编程之美」 这本书从第 5 章开始，就会有源码分析，有前辈带领读源码，轻松多了，这回让你更加了解本质，同时也会找到 JUC 升级的主线 4. 「Java 并发编程的艺术」这本书会满足你从各个角度看待并发编程问题 慎重，如果你是买书如山倒，读书如抽丝的童鞋，请忽略这点内容，停止你的买书行动，请安心跟踪公众号的内容即可 计划如无特殊异常，会按照 1 周 1 篇的节奏来分享，会控制篇幅大小，给大家留有思考空间，期待大家带着疑问等待下一篇文章的到来，我会从大家更多了解的内容出发，逐步走入并发的世界 并发开胃菜不再多废话，拿出之前收藏的一篇文章作为并发编程的开胃小菜，通过这个形象比喻，希望大家能对并发有个初步的了解: 摘自: https://www.cnblogs.com/CoolRandy/p/3169938.html 觉得图解的很到位，将并发编程的几个核心要素都以具象的形式表达出来了，接下来看看何为 进程（process）和 线程（thread） 1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。 3.进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个 进程，其他 进程 处于非运行状态。 4.一个车间里，可以有很多工人。他们协同完成一个任务。 5.线程 就好比车间里的工人。一个 进程 可以包括多个 线程。 6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个 进程 的内存空间是共享的，每个 线程 都可以使用这些共享内存。 7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个 线程 使用某些共享内存时，其他 线程 必须等它结束，才能使用这一块内存。 8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫 “互斥锁”（Mutual exclusion，缩写 Mutex），防止多个 线程 同时读写某一块内存区域。 9.还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的 线程 使用。 10.这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做 “信号量”（Semaphore），用来保证多个 线程 不会互相冲突。 不难看出，Mutex (互斥锁) 是 Semaphore (信号量)的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为 mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 11.操作系统的设计，因此可以归结为三点：（1）以多 进程 形式，允许多个任务同时运行；（2）以多 线程 形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止 进程 之间和 线程 之间产生冲突，另一方面允许 进程 之间和 线程 之间共享资源。 相信看过这之后就了解了并发编程大概要关注的一些内容了，在后续的文章中，希望大家牢记，你是一个工厂只能有一个车间运行的负责人，如何让工人高效的干活且不出差错，也不起冲突，你就是合格的负责人…… 提高效率工具 [center] 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Java-Concurrency","slug":"Java-Concurrency","permalink":"https://dayarch.top/tags/Java-Concurrency/"},{"name":"thread","slug":"thread","permalink":"https://dayarch.top/tags/thread/"},{"name":"并发","slug":"并发","permalink":"https://dayarch.top/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"SpringBoot统一异常处理","slug":"SpringBoot统一异常处理","date":"2019-08-09T07:13:46.000Z","updated":"2019-11-07T06:37:19.144Z","comments":true,"path":"/p/spring-boot-global-exception.html","link":"","permalink":"https://dayarch.top/p/spring-boot-global-exception.html","excerpt":"话说异常 「欲渡黄河冰塞川，将登太行雪满天」，无论生活还是计算机世界难免发生异常，上一篇文章RESTful API 返回统一JSON数据格式 说明了统一返回的处理，这是请求一切正常的情形；这篇文章将说明如何统一处理异常，以及其背后的实现原理，老套路，先实现，后说明原理，有了上一篇文章的铺底，相信，理解这篇文章就驾轻就熟了 实现 新建业务异常 新建 BusinessException.class 类表示业务异常，注意这是一个 Runtime 异常 1 2 3 4 5 6 7 8 9 @Data @AllArgsConstructor public final class Busine","text":"话说异常「欲渡黄河冰塞川，将登太行雪满天」，无论生活还是计算机世界难免发生异常，上一篇文章RESTful API 返回统一JSON数据格式 说明了统一返回的处理，这是请求一切正常的情形；这篇文章将说明如何统一处理异常，以及其背后的实现原理，老套路，先实现，后说明原理，有了上一篇文章的铺底，相信，理解这篇文章就驾轻就熟了 实现新建业务异常新建 BusinessException.class 类表示业务异常，注意这是一个 Runtime 异常 123456789@Data@AllArgsConstructorpublic final class BusinessException extends RuntimeException &#123; private String errorCode; private String errorMsg;&#125; 添加统一异常处理静态方法在 CommonResult 类中添加静态方法 errorResult 用于接收异常码和异常消息: 1234567public static &lt;T&gt; CommonResult&lt;T&gt; errorResult(String errorCode, String errorMsg)&#123; CommonResult&lt;T&gt; commonResult = new CommonResult&lt;&gt;(); commonResult.errorCode = errorCode; commonResult.errorMsg = errorMsg; commonResult.status = -1; return commonResult;&#125; 配置同样要用到 @RestControllerAdvice 注解，将统一异常添加到配置中: 12345678@RestControllerAdvice(\"com.example.unifiedreturn.api\")static class UnifiedExceptionHandler&#123; @ExceptionHandler(BusinessException.class) public CommonResult&lt;Void&gt; handleBusinessException(BusinessException be)&#123; return CommonResult.errorResult(be.getErrorCode(), be.getErrorMsg()); &#125;&#125; 三部搞定，到这里无论是 Controller 还是 Service 中，只要抛出 BusinessException, 我们都会返回给前端一个统一数据格式 测试将 UserController 中的方法进行改造，直接抛出异常: 1234@GetMapping(\"/&#123;id&#125;\")public UserVo getUserById(@PathVariable Long id)&#123; throw new BusinessException(\"1001\", \"根据ID查询用户异常\");&#125; 浏览器中输入: http://localhost:8080/users/1 在 Service 中抛出异常: 1234567891011121314@Servicepublic class UserServiceImpl implements UserService &#123; /** * 根据用户ID查询用户 * * @param id * @return */ @Override public UserVo getUserById(Long id) &#123; throw new BusinessException(\"1001\", \"根据ID查询用户异常\"); &#125;&#125; 运行是得到同样的结果，所以我们尽可能的抛出异常吧 (作为一个程序猿这种心理很可拍) 解剖实现过程解剖这个过程是相当纠结的，为了更好的说(yin)明(wei)问(wo)题(lan)，我要说重中之重了，真心希望看该文章的童鞋自己去案发现场发现线索还是在 WebMvcConfigurationSupport 类中实例化了 HandlerExceptionResolver Bean 12345678910111213@Beanpublic HandlerExceptionResolver handlerExceptionResolver() &#123; List&lt;HandlerExceptionResolver&gt; exceptionResolvers = new ArrayList&lt;&gt;(); configureHandlerExceptionResolvers(exceptionResolvers); if (exceptionResolvers.isEmpty()) &#123; addDefaultHandlerExceptionResolvers(exceptionResolvers); &#125; extendHandlerExceptionResolvers(exceptionResolvers); HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite(); composite.setOrder(0); composite.setExceptionResolvers(exceptionResolvers); return composite;&#125; 和上一篇文章一毛一样的套路，ExceptionHandlerExceptionResolver 实现了 InitializingBean 接口，重写了 afterPropertiesSet 方法: 123456789101112131415161718192021222324252627282930@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBodyAdvice beans initExceptionHandlerAdviceCache(); ...&#125;private void initExceptionHandlerAdviceCache() &#123; if (getApplicationContext() == null) &#123; return; &#125; List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext()); AnnotationAwareOrderComparator.sort(adviceBeans); for (ControllerAdviceBean adviceBean : adviceBeans) &#123; Class&lt;?&gt; beanType = adviceBean.getBeanType(); if (beanType == null) &#123; throw new IllegalStateException(\"Unresolvable type for ControllerAdviceBean: \" + adviceBean); &#125; // 重点看这个构造方法 ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType); if (resolver.hasExceptionMappings()) &#123; this.exceptionHandlerAdviceCache.put(adviceBean, resolver); &#125; if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123; this.responseBodyAdvice.add(adviceBean); &#125; &#125;&#125; 重点看上面我用注释标记的构造方法，代码很好懂，仔细看看吧，其实就是筛选出我们用 @ExceptionHandler 注解标记的方法并放到集合当中，用于后续全局异常捕获的匹配 123456789101112131415161718192021222324252627282930313233343536373839/** * A constructor that finds &#123;@link ExceptionHandler&#125; methods in the given type. * @param handlerType the type to introspect */public ExceptionHandlerMethodResolver(Class&lt;?&gt; handlerType) &#123; for (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) &#123; for (Class&lt;? extends Throwable&gt; exceptionType : detectExceptionMappings(method)) &#123; addExceptionMapping(exceptionType, method); &#125; &#125;&#125;/** * Extract exception mappings from the &#123;@code @ExceptionHandler&#125; annotation first, * and then as a fallback from the method signature itself. */@SuppressWarnings(\"unchecked\")private List&lt;Class&lt;? extends Throwable&gt;&gt; detectExceptionMappings(Method method) &#123; List&lt;Class&lt;? extends Throwable&gt;&gt; result = new ArrayList&lt;&gt;(); detectAnnotationExceptionMappings(method, result); if (result.isEmpty()) &#123; for (Class&lt;?&gt; paramType : method.getParameterTypes()) &#123; if (Throwable.class.isAssignableFrom(paramType)) &#123; result.add((Class&lt;? extends Throwable&gt;) paramType); &#125; &#125; &#125; if (result.isEmpty()) &#123; throw new IllegalStateException(\"No exception types mapped to \" + method); &#125; return result;&#125;private void detectAnnotationExceptionMappings(Method method, List&lt;Class&lt;? extends Throwable&gt;&gt; result) &#123; ExceptionHandler ann = AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class); Assert.state(ann != null, \"No ExceptionHandler annotation\"); result.addAll(Arrays.asList(ann.value()));&#125; 到这里，我们用 @RestControllerAdvice 和 @ExceptionHandler 注解就会被 Spring 扫描到上下文，供我们使用 让我们回到你最熟悉的调用的入口 DispatcherServlet 类的 doDispatch 方法: 123456789101112131415161718192021222324252627protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; ... // 当请求发生异常，该方法会通过 catch 捕获异常 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); ... &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 调用该方法分析捕获的异常 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; ...&#125; 接下来，我们来看 processDispatchResult 方法，这里只要展示调用栈你就会眼前一亮了，又是为了返回统一格式数据: 总结上一篇文章的返回统一数据格式是基础，当异常情况发生时，只不过需要将异常信息提取出来。本文主要为了说明问题，剖析原理，好多地方设计方式是不可取，比如我们最好将异常封装在一个 Enum 类，通过 enum 对象抛出异常等，如果你用到这些，去完善你的设计方案吧 回复 「demo」，打开链接，查看文件夹 「unifiedreturn」下内容，获取完整代码 附加说明之前看到的一本书对异常的分类让我印象深刻，在此摘录一小段分享给大家: 结合出国旅行的例子说明异常分类: 机场地震，属于不可抗力，对应异常分类中的 Error，在制订出行计划时，根本不需要把这个部分的异常考虑进去 堵车属于 checked 异常，应对这种异常，我们可以提前出发，或者改签机票。而飞机延误异常,虽然也需要 check，但我们无能为力，只能持续关注航班动态 没有带护照，明显属于可提前预测的异常，只要出发前检查即可避免；去机场路上车子抛锚，这个异常是突发的，虽然难以预料，但是必须处理，属于需要捕捉的异常，可以通过更换交通工具；应对检票机器故障属于 可透出异常，交由航空公司处理,我们无须关心 灵魂追问 这两篇文章，你学到了哪些设计模式？ 你能熟练的使用反射吗？当看源码是会看到很多反射的应用 你了解 Spring CGLIB 吗？它的工作原理是什么？ 提高效率工具 JSON-ViewerJSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入json-viewer + TAB ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题 另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"https://dayarch.top/tags/Exception/"}]},{"title":"Springboot返回统一JSON数据格式是怎么实现的？","slug":"每天用SpringBoot，还不懂统一返回数据格式是怎么实现的？","date":"2019-08-08T13:22:23.000Z","updated":"2019-11-07T06:38:17.571Z","comments":true,"path":"/p/spring-boot-global-return.html","link":"","permalink":"https://dayarch.top/p/spring-boot-global-return.html","excerpt":"关于 Spring 的全局处理，我有两方面要说: 1. 统一数据返回格式 2. 统一异常处理 为了将两个问题说明清楚，将分两个章节分别说明，本章主要说第一点 有童鞋说，我们项目都做了这种处理，就是在每个 API 都单独工具类将返回值进行封装，但这种不够优雅；我想写最少的代码完成这件事，也许有童鞋说，加几个注解就解决问题了，说的没错，但这篇文章主要是为了说明为什么加了几个注解就解决问题了，目的是希望大家知其所以然。 为了更好的说明问题，本文先说明如何实现，然后再详细剖析实现原理(这很关键) 为什么要做统一数据返回格式 前后端分离是当今服务形式的主流，如何设计一个好的","text":"关于 Spring 的全局处理，我有两方面要说: 统一数据返回格式 统一异常处理为了将两个问题说明清楚，将分两个章节分别说明，本章主要说第一点 有童鞋说，我们项目都做了这种处理，就是在每个 API 都单独工具类将返回值进行封装，但这种不够优雅；我想写最少的代码完成这件事，也许有童鞋说，加几个注解就解决问题了，说的没错，但这篇文章主要是为了说明为什么加了几个注解就解决问题了，目的是希望大家知其所以然。 为了更好的说明问题，本文先说明如何实现，然后再详细剖析实现原理(这很关键) 为什么要做统一数据返回格式前后端分离是当今服务形式的主流，如何设计一个好的 RESTful API ，以及如何让前端小伙伴可以处理标准的 response JSON 数据结构都至关重要，为了让前端有更好的逻辑展示与页面交互处理，每一次 RESTful 请求都应该包含以下几个信息: 名称 描述 status 状态码，标识请求成功与否，如 [1:成功；-1:失败] errorCode 错误码，给出明确错误码，更好的应对业务异常；请求成功该值可为空 errorMsg 错误消息，与错误码相对应，更具体的描述异常信息 resultBody 返回结果，通常是 Bean 对象对应的 JSON 数据, 通常为了应对不同返回值类型，将其声明为泛型类型 实现通用返回值类定义根据上面的描述，用 Java Bean 来体现这个结构就是这样: 123456789101112131415161718@Datapublic final class CommonResult&lt;T&gt; &#123; private int status = 1; private String errorCode = \"\"; private String errorMsg = \"\"; private T resultBody; public CommonResult() &#123; &#125; public CommonResult(T resultBody) &#123; this.resultBody = resultBody; &#125;&#125; 配置没错，我们需要借助几个关键注解来完成一下相关配置: 123456789101112131415161718192021@EnableWebMvc@Configurationpublic class UnifiedReturnConfig &#123; @RestControllerAdvice(\"com.example.unifiedreturn.api\") static class CommonResultResponseAdvice implements ResponseBodyAdvice&lt;Object&gt;&#123; @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) &#123; return true; &#125; @Override public Object beforeBodyWrite(Object body, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) &#123; if (body instanceof CommonResult)&#123; return body; &#125; return new CommonResult&lt;Object&gt;(body); &#125; &#125;&#125; 到这里就结束了，我们就可以纵情的写任何 RESTful API 了，所有的返回值都会有统一的 JSON 结构 测试新建 UserController，添加相应的 RESTful API，测试用例写的比较简单，只为了说明返回值的处理 12345678910111213@RestController@RequestMapping(\"/users\")public class UserController &#123; @GetMapping(\"\") public List&lt;UserVo&gt; getUserList()&#123; List&lt;UserVo&gt; userVoList = Lists.newArrayListWithCapacity(2); userVoList.add(UserVo.builder().id(1L).name(\"日拱一兵\").age(18).build()); userVoList.add(UserVo.builder().id(2L).name(\"tan\").age(19).build()); return userVoList; &#125;&#125; 打开浏览器输入地址测试: http://localhost:8080/users/ ，我们可以看到返回了 List JSON 数据 继续添加 RESTful API，根据用户 ID 查询用户信息 1234@GetMapping(\"/&#123;id&#125;\")public UserVo getUserByName(@PathVariable Long id)&#123; return UserVo.builder().id(1L).name(\"日拱一兵\").age(18).build();&#125; 打开浏览器输入地址测试: http://localhost:8080/users/1 ，我们可以看到返回了单个 User JSON 数据 添加一个返回值类型为 ResponseEntity 的 API 1234@GetMapping(\"/testResponseEntity\")public ResponseEntity getUserByAge()&#123; return new ResponseEntity(UserVo.builder().id(1L).name(\"日拱一兵\").age(18).build(), HttpStatus.OK);&#125; 打开浏览器输入地址测试: http://localhost:8080/users/testResponseEntity ，我们可以看到同样返回了单个 User JSON 数据 解剖实现过程我会将关键部分一一说明清楚，断案还需小伙伴自己去案发现场(打开自己的 IDE 查看) 故事要从 @EnableWebMvc 这个注解说起，打开该注解看: 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; 通过 @Import 注解引入了 DelegatingWebMvcConfiguration.class，那来看这个类吧: 1234@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; ...&#125; 有 @Configuration 注解，你应该很熟悉了，该类的父类 WebMvcConfigurationSupport 中却隐藏着一段关键代码: 123456@Beanpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() &#123; RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter(); ... return adapter;&#125; RequestMappingHandlerAdapter 是每一次请求处理的关键，来看该类的定义: 1234public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; ...&#125; 该类实现了 InitializingBean 接口，我在 Spring Bean 生命周期之“我从哪里来”？ 这篇文章中明确说明了 Spring Bean 初始化的几个关键，其中 InitializingBean 接口的afterPropertiesSet 方法就是关键之一，在 RequestMappingHandlerAdapter 类中同样重写了该方法: 123456789101112131415161718@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBody advice beans initControllerAdviceCache(); if (this.argumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.initBinderArgumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125;&#125; 该方法内容都非常关键，但我们先来看 initControllerAdviceCache 方法，其他内容后续再单独说明: 123456789101112131415161718private void initControllerAdviceCache() &#123; ... if (logger.isInfoEnabled()) &#123; logger.info(\"Looking for @ControllerAdvice: \" + getApplicationContext()); &#125; List&lt;ControllerAdviceBean&gt; beans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext()); AnnotationAwareOrderComparator.sort(beans); List&lt;Object&gt; requestResponseBodyAdviceBeans = new ArrayList&lt;Object&gt;(); for (ControllerAdviceBean bean : beans) &#123; ... if (ResponseBodyAdvice.class.isAssignableFrom(bean.getBeanType())) &#123; requestResponseBodyAdviceBeans.add(bean); &#125; &#125;&#125; 通过 ControllerAdviceBean 静态方法扫描 ControllerAdvice 注解，可是我们在实现上使用的是 @RestControllerAdvice 注解，打开看该注解: 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@ControllerAdvice@ResponseBodypublic @interface RestControllerAdvice &#123; 该注解由 @ControllerAdvice 和 @ResponseBody 标记，就好比你熟悉的 @RestController 注解由 @Controller 和 @ResponseBody 标记是一样的 到这里你已经知道我们用 @RestControllerAdvice 标记的 Bean 是如何被加载到 Spring 上下文的，接下来就要知道是 Spring 是如何使用我们的 bean 以及对返回 body 做处理的 其实在 HttpMessageConverter是如何转换数据的？ 这篇文章中已经说明了一部分，希望小伙伴先看这篇文章，下面的部分就会秒懂了，我们在这里做进一步的说明 在 AbstractMessageConverterMethodProcessor 的 writeWithMessageConverters 方法中，有一段核心代码: 12345678910if (messageConverter instanceof GenericHttpMessageConverter) &#123; if (((GenericHttpMessageConverter) messageConverter).canWrite( declaredType, valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); ... return; &#125;&#125; 可以看到通过 getAdvice() 调用了 beforeBodyWrite 方法，我们已经接近真相了 123protected RequestResponseBodyAdviceChain getAdvice() &#123; return this.advice;&#125; RequestResponseBodyAdviceChain，看名字带有 Chain，很明显用到了「责任链设计模式」，这些内容在 不得不知的责任链设计模式 文章中明确说明过，只不过它传递责任链以循环的方式完成: 123456789101112131415161718192021222324class RequestResponseBodyAdviceChain implements RequestBodyAdvice, ResponseBodyAdvice&lt;Object&gt; &#123; @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType contentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType, ServerHttpRequest request, ServerHttpResponse response) &#123; return processBody(body, returnType, contentType, converterType, request, response); &#125; @SuppressWarnings(\"unchecked\") private &lt;T&gt; Object processBody(Object body, MethodParameter returnType, MediaType contentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType, ServerHttpRequest request, ServerHttpResponse response) &#123; for (ResponseBodyAdvice&lt;?&gt; advice : getMatchingAdvice(returnType, ResponseBodyAdvice.class)) &#123; if (advice.supports(returnType, converterType)) &#123; body = ((ResponseBodyAdvice&lt;T&gt;) advice).beforeBodyWrite((T) body, returnType, contentType, converterType, request, response); &#125; &#125; return body; &#125;&#125; 我们重写的 beforeBodyWrite 方法终究会被调用到，真相就是这样了!!! 其实还没完，你有没有想过，如果我们的 API 方法返回值是 org.springframework.http.ResponseEntity&lt;T&gt; 类型，我们可以指定 HTTP 返回状态码，但是这个返回值会直接放到我们的 beforeBodyWrite 方法的 body 参数中吗？如果这样做很明显是错误的，因为 ResponseEntity 包含很多我们非业务数据在里面，那 Spring 是怎么帮我们处理的呢？ 在我们方法取得返回值并且在调用 beforeBodyWrite 方法之前，还要选择 HandlerMethodReturnValueHandler 用于处理不同的 Handler 来处理返回值 在类 HandlerMethodReturnValueHandlerComposite 中的 handleReturnValue 方法中 12345678910@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName()); &#125; handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125; 通过调用 selectHandler 方法来选择合适的 handler，Spring 内置了很多个 Handler，我们来看类图: HttpEntityMethodProcessor 就是其中之一，它重写了 supportsParameter 方法，支持 HttpEntity 类型，即支持 ResponseEntity 类型: 12345@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return (HttpEntity.class == parameter.getParameterType() || RequestEntity.class == parameter.getParameterType());&#125; 所以当我们返回的类型为 ResponseEntity 时，就要通过 HttpEntityMethodProcessor 的 handleReturnValue 方法来处理我们的结果: 12345678910111213141516171819202122232425@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; ... if (responseEntity instanceof ResponseEntity) &#123; int returnStatus = ((ResponseEntity&lt;?&gt;) responseEntity).getStatusCodeValue(); outputMessage.getServletResponse().setStatus(returnStatus); if (returnStatus == 200) &#123; if (SAFE_METHODS.contains(inputMessage.getMethod()) &amp;&amp; isResourceNotModified(inputMessage, outputMessage)) &#123; // Ensure headers are flushed, no body should be written. outputMessage.flush(); // Skip call to converters, as they may update the body. return; &#125; &#125; &#125; // Try even with null body. ResponseBodyAdvice could get involved. writeWithMessageConverters(responseEntity.getBody(), returnType, inputMessage, outputMessage); // Ensure headers are flushed even if no body was written. outputMessage.flush();&#125; 该方法提取出 responseEntity.getBody()，并传递个 MessageConverter，然后再继续调用 beforeBodyWrite 方法，这才是真相!!! 这是 RESTful API 正常返回内容的情况，下一篇文章，让我们来侦查一下统一异常情况的处理以及实现原理 灵魂追问 返回值是非 ResponseEntity 类型时，用的是什么 handler？它支持的返回值类型是什么？看过你也许就知道为什么要用 @ResponseBody 注解了 你有追踪过 DispatchServlet 的整个请求过程吗？ 提高效率工具 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"Shiro—小而美的安全框架","slug":"Shiro—小而美的安全框架","date":"2019-08-05T03:21:40.000Z","updated":"2019-11-07T06:36:52.166Z","comments":true,"path":"/p/shiro-in-practice.html","link":"","permalink":"https://dayarch.top/p/shiro-in-practice.html","excerpt":"写在前面 在一款应用的整个生命周期，我们都会谈及该应用的数据安全问题。用户的合法性与数据的可见性是数据安全中非常重要的一部分。但是，一方面，不同的应用对于数据的合法性和可见性要求的维度与粒度都有所区别；另一方面，以当前微服务、多服务的架构方式，如何共享Session，如何缓存认证和授权数据应对高并发访问都迫切需要我们解决。Shiro的出现让我们可以快速和简单的应对我们应用的数据安全问题 Shiro介绍 Shiro简介 这个官网解释不抽象，所以直接用官网解释：Apache Shiro™是一个强大且易用的 Java 安全框架，可以执行身份验证、授权、加密和会话管理等。基于 Shiro 的易于理解","text":"写在前面在一款应用的整个生命周期，我们都会谈及该应用的数据安全问题。用户的合法性与数据的可见性是数据安全中非常重要的一部分。但是，一方面，不同的应用对于数据的合法性和可见性要求的维度与粒度都有所区别；另一方面，以当前微服务、多服务的架构方式，如何共享Session，如何缓存认证和授权数据应对高并发访问都迫切需要我们解决。Shiro的出现让我们可以快速和简单的应对我们应用的数据安全问题 Shiro介绍Shiro简介这个官网解释不抽象，所以直接用官网解释：Apache Shiro™是一个强大且易用的 Java 安全框架，可以执行身份验证、授权、加密和会话管理等。基于 Shiro 的易于理解的API，您可以快速、轻松地使任何应用程序变得安全（从最小的移动应用到最大的网络和企业应用）。 谈及安全，多数 Java 开发人员都离不开 Spring 框架的支持，自然也就会先想到 Spring Security，那我们先来看二者的差别 Shiro Spring Security 简单、灵活 复杂、笨重 可脱离Spring 不可脱离Spring 粒度较粗 粒度较细 虽然 Spring Security 属于名震中外 Spring 家族的一部分，但是了解 Shiro 之后，你不会想 “嫁入豪门”，而是选择追求「诗和远方」冲动。 横看成岭侧成峰，远近高低各不同 (依旧是先了解概念就好) 远看 Shiro 看轮廓 Subject它是一个主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者 SecurityManager安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet前端控制器 Realm域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 近看 Shiro 看细节看图瞬间懵逼？别慌，会为你拆解来看，结合着图看下面的解释，这不是啥大问题，且看: Subject主体，可以看到主体可以是任何可以与应用交互的 “用户” SecurityManager相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理 Authenticator认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；需要自定义认证策略（Authentication Strategy），即什么情况下算用户认证通过了 Authrizer授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能 Realm可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm SessionManager如果写过 Servlet 就应该知道 Session 的概念，Session 需要有人去管理它的生命周期，这个组件就是 SessionManager；而Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB等环境；所以，Shiro 就抽象了一个自己的Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台Web服务器；接着又上了台EJB 服务器；这时又想把两台服务器的会话数据放到一个地方，我们就可以实现自己的分布式会话（如把数据放到Memcached 服务器） SessionDAODAO大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 Cryptography密码模块，Shiro提高了一些常见的加密组件用于如密码「加密/解密」的 注意上图的结构，我们会根据这张图来逐步拆分讲解，记住这张图也更有助于我们理解 Shiro 的工作原理，所以依旧是打开两个网页一起看就好喽 搭建概览多数小伙伴都在使用 Spring Boot， Shiro 也很应景的定义了 starter，做了更好的封装，对于我们来说使用起来也就更加方便，来看选型概览 序号 名称 版本 1 Springboot 2.0.4 2 JPA 2.0.4 3 Mysql 8.0.12 4 Redis 2.0.4 5 Lombok 1.16.22 6 Guava 26.0-jre 7 Shiro 1.4.0 使用 Spring Boot，大多都是通过添加 starter 依赖，会自动解决依赖包版本，所以自己尝试的时候用最新版本不会有什么问题，比如 Shiro 现在的版本是 1.5.0 了，整体问题不大，大家自行尝试就好 添加 Gradle 依赖管理 大体目录结构 application.yml 配置 基本配置 你就让我看这？这只是一个概览，先做到心中有数，我们来看具体配置，逐步完成搭建 其中 shiroFilter bean 部分指定了拦截路径和相应的过滤器，”/user/login”, ”/user”, ”/user/loginout” 可以匿名访问，其他路径都需要授权访问，shiro 提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限(先了解个大概即可)： 配置缩写 对应的过滤器 功能 anon AnonymousFilter 指定url可以匿名访问 authc FormAuthenticationFilter 指定url需要form表单登录，默认会从请求中获取username、password,rememberMe等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。 authcBasic BasicHttpAuthenticationFilter 指定url需要basic登录 Logout LogoutFilter 登出过滤器，配置指定url就可以实现退出功能，非常方便 noSessionCreation NoSessionCreationFilter 禁止创建会话 perms PermissionsAuthorizationFilter 需要指定权限才能访问 port PortFilter 需要指定端口才能访问 rest HttpMethodPermissionFilter 将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释 roles RolesAuthorizationFilter 需要指定角色才能访问 ssl SslFilter 需要https请求才能访问 user UserFilter 需要已登录或“记住我”的用户才能访问 数据库表设计数据库表设计请参考 entity package下的 bean，通过@Entity 注解与 JPA 的设置自动生成表结构 (你需要简单的了解一下 JPA 的功能)。 我们要说重点啦～～～ 身份认证身份认证是一个证明 “李雷是李雷，韩梅梅是韩梅梅” 的过程，回看上图，Realm 模块就是用来做这件事的，Shiro 提供了 IniRealm，JdbcReaml，LDAPReam等认证方式，但自定义的 Realm 通常是最适合我们业务需要的，认证通常是校验登录用户是否合法。 新建用户 User12345678910111213141516@Data@Entitypublic class User implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(unique =true) private String username; private String password; private String salt;&#125; 定义 Repository123456@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; public User findUserByUsername(String username);&#125; 编写UserController：1234567@GetMapping(\"/login\")public void login(String username, String password) &#123; UsernamePasswordToken token = new UsernamePasswordToken(username, password); token.setRememberMe(true); Subject currentUser = SecurityUtils.getSubject(); currentUser.login(token);&#125; 自定义 Realm自定义 Realm，主要是为了重写 doGetAuthenticationInfo(…)方法 123456789@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String username = token.getUsername(); User user = userRepository.findUserByUsername(username); SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(user, user.getPassword(), getName()); simpleAuthenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(user.getSalt())); return simpleAuthenticationInfo;&#125; 这些代码我需要做一个说明，你可能也满肚子疑惑: 这段代码怎么应用了 shiro？ controller 是怎么调用到 custom realm 的？ 重写的 doGetAuthenticationInfo(…) 方法目的是什么？ 认证流程说明用户访问/user/login 路径，生成 UsernamePasswordToken, 通过SecurityUtils.getSubject()获取Subject（currentUser），调用 login 方法进行验证，让我们跟踪一下代码，瞧一瞧就知道自定义的CustomRealm怎样起作用的，一起来看源码： 到这里我们要停一停了，请回看 Shiro 近景图，将源码追踪路径与其对比，是完全一致的 授权身份认证是验证你是谁的问题，而授权是你能干什么的问题， 产品经理：申购模块只能科室看程序员：好的产品经理：科长权限大一些，他也能看申购模块程序员：好的(黑脸)产品经理：科长不但能看，还能修改数据程序员：关公提大刀，拿命来… 作为程序员，我们的宗旨是：「能动手就不吵吵」; 硝烟怒火拔地起，耳边响起驼铃声（Shiro）：「放下屠刀，立地成佛」授权没有那么麻烦，大家好商量… 整个过程和身份认证基本是一毛一样，你对比看看 角色实体创建涉及到授权，自然要和角色相关，所以我们创建 Role 实体: 123456789101112@Data@Entitypublic class Role &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(unique =true) private String roleCode; private String roleName;&#125; 新建 Role Repository123456789@Repositorypublic interface RoleRepository extends JpaRepository&lt;Role, Long&gt; &#123; @Query(value = \"select roleId from UserRoleRel ur where ur.userId = ?1\") List&lt;Long&gt; findUserRole(Long userId); List&lt;Role&gt; findByIdIn(List&lt;Long&gt; ids);&#125; 定义权限实体 Permission123456789101112@Data@Entitypublic class Permission &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(unique =true) private String permCode; private String permName;&#125; 定义 Permission Repository12345678@Repositorypublic interface PermissionRepository extends JpaRepository&lt;Permission, Long&gt; &#123; @Query(value = \"select permId from RolePermRel pr where pr.roleId in ?1\") List&lt;Long&gt; findRolePerm(List&lt;Long&gt; roleIds); List&lt;Permission&gt; findByIdIn(List&lt;Long&gt; ids);&#125; 建立用户与角色关系其实可以通过 JPA 注解来制定关系的，这里为了说明问题，以单独外键形式说明 1234567891011121314@Data@Entitypublic class UserRoleRel &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; private Long userId; private Long roleId;&#125; 建立角色与权限关系12345678910111213@Data@Entitypublic class RolePermRel &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; private Long permId; private Long roleId;&#125; 编写 UserController12345@RequiresPermissions(\"user:list:view\")@GetMapping()public void getAllUsers()&#123; List&lt;User&gt; users = userRepository.findAll();&#125; @RequiresPermissions(&quot;user:list:view&quot;) 注解说明具有用户：列表：查看权限的才可以访问），官网明确给出权限定义格式，包括通配符等，我希望你自行去查看 自定义 CustomRealm (主要重写 doGetAuthorizationInfo) 方法: 与认证流程如出一辙，只不过多了用户，角色，权限的关系罢了 授权流程说明这里通过过滤器（见Shiro配置）和注解二者结合的方式来进行授权，和认证流程一样，最终会走到我们自定义的 CustomRealm 中，同样 Shiro 默认提供了许多注解用来处理不同的授权情况 注解 功能 @RequiresGuest 只有游客可以访问 @RequiresAuthentication 需要登录才能访问 @RequiresUser 已登录的用户或“记住我”的用户能访问 @RequiresRoles 已登录的用户需具有指定的角色才能访问 @RequiresPermissions 已登录的用户需具有指定的权限才能访问（如果不想和产品经理华山论剑，推荐用这个注解） 授权官网给出明确的授权策略与案例，请查看：http://shiro.apache.org/permissions.html 上面的例子我们通过一直在通过访问 Mysql 获取用户认证和授权信息，这中方式明显不符合生产环境的需求 Session会话管理做过 Web 开发的同学都知道 Session 的概念，最常用的是 Session 过期时间，数据在 Session 的 CRUD，同样看上图，我们需要关注 SessionManager 和 SessionDAO 模块，Shiro starter 已经提供了基本的 Session配置信息，我们按需在YAML中配置就好（官网https://shiro.apache.org/spring-boot.html 已经明确给出Session的配置信息） Key Default Value Description shiro.enabled true Enables Shiro’s Spring module shiro.web.enabled true Enables Shiro’s Spring web module shiro.annotations.enabled true Enables Spring support for Shiro’s annotations shiro.sessionManager.deleteInvalidSessions true Remove invalid session from session storage shiro.sessionManager.sessionIdCookieEnabled true Enable session ID to cookie, for session tracking shiro.sessionManager.sessionIdUrlRewritingEnabled true Enable session URL rewriting support shiro.userNativeSessionManager false If enabled Shiro will manage the HTTP sessions instead of the container shiro.sessionManager.cookie.name JSESSIONID Session cookie name shiro.sessionManager.cookie.maxAge -1 Session cookie max age shiro.sessionManager.cookie.domain null Session cookie domain shiro.sessionManager.cookie.path null Session cookie path shiro.sessionManager.cookie.secure false Session cookie secure flag shiro.rememberMeManager.cookie.name rememberMe RememberMe cookie name shiro.rememberMeManager.cookie.maxAge one year RememberMe cookie max age shiro.rememberMeManager.cookie.domain null RememberMe cookie domain shiro.rememberMeManager.cookie.path null RememberMe cookie path shiro.rememberMeManager.cookie.secure false RememberMe cookie secure flag shiro.loginUrl /login.jsp Login URL used when unauthenticated users are redirected to login page shiro.successUrl / Default landing page after a user logs in (if alternative cannot be found in the current session) shiro.unauthorizedUrl null Page to redirect user to if they are unauthorized (403 page) 分布式服务中，我们通常需要将Session信息放入Redis中来管理，来应对高并发的访问需求，这时只需重写SessionDAO即可完成自定义的Session管理 整合Redis12345678910111213141516@Configurationpublic class RedisConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public RedisTemplate&lt;String, Object&gt; stringObjectRedisTemplate() &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); return template; &#125;&#125; 重写SessionDao 查看源码，可以看到调用默认SessionManager的retriveSession方法，我们重写该方法，将Session放入HttpRequest中，进一步提高session访问效率 向ShiroConfig中添加配置 其实在概览模块已经给出代码展示，这里单独列出来做说明: 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 自定义RedisSessionDao用来管理Session在Redis中的CRUD * @return */@Bean(name = \"redisSessionDao\")public RedisSessionDao redisSessionDao()&#123; return new RedisSessionDao();&#125;/** * 自定义SessionManager,应用自定义SessionDao * @return */@Bean(name = \"customerSessionManager\")public CustomerWebSessionManager customerWebSessionManager()&#123; CustomerWebSessionManager customerWebSessionManager = new CustomerWebSessionManager(); customerWebSessionManager.setSessionDAO(redisSessionDao()); return customerWebSessionManager;&#125;/** * 定义Security manager * @param customRealm * @return */@Bean(name = \"securityManager\")public DefaultWebSecurityManager defaultWebSecurityManager(CustomRealm customRealm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager (); securityManager.setRealm(customRealm); securityManager.setSessionManager(customerWebSessionManager()); // 可不指定，Shiro会用默认Session manager securityManager.setCacheManager(redisCacheManagers()); //可不指定，Shiro会用默认CacheManager// securityManager.setSessionManager(defaultWebSessionManager()); return securityManager;&#125;/** * 定义session管理器 * @return */@Bean(name = \"sessionManager\")public DefaultWebSessionManager defaultWebSessionManager()&#123; DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager(); defaultWebSessionManager.setSessionDAO(redisSessionDao()); return defaultWebSessionManager;&#125; 至此，将 session 信息由 redis 管理功能就这样完成了 缓存管理应对分布式服务，对于高并发访问数据库权限内容是非常低效的方式，同样我们可以利用Redis来解决这一问题，将授权数据缓存到Redis中 新建 RedisCache123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Slf4j@Componentpublic class RedisCache&lt;K, V&gt; implements Cache&lt;K, V&gt; &#123; public static final String SHIRO_PREFIX = \"shiro-cache:\"; @Resource private RedisTemplate&lt;String, Object&gt; stringObjectRedisTemplate; private String getKey(K key)&#123; if (key instanceof String)&#123; return (SHIRO_PREFIX + key); &#125; return key.toString(); &#125; @Override public V get(K k) throws CacheException &#123; log.info(\"read from redis...\"); V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k)); if (v != null)&#123; return v; &#125; return null; &#125; @Override public V put(K k, V v) throws CacheException &#123; stringObjectRedisTemplate.opsForValue().set(getKey(k), v); stringObjectRedisTemplate.expire(getKey(k), 100, TimeUnit.SECONDS); return v; &#125; @Override public V remove(K k) throws CacheException &#123; V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k)); stringObjectRedisTemplate.delete((String) get(k)); if (v != null)&#123; return v; &#125; return null; &#125; @Override public void clear() throws CacheException &#123; //不要重写，如果只保存shiro数据无所谓 &#125; @Override public int size() &#123; return 0; &#125; @Override public Set&lt;K&gt; keys() &#123; return null; &#125; @Override public Collection&lt;V&gt; values() &#123; return null; &#125;&#125; 新建 RedisCacheManager12345678910public class RedisCacheManager implements CacheManager &#123; @Resource private RedisCache redisCache; @Override public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String s) throws CacheException &#123; return redisCache; &#125;&#125; 至此，我们不用每次访问 Mysql DB 来获取认证和授权信息，而是通过 Redis 来缓存这些信息，大大提升了效率，也满足分布式系统的设计需求 总结回复公众号 「demo」获取 demo 代码。这里只是梳理了Springboot整合Shiro的流程，以及应用Redis最大化利用Shiro，Shiro的使用细节还很多，官网说的也很明确，带着上面的架构图来理解Shiro会事半功倍，感觉这里面的代码挺多挺头大的？那是你没有自己动手去尝试，结合官网与 demo 相信你会对 Shiro 有更好的理解，另外你可以理解 Shiro 是 mini 版本的 Spring Security，我希望以小见大，当需要更细粒度的认证授权时，也会对理解 Spring Security 有很大帮助，点击文末「阅读原文」，效果更好 落霞与孤鹜齐飞 秋水共长天一色，产品经理和程序员一片祥和… 灵魂追问 都说 Redis 是单线程，但是很快，你知道为什么吗？ 你们项目中是怎样控制认证授权的呢？当授权有变化，对于程序员来说，这个修改是灾难吗？ 提高效率工具 MarkDown 表格生成器本文的好多表格是从官网粘贴的，如何将其直接转换成 MD table 呢？那么 https://www.tablesgenerator.com/markdown_tables 就可以帮到你了，无论是生成 MD table，还是粘贴内容生成 table 和内容都是极好的，当然了不止 MD table，自己发现吧，更多工具，公众号回复 「工具」获得 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 回复「工具」 面试问题分析与解答 技术资料领取 回复「资料」 后续会推出「多线程」与「ElasticSearch」等连载内容 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://dayarch.top/tags/Shiro/"}]},{"title":"@Conditional注解，Spring Boot 的灵活配置","slug":"Conditional注解，Spring-Boot-的灵活配置","date":"2019-07-31T08:30:07.000Z","updated":"2019-11-07T06:35:47.024Z","comments":true,"path":"/p/spring-boot-condition-annotation.html","link":"","permalink":"https://dayarch.top/p/spring-boot-condition-annotation.html","excerpt":"上一篇文章 你应该知道的 @ConfigurationProperties 注解的使用姿势，这一篇就够了 介绍了如何通过 @ConfigurationProperties 注解灵活读取配置属性，这篇文章将介绍如何灵活配置 Spring Bean 写在前面 当我们构建一个 Spring 应用的时候，有时我们想在满足指定条件的时候才将某个 bean 加载到应用上下文中， 在Spring 4.0 时代，我们可以通过 @Conditional 注解来实现这类操作 我们看到 @Conditional 注解接收的参数是 extends Condition 接口的泛型类，也就是说，我们要使用 @Con","text":"上一篇文章 你应该知道的 @ConfigurationProperties 注解的使用姿势，这一篇就够了 介绍了如何通过 @ConfigurationProperties 注解灵活读取配置属性，这篇文章将介绍如何灵活配置 Spring Bean 写在前面当我们构建一个 Spring 应用的时候，有时我们想在满足指定条件的时候才将某个 bean 加载到应用上下文中， 在Spring 4.0 时代，我们可以通过 @Conditional 注解来实现这类操作 我们看到 @Conditional 注解接收的参数是 extends Condition 接口的泛型类，也就是说，我们要使用 @Conditional 注解，只需要实现 Condition 接口并重写其方法即可: 看到接口的 matches 方法返回的是 boolean 类型，是不是和我们自定义 validation annotation 有些类似，都是用来判断是否满足指定条件。另外注意看，以上注解和接口都在 org.springframework.context.annotation package 中 终于到了 Spring Boot 时代，在这个全新的时代，Spring Boot 在 @Conditional 注解的基础上进行了细化，无需出示复杂的介绍信 (实现 Condition 接口)，只需要手持预定义好的 @ConditionalOnXxxx 注解印章的门票，如果验证通过，就会走进 Application Context 大厅 注解详解Spring Boot 对 @Conditional 注解为我们做了细化，这些注解都定义在 org.springframework.boot.autoconfigure.condition package 下 逐个打开这 13 个注解，我们发现这些注解上有相同的元注解: 从这些标记上我们可以了解如下内容: 都可以应用在 TYPE 上，也就是说，Spring 自动扫描的一切类 (@Configuration, @Component, @Service, @Repository, or @Controller) 都可以通过添加相应的 @ConditionalOnXxxx 来判断是否加载 都可以应用在 METHOD 上，所以有 @Bean 标记的方法也可以应用这些注解 都是用了 @Conditional 注解来标记，OnBeanCondition 等自定义 Condition 还是实现了 Condition 接口的，换汤不换药，没什么神秘的，只不过做了更具象的封装罢了，来看类依赖图: 其实看这些注解字面意思已经能理解这些注解的含义，但是我们还是要说明具体的使用以及一些注意事项，我按照个人使用频次由高到低讲解: @ConditionalOnProperty毫无疑问这个注解是榜首 这个条件解释是: application.properties 或 application.yml 文件中 mybean.enable 为 true 才会加载 MyCondition 这个 Bean，如果没有匹配上也会加载，因为 matchIfMissing = true，默认值是 false。 @ConditionalOnBean 和 ConditionalOnMissingBean有时候我们需要某个 Bean 已经存在应用上下文时才会加载，那么我们会用到 @ConditionalOnBean 注解: 与之相反，有时候我们需要某个 Bean 不存在于应用上下文时才会加载，那么我们会用到 @ConditionalOnMissingBean 注解 @ConditionalOnClass 和 @ConditionalOnMissingClass不要嫌我废话，和上面的一样，只不过判断某个类是否存在于 classpath 中，这就不做过多说明了 @ConditionalOnExpression如果我们有更复杂的多个配置属性一起判断，那么我们就可以用这个表达式了: 只有当两个属性都为 true 的时候才加载 MyModule，到这里要顺便揭晓上一篇文章 你应该知道的 @ConfigurationProperties 注解的使用姿势，这一篇就够了 灵魂追问 3，其中 :true 就是: 如果没有为该属性设置值，则为该属性设置默认值true, 其实这就是@Vaue 注解的规范，一切 SpEL 都可以应用在这里. 写到这，我常用的已经用完了，还要硬着头皮介绍其他几个内容 😄，开个玩笑，咱们继续: @ConditionalOnSingleCandidate这个注解和 @ConditionalOnBean 类似，为了更好的说明该注解的使用 (其实是 才疏学浅 ) ，我只能翻译一下类的注释了 只有指定类已存在于 BeanFactory 中，并且可以确定单个候选项才会匹配成功 BeanFactory 存在多个 bean 实例，但是有一个 primary 候选项被指定(通常在类上使用 @Primary 注解)，也会匹配成功。实质上，如果自动连接具有定义类型的 bean 匹配就会成功 目前，条件只是匹配已经被应用上下文处理的 bean 定义，本身来讲，强烈建议仅仅在 auto-configuration 类中使用这个条件，如果候选 bean 被另外一个 auto-configuration 创建，确保使用该条件的要在其后面运行 @ConditionalOnResource如果我们要加载的 bean 依赖指定资源是否存在于 classpath 中，那么我们就可以使用这个注解 看到这个 logback.xml 是不是很亲切，在我们引入第三方工具类如 Dozer 等都可以添加类似的开关 接下来的是真冷门，大家有个印象，如果有需要，至少能想到用这些注解实现灵活配置就好了 @ConditionalOnJndi只有指定的资源通过 JNDI 加载后才加载 bean @ConditionalOnJava只有运行指定版本的 Java 才会加载 Bean @ConditionalOnWebApplication 和 @ConditionalOnNotWebApplication只有运行在 web 应用里才会加载这个 bean 与之相反，在非 web 环境才加载 bean @ConditionalOnCloudPlatform这个注解冷的我呼吸都要停止了，只有运行在指定的云平台上才加载指定的 bean，CloudPlatform 是 org.springframework.boot.cloud 下一个 enum 类型的类，大家可以打开自行看看: 到此，Spring Boot 为我们提供的这 13 个注解就介绍完了，但是没有结束，下面的一些冷门知识，你需要知道: 组合条件组合条件 AND如果我们想多个条件一起应用，并且条件的关系是 and，我们只需要在类上使用多个@ConditionalOnXxxx 就可以了 (你这也叫冷门？) ，当然也可以继承 AllNestedConditions类封装我们多个条件 这样就有了组合 and 条件，只有内部所有条件都满足，才加载指定 bean 组合条件 OR如果我们希望组合的条件是 or 的关系，我们该怎么办呢？ 我们可以通过继承 AnyNestedCondition 来完成这一要求，示例代码和上面一样，大家自行打开 AnyNestedCondition 类，查看类说明即可 条件组合 NONE有 and 和 or 就肯定有 non(非)，我们可以通过继承 NoneNestedConditions 完成这一要求，大家自行查看即可 自定义注解通过组合方式实现了多条件逻辑应用，我们需要应用这些组合条件也就要自定义注解，其实文章开头已经讲过了，模仿内置的 13 个注解写就好了: 只需要通过@Conditional注解指定我们自定义的 condition 类就好了，然后应用到你想用的地方就好了 还是推荐大家看 RabbitMq 的 RabbitAutoConfiguration 类，这个类里面主流的注解都是用了 (只看这一个类就好了)，大家看框架理解学习这些注解是更好的方式: https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.java 总结到这里，你已经了解了如何灵活配置 bean，结合之前的文章，相信的定义会更加灵活，希望大家打开 IDE，自行查看这些注解，了解更多具体内容 灵魂追问 SpringBoot 添加了 web starter，有哪些方法将其更改为非 web 应用？ Java8 Stream 也有 findAny，findAll 这类的操作，这都是匹配，你有使用过吗？ 看下面这段代码，如果 classpath 中没有 MyBean class，编译会报错，那这个注解什么用呢？12345@Configuration @ConditionalOnClass(MyBean.class)public class MyConfiguration&#123; // omitted &#125; 提高效率工具 推荐阅读 红黑树，超强动静图详解，简单易懂 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 面试问题分析与解答 技术资料领取 后续会推出 「多线程」以及「ElasticSearch」等连载内容以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"注解","slug":"注解","permalink":"https://dayarch.top/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"红黑树，史上最强动静图详解","slug":"红黑树，史上最强动静图详解","date":"2019-07-29T08:42:05.000Z","updated":"2019-11-07T06:06:38.332Z","comments":true,"path":"/p/redblack-tree.html","link":"","permalink":"https://dayarch.top/p/redblack-tree.html","excerpt":"写在前面 红黑树，对很多童鞋来说，是既熟悉又陌生。学校中学过，只了解大概；工作中不怎么使用，但面试又是重点。每次需要查看红黑树内容时都很难以更生动形象的方式来理解其内容。没错，本文内容就是要解决这个问题，用简单的语言，搭配静图和动图(利用大脑图形记忆方式)，让你对红黑树有更深入的了解和更清晰的记忆，希望小伙伴们再次遇到红黑树的问题不至于头大，建议读该文章姿势: 打开两个页面，一个页面看图片和内容，一个页面看公式，像玩魔方一样，多玩几次就明白了 通过工具 (公众号回复「工具」—>那些可以提高效率的工具—>红黑树) 动态感受红黑树的转换过程 俺家司令买完东西后，我俩经常会发生这样的一段对话","text":"写在前面红黑树，对很多童鞋来说，是既熟悉又陌生。学校中学过，只了解大概；工作中不怎么使用，但面试又是重点。每次需要查看红黑树内容时都很难以更生动形象的方式来理解其内容。没错，本文内容就是要解决这个问题，用简单的语言，搭配静图和动图(利用大脑图形记忆方式)，让你对红黑树有更深入的了解和更清晰的记忆，希望小伙伴们再次遇到红黑树的问题不至于头大，建议读该文章姿势: 打开两个页面，一个页面看图片和内容，一个页面看公式，像玩魔方一样，多玩几次就明白了 通过工具 (公众号回复「工具」—&gt;那些可以提高效率的工具—&gt;红黑树) 动态感受红黑树的转换过程 俺家司令买完东西后，我俩经常会发生这样的一段对话:司令:你猜我买的这个多少钱？我: 1000司令: 高了我: 500司令: 低了:我: 750…… 直到最后猜中 这样说大家应该已经猜到了是「二分查找法」，通过这个例子我想要引出的是 树，来看图片 程序中的树其实是我们日常看到的树的倒影，或者发挥一下想象，倒影也可以是树根 二叉查找树二叉查找树，Binary Search Tree 「BST」，要想了解二叉查找树，我们首先看下二叉查找树有哪些特性呢？ 某节点的左子树节点值仅包含小于该节点值 某节点的右子树节点值仅包含大于该节点值 左右子树每个也必须是二叉查找树看个图就轻松理解上面三句话的意思了: 上图，结合二叉查找树的三条约束来看，非常好，没有什么问题。再来看一个图，依旧符合上面三条约束，感觉有问题吗？ 这是一个走路一米六，一米八的树 这是一个畸形的树，大风一挂很可能被折断的树从程序的角度来说这个树不够平衡，查找次数或时间复杂度 O(h)可能会随着一条腿长无限增长 理科生在高中学习生物时学过一个关键字「去除顶端优势」，通过去除植物顶端优势，侧芽会迅速生长，慢慢变得强壮和平衡， 红黑树其实就是去除二叉查找树顶端优势的解决方案，从而达到树的平衡 红黑树红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则: 每个节点都有红色或黑色 树的根始终是黑色的 (黑土地孕育黑树根，😄) 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点） 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点 瞬间懵逼？了解一下印象就行，开始玩魔方都是要照着魔方公式一点点玩的，多玩几次就熟悉了。红黑树也一样，红黑树有两大操作: recolor (重新标记黑色或红色) rotation (旋转，这是树达到平衡的关键)我们会先尝试 recolor，如果 recolor 不能达到红黑树的 4 点要求，然后我们尝试 rotation，其实红黑树的关键玩法就是弄清楚 recolor 和 rotation 的规则，接下来看看详细的算法公式吧 千万别着急记忆公式，有图示会逐步说明，就像魔方一样，多玩几次就懂了:假设我们插入的新节点为 X 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1 如果 X 的 uncle (叔叔) 是红色 3.1.1 将 parent 和 uncle 标记为黑色 3.1.2 将 grand parent (祖父) 标记为红色 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 话不多说，看下图 跟着上面的公式走: 将新插入的 X 节点标记为红色 发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」 发现 X 的 uncle (U) 同样为红色 将 P 和 U 标记为黑色 将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3 发现 G 是根结点，标记为黑色 结束 刚刚说了 X 的 uncle 是红色的情况，接下来要说是黑色的情况 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.2.3 右右 (和 3.2.1 镜像过来，恰好相反) 3.2.4 右左 (和 3.2.2 镜像过来，恰好相反)当出现 uncle 是黑色的时候我们第一步要考虑的是 旋转 ，这里先请小伙伴不要关注红黑树的第 4 条规则，主要是为了演示如何旋转的，来一点点看，不要看图就慌，有解释的😜:左左情况这种情况很简单，想象这是一根绳子，手提起 P 节点，然后变色即可 左右左旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的左孩子，然后再应用 左左情况 右右与左左情况一样，想象成一根绳子 右左右旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的右孩子，然后再应用 右右情况 你说的动图在哪里，你个大骗子，别着急，现在就为小伙伴们奉上动图演示，来说明公式的使用: 案例一 插入 10，20，30，15 到一个空树中 向空树中第一次插入数字 10，肯定是 root 节点 root 节点标记成黑色 向树中插入新节点 20，标记为红色 20 &gt; 10，并发现 10 没有叶子节点，将新节点 20 作为 10 的右孩子 向树中插入新节点 30，标记为红色 30 &gt; 10，查找 10 的右子树，找到 20 30 &gt; 20，继续查找 20 的右子树，发现 20 没有叶子节点，将值插在此处 30 和 20 节点都为红色，30 为右孩子，20 也为右孩子，触发了 右右情况 通过一次旋转，提起 20 节点 20 节点是根结点，标记为黑色 向树中插入新节点 15，标记为红色 通过比对大小和判断是否有叶子节点，最终插值为 10 节点的右孩子 15 和 10 节点都为红色，15 的 uncle 节点 30 也为红色 按照公式，将 15 的 parent 10 和 uncle 30 更改为黑色 让 15 节点 grand parent 20 的颜色与 15 节点的颜色一样，变为红色 20 为根结点，将其改为黑色 继续插入其他节点只不过反复应用上面的公式，上面应用到的红黑树工具，可以暂停动画效果，一帧一帧的看红黑树的转换过程，这样通过练习，查看公式，观察变化三管齐下，红黑树的入门理解应该完全不再是问题了 灵魂追问 jdk 1.8 HashMap 中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何 put 和 remove 的吗？ 这里讲的是红黑树的 insert，delete 又是什么规则呢？ 哪些场景可以应用红黑树？ 你了解各种树的时间复杂度吗？ 留个小作业，应用工具将 [10 70 32 34 13 56 32 56 21 3 62 4 ] 逐个插入到树中，理解红黑树 recolor 和 rotation 的转换规则 提高效率工具 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 [orange] 高效工具汇总 [green] 面试问题分析与解答 [pink] 技术资料领取 [red] 后续文章会为你讲解各种时间空间复杂度，以及多线程，ElasticSearch 等问题 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"https://dayarch.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"二叉查找树","slug":"二叉查找树","permalink":"https://dayarch.top/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"}]},{"title":"如何设计好的Restful API","slug":"如何设计好的Restful-API","date":"2019-05-16T06:48:27.000Z","updated":"2019-11-07T06:37:47.212Z","comments":true,"path":"/p/restful-api-design.html","link":"","permalink":"https://dayarch.top/p/restful-api-design.html","excerpt":"现状 现阶段的开发模式多以前后端分离形式存在，前后端开发人员需要通过大量 API 来进行数据交互，如果在交互过程中前后端人员经常遭遇如下问题： * 前端人员不能快速理解接口字段含义及接口字段变化 * 后端人员想复用某些接口，但是不能快速从接口 URL 的定义中明确该接口的含义，需要进一步读代码确认 * URL中的英文单词使用五花八门，搜索某个接口不知道具体的关键字 * 请求方法动词如 POST GET 随意使用 * 完成当前业务接口对接，前端人员经常会询问下一步业务流程的接口定义在哪里，对接形式是什么样的 以上只是前后端人员通过接口交互的一小部分问题，这些问题就好比”牙痛”，不致","text":"现状现阶段的开发模式多以前后端分离形式存在，前后端开发人员需要通过大量 API 来进行数据交互，如果在交互过程中前后端人员经常遭遇如下问题： 前端人员不能快速理解接口字段含义及接口字段变化 后端人员想复用某些接口，但是不能快速从接口 URL 的定义中明确该接口的含义，需要进一步读代码确认 URL中的英文单词使用五花八门，搜索某个接口不知道具体的关键字 请求方法动词如 POST GET 随意使用 完成当前业务接口对接，前端人员经常会询问下一步业务流程的接口定义在哪里，对接形式是什么样的 以上只是前后端人员通过接口交互的一小部分问题，这些问题就好比”牙痛”，不致命，但是在整个软件开发的生命周期内，天天”牙痛”是很要命的, 需要解决上述的问题，需要前后端人员都能认识与了解接口设计规范的重要性。 什么是REST在 2000 年，Roy Fielding 提出 Representational State Transfer (REST) 的概念，中文翻译过来”表述性状态传递”，感兴趣的朋友可以去维基百科看看原始概念，乍一看是一个挺抽象的概念，但其实，这个概念就像交通灯规则一样简单，就看如何看待相关规范. 当我们谈及 RESTful 设计规范，多数人能了解设计的大原则，但是不了解小细节，而对这些细节的了解与否，是能否治好”牙痛病”的关键 REST术语介绍现实世界交通灯有红绿黄，REST相关的概念也是三个：资源，集合，URL 资源资源是某种东西的对象或表示，它具有一些与之相关的数据，并且可以有一组方法对其进行操作。 例如, 动物，学校和员工是资源; 删除，添加，更新是对这些资源执行的相关操作 集合集合是资源集合，例如，公司是公司资源的集合 URLURL（统一资源定位符）是可以通过其定位资源的路径，并且可以对其执行某些操作 了解到以上内容， 那REST 世界的”交通灯”规则是什么样的？我们来了解一下 如何设计和开发一个高可用的 REST APIs 网上一直有关于”最好的Restful API的设计”争论，何为最好，至今没有一个官方的指导。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。在 Restful API 设计标准之上，我们可以为我们的设计增加一些弹性（团队都认可的方式），每个项目的情况不同，最重要的是项目组成员达成一致的Restful API 设计规则，达到高可用即可 URL 设计学英语，名词（car/animal/teacher）都很好记忆，但是如何用动词和这些名词组合来准确的表达特定的含义却很困难，庆幸的是在 REST 的世界，动词寥寥无几，并且含义单一 ，RESTful 的核心思想也是通过这些动词 + 名词完成对资源的操作与访问，但我们经常看到这样的动词与名词的 URL 组合： /getAllUsers /createNewCompany /updateUserInfo /deleteUser?name=zhangsan 这些 URL 的设计会导致文章开头所说的很多问题，我们进一步来了解如何应用所谓的动词 + 名词 动词动词通常就是 5 种 HTTP 方法，对应我们常见的 CRUD 操作： POST：新建（Create） GET：读取（Read） PUT：更新（Update） PATCH：更新（Update），通常不分更新，也很少用到 DELETE：删除（Delete） 根据 HTTP 规范，动词一律大写，另外根据RESTful 幂等性（多次调用是否会对资源产生影响）原则，我们不能乱用动词，GET/PUT/DELETE 是幂等的，POST/PATCH 不是幂等的 有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。 这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。 12POST /users/12 HTTP/1.1X-HTTP-Method-Override: PUT 上面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST 名词名词就是表示一个资源或者服务，如 /users，/teachers，这里看到我用名词复数的形式描述某一资源，至于用单数还是复数每个人都有自己的见解，我在这里推荐使用复数，因为在现实世界中，资源多数是以集合的形式存在的 动词 + 名词 资源 POST（Create） GET（Read） PUT（Update） DELETE （Delete） /users 创建新用户 查询所有用户 批量更新用户 删除所有用户 /users/12 方法不被允许（405） 查询指定用户 更新指定用户 删除指定用户 1234567POST /usersGET /usersPUT /usersDELETE /usersGET /users/12PUT /users/12DELETE /users/12 上述动词 + 名词的组合是不是清晰多了，没有杂乱的动词在 URL 中，大家的理解含义相同 URL 层级现实中哪有这么简单的 CRUD，资源的相互关联与嵌套很常见，查找 id 是 12 的用户的所有帖子， 如何设计这个 URL，下面两种设计也会有争论： 12GET /users/12/postsGET /posts?userId=12 第一种出现两个名词主题（users/posts），会让人有几秒钟的猜想，这到底请求的是用户资源还是帖子资源，当存在更深浅套的时候也不容易扩展，所以我推荐第二种方式，主体名词 posts 资源明显，其他过滤条件也更容易扩展，比如 /posts?userName=zhangsan，我们可以复用同样的接口 版本我们看到过很多如下 URL 设计，用来区分 API 版本： 12POST /v2/usersGET /V1/users/12 我们都指向同样的资源 users，URL 中为什么要加版本号呢？ 针对这个问题，答案依旧没有统一标准，如果多个版本的API版本返回数据结果结构一样，那没必要区分版本，如果结构已经发生变化，而且要向下兼容，那版本号是很好的区分方式，而且通过 URL 加版本的方式可以更好的发现资源 过滤/分页/排序实际的业务场景中会经常对请求资源做条件筛选，分页显示，以及排序，我们不要为这些业务要求创建不同步的 API，我们应该尽量保持 URL 的信息简单，只需添加查询条件参数来实现上述功能，同时符合”望 URL 知意”的原则 过滤12GET /users/12/posts?state=publishedGET /users/12/posts?published=true 上述两种方式都可以实现资源的过滤 分页1GET /users?pageNo=1&amp;pageSize=20 以分页方式查询用户列表，显示第 2 页内容，每页显示 20 条信息 排序1GET /users?sort=score_desc 按照学生分数降序进行排序 上述所有的方式我们都可以做到”望 URL 知意”，这就是好的设计 返回结果RESTful API 的返回结果也是设计环节中重要的一环 响应数据格式API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。同时客户端也应作出相应的配合，客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json，多渠道调用可能会存在相同资源需要有不同的 producer 类型的情况存在 响应状态码很多后端开发人员可能受开发框架所限，或者返回数据封装形式不够好，经常会给前端人员不是很友好的 HTTP 状态码，比如 response 有 error，却给出 200 HTTP.OK 的状态码 (明明吃了三碗粉，却给两碗粉的钱) 123456789HTTP/1.1 200 OKContent-Type: application/json&#123; \"status\": \"-1\", \"result\": &#123; \"error\": \"分数应小于150\" &#125;&#125; 有人说，我已经标记返回内容 status 是 -1（表示failure）, 用 200 作为状态码也无妨吧？这是一个很错误的观念，RESTful 的设计理念之一是简单直观，试想一下，前端开发人员打开开发者工具，所有请求都是200的状态码，但是页面数据就是没有显示出来，难道前端开发人员还要每个接口调用点开看一看，是哪个 status 是 -1 导致的吗？ 很显然我们不希望这样的情况发生，正确的做法应该类似这样的： 123456789HTTP/1.1 400 Bad RequestContent-Type: application/json&#123; \"status\": \"-1\", \"result\": &#123; \"error\": \"分数应小于150\" &#125;&#125; 下面页列举出来常用的状态码以及表示的含义： 2xx 状态码 200表示成功，同时我们可以表示的更加精确 GET: 200 OK 请求成功 POST: 201 Created 创建成功 PUT: 200 OK 更新成功 DELETE: 204 No Content 找不到要删除的内容 使用状态码 202 有时候会比 使用状态啊吗 201 是更好的选择，状态码 202 的意思是：服务端已接收到了请求，但是还没有创建任何资源，但结果一切正常。 比如： 异步操作：服务器已接收到请求，但是还未处理，但是会在未来处理 资源已经存在，没有创建新的资源 （有些业务可能会返回错误信息”您创建的数据已存在”，所以这种情景没有明确的规定，符合自己的业务需求即可） 4xx 状态码 4xx 状态码表示客户端的错误，主要有以下几种： 400 Bad Request：服务器不理解客户端的请求，未做任何处理 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限 404 Not Found：所请求的资源不存在，或不可用 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式 这里要注意状态码 401 和 403 的区别 5xx 状态码 5xx 状态码表示服务端错误，通常只会用到两个： 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态 无状态过去开发人员通常会将活动的用户信息存储在服务端的 session 中， 这种形式很显然不适用于现在分布式微服务架构的模式，我们可以使用 JWT (JSON Web Token) 如 OAuth2 来实现，这样每次在 Httpheader 中添加 token 来做验证即可 API 文档Swagger是一种广泛使用的工具来用来记录与呈现 REST API，它提供了一种探索特定 API 使用的方法，因此允许开发人员理解底层的语义行为。 这是一种使用注释添加文档的声明性方法，它进一步生成描述 API 及其用法的 JSON，可以实时应对 API 的更新，具体请参考 Swagger 官网 , 同时使用 Spring Boot 的小伙伴也可以很轻松的集成 Swagger，只需引入Swagger Starter 12345&lt;dependency&gt; &lt;groupId&gt;com.spring4all&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; HATEOASHATEOAS (Hypermedia As Transfer Engine Of Application State), API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS , 举个例子，列表页数据通常会有查看操作，这样我们在返回列表页的数据的时候同样返回如何操作查看具体数据详情的 API 接口： 123456789101112&#123; \"status\": \"-1\", \"result\": [&#123; \"id\": 1, \"name\": \"zhangsan\", \"links\":[ &#123; \"href\": \"http://localhost:8080/user/&#123;id&#125;\" &#125; ] &#125;]&#125; 使用 Spring 框架的小伙伴可以快速的体验一下这种方式，Spring 官网项目 Spring HATEOAS , 会快速的将参数都做替换, 将查看 API URL 中的 id 直接替换成 1。 123456789101112&#123; \"status\": \"-1\", \"result\": [&#123; \"id\": 1, \"name\": \"zhangsan\", \"links\":[ &#123; \"href\": \"http://localhost:8080/user/1\" &#125; ] &#125;]&#125; 提升效率工具RestfulToolkit后端开发人员可以安装 IntellJ idea 插件 RestfulToolkit, Mac 环境使用快捷键 CMD + \\ 输入关键字快速定位到 API 位置 同时在右侧工具栏打开 API，会自动生成 demoData 请求参数，实现快速调用测试： JSON-ViewerJSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入json-viewer + TAB ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题 另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便 PostmanPostman 功能十分强大， 搜索 Postman 自定义环境变量，会打开新世界的大门 写在最后如何设计出最好的 RESTful API 永远不会有结论，设计出高可用，团队认可，简单清晰明了的 RESTful API 就是好的。 欢迎交流你们在团队中是如何设计 RESTful API 的，遇到了哪些问题，是如何解决和规范的","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"安全-协议-规范","slug":"Coding/安全-协议-规范","permalink":"https://dayarch.top/categories/Coding/%E5%AE%89%E5%85%A8-%E5%8D%8F%E8%AE%AE-%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://dayarch.top/tags/RESTful/"},{"name":"HTTP","slug":"HTTP","permalink":"https://dayarch.top/tags/HTTP/"}]},{"title":"Excel的公式使用","slug":"Excel的公式使用","date":"2019-05-10T02:15:39.000Z","updated":"2019-12-15T13:04:23.475Z","comments":true,"path":"/p/excel-formula.html","link":"","permalink":"https://dayarch.top/p/excel-formula.html","excerpt":"前言 最近在做基础数据的整理，数据存放在 Word 表格中，要将大量的数据整理好并导入到数据库中着实需要费些力气，于是需要笨方法和巧方法一起用 整理过程 首先应用笨方法，将 Word 中的数据表格拷贝到 Excel 中，貌似这是必须的，由于拷贝过来的表格有合并单元格的情况，所以我们要将 Excel 中的表格标准化 Excel通过公式拼接字符串换行 我们通常都会通过Excel公式=CONCATENATE(Text1,[Text2])来拼接字符串，当我们需要拼接的字符串中需要换行时我们可以使用CHAR(10)来完成拼接换行符，请看如下例子 =CONCATENATE(\"hello\",CHAR(","text":"前言最近在做基础数据的整理，数据存放在 Word 表格中，要将大量的数据整理好并导入到数据库中着实需要费些力气，于是需要笨方法和巧方法一起用 整理过程首先应用笨方法，将 Word 中的数据表格拷贝到 Excel 中，貌似这是必须的，由于拷贝过来的表格有合并单元格的情况，所以我们要将 Excel 中的表格标准化 Excel通过公式拼接字符串换行我们通常都会通过Excel公式=CONCATENATE(Text1,[Text2])来拼接字符串，当我们需要拼接的字符串中需要换行时我们可以使用CHAR(10)来完成拼接换行符，请看如下例子 =CONCATENATE(&quot;hello&quot;,CHAR(10),&quot;world&quot;)输出结果如下： hello worldNOTE: 使用拼接字符串公式的单元格请设置为常规，不要是自动换行. 取消合并单元格 将 Excel 全部选中，然后点击取消单元格 将空单元格进行字段的填充 我们看到拆分后的单元格好多都是空的，我们需要将空的单元格填充为它上面一行的数据 选中待处理的单元格 按F5 在弹出框的位置选择空值选项 键盘输入等于号”=”，然后敲击向上方向键 Ctrl + Enter 组合完成 修改 Excel 的默认语言 我用的Mac 英文版，打开 Excel 没有类似 LENB() 这样的函数，所以我需要将语言就改为中文 12345# 修改 Excel 语言defaults write com.microsoft.Excel AppleLanguages '(\"zh-tw\")'# 修改 Word 语言defaults write com.microsoft.Word AppleLanguages '(\"zh-tw\")' 数字与汉字的拆分 拷贝过来的数据，需要做K-V 的映射，将一段文字中的数字提取出来作为 key， 将文本中的汉字提取出来作为 Value，所以需要用到两组公式： LEFT(单元格, length) / RIGHT(单元格, length) LEFT: 从单元格内容开始位置截取指定长度内容； RIGHT: 从单元格内容末尾位置截取指定长度内容； LEN(单元格) / LENB(单元格) LEN是返回字符串的字符数; LENB是返回字符串的字节数; 数字、字母、英文、标点符号（半角状态）都是按1计算的，汉字、全角状态下的标点符号，每个字符按2计算 阿拉伯数字转罗马数字 只需要应用公式：= ROMAN(A16) 罗马数字转阿拉伯数字 同样应用公式：=MATCH(B16,INDEX(ROMAN(ROW(INDIRECT(“1:4000”))),0),0) 以上就是这次数据提取用到的一些公式 附录在此处附上 office 的各种语言字典码","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"https://dayarch.top/tags/Excel/"}]},{"title":"双亲委派模型","slug":"双亲委派模型","date":"2019-04-26T06:56:22.000Z","updated":"2019-11-07T06:37:53.347Z","comments":true,"path":"/p/java-parents-delegation-model.html","link":"","permalink":"https://dayarch.top/p/java-parents-delegation-model.html","excerpt":"双亲委派模型 在介绍这个Java技术点之前，先试着思考以下几个问题： 1. 为什么我们不能定义同名的 String 的 java 文件？ 2. 多线程的情况下，类的加载为什么不会出现重复加载的情况？ 3. 下面代码，虚拟机是怎样初始化注册 Mysql 连接驱动(Driver)的？ 1 Connection conn= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK\", \"root\",","text":"双亲委派模型在介绍这个Java技术点之前，先试着思考以下几个问题： 为什么我们不能定义同名的 String 的 java 文件？ 多线程的情况下，类的加载为什么不会出现重复加载的情况？ 下面代码，虚拟机是怎样初始化注册 Mysql 连接驱动(Driver)的？ 1Connection conn= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK&quot;, &quot;root&quot;, &quot;000000&quot;); 热部署的原理是什么？ 想理解以上几个问题的前提是了解类加载时机与过程, 这篇文章将会以非常详细的解读方式来回答以上几个问题 类加载时机与过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 加载在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头（当class文件以二进制形式打开，会看到这个文件头，cafebabe）、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值通常情况下是数据类型的零值，假设一个类变量的定义为： 12// 变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行public static int value=123; 有通常情况就有特殊情况，这里的特殊是指： 12// 当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0public static final int value=123; 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 初始化在介绍初始化时，要先介绍两个方法：&lt;clinit&gt; 和 &lt;init&gt; : 在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法, 另一个是实例的初始化方法 clinit&gt;：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行 &lt;init&gt;: 在实例创建出来的时候调用，包括调用new操作符；调用 Class 或 Java.lang.reflect.Constructor 对象的newInstance()方法；调用任何现有对象的clone()方法；通过 java.io.ObjectInputStream 类的getObject() 方法反序列化。 类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备极端，变量已经付过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主管计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程. &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 static{} 中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下： 1234567public class Test &#123; static &#123; i=0; System.out.println(i); //这句编译器会报错：Illegal forward reference (不合法的向前引用) &#125; static int i=1;&#125; 那么去掉报错的那句，改成下面： 1234567891011public class Test &#123; static &#123; i=0; // System.out.println(i); //这句编译器会报错：Illegal forward reference (不合法的向前引用) &#125; static int i=1; public static void main(String args[])&#123; System.out.println(i); &#125;&#125; 输出结果：1 为什么输出结果是1，在准备阶段我们知道 i=0，然后类初始化阶段按照顺序执行，首先执行 static 块中的 i=0,接着执行 static赋值操作i=1, 最后在 main 方法中获取 i 的值为1 &lt;clinit&gt;()方法与实例构造器&lt;init&gt;()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类&lt;init&gt;()方法执行之前，父类的&lt;clinit&gt;()方法方法已经执行完毕 由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。 &lt;clinit&gt;()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产&lt;clinit&gt;()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。 让我们来验证上面的加载规则 虚拟机会保证在子类&lt;init&gt;()方法执行之前，父类的&lt;clinit&gt;()方法方法已经执行完毕 123456789101112131415161718192021222324252627282930313233343536373839404142public class SSClass&#123; static &#123; System.out.println(\"SSClass\"); &#125;&#125;public class SuperClass extends SSClass&#123; static &#123; System.out.println(\"SuperClass init!\"); &#125; public static int value = 123; public SuperClass() &#123; System.out.println(\"init SuperClass\"); &#125;&#125;public class SubClass extends SuperClass&#123; static &#123; System.out.println(\"SubClass init\"); &#125; static int a; public SubClass() &#123; System.out.println(\"init SubClass\"); &#125;&#125;public class NotInitialization&#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 输出结果 123SSClassSuperClass init!123 通过数组定义来引用类，不会触发此类的初始化(我的理解是数组的父类是Object) 1234567public class NotInitialization&#123; public static void main(String[] args) &#123; SuperClass[] sca = new SuperClass[10]; &#125;&#125; 输出结果：无 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 123456789101112131415public class ConstClass&#123; static &#123; System.out.println(\"ConstClass init!\"); &#125; public static final String HELLOWORLD = \"hello world\";&#125;public class NotInitialization&#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLOWORLD); &#125;&#125; 输出结果： 1hello world 验证小结 虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）： 遇到 new, getstatic, putstatic, invokestatic 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用jdk1.7动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getstatic, REF_putstatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。 有了这个加载规则的印象，双亲委派模型就很好理解了，别着急，继续向下看, 你会发现你的理解层面提高了 双亲委派模型刚看到这个词汇的时候我是完全懵懂的状态，其实就是定义了 JVM 启动的时候类的加载规则, 大家要按规矩办事，好办事，来看下图： 所谓双亲委派是指每次收到类加载请求时，先将请求委派给父类加载器完成（所有加载请求最终会委派到顶层的Bootstrap ClassLoader加载器中），如果父类加载器无法完成这个加载（该加载器的搜索范围中没有找到对应的类），子类尝试自己加载， 如果都没加载到，则会抛出 ClassNotFoundException 异常， 看到这里其实就解释了文章开头提出的第一个问题，父加载器已经加载了JDK 中的 String.class 文件，所以我们不能定义同名的 String java 文件。 为什么会有这样的规矩设定？ 因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String 已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。 我们发现除了启动类加载器（BootStrap ClassLoader），每个类都有其”父类”加载器 ⚠️ 其实这里的父子关系是组合模式，不是继承关系来实现 从图中可以看到类 AppClassLoader 和 ExtClassLoader 都继承 URLClassLoader， 而 URLClassLoader 又继承 ClassLoader， 在 ClassLoader 中有一个属性 1234// The parent class loader for delegation// Note: VM hardcoded the offset of this field, thus all new fields// must be added *after* it.private final ClassLoader parent; 在通过构造函数实例化 AppClassLoader 和 ExtClassLoader 的时候都要传入一个 classloader 作为当前 classloader 的 parent 12345AppClassLoader(URL[] var1, ClassLoader var2) &#123; // 通过层层调用 super，最后指定到 ClassLoader.java 中的 parent 属性 super(var1, var2, Launcher.factory); this.ucp.initLookupCache(this);&#125; 顶层ClassLoader有几个函数很关键，先有个印象 指定保护域（protectionDomain），把ByteBuffer的内容转换成 Java 类，这个方法被声明为final的 1defineClass(String name, java.nio.ByteBuffer b,ProtectionDomain protectionDomain) 把字节数组 b中的内容转换成 Java 类，其开始偏移为off,这个方法被声明为final的 1defineClass(String name, byte[] b, int off, int len) 查找指定名称的类 1findClass(String name) 链接指定的类 1resolveClass(Class&lt;?&gt;) 类加载器责任范围上面我们提到每个加载器都有对应的加载搜索范围 Bootstrap ClassLoader:这个加载器不是一个Java类，而是由底层的c++实现，负责在虚拟机启动时加载Jdk核心类库（如：rt.jar、resources.jar、charsets.jar等）以及加载后两个类加载器。这个ClassLoader完全是JVM自己控制的，需要加载哪个类，怎么加载都是由JVM自己控制，别人也访问不到这个类 Extension ClassLoader:是一个普通的Java类，继承自ClassLoader类，负责加载{JAVA_HOME}/jre/lib/ext/目录下的所有jar包。 App ClassLoader：是Extension ClassLoader的子对象，负责加载应用程序classpath目录下的所有jar和class文件。 123456789101112131415/** * 测试类加载器加载目录 */public class TestClassLoaderPath &#123; public static void main(String[] args)throws Exception&#123; // BootStrap ClassLoader加载的文件 System.out.println(System.getProperty(\"sun.boot.class.path\")); // ExtClassLoader加载的文件 System.out.println(System.getProperty(\"java.ext.dirs\")); // AppClassLoader加载的文件 System.getProperty(\"java.class.path\") &#125;&#125; 大家自行运行这个文件，就可以看到每个类加载器加载的文件了 两种类的加载方式通常用这两种方式来动态加载一个 java 类，Class.forName() 与 ClassLoader.loadClass() 但是两个方法之间也是有一些细微的差别 Class.forName() 方式查看Class类的具体实现可知，实质上这个方法是调用原生的方法： 1private static native Class&lt;?&gt; forName0(String name, boolean initialize,ClassLoader loader); 形式上类似于Class.forName(name,true,currentLoader)。 综上所述，Class.forName 如果调用成功会： 保证一个Java类被有效得加载到内存中； 类默认会被初始化，即执行内部的静态块代码以及保证静态属性被初始化； 默认会使用当前的类加载器来加载对应的类。 ClassLoader.loadClass方式如果采用这种方式的类加载策略，由于双亲托管模型的存在，最终都会将类的加载任务交付给Bootstrap ClassLoader进行加载。跟踪源代码，最终会调用原生方法： 1private native Class&lt;?&gt; findBootstrapClass(String name); 与此同时，与上一种方式的最本质的不同是，类不会被初始化，只有显式调用才会进行初始化。综上所述，ClassLoader.loadClass 如果调用成功会： 类会被加载到内存中； 类不会被初始化，只有在之后被第一次调用时类才会被初始化； 之所以采用这种方式的类加载，是提供一种灵活度，可以根据自身的需求继承ClassLoader类实现一个自定义的类加载器实现类的加载。（很多开源Web项目中都有这种情况，比如tomcat，struct2，jboss。原因是根据Java Servlet规范的要求，既要Web应用自己的类的优先级要高于Web容器提供的类，但同时又要保证Java的核心类不被任意覆盖，此时重写一个类加载器就很必要了） 双亲委派模型源码分析Launcher分析类加载器源码要从 sun.misc.Launcher.class 文件看起, 关键代码已添加注释，同时可以在此类中看到 ExtClassLoader 和 AppClassLoader 的定义，也验证了我们上文提到的他们不是继承关系，而是通过指定 parent 属性来形成的组合模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public Launcher() &#123; Launcher.ExtClassLoader var1; try &#123; // 获取扩展类加载器 var1 = Launcher.ExtClassLoader.getExtClassLoader(); &#125; catch (IOException var10) &#123; throw new InternalError(\"Could not create extension class loader\", var10); &#125; try &#123; // 获取应用程序类加载器，同时指定 parent 是var1（扩展类加载器） this.loader = Launcher.AppClassLoader.getAppClassLoader(var1); &#125; catch (IOException var9) &#123; throw new InternalError(\"Could not create application class loader\", var9); &#125; // 设置AppClassLoader为线程上下文类加载器（很关键），破坏双亲委派模型都要用到这个机制 Thread.currentThread().setContextClassLoader(this.loader); String var2 = System.getProperty(\"java.security.manager\"); if (var2 != null) &#123; SecurityManager var3 = null; if (!\"\".equals(var2) &amp;&amp; !\"default\".equals(var2)) &#123; try &#123; // 调用loadClass函数，这里的loader是AppClassLoader var3 = (SecurityManager)this.loader.loadClass(var2).newInstance(); &#125; catch (IllegalAccessException var5) &#123; &#125; catch (InstantiationException var6) &#123; &#125; catch (ClassNotFoundException var7) &#123; &#125; catch (ClassCastException var8) &#123; &#125; &#125; else &#123; var3 = new SecurityManager(); &#125; if (var3 == null) &#123; throw new InternalError(\"Could not create SecurityManager: \" + var2); &#125; System.setSecurityManager(var3); &#125; &#125;...// 静态内部类ExtClassLoaderstatic class ExtClassLoader extends java.net.URLClassLoader&#123; ...&#125;// 静态内部类AppClassLoaderstatic class AppClassLoader extends java.net.URLClassLoader&#123; ...&#125; 进入上面第25行的 loadClass 方法中 123456789101112131415161718192021222324252627282930313233343536373839protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; // parent为空，交给BootStrapClassLoader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //URLClassLoader重写了ClassLoader的findClass方法，会调用defineClass方法形成一个Java类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 我们看到方法有同步块（synchronized）, 这也就解释了文章开头第2个问题，多线程情况不会出现重复加载的情况。同时会询问parent classloader是否有加载，如果没有，自己尝试加载。 URLClassLoader中的 findClass方法： 123456789101112131415161718192021222324252627282930protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException &#123; final Class&lt;?&gt; result; try &#123; result = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123; public Class&lt;?&gt; run() throws ClassNotFoundException &#123; String path = name.replace('.', '/').concat(\".class\"); Resource res = ucp.getResource(path, false); if (res != null) &#123; try &#123; // 定义Class return defineClass(name, res); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name, e); &#125; &#125; else &#123; return null; &#125; &#125; &#125;, acc); &#125; catch (java.security.PrivilegedActionException pae) &#123; throw (ClassNotFoundException) pae.getException(); &#125; if (result == null) &#123; throw new ClassNotFoundException(name); &#125; return result; &#125; 借用网友的一个加载时序图来解释整个过程更加清晰： 双亲委派模型的破坏Java本身有一套资源管理服务JNDI，是放置在rt.jar中，由启动类加载器加载的。以对数据库管理JDBC为例，java给数据库操作提供了一个Driver接口： 1234567891011121314151617package java.sql;public interface Driver &#123; Connection connect(String url, java.util.Properties info) throws SQLException; boolean acceptsURL(String url) throws SQLException; DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info) throws SQLException; int getMajorVersion(); int getMinorVersion(); boolean jdbcCompliant(); public Logger getParentLogger() throws SQLFeatureNotSupportedException;&#125; 然后提供了一个DriverManager来管理这些Driver的具体实现： 123456789101112131415public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(\"registerDriver: \" + driver); &#125; 这里省略了大部分代码，可以看到我们使用数据库驱动前必须先要在DriverManager中使用registerDriver()注册，然后我们才能正常使用。 不破坏双亲委派模型的情况（不使用JNDI服务）我们看下mysql的驱动是如何被加载的： 1234// 1.加载数据访问驱动，以Class.forName的方式加载，会初始化Class.forName(\"com.mysql.jdbc.Driver\");//2.连接到数据\"库\"上去Connection conn= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK\", \"root\", \"\"); 核心就是这句Class.forName()触发了mysql驱动的加载，我们看下mysql对Driver接口的实现： 12345678910111213141516171819202122public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; 可以看到，Class.forName()其实触发了静态代码块，然后向DriverManager中注册了一个mysql的Driver实现。这个时候，我们通过DriverManager去获取connection的时候只要遍历当前所有Driver实现，然后选择一个建立连接就可以了。 破坏双亲委派模型的情况在JDBC4.0以后，开始支持使用spi的方式来注册这个Driver，具体做法就是在mysql的jar包中的META-INF/services/java.sql.Driver 文件中指明当前使用的Driver是哪个，然后使用的时候就直接这样就可以了： 1Connection conn= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK\", \"root\", \"\"); 可以看到这里直接获取连接，省去了上面的Class.forName()注册过程。 现在，我们分析下看使用了这种spi服务的模式原本的过程是怎样的: 第一，从META-INF/services/java.sql.Driver文件中获取具体的实现类名“com.mysql.jdbc.Driver” 第二，加载这个类，这里肯定只能用class.forName(“com.mysql.jdbc.Driver”)来加载 好了，问题来了，Class.forName()加载用的是调用者的Classloader，这个调用者DriverManager是在rt.jar中的，ClassLoader是启动类加载器，而com.mysql.jdbc.Driver肯定不在/lib下，所以肯定是无法加载mysql中的这个类的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。 那么，这个问题如何解决呢？按照目前情况来分析，这个mysql的drvier只有应用类加载器能加载，那么我们只要在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。 文章前半段提到线程上下文类加载器可以通过 Thread.setContextClassLoaser() 方法设置，如果不特殊设置会从父类继承，一般默认使用的是应用程序类加载器 很明显，线程上下文类加载器让父级类加载器能通过调用子级类加载器来加载类，这打破了双亲委派模型的原则 现在我们看下DriverManager是如何使用线程上下文类加载器去加载第三方jar包中的Driver类的，先来看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class DriverManager &#123; static &#123; loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); &#125; private static void loadInitialDrivers() &#123; String drivers; try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(\"jdbc.drivers\"); &#125; &#125;); &#125; catch (Exception ex) &#123; drivers = null; &#125; // If the driver is packaged as a Service Provider, load it. // Get all the drivers through the classloader // exposed as a java.sql.Driver.class service. // ServiceLoader.load() replaces the sun.misc.Providers() AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; // ServiceLoader 是 implements Iterable&lt;S&gt;的一个类，并重写了 iterator 方法（很关键） ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); /* Load these drivers, so that they can be instantiated. * It may be the case that the driver class may not be there * i.e. there may be a packaged driver with the service class * as implementation of java.sql.Driver but the actual class * may be missing. In that case a java.util.ServiceConfigurationError * will be thrown at runtime by the VM trying to locate * and load the service. * * Adding a try catch block to catch those runtime errors * if driver not available in classpath but it's * packaged as service and that service is there in classpath. */ try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; &#125; catch(Throwable t) &#123; // Do nothing &#125; return null; &#125; &#125;); println(\"DriverManager.initialize: jdbc.drivers = \" + drivers); if (drivers == null || drivers.equals(\"\")) &#123; return; &#125; String[] driversList = drivers.split(\":\"); println(\"number of Drivers:\" + driversList.length); for (String aDriver : driversList) &#123; try &#123; println(\"DriverManager.Initialize: loading \" + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println(\"DriverManager.Initialize: load failed: \" + ex); &#125; &#125; &#125;&#125; 使用时，我们直接调用DriverManager.getConnection() 方法自然会触发静态代码块的执行，开始加载驱动然后我们看下ServiceLoader.load()的具体实现： 12345678public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; // 上文介绍类加载源码时，注释说明过设置AppClassLoader为上下文加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl);&#125;public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader)&#123; return new ServiceLoader&lt;&gt;(service, loader);&#125; 继续向下看构造函数实例化 ServiceLoader 做了哪些事情： 123456private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123; service = Objects.requireNonNull(svc, \"Service interface cannot be null\"); loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload();&#125; 查看 reload() 函数： 1234public void reload() &#123; providers.clear(); lookupIterator = new LazyIterator(service, loader);&#125; 继续查看LazyIterator构造器，该类同样实现了Iterator接口： 1234private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123; this.service = service; this.loader = loader;&#125; 实例化到这里我们也将上下文得到的类加载器实例化到这里，来回看ServiceLoader 重写的 iterator() 方法： 12345678910111213141516171819202122232425public Iterator&lt;S&gt; iterator() &#123; return new Iterator&lt;S&gt;() &#123; Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() &#123; if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); &#125; // DriverManager 类中 driversIterator 调用的next() 方法实际是这个方法 public S next() &#123; if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125;;&#125; 上面next() 方法调用了lookupIterator.next()，这个lookupIterator 就是刚刚实例化的 LazyIterator(); 来看next方法 12345678910public S next() &#123; if (acc == null) &#123; return nextService(); &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125;&#125; 继续查看nextService 方法： 1234567891011121314151617181920212223private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; c = Class.forName(cn, false, loader); &#125; catch (ClassNotFoundException x) &#123; fail(service, \"Provider \" + cn + \" not found\"); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, \"Provider \" + cn + \" not a subtype\"); &#125; try &#123; S p = service.cast(c.newInstance()); providers.put(cn, p); return p; &#125; catch (Throwable x) &#123; fail(service, \"Provider \" + cn + \" could not be instantiated\", x); &#125; throw new Error(); // This cannot happen&#125; 终于到这里了，在上面 nextService函数中第8行调用了c = Class.forName(cn, false, loader) 方法，我们成功的做到了通过线程上下文类加载器拿到了应用程序类加载器（或者自定义的然后塞到线程上下文中的），同时我们也查找到了厂商在子级的jar包中注册的驱动具体实现类名，这样我们就可以成功的在rt.jar包中的DriverManager中成功的加载了放在第三方应用程序包中的类了同时在第16行完成Driver的实例化，等同于new Driver(); 文章开头的问题在理解到这里也迎刃而解了 JAVA热部署实现首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。 另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。 热部署步骤： 销毁自定义classloader(被该加载器加载的class也会自动卸载)； 更新class 使用新的ClassLoader去加载class JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）： 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。 加载该类的ClassLoader已经被GC。 该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法 自定义类加载器要创建用户自己的类加载器，只需要继承java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，即指明如何获取类的字节码流。 如果要符合双亲委派规范，则重写findClass方法（用户自定义类加载逻辑）；要破坏的话，重写loadClass方法(双亲委派的具体逻辑实现)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package classloader;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;class TestClassLoad &#123; @Override public String toString() &#123; return \"类加载成功。\"; &#125;&#125;public class PathClassLoader extends ClassLoader &#123; private String classPath; public PathClassLoader(String classPath) &#123; this.classPath = classPath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getData(String className) &#123; String path = classPath + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try &#123; InputStream is = new FileInputStream(path); ByteArrayOutputStream stream = new ByteArrayOutputStream(); byte[] buffer = new byte[2048]; int num = 0; while ((num = is.read(buffer)) != -1) &#123; stream.write(buffer, 0, num); &#125; return stream.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String args[]) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; ClassLoader pcl = new PathClassLoader(\"D:\\\\ProgramFiles\\\\eclipseNew\\\\workspace\\\\cp-lib\\\\bin\"); Class c = pcl.loadClass(\"classloader.TestClassLoad\");//注意要包括包名 System.out.println(c.newInstance());//打印类加载成功. &#125;&#125; 感谢与参考非常感谢以下博文的作者，通过反复拜读来了解双亲委派模型的原理 https://blog.csdn.net/u014634338/article/details/81434327 https://www.cnblogs.com/aspirant/p/7200523.html https://www.cnblogs.com/gdpuzxs/p/7044963.html https://www.jianshu.com/p/09f73af48a98 https://www.cnblogs.com/yahokuma/p/3668138.html","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://dayarch.top/tags/ClassLoader/"},{"name":"热部署","slug":"热部署","permalink":"https://dayarch.top/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"}]},{"title":"PKIX证书导入","slug":"PKIX证书导入","date":"2019-04-12T03:55:47.000Z","updated":"2019-12-21T11:12:55.103Z","comments":true,"path":"/p/pkix-certificate-import.html","link":"","permalink":"https://dayarch.top/p/pkix-certificate-import.html","excerpt":"通过理解SSL握手过程解决客户端证书问题最近做项目，调用远程服务器突然出现如下错误： 1 PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 很明显，客户端找不到服务器端返回的public certificate，所以我们需要拿到服务器给客户端的证书，并且存放到Keystore中，这就涉及到SSL握手（handshake）获取信任的过程。 图解","text":"通过理解SSL握手过程解决客户端证书问题 最近做项目，调用远程服务器突然出现如下错误： 1PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 很明显，客户端找不到服务器端返回的public certificate，所以我们需要拿到服务器给客户端的证书，并且存放到Keystore中，这就涉及到SSL握手（handshake）获取信任的过程。 图解SSL（Secure Socket Layer）协议开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake） 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法 服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random） 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端 服务端使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret） 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程 以上就是握手的整个过程，其中握手阶段有三点需要注意 生成对话密钥一共需要三个随机数。 握手之后的对话使用”对话密钥”加密（对称加密），服务器的公钥和私钥只用于加密和解密”对话密钥”（非对称加密RSA），无其他作用。 服务器公钥放在服务器的数字证书之中。 SSL具体握手过程用-Djavax.net.debug=all来开启调试信息的输出，SSL的握手过程一目了然： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174182018-02-01 17:05:24 --INFO-- ***Helper : https://xxx.xxx.com:8443/***/ws/***ServiceIgnoring unsupported cipher suite: TLS_DHE_DSS_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_DHE_DSS_WITH_AES_256_CBC_SHA256Ignoring unsupported cipher suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_DHE_RSA_WITH_AES_256_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_RSA_WITH_AES_256_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_RSA_WITH_AES_128_CBC_SHA256Allow unsafe renegotiation: falseAllow legacy hello messages: trueIs initial handshake: trueIs secure renegotiation: false%% Client cached [Session-5, TLS_RSA_WITH_AES_256_CBC_SHA]%% Try resuming [Session-5, TLS_RSA_WITH_AES_256_CBC_SHA] from port 12371##客户端跟服务器第一次打招呼##*** ClientHello, TLSv1RandomCookie: GMT: 1517410388 bytes = &#123; 95, 120, 132, 216, 69, 34, 205, 73, 133, 30, 240, 178, 37, 187, 228, 127, 73, 149, 1, 216, 19, 3, 35, 236, 29, 111, 125, 132 &#125;Session ID: &#123;248, 40, 73, 62, 46, 20, 43, 249, 49, 73, 148, 196, 222, 200, 202, 68, 221, 241, 33, 57, 128, 93, 149, 1, 7, 112, 248, 66, 173, 203, 187, 1&#125;##支持的加密算法##Cipher Suites: [TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, SSL_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA, SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA, SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA, SSL_RSA_WITH_RC4_128_SHA, TLS_ECDH_ECDSA_WITH_RC4_128_SHA, TLS_ECDH_RSA_WITH_RC4_128_SHA, SSL_RSA_WITH_RC4_128_MD5, TLS_EMPTY_RENEGOTIATION_INFO_SCSV]Compression Methods: &#123; 0 &#125;Extension elliptic_curves, curve names: &#123;secp256r1, sect163k1, sect163r2, secp192r1, secp224r1, sect233k1, sect233r1, sect283k1, sect283r1, secp384r1, sect409k1, sect409r1, secp521r1, sect571k1, sect571r1, secp160k1, secp160r1, secp160r2, sect163r1, secp192k1, sect193r1, sect193r2, secp224k1, sect239k1, secp256k1&#125;Extension ec_point_formats, formats: [uncompressed]Extension server_name, server_name: [host_name: idmtest.dcpc.com]***[write] MD5 and SHA1 hashes: len = 2200000: 01 00 00 D8 03 01 5A 72 D8 54 5F 78 84 D8 45 22 ......Zr.T_x..E\"0010: CD 49 85 1E F0 B2 25 BB E4 7F 49 95 01 D8 13 03 .I....%...I........DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Handshake, length = 220[Raw write]: length = 2250000: 16 03 01 00 DC 01 00 00 D8 03 01 5A 72 D8 54 5F ...........Zr.T_0010: 78 84 D8 45 22 CD 49 85 1E F0 B2 25 BB E4 7F 49 x..E\".I....%...I...[Raw read]: length = 50000: 16 03 01 06 22 ....\"[Raw read]: length = 15700000: 02 00 00 46 03 01 5A 72 63 4E F2 CF 4B 0F CE 58 ...F..ZrcN..K..X0010: 0E EF 36 D4 F3 3E C0 85 AD 6D 4B 8D DB CA FB 77 ..6..&gt;...mK....w0020: 80 B3 A1 D2 A7 90 20 D5 A6 FD 6E A7 FF 5A D4 DF ...... ...n..Z.....DefaultQuartzScheduler_Worker-3, READ: TLSv1 Handshake, length = 1570##服务器响应*** ServerHello, TLSv1RandomCookie: GMT: 1517445966 bytes = &#123; 242, 207, 75, 15, 206, 88, 14, 239, 54, 212, 243, 62, 192, 133, 173, 109, 75, 141, 219, 202, 251, 119, 128, 179, 161, 210, 167, 144 &#125;Session ID: &#123;213, 166, 253, 110, 167, 255, 90, 212, 223, 9, 221, 44, 82, 61, 249, 50, 79, 110, 177, 174, 106, 198, 101, 47, 213, 191, 119, 128, 106, 200, 188, 1&#125;##服务器选定的加密算法Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHACompression Method: 0***Warning: No renegotiation indication extension in ServerHello%% Initialized: [Session-8, TLS_RSA_WITH_AES_256_CBC_SHA]** TLS_RSA_WITH_AES_256_CBC_SHA[read] MD5 and SHA1 hashes: len = 740000: 02 00 00 46 03 01 5A 72 63 4E F2 CF 4B 0F CE 58 ...F..ZrcN..K..X0010: 0E EF 36 D4 F3 3E C0 85 AD 6D 4B 8D DB CA FB 77 ..6..&gt;...mK....w...##服务器返回给客户端的证书链,证明“我是我”*** Certificate chainchain [0] = [[ Version: V3 Subject: CN=*.****.com, ST=北京市, L=北京市, O=***公司, C=CN Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11 Key: Sun RSA public key, 2048 bits modulus: 256891288892062675553247103925... public exponent: 65537 Validity: [From: Wed May 17 16:15:30 CST 2017, To: Fri May 15 16:15:30 CST 2020] Issuer: CN=WoSign OV SSL CA, O=WoSign CA Limited, C=CN SerialNumber: [ 363fa17d 5c46082c dc707c24 6a8d81b2]Certificate Extensions: 9[1]: ObjectId: 1.3.6.1.5.5.7.1.1 Criticality=falseAuthorityInfoAccess [[ accessMethod: ocsp accessLocation: URIName: http://wosign-ovca.ocsp-certum.com, accessMethod: caIssuers accessLocation: URIName: http://repository.certum.pl/wosign-ovca.cer]][2]: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: A1 13 54 DC 56 73 2C 27 82 CA C8 84 EF EE BF 00 ..T.Vs,'........0010: FD 5F AB 56 ._.V]][3]: ObjectId: 2.5.29.19 Criticality=trueBasicConstraints:[ CA:false PathLen: undefined][4]: ObjectId: 2.5.29.31 Criticality=falseCRLDistributionPoints [ [DistributionPoint: [URIName: http://wosign.crl.certum.pl/wosign-ovca.crl]]][5]: ObjectId: 2.5.29.32 Criticality=falseCertificatePolicies [ [CertificatePolicyId: [2.23.140.1.2.2][] ] [CertificatePolicyId: [1.2.616.1.113527.2.5.1.12.2][PolicyQualifierInfo: [ qualifierID: 1.3.6.1.5.5.7.2.2 qualifier:0000: 30 81 E4 30 1F 16 18 41 73 73 65 63 6F 20 44 61 0..0...Asseco Da0010: 74 61 20 53 79 73 74 65 6D 73 20 53 2E 41 2E 30 ta Systems S.A.0...]] ]][6]: ObjectId: 2.5.29.37 Criticality=falseExtendedKeyUsages [ serverAuth clientAuth][7]: ObjectId: 2.5.29.15 Criticality=trueKeyUsage [ DigitalSignature Key_Encipherment][8]: ObjectId: 2.5.29.17 Criticality=falseSubjectAlternativeName [ DNSName: *.dcpc.com DNSName: dcpc.com][9]: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: B3 A6 53 AD 96 D8 B7 51 09 D5 E1 07 E5 B2 BC E6 ..S....Q........0010: B5 F2 82 2B ...+]]] Algorithm: [SHA256withRSA] Signature:0000: 9A 38 A4 8F B2 A8 CE 9A B6 98 2F 8F 18 AA 45 79 .8......../...Ey0010: DE D6 31 22 99 6E D7 14 45 5E C1 1F 06 EC 7F C9 ..1\".n..E^.........]***==客户端从本地找到的信赖证书(如果找不到会直接报certificate_unknow)==Found trusted certificate:[[ Version: V3 Subject: CN=*.****.com, ST=北京市, L=北京市, O=****公司, C=CN Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11 Key: Sun RSA public key, 2048 bits modulus: 2568912888920626755532471039254124.... public exponent: 65537 Validity: [From: Wed May 17 16:15:30 CST 2017, To: Fri May 15 16:15:30 CST 2020] Issuer: CN=WoSign OV SSL CA, O=WoSign CA Limited, C=CN SerialNumber: [ 363fa17d 5c46082c dc707c24 6a8d81b2]Certificate Extensions: 9[1]: ObjectId: 1.3.6.1.5.5.7.1.1 Criticality=falseAuthorityInfoAccess [ [ accessMethod: ocsp accessLocation: URIName: http://wosign-ovca.ocsp-certum.com, accessMethod: caIssuers accessLocation: URIName: http://repository.certum.pl/wosign-ovca.cer]][2]: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: A1 13 54 DC 56 73 2C 27 82 CA C8 84 EF EE BF 00 ..T.Vs,'........0010: FD 5F AB 56 ._.V]][3]: ObjectId: 2.5.29.19 Criticality=trueBasicConstraints:[ CA:false PathLen: undefined][4]: ObjectId: 2.5.29.31 Criticality=falseCRLDistributionPoints [ [DistributionPoint: [URIName: http://wosign.crl.certum.pl/wosign-ovca.crl]]][5]: ObjectId: 2.5.29.32 Criticality=falseCertificatePolicies [ [CertificatePolicyId: [2.23.140.1.2.2][] ] [CertificatePolicyId: [1.2.616.1.113527.2.5.1.12.2][PolicyQualifierInfo: [ qualifierID: 1.3.6.1.5.5.7.2.2 qualifier:0000: 30 81 E4 30 1F 16 18 41 73 73 65 63 6F 20 44 61 0..0...Asseco Da0010: 74 61 20 53 79 73 74 65 6D 73 20 53 2E 41 2E 30 ta Systems S.A.0...]] ]][6]: ObjectId: 2.5.29.37 Criticality=falseExtendedKeyUsages [ serverAuth clientAuth][7]: ObjectId: 2.5.29.15 Criticality=trueKeyUsage [ DigitalSignature Key_Encipherment][8]: ObjectId: 2.5.29.17 Criticality=falseSubjectAlternativeName [ DNSName: *.dcpc.com DNSName: dcpc.com][9]: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: B3 A6 53 AD 96 D8 B7 51 09 D5 E1 07 E5 B2 BC E6 ..S....Q........0010: B5 F2 82 2B ...+]]] Algorithm: [SHA256withRSA] Signature:0000: 9A 38 A4 8F B2 A8 CE 9A B6 98 2F 8F 18 AA 45 79 .8......../...Ey0010: DE D6 31 22 99 6E D7 14 45 5E C1 1F 06 EC 7F C9 ..1\".n..E^.........][read] MD5 and SHA1 hashes: len = 14920000: 0B 00 05 D0 00 05 CD 00 05 CA 30 82 05 C6 30 82 ..........0...0.0010: 04 AE A0 03 02 01 02 02 10 36 3F A1 7D 5C 46 08 .........6?..\\F....*** ServerHelloDone[read] MD5 and SHA1 hashes: len = 40000: 0E 00 00 00 ....*** ClientKeyExchange, RSA PreMasterSecret, TLSv1[write] MD5 and SHA1 hashes: len = 2620000: 10 00 01 02 01 00 85 BD 72 17 92 EA 05 0F 0A BD ........r.......0010: 90 92 72 51 08 0F 6E 29 C4 A2 F0 D2 BA 78 0B A0 ..rQ..n).....x.....DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Handshake, length = 262[Raw write]: length = 2670000: 16 03 01 01 06 10 00 01 02 01 00 85 BD 72 17 92 .............r..0010: EA 05 0F 0A BD 90 92 72 51 08 0F 6E 29 C4 A2 F0 .......rQ..n)......SESSION KEYGEN:PreMaster Secret:0000: 03 01 80 92 4B 03 FA 1D 39 CE F4 82 3D 4A 96 A7 ....K...9...=J.....CONNECTION KEYGEN:Client Nonce:0000: 5A 72 D8 54 5F 78 84 D8 45 22 CD 49 85 1E F0 B2 Zr.T_x..E\".I.......Server Nonce:0000: 5A 72 63 4E F2 CF 4B 0F CE 58 0E EF 36 D4 F3 3E ZrcN..K..X..6..&gt;...Master Secret:0000: 93 05 C4 97 B7 FB 23 5F 11 15 8A 8E 2C C1 C7 72 ......#_....,..r...Client MAC write Secret:0000: 22 84 BA CD 61 27 D9 62 5F 84 FA 7A DF 05 DE 0A \"...a'.b_..z.......Server MAC write Secret:0000: D2 AC 73 AC CE F2 D2 00 31 E6 4F 8A DE E3 97 8D ..s.....1.O.....0010: 73 52 BA D2 sR..Client write key:0000: CA FB B2 02 E7 3F 79 93 55 61 CB AB FF EF 1E 76 .....?y.Ua.....v0010: 10 4C DD DE 83 55 99 6F 28 8E 19 5D 18 25 33 A2 .L...U.o(..].%3.Server write key:0000: 1A 25 31 69 D2 3B 45 D7 70 09 5F 9A FF D5 B3 71 .%1i.;E.p._....q0010: 73 9D D6 52 F0 10 21 8B 8E 13 97 BE B1 02 75 46 s..R..!.......uFClient write IV:0000: 68 49 14 C3 A2 97 75 A0 F3 AC 89 DA 31 84 C3 EF hI....u.....1...Server write IV:0000: 2C 03 9D 28 6F C2 7D BD 37 B1 AA E5 30 6E 09 EA ,..(o...7...0n..DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Change Cipher Spec, length = 1[Raw write]: length = 60000: 14 03 01 00 01 01 ......*** Finishedverify_data: &#123; 56, 169, 160, 43, 198, 100, 229, 140, 160, 251, 76, 146 &#125;***[write] MD5 and SHA1 hashes: len = 160000: 14 00 00 0C 38 A9 A0 2B C6 64 E5 8C A0 FB 4C 92 ....8..+.d....L.Padded plaintext before ENCRYPTION: len = 480000: 14 00 00 0C 38 A9 A0 2B C6 64 E5 8C A0 FB 4C 92 ....8..+.d....L.0010: F5 B1 BB DE F4 25 ED A2 3A 18 9D C8 8E EE 2B A6 .....%..:.....+.0020: 4A 1E 3A C7 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B J.:.............DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Handshake, length = 48[Raw write]: length = 530000: 16 03 01 00 30 4E 92 1F 3A 1F 91 C8 1B 9F 6B 3A ....0N..:.....k:0010: CC 2C 67 2C 9D CA 58 DA 4F 91 21 01 8E D8 5A 37 .,g,..X.O.!...Z70020: 67 B8 BD A9 E4 F3 79 E9 9C E6 E1 52 BB 8D 39 0E g.....y....R..9.0030: 45 5F F5 7E 7A E_..z[Raw read]: length = 50000: 14 03 01 00 01 .....[Raw read]: length = 10000: 01 .DefaultQuartzScheduler_Worker-3, READ: TLSv1 Change Cipher Spec, length = 1[Raw read]: length = 50000: 16 03 01 00 30 ....0[Raw read]: length = 480000: A9 B4 AB 6C 68 BA 47 DB CF 6E EF 8A F2 6F BD 73 ...lh.G..n...o.s0010: E4 44 55 C8 93 1B 4B C6 D9 A3 DB 4D 03 3B E0 8D .DU...K....M.;..0020: 67 ED E8 35 CA 63 D8 F8 C8 11 40 1B 54 DD 6F F2 g..5.c....@.T.o.DefaultQuartzScheduler_Worker-3, READ: TLSv1 Handshake, length = 48Padded plaintext after DECRYPTION: len = 480000: 14 00 00 0C 58 5A F4 F0 FA C9 BE 1D 27 6A A5 3A ....XZ......'j.:0010: DC 90 D1 52 C8 53 16 DD CB 04 E9 F0 F7 46 E2 9F ...R.S.......F..0020: 9E A6 EF 63 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B ...c............*** Finishedverify_data: &#123; 88, 90, 244, 240, 250, 201, 190, 29, 39, 106, 165, 58 &#125;***%% Cached client session: [Session-8, TLS_RSA_WITH_AES_256_CBC_SHA][read] MD5 and SHA1 hashes: len = 160000: 14 00 00 0C 58 5A F4 F0 FA C9 BE 1D 27 6A A5 3A ....XZ......'j.:DefaultQuartzScheduler_Worker-3, setSoTimeout(9000000) calledPadded plaintext before ENCRYPTION: len = 960##发送数据0000: 50 4F 53 54 20 2F 69 64 6D 2F 77 73 2F 55 6E 69 POST /idm/ws/Uni0010: 74 53 65 72 76 69 63 65 20 48 54 54 50 2F 31 2E tService HTTP/1.0020: 30 0D 0A 43 6F 6E 74 65 6E 74 2D 54 79 70 65 3A 0..Content-Type:0030: 20 74 65 78 74 2F 78 6D 6C 3B 20 63 68 61 72 73 text/xml; chars0040: 65 74 3D 75 74 66 2D 38 0D 0A 41 63 63 65 70 74 et=utf-8..Accept0050: 3A 20 61 70 70 6C 69 63 61 74 69 6F 6E 2F 73 6F : application/so0060: 61 70 2B 78 6D 6C 2C 20 61 70 70 6C 69 63 61 74 ap+xml, applicat0070: 69 6F 6E 2F 64 69 6D 65 2C 20 6D 75 6C 74 69 70 ion/dime, multip0080: 61 72 74 2F 72 65 6C 61 74 65 64 2C 20 74 65 78 art/related, tex0090: 74 2F 2A 0D 0A 55 73 65 72 2D 41 67 65 6E 74 3A t/*..User-Agent:00A0: 20 41 78 69 73 2F 31 2E 34 0D 0A 48 6F 73 74 3A Axis/1.4..Host:00B0: 20 69 64 6D 74 65 73 74 2E 64 63 70 63 2E 63 6F ***.***.co00C0: 6D 3A 38 34 34 33 0D 0A 43 61 63 68 65 2D 43 6F m:8443..Cache-Co...DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Application Data, length = 960[Raw write]: length = 9650000: 17 03 01 03 C0 76 73 C9 5C 37 18 B3 8D 85 B6 4A .....vs.\\7.....J0010: A5 FF 06 E0 81 74 E2 46 22 C7 32 12 51 A6 C4 10 .....t.F\".2.Q...0020: 7E 1D 14 C6 1E 1B 44 95 57 6E AC 83 AA 8D A7 92 ......D.Wn......0030: 4C 34 01 5D E9 A1 1E 8C BB 03 55 D9 7A 09 0F 1E L4.]......U.z...0040: 5D C4 71 46 CA 29 72 0D C1 CC F8 CE 6E F9 51 3A ].qF.)r.....n.Q:...[Raw read]: length = 50000: 17 03 01 01 60 ....`[Raw read]: length = 3520000: CD C2 06 A2 9F EA 9F 00 C7 27 5E F0 B3 C4 3D 78 .........'^...=x0010: 2E 9B F4 52 08 FF D7 05 2E A8 1B 42 3F 9A 3D 73 ...R.......B?.=s...DefaultQuartzScheduler_Worker-3, READ: TLSv1 Application Data, length = 352##接收数据Padded plaintext after DECRYPTION: len = 3520000: 48 54 54 50 2F 31 2E 31 20 32 30 30 20 0D 0A 43 HTTP/1.1 200 ..C0010: 6F 6E 74 65 6E 74 2D 54 79 70 65 3A 20 74 65 78 ontent-Type: tex0020: 74 2F 78 6D 6C 3B 63 68 61 72 73 65 74 3D 55 54 t/xml;charset=UT0030: 46 2D 38 0D 0A 44 61 74 65 3A 20 54 68 75 2C 20 F-8..Date: Thu,0040: 30 31 20 46 65 62 20 32 30 31 38 20 30 39 3A 30 01 Feb 2018 09:00050: 35 3A 32 35 20 47 4D 54 0D 0A 43 6F 6E 6E 65 63 5:25 GMT..Connec0060: 74 69 6F 6E 3A 20 63 6C 6F 73 65 0D 0A 0D 0A 3C tion: close....&lt;0070: 73 6F 61 70 3A 45 6E 76 65 6C 6F 70 65 20 78 6D soap:Envelope xm0080: 6C 6E 73 3A 73 6F 61 70 3D 22 68 74 74 70 3A 2F lns:soap=\"http:/0090: 2F 73 63 68 65 6D 61 73 2E 78 6D 6C 73 6F 61 70 /schemas.xmlsoap00A0: 2E 6F 72 67 2F 73 6F 61 70 2F 65 6E 76 65 6C 6F .org/soap/envelo...[Raw read]: length = 50000: 15 03 01 00 20 ....[Raw read]: length = 320000: 10 E4 3E EF D9 D6 A2 0F F3 11 85 6F 8F 68 48 C8 ..&gt;........o.hH.0010: 26 73 2E C8 FA 9D 00 03 AB 3B 79 46 DE ED CC 40 &amp;s.......;yF...@DefaultQuartzScheduler_Worker-3, READ: TLSv1 Alert, length = 32Padded plaintext after DECRYPTION: len = 320000: 01 00 C2 40 0A 51 E1 F1 28 06 65 73 E4 84 81 01 ...@.Q..(.es....0010: 8F A9 A1 FD A9 6E 09 09 09 09 09 09 09 09 09 09 .....n..........DefaultQuartzScheduler_Worker-3, RECV TLSv1 ALERT: warning, close_notifyDefaultQuartzScheduler_Worker-3, called closeInternal(false)DefaultQuartzScheduler_Worker-3, SEND TLSv1 ALERT: warning, description = close_notifyPadded plaintext before ENCRYPTION: len = 320000: 01 00 4F BB 75 8C 9C 8A 12 64 D7 62 F6 AF 81 90 ..O.u....d.b....0010: 92 0E 91 25 6F 9B 09 09 09 09 09 09 09 09 09 09 ...%o...........DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Alert, length = 32[Raw write]: length = 370000: 15 03 01 00 20 C1 60 66 8A 2A 1D A5 6C 82 C3 59 .... .`f.*..l..Y0010: A8 D5 E9 28 70 1D 93 F1 DD 34 00 14 1F 56 12 46 ...(p....4...V.F0020: 33 0C 4C 3F 51 3.L?QDefaultQuartzScheduler_Worker-3, called closeSocket(selfInitiated)DefaultQuartzScheduler_Worker-3, called close()DefaultQuartzScheduler_Worker-3, called closeInternal(true)DefaultQuartzScheduler_Worker-3, called close()DefaultQuartzScheduler_Worker-3, called closeInternal(true) 证书识别Java程序对受信证书的查找顺序是： javax.net.ssl.trustStore 就是System.setProperty(“javax.net.ssl.trustStore”,”D:\\cacert.keystore”);或者通过JVM参数指定：-Djavax.net.ssl.trustStore=D:\\cacert.keystore。 JAVA_HOME\\jre\\lib\\security\\jssecacerts 【推荐】 默认没有jssecacerts，一般把cacerts复制成jssecacerts，然后再使用keytool来修改它。jsse的全称是Java Secure Socket Extension。 JAVA_HOME\\jre\\lib\\security\\cacerts 通常情况下不就建议通过-Djavax.net.ssl.trustStore=D:\\cacert.keystore来直接修改keystore文件的位置，因为这样会造成系统中其他模块可能找不到自己对应的证书了。推荐使用jssecacerts。我们需要什么证书直接往这个位置导就行了。程序不需要做调整。 Springboot 程序实现我们希望在Springboot应用每次启动后都向服务器请求证书，并将证书更新到Keystore中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203@ConditionalOnProperty(value = &quot;cert.installation&quot;, havingValue = &quot;true&quot;)@ConfigurationProperties(&quot;cert&quot;)@Configurationpublic class InstallCert implements CommandLineRunner &#123; private static Logger logger = LoggerFactory.getLogger(InstallCert.class); /** * 生成的证书需要存放的security路径，即： %JAVA_HOME%\\jre\\lib\\security */ private String path; /** * 需要SSL认证的域名 */ private List&lt;String&gt; domains = new ArrayList&lt;&gt;(); private String password = &quot;changeit&quot;; public String getPath() &#123; return path; &#125; public void setPath(String path) &#123; this.path = path; &#125; public List&lt;String&gt; getDomains() &#123; return domains; &#125; public void setDomains(List&lt;String&gt; domains) &#123; this.domains = domains; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public void run(String... strings) throws Exception &#123; logger.info(&quot;ready to install valid certs&quot;); if (!Collections.isEmpty(domains))&#123; logger.info(&quot;domains is &#123;&#125;&quot;, domains.toString()); String[] arrayStr = new String[domains.size()]; installValidCerts(domains.toArray(arrayStr)); &#125; &#125; private void installValidCerts(String[] args) throws Exception &#123; logger.info(&quot;Usage: java InstallCert &lt;host&gt;[:port] [passphrase]&quot;); char[] passphrase = password.toCharArray(); String certPath = path; if (Strings.isNullOrEmpty(path))&#123; char separator = File.separatorChar; certPath = System.getProperty(&quot;java.home&quot;) + separator + &quot;lib&quot; + separator + &quot;security&quot;; &#125; File dir = new File(certPath);// File file = new File(&quot;jssecacerts&quot;);// if (file.isFile() == false) &#123;// char SEP = File.separatorChar;// File dir = new File(System.getProperty(&quot;java.home&quot;) + SEP + &quot;lib&quot; + SEP + &quot;security&quot;);// file = new File(dir, &quot;jssecacerts&quot;);// if (file.isFile() == false) &#123;// file = new File(dir, &quot;cacerts&quot;);// &#125; KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); InputStream in = null; logger.info(&quot;jre security dir path: &#123;&#125;&quot;, dir.getCanonicalPath()); File file = new File(dir, &quot;jssecacerts&quot;); if (!file.exists() &amp;&amp; !file.isFile())&#123; file.createNewFile(); File file1 = new File(dir, &quot;cacerts&quot;); if (!file1.isFile())&#123; logger.info(&quot;no certs will be registered, casue no cacerts file was found&quot;); return; &#125; in = new FileInputStream(file1); ks.load(in, passphrase); logger.info(&quot;file jssecacerts is created successfully&quot;); &#125;else &#123; in = new FileInputStream(file); ks.load(in, passphrase); logger.info(&quot;file jssecacerts is existing, will not create again&quot;); &#125; IOUtils.closeQuietly(in); logger.info(&quot;Loading KeyStore &quot; + file + &quot;...&quot;); SSLContext context = SSLContext.getInstance(&quot;TLS&quot;); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(ks); X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0]; SavingTrustManager tm = new SavingTrustManager(defaultTrustManager); context.init(null, new TrustManager[] &#123; tm &#125;, null); SSLSocketFactory factory = context.getSocketFactory(); OutputStream out = new FileOutputStream(file); for (String domain: args)&#123; logger.info(&quot;domain is &#123;&#125;&quot;, domain); String[] c = args[0].split(&quot;:&quot;); String host = c[0]; int port = (c.length == 1) ? 443 : Integer.parseInt(c[1]); logger.info(&quot;Opening connection to &quot; + host + &quot;:&quot; + port + &quot;...&quot;); SSLSocket socket = (SSLSocket) factory.createSocket(host, port); socket.setSoTimeout(10000); try &#123; logger.info(&quot;Starting SSL handshake...&quot;); socket.startHandshake(); socket.close(); logger.info(&quot;No errors, certificate is already trusted&quot;); &#125; catch (SSLException e) &#123; e.printStackTrace(System.out); &#125; X509Certificate[] chain = tm.chain; if (chain == null) &#123; logger.info(&quot;Could not obtain server certificate chain, continue next one&quot;); continue; &#125; logger.info(&quot;Server sent &quot; + chain.length + &quot; certificate(s):&quot;); MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA1&quot;); MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); for (int i = 0; i &lt; chain.length; i++) &#123; X509Certificate cert = chain[i]; logger.info(&quot; &quot; + (i + 1) + &quot; Subject &quot; + cert.getSubjectDN()); logger.info(&quot; Issuer &quot; + cert.getIssuerDN()); sha1.update(cert.getEncoded()); logger.info(&quot; sha1 &quot; + toHexString(sha1.digest())); md5.update(cert.getEncoded()); logger.info(&quot; md5 &quot; + toHexString(md5.digest())); &#125; int k=0; X509Certificate cert = chain[k]; String alias = host + &quot;-&quot; + (k + 1); ks.setCertificateEntry(alias, cert); ks.store(out, passphrase); logger.info(cert.toString()); logger.info(&quot;Added &#123;&#125; certificate to keystore &apos;jssecacerts&apos; using alias &#123;&#125;&quot;, domain, alias); &#125; IOUtils.closeQuietly(out); &#125; private static final char[] HEXDIGITS = &quot;0123456789abcdef&quot;.toCharArray(); private static String toHexString(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(bytes.length * 3); for (int b : bytes) &#123; b &amp;= 0xff; sb.append(HEXDIGITS[b &gt;&gt; 4]); sb.append(HEXDIGITS[b &amp; 15]); sb.append(&apos; &apos;); &#125; return sb.toString(); &#125; private static class SavingTrustManager implements X509TrustManager &#123; private final X509TrustManager tm; private X509Certificate[] chain; SavingTrustManager(X509TrustManager tm) &#123; this.tm = tm; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; throw new UnsupportedOperationException(); &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; throw new UnsupportedOperationException(); &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; this.chain = chain; tm.checkServerTrusted(chain, authType); &#125; &#125;&#125; 接下来我们只需要在YAML（applicaton.yml）中配置要申请握手的服务器就好 12345cert: installation: true domains: - bidxxxxxxx.xxxxxxxxxxxxxx.com - suppxxxxxx.xxxxx.com 至此，就不会出现证书找不到的问题了 参考 https://www.cnblogs.com/huqiaoblog/p/8398009.html http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html https://blog.csdn.net/catoop/article/details/80819638","categories":[],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://dayarch.top/tags/SSL/"}]},{"title":"Arthas调整log日志等级","slug":"Arthas调整log日志等级","date":"2019-04-09T05:39:37.000Z","updated":"2019-11-07T05:14:40.445Z","comments":true,"path":"/p/arthas-log-level.html","link":"","permalink":"https://dayarch.top/p/arthas-log-level.html","excerpt":"阿里的开源Java诊断工具Arthas可以在线调整log等级 1. 查找当前类的classloader hashcode 1 sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 2. 用OGNL获取logger 1 ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger' 3. 单独设置UserController的logger level 1 ognl -c 1be6f5c3 '@c","text":"阿里的开源Java诊断工具Arthas可以在线调整log等级 查找当前类的classloader hashcode 1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 用OGNL获取logger 1ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger' 单独设置UserController的logger level 1ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)' 全局设置logger level 1ognl -c 1be6f5c3 '@org.slf4j.LoggerFactory@getLogger(\"root\").setLevel(@ch.qos.logback.classic.Level@DEBUG)'","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Arthas","slug":"Coding/Arthas","permalink":"https://dayarch.top/categories/Coding/Arthas/"}],"tags":[{"name":"Arthas","slug":"Arthas","permalink":"https://dayarch.top/tags/Arthas/"}]},{"title":"Springboot去掉@RequestBody中字符串类型值的前后空格","slug":"Springboot去掉-RequestBody中字符串类型值的前后空格","date":"2018-07-12T08:06:17.000Z","updated":"2019-11-01T08:56:36.962Z","comments":true,"path":"/p/spring-boot-request-body-space.html","link":"","permalink":"https://dayarch.top/p/spring-boot-request-body-space.html","excerpt":"改造MappingJackson2HttpMessageConverter前言 项目组提出要求，Springboot项目中，@ResquestBody标记的bean传入的字符串类型的值要去掉前后空格 实现 因为项目默认使用 MappingJackson2HttpMessageConverter 作为 Json转换器， 于是乎重写一些方法做文章，具体实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42","text":"改造MappingJackson2HttpMessageConverter 前言项目组提出要求，Springboot项目中，@ResquestBody标记的bean传入的字符串类型的值要去掉前后空格 实现因为项目默认使用 MappingJackson2HttpMessageConverter 作为 Json转换器， 于是乎重写一些方法做文章，具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@EnableWebMvc@Configurationpublic class WebConfig implements WebMvcConfigurer&#123; //... 省略重写的其他方法 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super.configureMessageConverters(converters); //对应无法直接返回String类型 converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); return super.getObjectMapper(); &#125; /** * 重写read方法，然后做去掉前后空格处理，重新转换成object * @param type * @param contextClass * @param inputMessage * @return * @throws IOException * @throws HttpMessageNotReadableException */ @Override public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; Object object = super.read(type, contextClass, inputMessage); String json = JSONObject.toJSONString(object); Map&lt;String,Object&gt; map = (Map&lt;String, Object&gt;) JSONObject.parse(json); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet(); Map&lt;String, Object&gt; removeSpaceMap = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; entry : entrySet)&#123; if (entry.getValue() instanceof String)&#123; removeSpaceMap.put(entry.getKey(), ((String) entry.getValue()).trim()); &#125;else &#123; removeSpaceMap.put(entry.getKey(),entry.getValue()); &#125; &#125; Gson gson = new Gson(); String removeSpaceJson = JSON.toJSONString(removeSpaceMap); return gson.fromJson(removeSpaceJson, type); &#125; &#125;); &#125;&#125; 但是上面的代码经过各种测试发现一个问题，Gson在处理Integer，Long非浮点型的数值类型时候，自动转换为Double来处理，这导致后续代码做一些数据转换的时候会出现问题，因为Gson内部在处理数据类型都当成Number类型，可以读一下源码，这样需要做如下的改动： 1234567891011121314151617181920212223242526272829303132/** * * @param type * @param contextClass * @param inputMessage * @return * @throws IOException * @throws HttpMessageNotReadableException */@Overridepublic Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; Object object = super.read(type, contextClass, inputMessage); String json = JSONObject.toJSONString(object); Map&lt;String,Object&gt; map = (Map&lt;String, Object&gt;) JSONObject.parse(json); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet(); Map&lt;String, Object&gt; removeSpaceMap = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; entry : entrySet)&#123; if (entry.getValue() instanceof String)&#123; removeSpaceMap.put(entry.getKey(), ((String) entry.getValue()).trim()); &#125;else &#123; removeSpaceMap.put(entry.getKey(),entry.getValue()); &#125; &#125; String removeSpaceJson = JSON.toJSONString(removeSpaceMap); return JSONObject.parseObject(removeSpaceJson, type); //注释掉Gson，转换默认将Integer，Long等转换成Double，内部处理看作Number /*Gson gson = new Gson(); return gson.fromJson(removeSpaceJson, type);*/&#125; 以为这样就结束了吗？哈哈，没有… 😒 以上我们传入的都是正常的JsonObject，比如这种格式的数据 1234567891011121314151617181920212223242526&#123; \"commonName\":\"test2\", \"ver\":1, \"certificateRootType\":\"Z200\", \"expiredDate\":\"2118-01-01\", \"certificateName\":\"税务登记证 。\", \"commonCode\":\"suibian\", \"updateTime\":\"2018-07-12 13:09:14\", \"perpetual\":2, \"certificateNo\":\"11111111\", \"certificateTypeName\":\"税务登记证\", \"imgInfoVOList\":[ &#123; \"url\":\"https://www.a.b.c/a.jpg\" &#125;, &#123; \"url\":\"https://www.a.b.c/b.jpg\" &#125; ], \"producerType\":1, \"createTime\":\"2018-07-12 13:09:14\", \"supplier\":1043, \"id\":5016, \"startDate\":\"2018-01-01\", \"certificateType\":\"Z202\"&#125; 但是要有这种格式的数据 1234567891011121314[ &#123; \"roleId\":212, \"name\":\"上帝视角\" &#125;, &#123; \"roleId\":212, \"name\":\"上帝视角\" &#125;, &#123; \"roleId\":212, \"name\":\"上帝视角\" &#125;] 如果是下面这种格式的，我们解析的时候就会报转换错误，所以针对下面JsonArray类型的数据，我们需要做特殊处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * * @param type * @param contextClass * @param inputMessage * @return * @throws IOException * @throws HttpMessageNotReadableException */@SuppressWarnings(\"unchecked\")@Overridepublic Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; Object object = super.read(type, contextClass, inputMessage); String json = JSONObject.toJSONString(object); String jsonResult = null; if (json.startsWith(\"[\"))&#123; JSONArray jsonArray = JSONArray.parseArray(json); if (jsonArray != null &amp;&amp; !jsonArray.isEmpty())&#123; List&lt;Map&lt;String, Object&gt;&gt; result = Lists.newArrayList(); for (int i=0; i&lt;jsonArray.size(); i++)&#123; Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) jsonArray.get(i); Map&lt;String, Object&gt; removeSpaceMap = removeSpace(map); result.add(removeSpaceMap); &#125; jsonResult = JSON.toJSONString(result); &#125; &#125;else &#123; Map&lt;String,Object&gt; map = (Map&lt;String, Object&gt;) JSONObject.parse(json); Map&lt;String, Object&gt; removeSpaceMap = removeSpace(map); jsonResult = JSON.toJSONString(removeSpaceMap); &#125; //注释掉Gson，转换默认将Integer，Long等转换成Double，内部处理看作Number /*Gson gson = new Gson(); return gson.fromJson(removeSpaceJson, type);*/ return JSONObject.parseObject(jsonResult, type);&#125;private Map&lt;String, Object&gt; removeSpace(Map&lt;String, Object&gt; map)&#123; Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet(); Map&lt;String, Object&gt; removeSpaceMap = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; entry : entrySet)&#123; if (entry.getValue() instanceof String)&#123; removeSpaceMap.put(entry.getKey(), ((String) entry.getValue()).trim()); &#125;else &#123; removeSpaceMap.put(entry.getKey(),entry.getValue()); &#125; &#125; return removeSpaceMap;&#125; 这样就应对大多数问题了 接下来需要具体了解一下，构建过程，如上图，在HttpInputMessage 通过 converter 转换成Object对象之前做处理，这样在Controller接收的时候就可以拿到处理后的对象了","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://dayarch.top/tags/Json/"},{"name":"Springboot","slug":"Springboot","permalink":"https://dayarch.top/tags/Springboot/"}]},{"title":"Java实现文件下载并压缩成zip文件","slug":"Java实现文件下载并压缩成zip文件","date":"2018-07-04T05:48:44.000Z","updated":"2019-11-07T05:42:07.256Z","comments":true,"path":"/p/java-download-file-zip.html","link":"","permalink":"https://dayarch.top/p/java-download-file-zip.html","excerpt":"IO流，网络编程的基础背景 最近在做Springboot分布式微服务项目，用到了文件上传和下载，文件上传是既有的功能，将文件或图片上传到S3服务器上，将生成的文件URL地址和截取的文件名存储到DB中，正常我们只需要给前端URL，通过浏览器就可以实现文件的下载了，但是我们在将文件上传到S3服务器之前是将文件名称进行转码的，如：文件test.docx上传到S3服务器之后的URL地址是： http://www.S3.xxx.com/files/abRsdf.docx, 这样我们下载下来的文件文件名就是 abRsdf.docx, 显然这是不符合我们要求的，下载的文件名应该是test.docx, 并且需","text":"IO流，网络编程的基础 背景最近在做Springboot分布式微服务项目，用到了文件上传和下载，文件上传是既有的功能，将文件或图片上传到S3服务器上，将生成的文件URL地址和截取的文件名存储到DB中，正常我们只需要给前端URL，通过浏览器就可以实现文件的下载了，但是我们在将文件上传到S3服务器之前是将文件名称进行转码的，如：文件test.docx上传到S3服务器之后的URL地址是： http://www.S3.xxx.com/files/abRsdf.docx, 这样我们下载下来的文件文件名就是 abRsdf.docx, 显然这是不符合我们要求的，下载的文件名应该是test.docx, 并且需要多个文件压缩成zip文件打包下载. 所以需要在response中做一些文章，修改文件名，以及做多文件的压缩。 实现因为DB中存储了文件的URL和文件名称，大概数据形式如下： 序号 url name 1 http://www.S3.xxx.com/files/abRsdf.docx test.docx 2 http://www.S3.xxx.com/files/lsdTew.docx test1.docx 封装DB数据将DB中的url和name数据封装到类型为DownloadVO.java中，DownloadVO.java的代码很简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319import com.google.common.base.Strings;import com.viewhigh.epro.mall.vo.base.DownloadVO;import io.jsonwebtoken.lang.Collections;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.UUID;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class DownloadUtil &#123; private final static Logger LOG = LoggerFactory.getLogger(DownloadUtil.class); /** * 下载单个文件 * @param downloadVO * @param request * @param response * @throws IOException */ public static void toDownloadFile(DownloadVO downloadVO, HttpServletRequest request, HttpServletResponse response)throws IOException &#123; String savePath = request.getServletContext().getRealPath(new StringBuffer(File.separator).append(\"attachment\").append(File.separator).toString()); LOG.info(\"The Path where file will storage is &#123;&#125;\", savePath); downloadFile(getFile(downloadVO, savePath), request, response, true); &#125; /** * 在服务器生成文件 * @param downloadVO * @param savePath * @return * @throws IOException */ public static File getFile(DownloadVO downloadVO, String savePath) throws IOException&#123; InputStream inputStream = null; FileOutputStream fileOutputStream = null; try &#123; URL url = new URL(downloadVO.getUrl()); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); // 创建连接实例 conn.setConnectTimeout(3*1000); //设置超时间为3秒 conn.setRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)\"); //防止屏蔽程序抓取而返回403错误 conn.setRequestProperty(\"Charset\", \"UTF-8\"); inputStream = conn.getInputStream(); //获取连接输入流 byte[] getData = readInputStream(inputStream); //获取字节数组 File saveDir = new File(savePath); // 创建文件存放路径 if (!saveDir.exists())&#123; saveDir.mkdir(); &#125; File file = new File(savePath, downloadVO.getName()); // 在新建路径下创建对应附件名称的文件 fileOutputStream = new FileOutputStream(file); fileOutputStream.write(getData); return file; &#125; catch (MalformedURLException e) &#123; throw e; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; // 关闭流 if(fileOutputStream!=null)&#123; fileOutputStream.close(); &#125; if(inputStream!=null)&#123; inputStream.close(); &#125; &#125; &#125; /** * 下载多个文件，并压缩成zip * @param downloadVOS 待下载的文件信息 * @param request Servlet请求 * @param response Servlet相应 * @param zipName 待生成的zip文件名成 * @throws IOException * @throws ServletException */ public static void toDownloadFiles(List&lt;DownloadVO&gt; downloadVOS, HttpServletRequest request, HttpServletResponse response, String zipName)throws IOException, ServletException &#123; if (!Collections.isEmpty(downloadVOS))&#123; LOG.info(\"The total of Attachment is &#123;&#125;\" , downloadVOS.size()); String savePath = request.getServletContext().getRealPath(new StringBuffer(File.separator).append(\"attachment\").append(File.separator).toString()); LOG.info(\"The Path where file will storage is &#123;&#125;\", savePath); List&lt;File&gt; files = new ArrayList&lt;File&gt;(downloadVOS.size()); /** * 处理同名文件，如果存在，则以 a.txt, a(1).txt, a(2).txt */ Map&lt;String, Integer&gt; map = Maps.newHashMap(); for (DownloadVO downloadVO : downloadVOS)&#123; String fileName = downloadVO.getName(); if (map.containsKey(fileName))&#123; map.put(fileName, map.get(fileName) + 1); &#125;else &#123; map.put(fileName, 0); &#125; if (map.get(fileName) != 0)&#123; int position = fileName.lastIndexOf(\".\"); downloadVO.setName(new StringBuffer(fileName.substring(0, position)).append(\"(\").append(map.get(fileName)).append(\")\").append(fileName.substring(position, fileName.length())).toString()); &#125; File file = getFile(downloadVO, savePath); files.add(file); &#125; // 生成zip文件 File fileZip = generateZipFile(files, savePath, zipName); // 下载zip文件 downloadFile(fileZip, request, response, true); // 删除源文件 deleteSourceFile(files); &#125; &#125; private static void deleteSourceFile(List&lt;File&gt; files) &#123; if (!Collections.isEmpty(files))&#123; files.forEach(File::delete); &#125; &#125; /** * 从输入流中获取字节数组，根据 available 获取一次性读取的字节数量 * @param inputStream * @return * @throws IOException */ public static byte[] readInputStream(InputStream inputStream) throws IOException &#123; int count = 0; while (count == 0) &#123; count = inputStream.available(); &#125; byte[] buffer = new byte[count]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while((len = inputStream.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; LOG.info(\"current file length is &#123;&#125;\", len); bos.close(); return bos.toByteArray(); &#125; /** * 生成zip文件 * @param files * @param savePath * @param zipName * @return */ public static File generateZipFile(List&lt;File&gt; files, String savePath, String zipName) throws IOException, ServletException &#123; String zipFileName = zipName; if (Strings.isNullOrEmpty(zipFileName))&#123; zipFileName = UUID.randomUUID().toString(); &#125; zipFileName = zipFileName + \".zip\"; File fileZip = new File(savePath, zipFileName ); FileOutputStream fileOutputStream = null; // 文件输出流 ZipOutputStream zipOutputStream = null; // 压缩流 try &#123; fileOutputStream = new FileOutputStream(fileZip); zipOutputStream = new ZipOutputStream(fileOutputStream); zipFile(files, zipOutputStream); &#125; catch (FileNotFoundException e) &#123; throw e; &#125;finally &#123; if (zipOutputStream != null)&#123; zipOutputStream.close(); &#125; if (fileOutputStream != null)&#123; fileOutputStream.close(); &#125; &#125; return fileZip; &#125; /** * 压缩文件 * @param files * @param outputStream * @throws IOException * @throws ServletException */ public static void zipFile(List&lt;File&gt; files, ZipOutputStream outputStream) throws IOException, ServletException &#123; try &#123; int size = files.size(); // 压缩列表中的文件 for (int i = 0; i &lt; size; i++) &#123; File file = (File) files.get(i); zipFile(file, outputStream); &#125; &#125; catch (IOException e) &#123; throw e; &#125; &#125; public static void zipFile(File inputFile, ZipOutputStream outputstream) throws IOException, ServletException &#123; FileInputStream inStream = null; BufferedInputStream bInStream = null; try &#123; if (inputFile.exists()) &#123; if (inputFile.isFile()) &#123; inStream = new FileInputStream(inputFile); bInStream = new BufferedInputStream(inStream); ZipEntry entry = new ZipEntry(inputFile.getName()); outputstream.putNextEntry(entry); final int MAX_BYTE = 10 * 1024 * 1024; // 最大的流为10M long streamTotal = 0; // 接受流的容量 int streamNum = 0; // 流需要分开的数量 int leaveByte = 0; // 文件剩下的字符数 byte[] inOutbyte; // byte数组接受文件的数据 streamTotal = bInStream.available(); // 通过available方法取得流的最大字符数 streamNum = (int) Math.floor(streamTotal / MAX_BYTE); // 取得流文件需要分开的数量 leaveByte = (int) streamTotal % MAX_BYTE; // 分开文件之后,剩余的数量 if (streamNum &gt; 0) &#123; for (int j = 0; j &lt; streamNum; ++j) &#123; inOutbyte = new byte[MAX_BYTE]; // 读入流,保存在byte数组 bInStream.read(inOutbyte, 0, MAX_BYTE); outputstream.write(inOutbyte, 0, MAX_BYTE); // 写出流 &#125; &#125; // 写出剩下的流数据 inOutbyte = new byte[leaveByte]; bInStream.read(inOutbyte, 0, leaveByte); outputstream.write(inOutbyte); outputstream.closeEntry(); // Closes the current ZIP entry // and positions the stream for // writing the next entry &#125; &#125; else &#123; throw new ServletException(\"文件不存在！\"); &#125; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; if (bInStream != null)&#123; bInStream.close(); // 关闭 &#125; if (inStream != null)&#123; inStream.close(); &#125; &#125; &#125; /** * 下载zip文件 * @param file * @param response * @param isDelete */ public static void downloadFile(File file,HttpServletRequest request , HttpServletResponse response,boolean isDelete) throws IOException &#123; BufferedInputStream bufferedInputStream = null; OutputStream outputStream = null; try &#123; bufferedInputStream = new BufferedInputStream(new FileInputStream(file.getPath())); byte[] buffer = new byte[bufferedInputStream.available()]; bufferedInputStream.read(buffer); response.reset(); // 清空response outputStream = new BufferedOutputStream(response.getOutputStream()); response.setContentType(\"application/octet-stream\"); LOG.info(\"fileName:\" + file.getName()); String userAgent = request.getHeader(\"User-Agent\"); String formFileName = file.getName(); // 针对IE或者以IE为内核的浏览器： if (userAgent.contains(\"MSIE\") || userAgent.contains(\"Trident\") || userAgent.contains(\"Edge\")) &#123; formFileName = java.net.URLEncoder.encode(formFileName, \"UTF-8\"); &#125; else &#123; // 非IE浏览器的处理： formFileName = new String(formFileName.getBytes(\"UTF-8\"), \"ISO-8859-1\"); &#125; response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + formFileName); outputStream.write(buffer); outputStream.flush(); //是否将生成的服务器端文件删除 if(isDelete)&#123; file.delete(); &#125; &#125; catch (IOException ex) &#123; throw ex; &#125;finally &#123; if (bufferedInputStream != null)&#123; bufferedInputStream.close(); &#125; if (outputStream != null)&#123; outputStream.close(); &#125; &#125; &#125;&#125; servlet路径问题上面的代码将文件下载到了servlet的realPath中，顺便总结一下各种路径的差别 请求路径的URL http://localhost:8080/electest/system/elecMenuAction_menuHome.do 12345678System.out.println(\"contentType------\"+request.getContentType());System.out.println(\"requestcontextPath------\"+request.getContextPath());System.out.println(\"servletPath----\"+request.getServletPath());System.out.println(\"requestRealPath\"+request.getRealPath(\"\"));System.out.println(\"realPath------\"+request.getServletContext().getRealPath(\"\"));System.out.println(\"requestURI------\"+request.getRequestURI());System.out.println(\"requestURL-------\"+request.getRequestURL());System.out.println(\"contextPath-------\"+request.getServletContext().getContextPath()); 打印结果 12345678contentType------application/x-www-form-urlencodedrequestcontextPath------/electestservletPath----/system/elecMenuAction_menuHome.dorequestRealPathD:\\tomcate\\apache-tomcat-7.0.63-windows-x64\\apache-tomcat-7.0.63\\webapps\\electestrealPath------D:\\tomcate\\apache-tomcat-7.0.63-windows-x64\\apache-tomcat-7.0.63\\webapps\\electestrequestURI------/electest/system/elecMenuAction_menuHome.dorequestURL-------http://localhost:8080/electest/system/elecMenuAction_menuHome.docontextPath---------/electest 方法和代码的注释写的已经很详细了，具体的实现就不再详述了","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://dayarch.top/tags/IO/"}]},{"title":"Springboot Json格式数据不返回null值属性","slug":"Springboot-Json格式数据不返回null值属性","date":"2018-07-02T05:41:37.000Z","updated":"2019-11-07T06:21:40.625Z","comments":true,"path":"/p/spring-boot-json-return-non-null.html","link":"","permalink":"https://dayarch.top/p/spring-boot-json-return-non-null.html","excerpt":"Spring ResponseBody without null field通常Restful返回的Json格式数据，里面包含很多为空值null的字段，我们没必要将这些字段返回给前端，应该给出更多的有效字段，所以我们需要在Converter Message的时候将这些null值字段给过滤掉 方法一 添加 @JsonInclude(JsonInclude.Include.NON_NULL) 注解 该方法很简单，但是我们有太多的返回类型，一一添加也是很大的工作量，所以我们需要在转换的源头进行控制 方法二 实现 WebMvcConfigurer 接口，添加 @EnableWebMvc 和 @Co","text":"Spring ResponseBody without null field 通常Restful返回的Json格式数据，里面包含很多为空值null的字段，我们没必要将这些字段返回给前端，应该给出更多的有效字段，所以我们需要在Converter Message的时候将这些null值字段给过滤掉 方法一添加 @JsonInclude(JsonInclude.Include.NON_NULL) 注解该方法很简单，但是我们有太多的返回类型，一一添加也是很大的工作量，所以我们需要在转换的源头进行控制 方法二实现 WebMvcConfigurer 接口，添加 @EnableWebMvc 和 @Configuration 注解，然后重写 MappingJackson2HttpMessageConverter 中 getObjectMapper() 方法 123456789101112131415161718@EnableWebMvc@Configurationpublic class WebConfig implements WebMvcConfigurer&#123; //... 省略重写的其他方法 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super.configureMessageConverters(converters); //对应无法直接返回String类型 converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); return super.getObjectMapper(); &#125; &#125;); &#125;&#125; 这样所有的null值都会被过滤掉，注意这里使用的是 JsonInclude.Include.NON_NULL， Json中的某个集合如果为空还是会返回空数组，我们希望把这样的数据也过滤掉，只需要将JsonInclude.Include.NON_NULL 修改为 JsonInclude.Include.NON_EMPTY 这样就好了，返回给前端清晰有效的数据.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"Json","slug":"Json","permalink":"https://dayarch.top/tags/Json/"}]},{"title":"使用 Docker 部署 Spring Boot","slug":"使用-Docker-部署-Spring-Boot","date":"2018-04-09T07:43:42.000Z","updated":"2019-11-01T08:58:35.964Z","comments":true,"path":"/p/docker-deploy-spring-boot.html","link":"","permalink":"https://dayarch.top/p/docker-deploy-spring-boot.html","excerpt":"前言 最近陆续在通过SpringBoot搭建项目，往里面逐渐添加功能，项目地址SpringBootLearning, 当总结Docker部署SpringBoot的时候，我遇到了一些问题，加以总结 问题汇总 文章主要参考Spring Boot 2.0(四)：使用 Docker 部署 Spring Boot, 因为我是已有的SpringBoot项目，不是简单的SpringBoot项目，所以使用Docker部署SpringBoot的时候遇到了一些问题，现总结如下： 1. mvn package 打包命令不能生成jar包到target目录下 因为Docker会用到jar包，所以在用Doc","text":"前言最近陆续在通过SpringBoot搭建项目，往里面逐渐添加功能，项目地址SpringBootLearning, 当总结Docker部署SpringBoot的时候，我遇到了一些问题，加以总结 问题汇总文章主要参考Spring Boot 2.0(四)：使用 Docker 部署 Spring Boot, 因为我是已有的SpringBoot项目，不是简单的SpringBoot项目，所以使用Docker部署SpringBoot的时候遇到了一些问题，现总结如下： mvn package 打包命令不能生成jar包到target目录下因为Docker会用到jar包，所以在用Docker部署之前，先用Maven来进行打包，保证正确，但是使用命令并不能生成jar包，发现打包中打了我的测试用例类，测试用例有持续执行操作，当然其他持续操作也有可能出现这个问题，所以我在pom.xml中加入了plugin来过滤掉Test case.123456789101112&lt;properties&gt;&lt;!--mvn 打包时省略test用例--&gt;&lt;skipTests&gt;true&lt;/skipTests&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;$&#123;skipTests&#125;&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 通过Maven的docker插件来部署，遇到了两个问题： [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: connect -&gt; [Help 1] [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target -&gt; [Help 1] 通过查找资料在pom.xml中maven的docker插件中添加了如下内容： 12&lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt;&lt;dockerCertPath&gt;D:/Users/fraser.yu/.docker/machine/machines/default&lt;/dockerCertPath&gt;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"Docker学习(四)——容器","slug":"Docker学习-四-——容器","date":"2017-11-07T02:45:33.000Z","updated":"2019-11-07T05:21:11.715Z","comments":true,"path":"/p/docker-container.html","link":"","permalink":"https://dayarch.top/p/docker-container.html","excerpt":"容器是镜像的一个运行实例，所不同的是，它有额外的可写文件层上一篇文章Docker学习(三)——镜像介绍了Docker的镜像， 包括 获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像，接下来逐步拆分讲解Docker的核心内容之一——容器. Docker的容器十分轻量级，用户可以随时创建或删除容器 创建容器 单纯创建容器 语法: docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 1. 为本地Ubuntu镜像创建容器 1 $ docker create -it ubuntu","text":"容器是镜像的一个运行实例，所不同的是，它有额外的可写文件层 上一篇文章Docker学习(三)——镜像介绍了Docker的镜像，包括 获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像，接下来逐步拆分讲解Docker的核心内容之一——容器. Docker的容器十分轻量级，用户可以随时创建或删除容器 创建容器单纯创建容器语法: docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 为本地Ubuntu镜像创建容器 1$ docker create -it ubuntu:latest 查看本地启动的容器（注意观察容器的状态是Created,换句话说这个容器是终止状态，没有运行） 1$ docker ps -a 容器信息解释 CONTAINER ID： 容器ID IMAGE: 容器所运行镜像的名称 COMMAND: 运行容器时的命令 CREATED: 容器的创建时间 STATUS: 容器当前状态 详细信息请使用下面命令自行了解 1$ docker create --help 启动容器方法一语法: docker start [OPTIONS] CONTAINER [CONTAINER…] 查看刚刚创建的容器ID，通过start命令来启动 1$ docker start 93f 重新查看容器信息（注意当前容器状态是Exited，即容器运行终止） 1$ docker ps -a 详细信息请使用下面命令自行了解 1$ docker start --help 启动容器方法二创建容器和启动容器有一种更方便的命令来完成上面create 和 start 的操作.语法: docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 为本地Ubuntu镜像在此创建容器并启动1$ docker run -it ubuntu:latest 详细信息请使用下面命令自行了解（和create是一样的）1$ docker run --help 退出容器输入exit或者Ctrl+D来退出容器，对于所创建的bash容器，当使用exit命令退出之后，该容器就出于终止状态了，这是因为对于Docker容器来说，当运行的应用（此处以bash为例）退出后，容器也就没有继续运行的必要了. 守护态运行更多的时候，需要让Docker容器在后台以守护态（Daemonized）形式运行，用户可以通过添加-d option来实现. 运行容器，每隔一秒打印出hello world1$ docker run -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 获取容器的输出信息1$ docker logs ce90 详细信息请使用下面命令自行了解1$ docker logs --help 终止容器语法: docker stop [OPTIONS] CONTAINER [CONTAINER…]执行上述命令后，终止容器分为两个步骤，先向容器发送一个SIGTERM信号，10秒钟后会再次发送一个SIGKILL信号终止容器 终止上文中启动的容器1$ docker stop ce90 查看终止的容器1$ docker ps -a -q 启动容器1$ docker start ce90 重启容器（将运行中的容器终止，并重新启动）1$ docker restart ce90 详细信息请使用下面命令自行了解1$ docker stop --help 进入容器上文中提到使用-d参数可以使Docker成守护态运行，但是用户无法看到容器的内部信息，而很多时候我们需要进入到容器内进行操作，Docker也提供了集中方法来实现这个功能 docker attach语法: docker attach [OPTIONS] CONTAINER, 运行该命令时，该容器必须是运行状态（UP）,如果没有运行，使用start命令，attach命令可以不用指定命令参数，默认执行上次run的命令参数/bin/bash, 但是当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示，当某个窗口因为某一个命令阻塞时，其他窗口就无法执行其他操作了，所以不建议使用. 进入刚刚以守护态启动的容器1$ docker attach 9d89 详细信息请使用下面命令自行了解1$ docker attach --help docker exec语法: docker exec [OPTIONS] CONTAINER COMMAND [ARG…], 该命令至少需要一个命令参数 进入刚刚一守护态启动的容器1$ docker exec -it 9d89 /bin/bash 详细信息请使用下面命令自行了解1$ docker exec --help 删除容器语法: docker rm [OPTIONS] CONTAINER [CONTAINER…] 删除处于 终止状态 的容器，同时可以输入多个容器ID批量删除容器 删除处于终止状态的容器1$ docker rm 9d89 详细信息请使用下面命令自行了解1$ docker rm --help 导入和导出容器导出容器导出容器是指导出一个已经创建的容器到一个文件，不管该容器是否是处于运行状态语法: docker export [OPTIONS] CONTAINER 导出9d89容器到ubuntu_export.tar文件1$ docker export 9d89 &gt; ubuntu_export.tar 详细信息请使用下面命令自行了解1$ docker export --help 导入容器导出的文件又可以使用docker import 命令导入，成为镜像 导入上文中的ubuntu_export.tar文件成为镜像1$ cat ubuntu_export.tar | docker import - test/ubuntu:v1.0 详细信息请使用下面命令自行了解1$ docker import --help 我们在上一节中讲过载入镜像 docker load 命令导入镜像文件到本地镜像库，这节通过 docker import 命令来导入一个容器快照到本地镜像库，但是容器快照文件将丢弃所有历史数据和元数据（仅仅保存容器当前的快照状态）， 而镜像文件形式保存完整记录，体积要大，此外，容器快照导入标签可以重新指定标签元数据等，向上文中的test/ubuntu:v1.0","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"Docker学习(三)——镜像","slug":"Docker学习-三-——镜像","date":"2017-11-06T06:50:32.000Z","updated":"2019-11-07T05:19:56.130Z","comments":true,"path":"/p/docker-image.html","link":"","permalink":"https://dayarch.top/p/docker-image.html","excerpt":"镜像是Docker运行容器的前提上一篇文章Docker学习(二)——Docker架构讲述了Docker的基本架构，接下来逐步拆分讲解Docker的核心内容之一——镜像. Docker 运行容器前需要本地存有对应的镜像，如果镜像不存在，Docker会尝试先从默认（Docker Hub公共注册服务器中的仓库）镜像仓库下载，用户也可以配置使用自己的仓库. 本章内容主要有：获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像. 看着内容很多，其实熟悉Git的朋友，分分钟就可以理解上面的这些内容， 操作方式都是相通的, 话不多说，看命令说话. 获取镜像 语法: docker","text":"镜像是Docker运行容器的前提 上一篇文章Docker学习(二)——Docker架构讲述了Docker的基本架构，接下来逐步拆分讲解Docker的核心内容之一——镜像. Docker 运行容器前需要本地存有对应的镜像，如果镜像不存在，Docker会尝试先从默认（Docker Hub公共注册服务器中的仓库）镜像仓库下载，用户也可以配置使用自己的仓库. 本章内容主要有：获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像. 看着内容很多，其实熟悉Git的朋友，分分钟就可以理解上面的这些内容， 操作方式都是相通的, 话不多说，看命令说话. 获取镜像语法: docker pull NAME[:TAG] 从Docker Hub的Ubuntu仓库下载最新版本Ubuntu镜像(如果不指定tag，默认tag是latest,即下载最新版本)1$ docker pull ubuntu 从Docker Hub的Ubuntu仓库下载指定版本Ubuntu镜像1$ docker pull ubuntu:16.04 我们前面讲过，默认是从Docker Hub的Registry中下载，所以以上的命令相当于12$ docker pull registry.hub.docker.com/ubuntu:latest$ docker pull registry.hub.docker.com/ubuntu:16.04 从其他注册服务器下载Docker镜像（如DockerPool社区，需要指定完整的注册服务器地址）1$ docker pull dl.dockerpool.com:5000/ubuntu 详细信息请使用下面命令自行了解1$ docker pull --help 查看镜像信息语法：docker images通过该命令可以查看本地所有的镜像，说明一下执行该命令之后每列的含义 REPOSITORY: 来自于哪个仓库，同样是如果没有指定注册服务器的地址，那默认就是Docker Hub的仓库 TAG：镜像的标签信息，比如latest、16.04 IMAGE ID：镜像的唯一ID标识 CREATED:（镜像拉取到本地或者在本地创建镜像的时间） VIRTUAL SIZE:镜像的大小 repository是不同的仓库，tag是标记同一个仓库的不同的镜像 Tag打标记有时候镜像需要一个自己需要的tag标识，这会我们需要用到docker 的tag命令来方便我们管理镜像语法：docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] 给镜像打上自己的标签1$ docker tag dl.dockerpool.com:5000/ubuntu:latest ubuntu:20171106_ubuntu 详细信息请使用下面命令自行了解1$ docker tag --help 执行完以上命令再次查看[docker images]本地所有镜像，发现我们打了标记的镜像和被打标记的镜像的镜像ID竟然一样.这说明新打上标签的镜像只是指向了同一个镜像文件，只是别名不同，标签在这里就起到了引用或快捷方式的作用. 查看镜像的详细信息语法：docker inspect [OPTIONS] NAME|ID [NAME|ID]执行[docker inspect]命令会得到一个Json格式的信息，如果我们需要关注某一个部分，可以使用[-f]参数来使用，镜像ID使用前几个字符就可以，不用输入全部 查看刚刚打了标记的Ubuntu镜像的详细信息(镜像ID因人而异)1$ docker inspect 5506de2b643b 查看镜像指定的详细信息1$ docker inspect -f &#123;&#123;\".Architecture\"&#125;&#125; 5506 详细信息请使用下面命令自行了解1$ docker inspect --help 搜寻镜像语法：docker search [OPTIONS] TERM 搜寻mysql镜像1$ docker search mysql 说明一下执行该命令之后每列的含义 NAME: 镜像名称 DESCRIPTION：竞相描述 STARTS：镜像星级（代表受欢迎程度） OFFICIAL:是否为官方创建和维护的 AUTOMATED:是否自动创建（自动创建的资源允许用户验证镜像内容以及来源） 删除镜像语法：docker rmi [OPTIONS] IMAGE [IMAGE…], IMAGE可以是镜像标签或者镜像ID，rmi其实就是remove image的缩写. 删除镜像这里的规矩稍稍多一点但是遵循以下几个原则，不用背诵以下，会在后面的实践中逐步来验证 当本地一个镜像有多个标签时，删除某一个标签不影响其他镜像 当本地一个镜像只有一个标签时，删除该标签会彻底删除该镜像 当通过镜像ID删除镜像的时候，会逐个删除指向该镜像的标签，最终删除镜像. 当有该镜像创建的容器存在时，镜像不会被删除，docker会更换该镜像ID，并且镜像没有名字. 当有该镜像创建的容器存在时,可以使用[-f] 参数来强制删除镜像（不建议这样做） 当有该镜像创建的容器存在时,应遵循先删除容器，然后再删除镜像 删除mysql镜像1$ docker rmi mysql:latest 创建镜像创建镜像有三种方式： 基于已有镜像的容器创建 基于本地模板导入 基于Dockerfile创建（最常用，此处先了解整个过程，后续章节经常使用的时候自然就会了） 基于已有镜像的容器创建新镜像语法：docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 启动镜像（通过容器运行Ubuntu16.04, 并且进入bash环境），运行后通过[docker ps -a]来查看容器信息，当下主要关注容器ID1$ docker run -it ubuntu:1604 /bin/bash 创建test文件并且退出容器12touch testexit 通过运行的容器创建新的镜像,执行成功后会返回新创建的镜像ID信息1$ docker commit -m \"added a new file\" -a \"fraser\" a925cb test:latest 详细信息请使用下面命令自行了解[“-m”:提交信息,”-a”:作者信息,”-p”:提交时暂停容器运行]1$ docker commit --help 基于本地模板导入可以直接从一个操作系统模板文件导入一个镜像，推荐OpenVZ提供的模板来创建(个人觉得这个应用的不是很多，了解即可) 通过模板文件导入1$ sudo cat ubuntu-16.04-x86_64.tar.gz | docker import - ubuntu:1604 基于Dockerfile创建Dockerfile需要讲解的内容很多，包括里面各个指令的应用，我们会单独拿出一个章节来讲解Dockerfile. 存出和载入镜像存出镜像语法：docker save [OPTIONS] IMAGE [IMAGE…] , 存出镜像到本地文件 存出本地的ubuntu:1604镜像为ubuntu_1604.tar1$ docker save -o ubuntu_1604.tar ubuntu:1604 详细信息请使用下面命令自行了解1$ docker save --help 载入镜像语法：docker load [OPTIONS] , 从存出的本地文件中再导入到本地镜像库 从ubuntu_1604.tar文件导入镜像到到本地镜像列表123$ docker load --input ubuntu_1604.tar或$ docker load &lt; ubuntu_1604.tar 上传镜像语法：docker push [OPTIONS] NAME[:TAG]用户在DockerHub上完成注册之后，即可上传自制的镜像，但是需要打上带有user的标签（注册的用户名） 将本地hello-world镜像加上标签1$ docker tag hello-world:latest fraseryu/helloworld:latest 查看本地镜像列表可以看到打上标签的镜像1$ docker images 登录完成DockerHub授权认证，输入刚刚在DockerHub上注册的用户名和密码1$ docker login push本地订制的镜像到DockerHub1$ docker push fraseryu/helloworld:latest 登录DockerHub看到我们的镜像已经push成功","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"Docker学习(二)——Docker架构","slug":"Docker学习-二-——Docker架构","date":"2017-11-03T05:53:16.000Z","updated":"2019-11-07T05:20:30.846Z","comments":true,"path":"/p/docker-architect.html","link":"","permalink":"https://dayarch.top/p/docker-architect.html","excerpt":"像面向对象编程一样理解Docker镜像与容器上一篇文章Docker学习(一)——Docker安装讲述了在Ubuntu下安装，安装完了要了解一下Docker架构与一些名词解释，这样对Docker后续的操作会有更好的理解. Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器, 也就是说我们通过Docker客户端来完成对镜像以及容器的一系列操作 对于上面的图片出现的一系列名词可以这样理解： 名词术语解释Docker 镜像(Images)Docker 镜像是用于创建 Docker 容器的模板Docker 容器(Container)容器是独立运行的一","text":"像面向对象编程一样理解Docker镜像与容器 上一篇文章Docker学习(一)——Docker安装讲述了在Ubuntu下安装，安装完了要了解一下Docker架构与一些名词解释，这样对Docker后续的操作会有更好的理解. Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器, 也就是说我们通过Docker客户端来完成对镜像以及容器的一系列操作 对于上面的图片出现的一系列名词可以这样理解： 名词术语 解释 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板 Docker 容器(Container) 容器是独立运行的一个或一组应用 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器 Docker 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库，Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用 关于Registry我要多说一句，应该把它理解成管理仓库的仓库，这个仓库中有Ubuntu仓库，Apache仓库，Nginx仓库等， 每个小仓库还都管理不同version的镜像，如Ubuntu1604,Ubuntu1404等. 文章开头提到像面向对象编程一样理解Docker镜像与容器，看如下表格，一个类可以创建多个对象（除了单例模式），也就是说一个镜像可以有多个容器来运行. Docker 面向对象 镜像 类 容器 对象 充分理解一下这篇架构图以及名词解释，就要进入接下来的Docker之旅了. 参考 Docker架构 几张图帮你理解 docker 基本原理及快速入门","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"Docker学习(一)——Docker安装","slug":"Docker学习-一-——Docker安装","date":"2017-11-01T06:04:46.000Z","updated":"2019-11-07T05:18:34.850Z","comments":true,"path":"/p/docker-install.html","link":"","permalink":"https://dayarch.top/p/docker-install.html","excerpt":"Docker, incredible virtual machine什么是Docker 按照惯例，介绍一些历史，说明一下来龙去脉，至少知道它是怎么来的，又为什么会来，能干什么 1. Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护 2. Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHE","text":"Docker, incredible virtual machine 什么是Docker按照惯例，介绍一些历史，说明一下来龙去脉，至少知道它是怎么来的，又为什么会来，能干什么 Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护 Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 Docker与传统虚拟机的对比通过两张图，来理解一下Docker与传统虚拟机的对比，通过下面两张图能看出来Docker节省了哪些资源即可,其他的好处在后面的学习过程中陆续介绍 Docker目前分为两个版本 Docker Enterprise Edition (Docker EE) 专为企业开发和IT团队设计，用于在大规模生产中构建，运送和运行关键业务应用程序Docker EE集成，认证和支持，为企业提供业界最安全的容器平台，使所有应用程序现代化 Docker Community Edition (Docker CE) 是开发人员和小团队的理想选择，希望开始使用Docker并尝试基于容器的应用程序Docker CE可在许多平台上使用，从桌面到云到服务器 环境Docker系列学习主要通过 VirtualBox 在 Ubuntu16.04 中完成安装以及后续进阶课程的学习, Docker版本为DockerCE 安装安装Ubuntu16.04VirtualBox 安装Ubuntu1604请参考在virtualbox下安装ubuntu server 16.04 安装docker按照Docker官网Get Docker CE for Ubuntu描述安装DockerCE 检查安装条件Docker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 Ubuntu 版本是否支持 Docker。通过 uname -r 命令查看你当前的内核版本 1$ uname -r 卸载旧的版本老的Docker版本我们叫做docker或docker-engine, 如果之前安装过，这里需要先卸载, Docker CE package现在叫做docker-ce 1$ sudo apt-get remove docker docker-engine docker.io 搭建Docker仓库首次在宿主机上安装DockerCE，需要搭建Docker repository,搭建完成后，可以通过repository安装或更新Docker. 更新apt package1$ sudo apt-get update 允许apt用https方式访问Docker仓库（命令太长可以用 \\ 符号换行）12345$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 添加Docker的官方GPG密钥1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 验证fingerprint 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88, 用后八位字符即可 1$ sudo apt-key fingerprint 0EBFCD88 设置稳定版Repository1234$ sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 安装Docker CE 更新apt索引1$ sudo apt-get update 安装最新版本的Docker CE1$ sudo apt-get install docker-ce 生产环境指定Docker版本生产环境为了稳定性会选择指定版本，而不是Dokcer的最新版本，查看可用版本：123$ apt-cache madison docker-cedocker-ce | 17.09.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages 安装指定Docker CE 版本1$ sudo apt-get install docker-ce=&lt;VERSION&gt; 确认Docker CE 是否安装成功 仔细阅读docker run hello-world的输出内容，对于理解docker的工作原理有帮助 12$ sudo docker run hello-world$ sudo docker version 启动Docker1$ systemctl start docker 重新启动Docker1$ systemctl restart docker Docker命令去掉sudo默认情况下，我们每次敲docker命令都需要sudo权限，下面的方法可以省去sudo方便很多. 创建docker组1$ sudo groupadd docker 添加当前用户到docker组1$ sudo usermod -aG docker $USER 登出，重新登录shell 验证docker命令是否可以运行（注意没有sudo）1$ docker run hello-world","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"指数基金交易会产生哪些费用","slug":"指数基金交易会产生哪些费用","date":"2017-06-09T01:58:14.000Z","updated":"2019-11-01T09:02:37.016Z","comments":true,"path":"/p/investment-index-fee.html","link":"","permalink":"https://dayarch.top/p/investment-index-fee.html","excerpt":"引言 在购买指数基金时，我们会看到让人眼花缭乱的各种费用，既然理财了，就要知道： 1. 我们为了购买这些基金都发生了那些费用？ 2. 怎样购买方式能节省这些费用？ 了解这些对于我们财富增长将会起到重要作用， 以下文章是借鉴前辈”银行螺丝钉” 的文章加以总结. 钱都花到哪里去了 申购费、赎回费、交易佣金、印花税、服务费、托管费、管理费……, 在了解这么对费用之前，我们需要知道指数基金按照购买方式可以分为： 1. 场内基金 场内基金指的是上市（股市）交易的基金，只能用证券帐户购买，主要是封闭式基金和上市型开放式基金（LOF基金） 2. 场外基金","text":"引言在购买指数基金时，我们会看到让人眼花缭乱的各种费用，既然理财了，就要知道： 我们为了购买这些基金都发生了那些费用？ 怎样购买方式能节省这些费用？ 了解这些对于我们财富增长将会起到重要作用， 以下文章是借鉴前辈”银行螺丝钉” 的文章加以总结. 钱都花到哪里去了申购费、赎回费、交易佣金、印花税、服务费、托管费、管理费……, 在了解这么对费用之前，我们需要知道指数基金按照购买方式可以分为： 场内基金 场内基金指的是上市（股市）交易的基金，只能用证券帐户购买，主要是封闭式基金和上市型开放式基金（LOF基金） 场外基金 场外基金不上市交易，是只能在指定的网点（银行、基金公司、证券公司等）申购的基金，如一般的开放式基金 场内基金，例如ETF基金，它既可以申购赎回，又可以买卖。申购赎回需要几十万起，买卖则是100股起，所以我们一般是通过买卖获取ETF基金。场外基金一般只有申购赎回，大部分是1000元起，我们一般通过申赎获取场外基金，先做一个表格来说明这些费用都发生在哪些基金上 基金\\费用 申购费 赎回费 交易佣金 印花税 服务费 托管费 管理费 场内基金 无 无 有 有 无 有 有 场外基金 有 有 无 无 有/无 有 有 费用详解 申购费和赎回费 场内基金也可以申购，我在上面表格中没有写, 因为例如ETF基金申购一般是几十万起，我们一般不通过申购这一途径获取ETF基金，而是通过场内买卖ETF来获取。买卖跟股票一样，100股起买； 场外基金，一般都是申购获得。交易日下午3点前申购，按照当天收盘的基金净值申购；3点后，按照下一交易日收盘基金净值申购。 以我开始投资场外基金的平台南方基金来看下图： 如果频繁操作购买，1-1.5%的申购与赎回费用还是非常高的，购买1万元就要100到150元的成本，购买指数基金我们一般都会持有至少三年以上，现在好多基金平台都推出申购零手续费，如果持有超过两年也免掉赎回费用. 交易佣金(买卖佣金) 交易佣金针对场内基金来的。上面说过，场内基金可以通过买卖来获得，跟股票一样。需要去券商开股票账户，目前基本所有券商开户都是免费的。交易费率跟股票是一样的，部分券商可以商议。不确定的话可以联系自己的券商客户经理确定，没有任何做广告的嫌疑，我现在用华泰证券，费率还是很合适的. 印花税 印花税也是针对场内的品种来说的，股票买卖交易是需要交印花税的。印花税是股票交易非常重要的一个税种，甚至可以起到调节股市牛熊的作用。印花税是在买卖股票交割的时候券商就代为扣收了，买卖完股票后第二天查下交割单就可以知道扣了多少印花税。目前股票交易的印花税是交易额的千分之一，单边收取，即买股票不收，卖股票收。对场内基金来说，目前不需要交印花税 销售服务费 我们经常能看到一些基金公司宣传某只指数基金申赎费用全免。这里免申赎费用的基金指的是C类基金。是针对场外基金来说的。一般的场外指数基金，是收取申购赎回费，不管买卖频率如何。这样对于一些频繁操作场外基金的投资者，交易成本是非常高的。C类基金比较特殊。它不收取申购费用，一般持有一个月以上赎回也不收取赎回费用。但会固定收取一定比例的销售服务费，一般是0.4-0.6%。这样就把交易成本固定下来了, 依旧以南方基金举例 不过我投资指数基金一般是在低估值的时候分批买，高估值的时候分批卖，一般需要持有一年或多年以上。这种情况下挑选申购费一折的平台申购场外基金，交易成本可以控制在千一左右，持有两年以上也没有了赎回费；C类基金则需要固定交千四到千六，如果不是频繁申赎，不是特别好的选择 托管费管理费 上面说的费用都是在基金交易相关的费用。实际上基金在运营的时候还会产生管理费和托管费。这两项费用会直接从基金净值中扣。管理费就是基金公司的一个非常重要的利润来源。主动型基金一般会收取基金规模的1.5%作为管理费。例如管理10个亿的资产的股票基金，一年会收取1500万的管理费。指数基金作为被动型基金，管理费率一般低一些。国内指数基金的平均管理费率在0.83%左右。部分规模较大、运行时间较长的基金，管理费率会降到0.5%。这些可以在基金的公告中查看。托管费是交给基金的托管方的。基金的庞大资产，并不是直接存放在基金公司，一般会在第三方托管方，例如某家大型银行。像我们熟知的50ETF（510050），它的托管方就是工商银行。国内指数基金的托管费率平均在0.17%左右，低的可以做到0.15% 总结按照上面的表格以及费用详细做出如下总结： 总体来说，投资指数基金，无论场内还是场外，管理费和托管费都要交的，会从基金净值中扣（我们无能为力） 场内基金会收取交易佣金和印花税。目前场内基金印花税下调到了0，交易佣金不同券商不一样 场外基金如果不是C类基金，会收取申购费，赎回费持有超两年可免；C类基金适合频繁申赎的朋友，会收取约0.4-0.6%的销售服务费。定投的话选普通的场外基金就好，不用选C类（因为我们会持有这个基金至少3年以上） 我们经常看到某一只股票上标注一个“融”字，那这个字的含义是什么呢？ 这个词距离资金量还不是很大的投资者来说其实是一个比较遥远的，因为能做到融资融券不同的券商对投资者还有有很高的规格限制的，不过这个“融”字的内在含义还是非常有意思的. 融——融资融券融资融券是券商开拓的业务，都是发生在券商和投资者之间，和上市公司本生没关系。 融：就是扩大，开拓的意思 融资：其实就是借钱 融券：就是借股票 借钱我们好理解，但是为什么要借股票呢？我们知道中国股票市场只能做多，就是你买了股票只能等待上涨获利，如果股票下跌就没法获利了，而融券就提供了一种做空的工具。 举例说明 融资：投资者看好一只股票在未来会有上升趋势，苦于手中没有银两来购买股票，于是乎打算向券商借钱来购买该股票，等到指定期限将钱还给券商同时还要支付一些利息（钱不能是白借的啊） 张三看好股票A在未来会有上升趋势，手中却没有银两，张三已经具备了融资的资格（不同的券商标准不一样，请咨询具体的券商经理），于是乎向券商借了1万元钱以每股10元的价格购买了1000股，券商协定的还款日期到了，此时股票A的股价已经涨到了20元，这会我还是还券商1万元钱+利息，也就是说在这次融资的过程中（除去利息）赚了20000-10000=10000（元） 融券：与融资相反，投资者觉得某股A具有明显的下跌空间，但是手中并没有该股，于是乎打算向券商借来股票卖出去 张三觉得某股A具有明显的下跌空间，但是手中并没有该股，于是向券商借了100手于10元卖出，得10万元，等到该股下跌到9元后买回100手该股还给券商，买回只用了9万，获利1万元。这就是一种典型的融券 融券还有一种方式叫做对冲，试举例说明：投资者当天于10元买入某股100手，当天就涨到于11元，投资者想于该点卖出，但是苦于中国股市是T+1制度，当天买进的股票当天不能卖出。这时你可以融券该股100手于11元卖出，而把手中的100手还给券商，就相当于做了个T+0. 注意 实际操作中还有很多限制，比如“标的”就是一种，你不能对任何股票都进行融券，而只能对券商指定的股票群进行融券，这个股票群就叫“标的”。 另一个限制就是券商手中有可能没有你想融券的“标的”，因为券商也不傻，你想卖的股票，多半券商也不想留在手中。。。所以在考虑融券之前要查询一下券商手中是否还有该股票。 另外，借，就要有利息，不管融资还是融券都按照相关市值的银行利息结算（大致如此），但是很多券商都规定：当天借当天还没利息，所以有利于做T+0","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"投资理财学习","slug":"Life/投资理财学习","permalink":"https://dayarch.top/categories/Life/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"费用","slug":"费用","permalink":"https://dayarch.top/tags/%E8%B4%B9%E7%94%A8/"},{"name":"指数基金","slug":"指数基金","permalink":"https://dayarch.top/tags/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"}]},{"title":"Java多态调用顺序","slug":"Java多态调用顺序","date":"2017-05-05T12:21:20.000Z","updated":"2019-11-07T06:36:20.433Z","comments":true,"path":"/p/java-polymorphism-order.html","link":"","permalink":"https://dayarch.top/p/java-polymorphism-order.html","excerpt":"Java多态调用该案例 大家先看自行测试如下程序的输出结果是什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class A { public String show(D obj) { return (\"A and D\"); } public String show(A obj) {","text":"Java多态调用该案例大家先看自行测试如下程序的输出结果是什么？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class A &#123; public String show(D obj) &#123; return (\"A and D\"); &#125; public String show(A obj) &#123; return (\"A and A\"); &#125; &#125; public class B extends A&#123; public String show(B obj)&#123; return (\"B and B\"); &#125; public String show(A obj)&#123; return (\"B and A\"); &#125; &#125; public class C extends B&#123; &#125; public class D extends B&#123; &#125; public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1--\" + a1.show(b)); System.out.println(\"2--\" + a1.show(c)); System.out.println(\"3--\" + a1.show(d)); System.out.println(\"4--\" + a2.show(b)); System.out.println(\"5--\" + a2.show(c)); System.out.println(\"6--\" + a2.show(d)); System.out.println(\"7--\" + b.show(b)); System.out.println(\"8--\" + b.show(c)); System.out.println(\"9--\" + b.show(d)); &#125; &#125; 仔细思考哦…………….来看答案，有没有意外发生？ 1--A and A 2--A and A 3--A and D 4--B and A 5--B and A 6--A and D 7--B and B 8--B and B 9--A and D 接下来主要针对第四个输出结果做出解释，其他的输出结果按照此规矩自然就能得出，请记住： 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O) 所以，这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。 感谢感谢作者原文","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"多态","slug":"多态","permalink":"https://dayarch.top/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"OAuth2.0 详解","slug":"Oauth2-0-详解","date":"2017-05-05T08:13:12.000Z","updated":"2019-11-01T09:00:21.204Z","comments":true,"path":"/p/oauth2-detail.html","link":"","permalink":"https://dayarch.top/p/oauth2-detail.html","excerpt":"OAuth2.0 详解 以下内容为转载博主的内容 1. 为什么需要 Oauth2.0 协议？ 2. 开放平台 3. Access Token 与 Refresh Token 4. Implicit 授权方式 5. Authorization Code 授权 6. Resource Owner Password Credentials 授权和 Client Credentials 授权","text":"OAuth2.0 详解以下内容为转载博主的内容 为什么需要 Oauth2.0 协议？ 开放平台 Access Token 与 Refresh Token Implicit 授权方式 Authorization Code 授权 Resource Owner Password Credentials 授权和 Client Credentials 授权","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"安全-协议-规范","slug":"Coding/安全-协议-规范","permalink":"https://dayarch.top/categories/Coding/%E5%AE%89%E5%85%A8-%E5%8D%8F%E8%AE%AE-%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"https://dayarch.top/tags/OAuth2-0/"}]},{"title":"Hybris tomcat Jrebel热部署配置","slug":"Hybris-tomcat-Jrebel热部署配置","date":"2017-03-30T07:31:33.000Z","updated":"2019-11-07T05:28:27.664Z","comments":true,"path":"/p/hybris-jrebel.html","link":"","permalink":"https://dayarch.top/p/hybris-jrebel.html","excerpt":"背景 Jrebel是非常强大的实现项目热部署的软件，当然也比较消耗电脑的性能，当如Hybris的这种启动需要一段时间的项目，对于后端开发人员来说，改动一些东西就要重启服务真的是一种折磨，浪费时间，接下来说明一下Jrebel在Hybris项目中的配置 配置Jrebel Jrebel可以通过IntelliJ IDEA来下载安装集成好的插件，也可以单独下载Jrebel的包 （请支持正版） 方法一：通过IntelliJ IDEA 插件 如下图下载安装InteliJ IDEA 插件 安装好之后我们就可以在IntelliJ IDEA的安装目录中看到该插件，接下来在Hybris的local.prop","text":"背景Jrebel是非常强大的实现项目热部署的软件，当然也比较消耗电脑的性能，当如Hybris的这种启动需要一段时间的项目，对于后端开发人员来说，改动一些东西就要重启服务真的是一种折磨，浪费时间，接下来说明一下Jrebel在Hybris项目中的配置 配置JrebelJrebel可以通过IntelliJ IDEA来下载安装集成好的插件，也可以单独下载Jrebel的包 （请支持正版） 方法一：通过IntelliJ IDEA 插件如下图下载安装InteliJ IDEA 插件 安装好之后我们就可以在IntelliJ IDEA的安装目录中看到该插件，接下来在Hybris的local.properties文件中来配置tomcat #JRebel tomcat.javaoptions=-agentpath:&quot;D:/Users/fraser/.IntelliJIdea2016.2/config/plugins/jr-ide-idea/lib/jrebel6/lib/jrebel64.dll&quot; -DforceANSI=true tomcat.debugjavaoptions=-agentpath:&quot;D:/Users/fraser/.IntelliJIdea2016.2/config/plugins/jr-ide-idea/lib/jrebel6/lib/jrebel64.dll&quot; -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n -DforceANSI=true方法二：通过安装包下载Jrebel安装包来，将安装包解压到某一个目录下，然后同样配置local.properties 文件如下： #JREBEL tomcat.javaoptions=-Xverify:none -javaagent:&quot;E:/MyProjectSpace/jrebel_5.6.0/jrebe/jrebel.jar=de.hybris.tomcat.HybrisWebappClassLoader60&quot; tomcat.debugjavaoptions=-Xverify:none -javaagent:&quot;E:/MyProjectSpace/jrebel_5.6.0/jrebe/jrebel.jar=de.hybris.tomcat.HybrisWebappClassLoader60&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8060,suspend=y #可不配 tomcat.generaloptions=-Xmx2G -Xms2G -XX:PermSize=500M -XX:MaxPermSize=300M -Xss256K -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+CMSPermGenSweepingEnabled -XX:+CMSClassUnloadingEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+CMSScavengeBeforeRemark -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:&quot;${HYBRIS_LOG_DIR}/tomcat/java_gc.log&quot; -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dorg.tanukisoftware.wrapper.WrapperManager.mbean=true -Djava.endorsed.dirs=..b/endorsed -Dcatalina.base=%CATALINA_BASE% -Dcatalina.home=%CATALINA_HOME% -Dfile.encoding=UTF-8 -Dlog4j.configuration=log4j_init_tomcat.properties -Djava.util.logging.config.file=jdk_logging.properties -Djava.io.tmpdir=&quot;${HYBRIS_TEMP_DIR}&quot; -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000测试启动Hybris服务器如看到如下信息就说明Jrebel配置成功： 这样我们执行ant build 命令等待build成功，就可以实现热部署，如果遇到如下问题： 找到D:\\projects\\hybrisHn\\hybris\\bin\\ext-backoffice\\backoffice\\buildcallbacks.xml 文件，按照如下注释掉 即可 &lt;macrodef name=&quot;backoffice_after_build&quot;&gt; &lt;sequential&gt; &lt;!--&lt;backoffice_remove_web_fragments/&gt;--&gt; &lt;backoffice_create_web_fragments/&gt; &lt;/sequential&gt; &lt;/macrodef&gt;重新尝试ant build 命令应该就可以build成功，快尝试一下吧","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Hybris","slug":"Hybris","permalink":"https://dayarch.top/tags/Hybris/"},{"name":"Jrebel","slug":"Jrebel","permalink":"https://dayarch.top/tags/Jrebel/"}]},{"title":"Linux 根据关键字查看集群服务器的log","slug":"Linux-根据关键字查看集群服务器的log","date":"2017-03-29T07:22:34.000Z","updated":"2019-11-01T08:46:43.214Z","comments":true,"path":"/p/linux-search-keyword-script.html","link":"","permalink":"https://dayarch.top/p/linux-search-keyword-script.html","excerpt":"背景 现在项目多数会采用集群部署的形式，进行负载均衡，来分担客户端大量请求的压力，当客户端请求发生异常，异常log只能在某一个服务器节点上产生，当服务器节点比较少时候，我们可以根据log的关键字来单个查找，但是当服务器节点多的时候我们还这么查找真的有些浪费时间而且不准确. 解决方案 在某一台release 服务器上执行下面脚本即可完成多个节点的log信息的查询 check_log_in_console.sh脚本内容如下 #!/bin/bash if [ $# -lt 1 ]; then echo \"please provide the content you want to find","text":"背景现在项目多数会采用集群部署的形式，进行负载均衡，来分担客户端大量请求的压力，当客户端请求发生异常，异常log只能在某一个服务器节点上产生，当服务器节点比较少时候，我们可以根据log的关键字来单个查找，但是当服务器节点多的时候我们还这么查找真的有些浪费时间而且不准确. 解决方案在某一台release 服务器上执行下面脚本即可完成多个节点的log信息的查询check_log_in_console.sh脚本内容如下 #!/bin/bash if [ $# -lt 1 ]; then echo &quot;please provide the content you want to find&quot; echo &quot;usage: $0 [content] [date in yyyymmdd format]&quot; exit 0 fi if [ &quot;$2&quot; == &quot;&quot; ]; then d=`date +%Y%m%d` else d=$2 fi s=prd-hybris-pad for((i=1;i&lt;=4;i++)) do server=$s$i.bb.com echo &quot;============check logs on $server====================&quot; ssh app@$server &quot;grep &apos;$1&apos; /data/workspace/hybris/hybris/log/tomcat/console-$d.log&quot; sleep 1 done echo &quot;done&quot; #exit 0这样我们只需要在该文件目录中执行 ./check_log_in_console.sh &quot;你要搜索的关键字&quot; [回车]就会去以上节点中四个服务器中去查找你要搜索的关键字，打印出类似如下的log信息： ============check logs on prd-hybris-pad1.bb.com========== ============check logs on prd-hybris-pad2.bb.com========== ============check logs on prd-hybris-pad3.bb.com========== ============check logs on prd-hybris-pad4.bb.com==========","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Linux","slug":"Coding/Linux","permalink":"https://dayarch.top/categories/Coding/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dayarch.top/tags/Linux/"}]},{"title":"Spring MVC 之 @ResponseStatus","slug":"Spring-MVC-之-ResponseStatus","date":"2017-03-28T09:09:03.000Z","updated":"2019-12-19T13:33:55.817Z","comments":true,"path":"/p/springmvc-response-status.html","link":"","permalink":"https://dayarch.top/p/springmvc-response-status.html","excerpt":"@ResponseStatus Restful webservice请求会用到@ResponseStatus 注解，该注解可用于类级别上，也可以应用在方法级别上，代表请求响应的状态，通常就是返回HttpStatus的状态码，具体可查询每个状态码代，这里简单罗列一些： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 CONTINUE(100, \"Continue\"), SWITCHING_PROTOCOLS(101, \"Switching Protocols\"), PROCESSING(102, \"Processing\"), CHECKPOINT(103","text":"@ResponseStatusRestful webservice请求会用到@ResponseStatus 注解，该注解可用于类级别上，也可以应用在方法级别上，代表请求响应的状态，通常就是返回HttpStatus的状态码，具体可查询每个状态码代，这里简单罗列一些： 1234567891011121314151617CONTINUE(100, \"Continue\"),SWITCHING_PROTOCOLS(101, \"Switching Protocols\"),PROCESSING(102, \"Processing\"),CHECKPOINT(103, \"Checkpoint\"),OK(200, \"OK\"),CREATED(201, \"Created\"),ACCEPTED(202, \"Accepted\"),NON_AUTHORITATIVE_INFORMATION(203, \"Non-Authoritative Information\"),NO_CONTENT(204, \"No Content\"),RESET_CONTENT(205, \"Reset Content\"),PARTIAL_CONTENT(206, \"Partial Content\"),MULTI_STATUS(207, \"Multi-Status\"),ALREADY_REPORTED(208, \"Already Reported\"),IM_USED(226, \"IM Used\"),MULTIPLE_CHOICES(300, \"Multiple Choices\"),MOVED_PERMANENTLY(301, \"Moved Permanently\"),FOUND(302, \"Found\"), 应用在类级别创建一个异常类，用该注解标注 123456789package com.zj.exception;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=\"用户不匹配\")public class UserNotMatchException extends RuntimeException&#123;&#125; 写一个目标方法来抛出异常 123456@RequestMapping(\"/testResponseStatus\")public String testResponseStatus(int i)&#123; if(i==0) throw new UserNotMatchException(); return \"hello\";&#125; 这样当我们请求该方法，如果出现异常，会将用户不匹配的信息返回给浏览器，让异常信息更加明确，而不是一堆异常信息代码 应用在方法级别1234567@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=\"用户名不匹配\")@RequestMapping(\"/testResponseStatus\")public String testResponseStatus(int i)&#123; if(i==0) throw new UserNotMatchException(); return \"hello\";&#125; ResponseStatus修饰目标方法，无论它执行方法过程中有没有异常产生，用户都会得到异常的界面。而目标方法正常执行 这个情况要看项目的使用情况，通常会制定一个标准的异常信息显示，可以灵活使用.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://dayarch.top/tags/Spring/"}]},{"title":"Spring MVC 之 @initbinder","slug":"Spring-MVC-之-initbinder","date":"2017-03-28T08:24:26.000Z","updated":"2019-12-19T13:33:04.382Z","comments":true,"path":"/p/springmvc-init-binder.html","link":"","permalink":"https://dayarch.top/p/springmvc-init-binder.html","excerpt":"背景 在Web项目中，太多需要提交表单或者在请求URL中添加参数信息的操作，无论是前者还是后者，SpringMVC都将每个元素当做String来处理， 如果前台传入格式化为字符串的日期或这数值类型的时候就会报错（在SpringMVC中，bean中定义了Date，double等类型，如果没有做任何处理的话，日期以及double都无法绑定），我们手动来强制转型很是麻烦，SpringMVC 提供的@initbinder 就是解决这个问题 @initbinder 在我的项目中是在BaseController中增加方法initBinder，并使用注解@InitBinder标注，那么spring mvc","text":"背景在Web项目中，太多需要提交表单或者在请求URL中添加参数信息的操作，无论是前者还是后者，SpringMVC都将每个元素当做String来处理， 如果前台传入格式化为字符串的日期或这数值类型的时候就会报错（在SpringMVC中，bean中定义了Date，double等类型，如果没有做任何处理的话，日期以及double都无法绑定），我们手动来强制转型很是麻烦，SpringMVC 提供的@initbinder 就是解决这个问题 @initbinder在我的项目中是在BaseController中增加方法initBinder，并使用注解@InitBinder标注，那么spring mvc在绑定表单之前，都会先注册这些编辑器, Spring自己提供了大量的实现类，诸如CustomDateEditor ，CustomBooleanEditor，CustomNumberEditor等许多，基本上够用, 当然我们也可以自己来写这些编辑器. 自定义编辑器123456789101112131415161718192021222324252627282930import org.springframework.beans.propertyeditors.PropertiesEditor; public class DoubleEditor extends PropertiesEditor &#123; @Override public void setAsText(String text) throws IllegalArgumentException &#123; if (text == null || text.equals(\"\")) &#123; text = \"0\"; &#125; setValue(Double.parseDouble(text)); &#125; @Override public String getAsText() &#123; return getValue().toString(); &#125; &#125; ``` 类似Long、Float等都可以这样写，然后将这些自定义的编辑器或Spring自带的编辑器放到BaseController中带有@initbinder的方法中注册就好.```java@InitBinder protected void initBinder(WebDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"), true)); binder.registerCustomEditor(int.class, new CustomNumberEditor(int.class, true)); binder.registerCustomEditor(int.class, new IntegerEditor()); binder.registerCustomEditor(long.class, new CustomNumberEditor(long.class, true)); binder.registerCustomEditor(long.class, new LongEditor()); binder.registerCustomEditor(double.class, new DoubleEditor()); binder.registerCustomEditor(float.class, new FloatEditor()); &#125; 当然我们也可以将自定义的编辑器直接继承 PropertyEditorSupport， 因为： 1public class org.springframework.beans.propertyeditors.PropertiesEditor extends java.beans.PropertyEditorSupport &#123; 参考非常感谢一下两位作者贡献整理的文章： spring mvc使用@InitBinder 标签对表单数据绑定 @InitBind来解决字符串转日期类型","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://dayarch.top/tags/SpringMVC/"}]},{"title":"Java中的ArrayList的容量","slug":"Java中的ArrayList的容量","date":"2017-03-16T03:33:44.000Z","updated":"2019-11-07T05:31:10.268Z","comments":true,"path":"/p/java-arraylist-capacity.html","link":"","permalink":"https://dayarch.top/p/java-arraylist-capacity.html","excerpt":"1. List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。 2. ArrayList继承于List接口，除继承过来的方法外，还提供一些方法来操作内部用来存储列表的数组的大小。 3. 每个ArrayList实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。 4. ArrayList是经常会被用到的，一般情况下，使用的时候会","text":"List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。 ArrayList继承于List接口，除继承过来的方法外，还提供一些方法来操作内部用来存储列表的数组的大小。 每个ArrayList实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。 ArrayList是经常会被用到的，一般情况下，使用的时候会像这样进行声明： List arrayList = new ArrayList();如果像上面这样使用默认的构造方法，初始容量被设置为10。当ArrayList中的元素超过10个以后，会重新分配内存空间，使数组的大小增长到16。可以通过调试看到动态增长的数量变化：10-&gt;16-&gt;25-&gt;38-&gt;58-&gt;88-&gt;… 也可以使用下面的方式进行声明： List arrayList = new ArrayList(4);将ArrayList的默认容量设置为4。当ArrayList中的元素超过4个以后，会重新分配内存空间，使数组的大小增长到7。可以通过调试看到动态增长的数量变化：4-&gt;7-&gt;11-&gt;17-&gt;26-&gt;… 那么容量变化的规则是什么呢？请看下面的公式： ((旧容量 * 3) / 2) + 1注：这点与C#语言是不同的，C#当中的算法很简单，是翻倍。 一旦容量发生变化，就要带来额外的内存开销，和时间上的开销。所以，在已经知道容量大小的情况下，推荐使用下面方式进行声明：List arrayList = new ArrayList(CAPACITY_SIZE); 即指定默认容量大小的方式。 感谢原文作者：原文","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"https://dayarch.top/tags/ArrayList/"}]},{"title":"Jenkins自动化部署Hybris","slug":"Jenkins自动化部署Hybris","date":"2017-03-08T07:03:17.000Z","updated":"2019-11-01T08:46:23.478Z","comments":true,"path":"/p/jenkins-hybris-deploy.html","link":"","permalink":"https://dayarch.top/p/jenkins-hybris-deploy.html","excerpt":"前言 项目开发时间不算紧张，知道项目应用Jenkins 持续集成实现自动化部署，这个部署是如何实现的，向架构师取经研究之后做此记录. 部署架构拓扑图 以下是项目部署架构简易拓扑图，不包括Solr服务器的部署, Prod Env采用Cluster Deployment的方式. 运维人员搭建Jenkins服务器之后，每位被授权的开发人员都可以访问Jenkins 工作主页， 当push代码之后，统一在指定时间点build (Jenkins没有采用有push代码自动build的方式 ). 1. 开发人员Push 代码 2. Build QA1, 功能测试通过之后进行下一步 3. Bu","text":"前言项目开发时间不算紧张，知道项目应用Jenkins 持续集成实现自动化部署，这个部署是如何实现的，向架构师取经研究之后做此记录. 部署架构拓扑图以下是项目部署架构简易拓扑图，不包括Solr服务器的部署, Prod Env采用Cluster Deployment的方式. 运维人员搭建Jenkins服务器之后，每位被授权的开发人员都可以访问Jenkins 工作主页， 当push代码之后，统一在指定时间点build (Jenkins没有采用有push代码自动build的方式 ). 开发人员Push 代码 Build QA1, 功能测试通过之后进行下一步 Build QA2, 功能测试通过之后进行下一步 等待发布版本时间节点 Build Stage环境，功能测试通过之后进行下一步 （拓扑图中没有显示Stage环境） Build Prod 环境， 功能测试通过之后成功发布. 开发人员只需要点击Jenkins控制台的Build，即可完成自动化部署，这正是Jenkins 带来的便利，接下来就解释一下Jenkins 整个工作过程. Jenkins 持续集成过程详解生产环境是采用集群部署，和QA环境是有所区别的，下面针对生产环境和QA环境分别作解释 Common 环境解释Jenkins 的Home Directory 是 /var/lib/jenkinsQA环境部署 以QA1 环境为例，item名称为 qa_honor_hybris, workspace的路径是Jenkins 的workspace路径与item名称的拼接，这样当前item的$workspace的路径为 /var/lib/jenkins/workspace/qa_honor_hybris 点击build之后，Jenkins会按照该item配置好的Git Repository 来拉取最新代码到workspace中 执行自定义Shell 脚本(Jenkins 控制台写好的脚本) # 1. 移除掉工作区旧代码 rm -rf /data/qa_honor_hybris/hybris/bin/custom # 2. copy 拉取下来的最新代码到工作区中 cp -r $WORKSPACE/bin/custom /data/qa_honor_hybris/hybris/bin # 3. copy local.properties 和 localextensions.xml 到 工作区config目录下 cp $WORKSPACE/config/local.properties /data/qa_honor_hybris/hybris/config cp $WORKSPACE/config/localextensions.xml /data/qa_honor_hybris/hybris/config # 5. 进入工作区platform 目录 cd /data/qa_honor_hybris/hybris/bin/platform # 6. 设置基本环境变量，当然可以Jenkins 设置好 export JAVA_HOME=/usr/local/jdk1.8 export JRE_HOME=/usr/local/jdk1.8/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$PATH # 7. 指定ant 目录并且build，执行该步骤是为了检测项目是否能build成功 . ./setantenv.sh ant clean all # 8. 切换到工作区build 目录下 cd /data/qa_honor_hybris/build ./build_and_deploy.sh ./build_and_deploy.sh 脚本内容 #!/bin/bash # 1. 进入工作区目录 cd /var/lib/jenkins/workspace/qa1-honor-hybris echo &quot;build for honor hybris qa1&quot; # 删除workspace 历史内容 echo &quot;create honor source code tar ball&quot; rm -rf honor rm -rf honor.tar.gz # 创建文件夹，等待打包 mkdir honor # copy workspace 最新代码拷贝到 刚刚新建的honor 文件夹中 cp -r /var/lib/jenkins/workspace/qa1-honor-hybris/bin honor cp -r /var/lib/jenkins/workspace/qa1-honor-hybris/config/qa honor # 将honor 文件夹压缩打包 tar -zcvf honor.tar.gz honor # 将打包的honor.tar.gz 远程copy到 QA1 服务器的workspace 中 echo &quot;======copy tar ball to qa1 server(10.11.12.233)=====&quot; scp honor.tar.gz app@10.11.12.233:/data/build_workspace # 进入到QA1 环境并且进入workspace, 停掉QA1 的服务 echo &quot;===build hybris and start hybris on qa1 server===&quot; ssh app@10.11.12.233 &apos;cd /data/build_workspace;. ./stop.sh&apos; # 执行QA1相应路径下的脚本. ssh app@10.11.12.233 &apos;cd /data/build_workspace;. ./build_and_start.sh&apos; echo &quot;build_and_deploy done&quot; exit 0 ./build_and_start.sh 脚本内容 #!/bin/bash # 1. 删除掉honor 文件夹（确保文件夹删除，下面其实已经删除了一次） rm -rf honor # 2. 赋予可读可写可执行的权限 chmod 755 honor.tar.gz # 3. 解压刚刚传输过来的压缩包，并赋予可读可写可执行的权限 tar -zxvf honor.tar.gz chmod -R 755 honor # 4. 删除掉旧的Hybris代码 echo &quot;remove old honor hybris source code...&quot; rm -rf /data/build_workspace/honor-hybris/hybris/bin/custom rm -rf /data/build_workspace/honor-hybris/hybris/config/local.properties rm -rf /data/build_workspace/honor-hybris/hybris/config/localextensions.xml # 5. copy刚刚解压出来的honor文件夹的内容到工作区 echo &quot;copy new honor source code...&quot; cd /data/build_workspace cp -r honor/* honor-hybris/hybris cp honor/qa/local_qa1.properties honor-hybris/hybris/config/local.properties cp honor/qa/localextensions.xml honor-hybris/hybris/config/localextensions.xml # 6. 删除解压出来的文件夹 rm -rf honor # 7. 设置环境变量 echo &quot;begin to start qa1...&quot; export JAVA_HOME=&quot;/usr/local/jdk1.8.0_101&quot; export PATH=$JAVA_HOME/bin:$PATH cd /data/build_workspace/honor-hybris/hybris/bin/platform . ./setantenv.sh ant clean all # 8. 直接以debug模式启动（方便远程调试，但是Jenkins build进度条始终是红色，不影响使用，还没找到这个解决办法） . ./hybrisserver.sh debug exit 0 以上是QA环境还不涉及到多node的情况，接下来会介绍Prod 的情况，大体流程和QA环境相似，只不过是多了处理node的情况. Prod 环境部署 Jenkins 在build之后会将最新的代码pull到release服务器， 然后在release服务器上执&gt; 行脚本，将代码发布到各个服务器上, 在release服务器的/data 目录下有两个目录 /data/install: 将环境所需的软件、Licence等存放在此，这些只是第一次发布的时候会用到 /data/build: 这是真正build的所需要的目录 点击build之后，Jenkins会按照该item配置好的Git Repository 来拉取最新代码到workspace中 执行自定义Shell 脚本(Jenkins 控制台写好的脚本, 和QA环境类似，注意目录的改变) rm -rf /data/prod_honor_hybris/hybris/bin/custom cp -r $WORKSPACE/bin/custom /data/prod_honor_hybris/hybris/bin cp $WORKSPACE/config/local.properties /data/prod_honor_hybris/hybris/config cp $WORKSPACE/config/localextensions.xml /data/prod_honor_hybris/hybris/config cd /data/prod_honor_hybris/hybris/bin/platform export JAVA_HOME=/usr/local/jdk1.8 export JRE_HOME=/usr/local/jdk1.8/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$PATH . ./setantenv.sh ant clean all cd /data/prod_honor_hybris/build ./build_and_deploy.sh ./build_and_deploy.sh 脚本内容 #!/bin/bash cd /var/lib/jenkins/workspace/prod-honor-hybris echo &quot;build for honor hybris product&quot; echo &quot;create honor source code tar ball&quot; rm -rf honor rm -rf honor.tar.gz mkdir honor cp -r /var/lib/jenkins/workspace/prod-honor-hybris/bin honor cp -r /var/lib/jenkins/workspace/prod-honor-hybris/config/prod honor tar -zcvf honor.tar.gz honor # 1. 生产上要备份原有的压缩包，以防万一进行恢复版本 echo &quot;======backup original tar in release server(10.11.12.232)=====&quot; ssh app@10.11.12.232 &quot;cp /data/build/product/honor.tar.gz /data/build/product/honor.tar.gz_backup&quot; echo &quot;======copy tar ball to release server(10.11.12.232)=====&quot; scp honor.tar.gz app@10.11.12.232:/data/build/product echo &quot;build_and_deploy done&quot; exit 0 发布内容前端服务器，进入到Prod Release 服务器相应目录执行脚本app_release.sh 主要动态循环IP地址，将文件传送到不同的服务器，执行相应服务器的脚本. #!/bin/bash if [ $# -lt 2 ]; then echo &quot;please provide server start index and end index&quot; echo &quot;usage: $0 [start] [end]&quot; # exit 0 fi s=prd-hybris-pad baseIp=11.12.126. let ipStartNum=$1+54 echo &quot;release artifact to hybris server from $s$1 to $s$2&quot; for((i=$1;i&lt;=$2;i++)) do server=$s$i.xxx.com ipAddr=$baseIp$ipStartNum echo &quot;============deploy on $server====================&quot; echo &quot;copy Hybris production Deployment ZIP to $server&quot; scp /data/build/product/honor.tar.gz app@$server:/data/workspace echo &quot;build hybris on $server and start hybris&quot; ssh app@$server &quot;cd /data/workspace;./stop.sh; nohup ./build_and_start.sh $ipAddr &gt;./build.log 2&gt;&amp;1 &amp; &quot; let ipStartNum=$ipStartNum+1 sleep 1 done echo &quot;done&quot; #exit 0 Prod 服务器目录结构 进入到Prod 服务器之一 查看./stop.sh 脚本内容 #!/bin/bash cd /data/workspace/hybris/hybris/bin/platform . ./setantenv.sh &amp;&amp; ./hybrisserver.sh stop 查看./build_and_start.sh内容（内容有些复杂） #!/bin/bash rm -rf honor chmod 755 honor.tar.gz tar -zxvf honor.tar.gz chmod -R 755 honor echo &quot;remove old honor hybris source code...&quot; rm -rf /data/workspace/hybris/hybris/bin/custom rm -rf /data/workspace/hybris/hybris/config/local.properties rm -rf /data/workspace/hybris/hybris/config/localextensions.xml echo &quot;copy new honor source code...&quot; cp -r honor/* hybris/hybris cp honor/prod/local.properties hybris/hybris/config/local.properties cp honor/prod/localextensions.xml hybris/hybris/config/localextensions.xml cp template.tomcat.context.tpl hybris/hybris/config/tomcat/tomcat_context.tpl sed -c -i &apos;s/.*name=&quot;backoffice&quot;.*/&lt;!-- &lt;extension name=&quot;backoffice&quot; \\/&gt; --&gt;/g&apos; hybris/hybris/config/localextensions.xml sed -c -i &apos;s/.*requires-channel=&quot;https&quot;.*/&lt;intercept-url pattern=&quot;\\/\\*\\*&quot; requires-channel=&quot;https&quot;\\/&gt;/g&apos; hybris/hybris/bin/custom/honor/honorcommercewebservices/web/webroot/WEB-INF/config/v2/security-v2-spring.xml sed -c -i &apos;s/.*name=&quot;mcc&quot;.*/&lt;!-- &lt;extension name=&quot;mcc&quot; \\/&gt; --&gt;/g&apos; hybris/hybris/config/localextensions.xml #echo cluster.id=$1 &gt;&gt; hybris/hybris/config/local.properties echo -e &quot;\\ncluster.broadcast.method.jgroups.tcp.bind_addr=$1&quot; &gt;&gt; hybris/hybris/config/local.properties echo -e &quot;\\ntask.processing.enabled=fase&quot; &gt;&gt; hybris/hybris/config/local.properties echo -e &quot;\\nhac.webroot=/hac&quot; &gt;&gt; hybris/hybris/config/local.properties rm -rf honor echo &quot;begin to start server...&quot; export JAVA_HOME=&quot;/usr/local/jdk1.8.0_101&quot; export PATH=$JAVA_HOME/bin:$PATH cd /data/workspace/hybris/hybris/bin/platform . ./setantenv.sh ant clean all . ./hybrisserver.sh start exit 0 template.tomcat.context.tpl 文件内容 #if ( $contextPath != &apos;/hmc&apos; &amp;&amp; $contextPath != &apos;/hac&apos; &amp;&amp; $contextPath != &apos;/backoffice&apos; &amp;&amp; $contextPath != &apos;/advancedexport&apos; &amp;&amp; $contextPath != &apos;/admincockpit&apos; &amp;&amp; $contextPath != &apos;/mcc&apos; &amp;&amp; $contextPath != &apos;/reportcockpit&apos; &amp;&amp; $contextPath != &apos;/importcockpit&apos; &amp;&amp; $contextPath != &apos;/cscockpit&apos; &amp;&amp; $contextPath != &apos;/cmscockpit&apos; &amp;&amp; $contextPath != &apos;/cmscockpitRegular&apos; &amp;&amp; $contextPath != &apos;/productcockpit&apos; &amp;&amp; $contextPath != &apos;/chinacheckoutaddon&apos; &amp;&amp; $contextPath != &apos;/instore&apos; &amp;&amp; $contextPath != &apos;/virtualjdbc&apos; &amp;&amp; $contextPath != &apos;/erpintegration&apos; &amp;&amp; $contextPath != &apos;/acceleratorservices&apos; &amp;&amp; $contextPath != &apos;/commercesearchsampledata&apos; &amp;&amp; $contextPath != &apos;/solrfacetsearch&apos; ) #if($contextDescription &amp;&amp; $contextDescription != &apos;&apos;) &lt;!-- $contextDescription --&gt; #end &lt;Context path=&quot;$contextPath&quot; docBase=&quot;$contextDocBase&quot; $!contextAdditionalAttributes&gt; &lt;Manager pathname=&quot;&quot; /&gt; #if($contextLoader &amp;&amp; $contextLoader != &apos;&apos;) $contextLoader #end #if($contextAdditionalElements &amp;&amp; $contextAdditionalElements != &apos;&apos;) $contextAdditionalElements #end &lt;/Context&gt; #end 发布内容后端服务器，进入到Prod Release 服务器相应目录执行脚本backend_release.sh #!/bin/bash if [ $# -lt 2 ]; then echo &quot;please provide server start index and end index&quot; echo &quot;usage: $0 [start] [end]&quot; # exit 0 fi s=prd-hybris baseIp=10.0.126. let ipStartNum=$1+52 echo &quot;release artifact to hybris server from $s$1 to $s$2&quot; for((i=$1;i&lt;=$2;i++)) do server=$s$i.xxxx.com ipAddr=$baseIp$ipStartNum echo &quot;============deploy on $server====================&quot; echo &quot;copy Hybris production Deployment ZIP to $server&quot; scp /data/build/product/honor.tar.gz app@$server:/data/workspace echo &quot;build hybris on $server and start hybris&quot; ssh app@$server &quot;cd /data/workspace;./stop.sh; nohup ./build_and_start.sh $ipAddr &gt;./build.log 2&gt;&amp;1 &amp; &quot; let ipStartNum=$ipStartNum+1 sleep 1 done echo &quot;done&quot; #exit 0 security-v2-spring.xml 文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- [y] hybris Platform Copyright (c) 2000-2016 SAP SE or an SAP affiliate company. All rights reserved. This software is the confidential and proprietary information of SAP (&quot;Confidential Information&quot;). You shall not disclose such Confidential Information and shall use it only in accordance with the terms of the license agreement you entered into with SAP. --&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:security=&quot;http://www.springframework.org/schema/security&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;http pattern=&quot;/v2/**&quot; entry-point-ref=&quot;oauthAuthenticationEntryPointV2&quot; access-decision-manager-ref=&quot;webSecurityAccessDecisionManager&quot; xmlns=&quot;http://www.springframework.org/schema/security&quot; create-session=&quot;stateless&quot;&gt; &lt;anonymous username=&quot;anonymous&quot; granted-authority=&quot;ROLE_ANONYMOUS&quot;/&gt; &lt;!--&lt;session-management session-authentication-strategy-ref=&quot;fixation&quot;/&gt;--&gt; &lt;intercept-url pattern=&quot;/**&quot; requires-channel=&quot;https&quot;/&gt; &lt;port-mappings&gt; &lt;port-mapping http=&quot;#{configurationService.configuration.getProperty(&apos;tomcat.http.port&apos;)}&quot; https=&quot;#{configurationService.configuration.getProperty(&apos;tomcat.ssl.port&apos;)}&quot;/&gt; &lt;port-mapping http=&quot;#{configurationService.configuration.getProperty(&apos;embeddedserver.http.port&apos;)}&quot; https=&quot;#{configurationService.configuration.getProperty(&apos;embeddedserver.ssl.port&apos;)}&quot; /&gt; &lt;/port-mappings&gt; &lt;custom-filter ref=&quot;resourceServerFilter&quot; before=&quot;PRE_AUTH_FILTER&quot;/&gt; &lt;access-denied-handler ref=&quot;oauthAccessDeniedHandlerV2&quot;/&gt; &lt;headers &gt; &lt;content-type-options /&gt; &lt;hsts include-subdomains=&quot;true&quot; max-age-seconds=&quot;16070400&quot; /&gt; &lt;xss-protection /&gt; &lt;security:frame-options disabled=&quot;true&quot;/&gt; &lt;/headers&gt; &lt;security:csrf disabled=&quot;true&quot;/&gt; &lt;/http&gt; &lt;bean id=&quot;oauthAuthenticationEntryPointV2&quot; parent=&quot;oauthAuthenticationEntryPoint&quot;&gt; &lt;property name=&quot;exceptionRenderer&quot; ref=&quot;oAuth2ExceptionRendererV2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;oauthAccessDeniedHandlerV2&quot; parent=&quot;oauthAccessDeniedHandler&quot;&gt; &lt;property name=&quot;exceptionRenderer&quot; ref=&quot;oAuth2ExceptionRendererV2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;oAuth2ExceptionRendererV2&quot; parent=&quot;oAuth2ExceptionRenderer&quot;&gt; &lt;property name=&quot;messageConverters&quot; ref=&quot;messageConvertersV2&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 大家看到了好处，也看到了Jenkins 不同服务器的部署基本类似，就是苦力活了， 接下来会将docker的部署陆续添加进来.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://dayarch.top/tags/Jenkins/"}]},{"title":"Spring AOP","slug":"Spring-AOP配置","date":"2017-02-23T12:14:54.000Z","updated":"2019-11-01T08:52:53.872Z","comments":true,"path":"/p/spring-aop.html","link":"","permalink":"https://dayarch.top/p/spring-aop.html","excerpt":"前言 Spring AOP 的道理懂得，但是很少在项目中使用，刚巧这个项目中有用到，将AOP的理解以及使用中遇到的问题加以总结记录 使用场景 设想一下，项目已接近尾声，经理说为了项目验收，更好的监控程序调用日志，需要在每个方法调用前或调用后加上日志，天啊，这是多大的工作量，项目中至少有几百个方法，我们要做这种无脑的工作了吗？ 如果不懂得Spring AOP面向切面编程的道理，那这个体力活看来是费力不讨好的事情，接下来让我们慢慢剖析Spring AOP 的道理. Java 动态代理 Java23中设计模式之一代理模式，Spring AOP充分利用了Java 动态代理功能来实现（对动态代理有所","text":"前言Spring AOP 的道理懂得，但是很少在项目中使用，刚巧这个项目中有用到，将AOP的理解以及使用中遇到的问题加以总结记录 使用场景设想一下，项目已接近尾声，经理说为了项目验收，更好的监控程序调用日志，需要在每个方法调用前或调用后加上日志，天啊，这是多大的工作量，项目中至少有几百个方法，我们要做这种无脑的工作了吗？ 如果不懂得Spring AOP面向切面编程的道理，那这个体力活看来是费力不讨好的事情，接下来让我们慢慢剖析Spring AOP 的道理. Java 动态代理Java23中设计模式之一代理模式，Spring AOP充分利用了Java 动态代理功能来实现（对动态代理有所理解的可以跳过该段内容），即便没有Spring AOP 我们也能够通过Java 动态代理解决上述问题. 在Java 动态代理中有两个重要的接口或类： InvocationHandler （Interface） Proxy （Class） 这一个接口和类是实现我们动态代理所必须用到的，其实这种设计模式可以联想到我们现实生活中的代购或代理商: 这是什么，怎么好像和我们说的项目中需要不沾边际，项目快要结束了，满项目鞋子和衣服方法已经写好，突然项目经理说要给鞋子和衣服加上包装（日志），刚好代理商可以轻松做到这个，每次客户调用鞋子和衣服方法时，只需要调用代理商暴露出来的鞋子和方法即可, 还没懂？ 没关系，程序猿看代码还是最实际的. InvocationHandler看一下官方定义： InvocationHandler is the interface implemented by the invocation handler of a proxy instance. Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler. —— InvocationHandler 是一个接口，它被一个代理类实例的handler所实现，每一个代理类实例都有其对应的handler, 当一个代理实例的方法被调用，方法的调用就交给了它对应的handler来处理 InvocationHandler 接口只定义了一个方法： Object invoke(Object proxy, Method method, Object[] args) throws Throwable; proxy : 代理类对象 method : 我们调用真实对象的某个方法 args : 我们调用真是对象的某个方法接受的参数 Proxy看一下官方定义： Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. —— Proxy提供一个静态方法用来创建动态代理类实例，并且是所有代理类的父类 Proxy 类中最常用的方法是： /** *Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler */ public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) { try { Class e = getProxyClass(loader, interfaces); return e.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{h}); } catch (RuntimeException var4) { throw var4; } catch (Exception var5) { throw new CodeGenerationException(var5); } } loader : 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载 interfaces : 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 h : 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 代码示例定义Subject 接口：public interface Subject { public void shoes(); public void clothes(String str); }定义接口真实实现类public class RealSubject implements Subject { @Override public void shoes() { System.out.println(&quot;This is shoes method without packaging&quot;); } @Override public void clothes(String str) { System.out.println(&quot;hello: &quot; + str); } }定义动态代理类，并实现InvocationHandler 接口public class DynamicProxy implements InvocationHandler { //这个就是我们要代理的真实对象 private Object subject; //构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) { this.subject = subject; } @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable { //在代理真实对象前我们可以添加一些自己的操作，比如给鞋子和衣服做包装 System.out.println(&quot;before packaging&quot;); System.out.println(&quot;Method:&quot; + method); //当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); //在代理真实对象后我们也可以添加一些自己的操作，加完包装之后的一些售后服务 System.out.println(&quot;after packaging&quot;); return null; } }看看客户端类的定义public class Client { public static void main(String[] args) { //我们要代理的真实对象 Subject realSubject = new RealSubject(); //我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject .getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.shoes(); subject.clothes(&quot;clothes, it&apos;s without packaging&quot;); } }控制台的输出结果$Proxy0 before packaging Method:public abstract void com.xiaoluo.dynamicproxy.Subject.shoes() This is shoes method without packaging after packaging before packaging Method:public abstract void com.xiaoluo.dynamicproxy.Subject.clothes(java.lang.String) hello: clothes, it&apos;s without packaging after packagingProxy.newProxyInstance 生成代理对象时所需要的invocationHandler 参数更像是代理商和供应商之间的物流，当代理商需要供应商的鞋子时候，需要告诉这个物流去取鞋子. 一个代理商当然也代理多个品牌，这就是为什么参数中interfaces 是数组形式，至此关于Java 动态代理就告一段落了，我们来看看Spring AOP , 道理都是相通的. Spring AOP术语解释 术语名称 对应解释 官方术语描述 Aspect 它是一个包含一系列API的模块，同时提供横切的需求，比如日志记录. A module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement. Join point 应用程序真正会发生通知行为的一个点 This represents a point in your application where you can plug-in AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework. Advice 可以理解为通知，在目标程序执行前通知还是执行后通知 This is the actual action to be taken either before or after the method execution. This is actual piece of code that is invoked during program execution by Spring AOP framework. Pointcut Join Point的集合，程序中所有想切入的点的集合 This is a set of one or more joinpoints where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples. Advice 通知 术语名称 对应解释 官方术语描述 before 在调用目标方法之前通知 Run advice before the a method execution after 在调用目标方法之后通知，不管目标方法是否执行成功 Run advice after the a method execution regardless of its outcome. after-returning 当目标方法成功执行没有任何异常之后 Run advice after the a method execution only if method completes successfully after-throwing after 或 after-returning 运行之后捕获异常 Run advice after the a method execution only if method exits by throwing an exception. around 运行目标方法前后环绕 Run advice before and after the advised method is invoked try{ //前置通知 //环绕通知 //调用目标对象方法 //环绕通知 //后置通知 }catch(){ //异常通知 }finally{ //终止通知 }Spring XML配置&lt;context:annotation-config/&gt; &lt;aop:config proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;&gt; &lt;aop:aspect ref=&quot;capitalModification&quot;&gt; &lt;aop:pointcut id=&quot;handleOrder&quot; expression=&quot;execution(* com.honor.facades.app.order.HonorOrderFacade.handleCapital(..)) || execution(* com.honor.facades.serviceOrder.HonorServiceOrderFacade.handleCapital(..)) || execution(* com.honor.facades.aftersales.HonorReturnFormFacades.handleCapital(..))&quot;/&gt; &lt;aop:after method=&quot;capitalAndRecordModification&quot; pointcut-ref=&quot;handleOrder&quot;/&gt; &lt;aop:after-throwing throwing=&quot;ex&quot; method=&quot;capitalAndRecordModificationExceptionHandle&quot; pointcut-ref=&quot;handleOrder&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=&quot;capitalModification&quot; class=&quot;com.honor.core.customerCapital.impl.DefaultCapitalModificationStrategy&quot;&gt; &lt;property name=&quot;customerCapitalService&quot; ref=&quot;customerCapitalService&quot;/&gt; &lt;property name=&quot;honorSuperOrderService&quot; ref=&quot;honorSuperOrderService&quot;/&gt; &lt;property name=&quot;honorBillService&quot; ref=&quot;honorBillService&quot;/&gt; &lt;/bean&gt;多个pointcut 可以用 || 或 or 来实现. 项目使用中遇到的问题关于AOP无法切入同类调用方法的问题Controller 层方法A调用了Facade层方法B，可是B内调用了方法C, 我们想使用AOP织入方法C, 当程序运行后， 始终找不到代理方法，意味着织入C没有成功, public class MyController{ public void methodA(){ myFacade.methodB(); } } public class MyController{ public void methodB(){ myFacade.methodC(); } public void methodC(){ System.out.println(&quot;bingo&quot;); } } public class Aspect { @AfterReturning(execution(* Facade.methodB(..))) public void after() { Logger.info(after call and do something); } } 我们发现在 AopContext.class 中： public static Object currentProxy() throws IllegalStateException { Object proxy = currentProxy.get(); if(proxy == null) { throw new IllegalStateException(&quot;Cannot find current proxy: Set \\&apos;exposeProxy\\&apos; property on Advised to \\&apos;true\\&apos; to make it available.&quot;); } else { return proxy; } }解决办法： 设置proxy-target-class=”true”expose-proxy=”true” &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;expose-proxy=&quot;true&quot;/&gt; 手动指定代理调用方法 ((Facade) AopContext.currentProxy()).methodB(); 参考链接非常感谢以下几位博主，在你们认真的博客上学到了许多. http://blog.csdn.net/lirui0822/article/details/8555691 http://www.cnblogs.com/xiaoluo501395377/p/3383130.html 同时修改AOP函数返回值及获取函数参数请参考以下文章： http://blog.csdn.net/cleverutd/article/details/8607491 https://my.oschina.net/itblog/blog/211693","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring","slug":"Coding/Spring","permalink":"https://dayarch.top/categories/Coding/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://dayarch.top/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://dayarch.top/tags/AOP/"}]},{"title":"Jenkins学习之邮箱配置","slug":"Jenkins学习之邮箱配置","date":"2017-01-05T07:05:18.000Z","updated":"2019-11-01T08:46:03.072Z","comments":true,"path":"/p/jenkins-config-mail.html","link":"","permalink":"https://dayarch.top/p/jenkins-config-mail.html","excerpt":"使用场景 开发人员build project 之后，build结果无论是成功还是失败，都要及时的通知组内其他成员了解最新情况，邮件通知这时候就派上用场，恰巧 Jenkins 提供了这么一个功能，不过该功能还是过于单一，如不能编写email template 来格式化邮件内容，但Extended E-mail Notification（Jenkins 邮件插件）实现了更高级的功能，接下来逐步看一下 Jenkins 邮件功能的配置 配置邮件服务器 以管理员身份登录，在 Jenkins 首页click Manage Jenkins, 然后 click Configure System, 下拉到页面","text":"使用场景开发人员build project 之后，build结果无论是成功还是失败，都要及时的通知组内其他成员了解最新情况，邮件通知这时候就派上用场，恰巧 Jenkins 提供了这么一个功能，不过该功能还是过于单一，如不能编写email template 来格式化邮件内容，但Extended E-mail Notification（Jenkins 邮件插件）实现了更高级的功能，接下来逐步看一下 Jenkins 邮件功能的配置 配置邮件服务器以管理员身份登录，在 Jenkins 首页click Manage Jenkins, 然后 click Configure System, 下拉到页面的最底部 E-mail Notification 处： 此处我用了网易yeah.net的邮箱，User Name(邮箱账号)，Password(邮箱密码)，在Test e-mail recipient(接收邮件)，不过配置了这些仅仅是配置邮件服务器地址、账号和密码，但是jenkins不知道采用哪个邮箱去发送，所以我们需要在该处配置发送的邮箱，并且要和管理员的邮箱一致 到此点击一下Test configuration button 看一下测试结果，如果测试不成功要检查一下管理员邮箱是否有开通 SMTP服务，登录你设置的邮箱开通SMTP 设置完之后测试结果为成功 当我们在project 中配置build之后的行为时，可以添加邮件通知，这样在接收人列表中的人都可以接受到build的结果： build 一下项目，看一下有没有收到邮件通知吧. 安装Email插件Jenkins 首页 —— Manage Jenkins —— Manage Plugins，安装该插件 重新启动Jenkins, 可以在刚刚配置邮件的上方看到已安装好的email 插件 这样编辑Default Content 字段来编写email template, 支持 HTML 标签. 这样在项目构建后行为中选择Editable Email Notificatioin 来发布build的结果 NOTE: 大家看不懂的字段多多点开字段右侧的问号，里面的说明还是非常清晰的. 邮件插件的其他小功能也请自行研究.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://dayarch.top/tags/Jenkins/"}]},{"title":"巧用PostMan","slug":"巧用PostMan","date":"2016-10-27T09:06:12.000Z","updated":"2019-11-01T09:01:07.922Z","comments":true,"path":"/p/postman-advanced-usage.html","link":"","permalink":"https://dayarch.top/p/postman-advanced-usage.html","excerpt":"现在越发的认识到巧用工具提高工作效率的重要性，接下来看一下PostMan带来的便利 业务情景 在实际工作中，当App或其他渠道来调用Java后台接口的时候，我们通常会用到PostMan这个工具来模拟调用，当需要token来作为验证的时候，当每次请求的token发生变化的时候我们同时要改变其他请求URL中的token内容，这样很麻烦，降低工作效率，PostMan的环境变量解决了这个问题 配置环境变量 and and and and and and 至此设置环境变量结束，其他功能会陆续补充.","text":"现在越发的认识到巧用工具提高工作效率的重要性，接下来看一下PostMan带来的便利 业务情景在实际工作中，当App或其他渠道来调用Java后台接口的时候，我们通常会用到PostMan这个工具来模拟调用，当需要token来作为验证的时候，当每次请求的token发生变化的时候我们同时要改变其他请求URL中的token内容，这样很麻烦，降低工作效率，PostMan的环境变量解决了这个问题 配置环境变量andandandandandand 至此设置环境变量结束，其他功能会陆续补充.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"PostMan","slug":"PostMan","permalink":"https://dayarch.top/tags/PostMan/"}]},{"title":"Git Ignoring Files","slug":"Git-Ignoring-Files","date":"2016-10-15T01:32:43.000Z","updated":"2019-11-07T05:24:49.443Z","comments":true,"path":"/p/git-ignore.html","link":"","permalink":"https://dayarch.top/p/git-ignore.html","excerpt":"前言 以下内容根据Git Help以及Git Docs 整理翻译 Ignoring files(忽略文件) 有时候会有一些我们不想Git 提交一些文件到GitHub/GitLab，下面有几种方式让我们告诉Git来忽略哪些文件. Create a local .gitignore（创建局部/本地的.gitignore文件） 如果在local repository（仓库）中创建一个名为.gitignore的文件，在你commit（提交）动作之前，Git 将会读取*.gitignore文件去判断哪些文件或者目录需要忽略掉. 同时这个文件应该push到remote repository, 这样cl","text":"前言以下内容根据Git Help以及Git Docs 整理翻译 Ignoring files(忽略文件)有时候会有一些我们不想Git 提交一些文件到GitHub/GitLab，下面有几种方式让我们告诉Git来忽略哪些文件. Create a local .gitignore（创建局部/本地的.gitignore文件） 如果在local repository（仓库）中创建一个名为.gitignore的文件，在你commit（提交）动作之前，Git 将会读取*.gitignore文件去判断哪些文件或者目录需要忽略掉. 同时这个文件应该push到remote repository, 这样clone该repository的用户都会共享ignore的规则. 当然GitHub上维护了一个官方的、针对许多流行的操作系统、环境、语言的.gitignore 文件样例 在终端，定位到Git repository所在位置，输入以下命令来创建.gitignore文件（当然在windows环境可以直接在仓库位置鼠标右键创建名为.gitignore的文件即可） touch .gitignore注意：如果某个文件已经被提交，此时你想让git 忽略它，这是你把这个文件添加到.gitignore文件中，git也不会忽略它，此时我们必须先untrack这个文件，这样Git才会忽略这个文件 git rm --cached FILENAMECreate a global .gitignore（创建全局.gitignore文件） 通常我们会有多个repository，如果多个仓库需要的规则类似，我们还需要为每一个repository都新建一个.gitignore 文件吗？显然我们此刻需要一个全局的方式来管控所有的repository. 有两种方式来创建该全局文件： 当安装了Git之后，在git 主目录(Windows环境C:\\Users\\Fraser)下会有一个.gitconfig文件，里面指定了如下内容： [user] [core] excludesfile = D:\\\\Users\\\\fraser\\\\Documents\\\\gitignore_global.txt [user] [user] name = XXXXX email = XXXXX@qq.com也就是说我们把规则定义在gitignore_global.txt文件中就好. 或者指定其他文件， 这个文件是windows自动生成的 通过命令指定.gitignore_global的文件 git config --global core.excludesfile ~/.gitignore_global通常.gitignore_global文件也是放在主目录下. Explicit repository excludes(明确仓库忽略的文件) 如果你不想创建一个.gitignore文件并且share给其他人，你可以创建一个不需要提交到repository的规则，比如我使用IntelliJ IDEA编辑器，编辑器会生成一些相应文件，但是同事使用Eclipse，也就是说IntelliJ IDEA编辑器生成的文件规则并不适用Eclipse，所以我们需要用另外方法来处理这种情况. 用编辑器打开.git/info/exclude，将规则加载这里即可,这个git是不会提交的. Ignore 规则说明gitignore - Specifies intentionally untracked files to ignore 描述上面我们说到了我们可以采用多种方式来让git ignore文件，同时配置了这些文件，优先级是什么呢？ Level1命令行执行的命令(很少用) Level2仓库中的.gitignore 文件 Level3$GIT_DIR/info/exclude Level4全局的配置：core.excludesFile PATTERN FORMAT规则说明 空行，没有任何实际ignore意义，只是作为可读性的分隔符 “#”号开头代表该行是注释，如果在前面加上“\\”，则转义成以“#”开头 “!” 是重新让git check in 某文件的意思，但是该文件的父目录被exclude，re-include 该文件Git是做不到的. 同样可以加上”&quot;来转义，!important!.txt和!important!.txt 以“/”结束，如foo/ 会匹配foo以及foo下面的子文件夹，但是不会匹配foo/下面的任何文件. * 是通配符，如*.c，会匹配所有.c为后缀的文件 ** 的含义非常多： A leading “**” followed by a slash means match in all directories. For example, “/foo” matches file or directory “foo” anywhere, the same as pattern “foo”. “/foo/bar” matches file or directory “bar” anywhere that is directly under directory “foo”. A trailing “/**” matches everything inside. For example, “abc/**” matches all files inside directory “abc”, relative to the location of the .gitignore file, with infinite depth. A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, “a/**/b” matches “a/b”, “a/x/b”, “a/x/y/b” and so on.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dayarch.top/tags/Git/"}]},{"title":"Windows下删除过长文件路径或过长文件名的文件","slug":"Windows下删除过长文件路径或过长文件名的文件","date":"2016-09-05T07:28:25.000Z","updated":"2019-11-01T08:58:12.351Z","comments":true,"path":"/p/delete-long-name-file-in-windows.html","link":"","permalink":"https://dayarch.top/p/delete-long-name-file-in-windows.html","excerpt":"在Windows下，删除文件时报错”文件路径太长或者文件名太长”，无论是Shift+Del、进入子目录一点点删除都不可以以及使用Windows内置命令都不可以，但是我电脑中装有node，于是安装【rimraf】——是专门用于删除模块的插件 官方描述：A deep deletion module for node (like rm -rf) npm install -g rimraf 使用方法： 1. 进入project目录 cd project/ 2. 删除hybris目录及目录下所有文件 rimraf hybris","text":"在Windows下，删除文件时报错”文件路径太长或者文件名太长”，无论是Shift+Del、进入子目录一点点删除都不可以以及使用Windows内置命令都不可以，但是我电脑中装有node，于是安装【rimraf】——是专门用于删除模块的插件 官方描述：A deep deletion module for node (like rm -rf) npm install -g rimraf使用方法： 进入project目录 cd project/ 删除hybris目录及目录下所有文件 rimraf hybris 可以看到，hybris目录及其所有子目录及文件全部删除干净，非常爽。 感谢原作者的分享","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://dayarch.top/tags/Windows/"},{"name":"Node","slug":"Node","permalink":"https://dayarch.top/tags/Node/"}]},{"title":"Git配置多个账号（GitLab和GitHub）","slug":"Git配置多个账号（GitLab和GitHub）","date":"2016-08-09T02:29:32.000Z","updated":"2019-11-07T05:27:32.582Z","comments":true,"path":"/p/git-multiple-account.html","link":"","permalink":"https://dayarch.top/p/git-multiple-account.html","excerpt":"背景 现在好多公司用GitLab作为项目管理工具，自己也会有开源项目在GitHub上，按照以往的配置全局的用户貌似在这种情形下就没有作用了（公司的项目需要用公司邮箱，自己的项目需要用自己的邮箱），此时就要做Git多账户的管理与设置。 Git支持的协议 Git主要支持四中协议： file:// , git://, http(s)://, ssh://, 这里主要说明一下http(s)和ssh协议的区别。 https 和 SSH 的区别 1. 前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key (这里就是添加公钥","text":"背景现在好多公司用GitLab作为项目管理工具，自己也会有开源项目在GitHub上，按照以往的配置全局的用户貌似在这种情形下就没有作用了（公司的项目需要用公司邮箱，自己的项目需要用自己的邮箱），此时就要做Git多账户的管理与设置。 Git支持的协议Git主要支持四中协议： file:// , git://, http(s)://, ssh://, 这里主要说明一下http(s)和ssh协议的区别。 https 和 SSH 的区别 前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key (这里就是添加公钥，取得管理员的信任)，否则无法克隆。 https url 在push的时候是需要验证用户名和密码的，而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。 Git设置多账户检查本机是否已有SSH Key$ cd ~/.ssh $ ls如果存在会有两个秘钥文件id_rsa(私钥)和id_rsa.pub(公钥)，如果没有则需要下一步的创建。 创建SSH Key输入如下命令： $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;参数解析： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： Generating public/private rsa key pair. # Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]当然，你也可以不输入文件名，直接车，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），这样别人用你的机器没有密码是不可能随便push代码的，一种安全性的体现，当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了。 Enter passphrase (empty for no passphrase): # Enter same passphrase again:在此案例中，就需要输入两个email来创建个相应的SSH Key: $ ssh-keygen -t rsa -C &quot;personal@example.com&quot; (个人邮箱) $ ssh-keygen -t rsa -C &quot;company@example.com&quot; (公司邮箱)此时在.ssh 目录下应该会有下面四个文件： id_rsa id_rsa.pub id_rsa_company id_rsa_company.pub将公钥id_rsa.pub和id_rsa_company.pub 分别添加到GitHub和GitLab上，怎样添加请自行查询，至此，我们已经有两个用户（可以更多），怎样指定要连接GitHub还是GitLab呢？这样就需要解决多用户的权限问题。 多用户权限问题GitHub/GitLab使用SSH与客户端连接。如果是单用户（A），生成密钥对后，将公钥保存至 GitHub/GitLab，每次连接时SSH客户端发送本地私钥（默认~/.ssh/id_rsa）到服务端验证。单用户情况下，连接的服务器上保存的公钥和发送的私钥自然是配对的。但是如果是 多用户 （A,B），我们在连接到第二个帐号时，B保存的是自己的公钥，但是SSH客户端依然发送默认私钥，即A的私钥，那么这个验证自然无法通过, 所以需要让SSH客户端发现B的私钥。 查看系统SSH Key $ ssh-add -l如果提示： $ Could not open a connection to your authentication agent.可以输入如下命令然后重新输入：ssh-add -l $ ssh-agent bash ssh-agent bash命令解释：ssh-agent是专为既令人愉快又安全的处理RSA和DSA密钥而设计的特殊程序，不同于ssh，ssh-agent是个长时间持续运行的守护进程（daemon），设计它的唯一目的就是对解密的专用密钥进行高速缓存。ssh包含的内建支持允许它同ssh-agent通信，允许ssh不必每次新连接时都提示您要密码才能获取解密的专用密钥。对于ssh-agent，您只要使用ssh-add把专用密钥添加到ssh-agent的高速缓存中。这是个一次性过程；用过ssh-add之后，ssh将从ssh-agent获取您的专用密钥，而不会提示要密码短语来烦您了。如果出现如下提示信息说明没有SSH Key在代理中 $ The agent has no identities.下面可以手动加入SSH Key 到代理中： $ ssh-add ~/.ssh/id_rsa_company可以使用如下命令remove SSH Key $ ssh-add -D 配置config 路由文件config文件即绑定私钥和远程服务器的关系，以我的config文件为例： # 该文件用于配置私钥对应的服务器 # 默认自己GitHub的配置 Host github HostName github.com User FraserYu PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa # 公司所用GitLab的配置 Host gitlab HostName gitlab.com #(可以是域名/IP地址) User Fraser PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_company 测试输入如下命令进行GitLab和GitHub的测试(注意命令中用了Host的别名)： $ ssh -T git@github $ ssh -T git@gitlab $ git clone git@github:username/project.git 用户名邮箱配置Git全局配置和单个仓库的用户名邮箱配置，学习git的时候, 大家刚开始使用之前都配置了一个全局的用户名和邮箱 $ git config --global user.name &quot;github&apos;s Name&quot; $ git config --global user.email &quot;github@xx.com&quot; $ git config --list如果你公司的项目是放在自建的gitlab上面, 如果你不进行配置用户名和邮箱的话, 则会使用全局的, 这个时候是错误的, 正确的做法是针对公司的项目, 在项目根目录下进行单独配置 $ git config user.name &quot;gitlab&apos;s Name&quot; $ git config user.email &quot;gitlab@xx.com&quot; $ git config --listgit config –list查看当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置 除了默认的id_rsa是被git默认读取，我们每次打开终端都需要执行 ssh-add ～/.ssh/id_rsa_company， 这样十分麻烦，以MacOs为🌰，我们可以将其添加到 KeyChain Access， 执行命令 ssh-add -K [path/to/your/ssh-key]， 如：ssh-add -K ～/.ssh/id_rsa_company 即可","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dayarch.top/tags/Git/"}]},{"title":"Chrome保存网页为脱机文件","slug":"Chrome保存网页为脱机文件","date":"2016-08-08T11:23:15.000Z","updated":"2019-11-01T08:36:23.784Z","comments":true,"path":"/p/chrome-save-offline-file.html","link":"","permalink":"https://dayarch.top/p/chrome-save-offline-file.html","excerpt":"Chrome 浏览器保存网页为脱机文件 我们经常需要将一些网页保存为脱机文件，这样即便没有网络我们也可以正常的浏览，IE浏览器将网页另存为在选择文件类型的地方会有选择*.mht, 可是Chrome 却没有这个选项，接下来教大家如何通过Chrome来保存网页为mht文件 1. 打开浏览器输入 chrome://flags/ 2. 通过关键字搜索save 或 另存为如下图： 3. 点击Enable或使用，重新启动浏览器 4. 鼠标右键另存为选择类型和保存路径如下图： 5. 等待下载完成即","text":"Chrome 浏览器保存网页为脱机文件我们经常需要将一些网页保存为脱机文件，这样即便没有网络我们也可以正常的浏览，IE浏览器将网页另存为在选择文件类型的地方会有选择*.mht, 可是Chrome 却没有这个选项，接下来教大家如何通过Chrome来保存网页为mht文件 打开浏览器输入 chrome://flags/ 通过关键字搜索save 或 另存为如下图： 点击Enable或使用，重新启动浏览器 鼠标右键另存为选择类型和保存路径如下图： 等待下载完成即可","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://dayarch.top/tags/Chrome/"}]},{"title":"git 使用流程","slug":"git-使用流程","date":"2016-06-24T01:44:01.000Z","updated":"2019-11-07T06:36:00.509Z","comments":true,"path":"/p/git-workflow.html","link":"","permalink":"https://dayarch.top/p/git-workflow.html","excerpt":"Git分支管理策略 首先share一下Ruan老师的博客内容：Git分支管理策略 ，读过之后，理解Master、Develop、临时分支（feature、release、fixbug）的基本意思，这里写的就更加透彻了：A successful Git branching model， 项目中如果按照这种严格规范来执行版本的管理，应该是会取得成功的结果. 仔细阅读这个workflow深刻的体会： Git 使用实战情景说明 为什么不罗列出来Git的命令列表，因为罗列在这貌似也很难深刻理解命令的含义，也不知道怎样去使用，所以做一些情景案例来说明git命令 跟踪GitHub上开源项目 当在Git","text":"Git分支管理策略首先share一下Ruan老师的博客内容：Git分支管理策略 ，读过之后，理解Master、Develop、临时分支（feature、release、fixbug）的基本意思，这里写的就更加透彻了：A successful Git branching model， 项目中如果按照这种严格规范来执行版本的管理，应该是会取得成功的结果. 仔细阅读这个workflow深刻的体会： Git 使用实战情景说明为什么不罗列出来Git的命令列表，因为罗列在这貌似也很难深刻理解命令的含义，也不知道怎样去使用，所以做一些情景案例来说明git命令 跟踪GitHub上开源项目当在Github中遨游一阵，发现了喜欢的项目想在本地研究，同时还想跟踪了解源项目的最新动态，我们需要如下的一些步骤： Fork (分叉)在跟踪的开源项目上点击Fork，会发现分叉到你的Repo中，此时我们应用如下命令将项目clone到local Repo, https或ssh两种都可以 $ git clone git@github.com:YOUR-USERNAME/REPO-NAME $ git clone https://github.com/YOUR-USERNAME/REPO-NAME此时可以通过如下命令来查看remote的版本，即你自己的remote Repo的信息 $ git remote -v得到如下结果： https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 添加 fork 源仓库的地址我们的目的不但是要在本地修改自己想要的代码，还要了解最新的源的动态，所以我们需要用如下命令： $ git remote add originProject https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git同样应用 git remote -v命令会的到如下结果： origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) originProject https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git(fetch) originProject https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git (push)此处的originProject 可以是你取得任意的名字, 就是给远程主机取个名字 $ git remote add &lt;主机名&gt; &lt;网址&gt; Fetch源当你要跟踪源动态，就要fetch一份到本地Repo $ git fetch originProject通过如下命令查看分支： $ git branch 合并源到本地首先切换到本地master分支 $ git checkout master之后merge源到本地master $ git merge originProject/master这个地方可能会有冲突，需要解决冲突完成merge，最后将merge好的代码push到自己remote git push origin master 本地上传代码到GitHub通常会在本地写点程序，然后放到github来管理，此时我们怎样把本地的代码上传到github呢 git初始化新建一个文件夹，初始化 $ git init你的项目code应该在这个文件夹中 添加项目文件到本地Repo我们需要将本地的code添加到本地的Repo中，add . 代表添加全部文件 $ git add . 提交文件到本地Repo添加文件之后，我们需要commit文件到本地Repo，并且标记注释 $ git commit -m &quot;注释语句&quot; 在github上新建Repo在github上新建Repo，并且copy Repo的https或ssh URL $ git remote add origin https://github.com/YOUR_USERNAME/YOUR_FORK.git Pull远程代码在push之前我们需要pull remote 代码 $ git pull origin master Push本地代码到remote我们已经提交代码到本地Repo，此时我们需要push到remote $ git push -u origin master 更改远程URL在实际场景中我们会遇到Git服务器迁移了，这样我们.git仓库存储的remote repository的地址信息就是错误的，所以需要更改这个URL. 请参考Git Help之Changing a remote’s URL 如果你觉得你合并后的状态是一团乱麻，想把当前的修改都放弃，你可以用下面的命令回到合并之前的状态： $ git reset --hard HEAD或者你已经把合并后的代码提交，但还是想把它们撒销： $ git reset --hard ORIG_HEAD但是刚才这条命令在某些情况会很危险，如果你把一个已经被另一个分支合并的分支给删了，那么 以后在合并相关的分支时会出错。 Git远程操作命令详解有了基本的了解，我们还是在这里引用一下Ruan老师的博客内容，慢慢理解与体会 Git远程操作详解 和 Git常用命令清单, 同时还要把廖雪峰老师的Git教程简介：Git远程操作详解放在这里，都是最好的学习资料，后续我还会继续补充. 有疑问可以留言，加入git实用情景中.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dayarch.top/tags/Git/"}]},{"title":"WeChatFeedback","slug":"WeChatFeedback","date":"2016-05-23T07:55:56.000Z","updated":"2019-11-01T08:57:45.837Z","comments":true,"path":"/p/english-common-model.html","link":"","permalink":"https://dayarch.top/p/english-common-model.html","excerpt":"郑重声明： 未经同意，不得转载 微信作业反馈2016 万能句型 万能句型第一发[got to get] 先附上两张图片来做一个总览，接下来逐个举例说明： 万能句型前面搭配： 序号搭配省略’ve或’s1I’ve可以2We’ve可以3You’ve可以4They’ve可以5He’s不可以6She’s不可以万能句型举例： 序号句子翻译连读音标1I got to get going我得走了2I got to get used to it我得适应某物3I got to get used to this bed我得适应这张床4I got to get Used to the new comp","text":"郑重声明： 未经同意，不得转载 微信作业反馈2016万能句型万能句型第一发[got to get]先附上两张图片来做一个总览，接下来逐个举例说明： 万能句型前面搭配： 序号 搭配 省略’ve或’s 1 I’ve 可以 2 We’ve 可以 3 You’ve 可以 4 They’ve 可以 5 He’s 不可以 6 She’s 不可以 万能句型举例： 序号 句子 翻译 连读音标 1 I got to get going 我得走了 2 I got to get used to it 我得适应某物 3 I got to get used to this bed 我得适应这张床 4 I got to get Used to the new computer 我得适应这个新电脑 5 I got to get used to waking up early 我得适应早起 6 I got to get Used to eating less 我得适应少吃点 7 I got to get Used to drinking tea 我得适应喝茶 序号 句子 翻译 连读音标 1 I got to get a life 我得得到一个生活（想象：天天宅在家里，突然醒悟对自己说这句话） 2 I got to get a nicer house 我得得到/有/买一个更好的房子 3 I got to get a girl friend 我得有个女朋友 4 I got to get an invite 我得得到/收到一个邀请 5 I got to get an extra plate 我得要一个额外的盘子 6 I got to get an apartment 我得有/买/得到个公寓 7 I got to get a coffee 我得来杯咖啡 序号 句子 翻译 连读音标 1 I got to get serious 我得变得严肃点 2 I got to get stronger 我得变得更强壮 3 I got to get taller 我得更高一点 4 I got to get healthier 我得更健康一些 5 I got to get better at sth 我得更擅长某事 6 I got to get better at doing sth 我得更擅长做某事 7 I got to get faster at sth 我得更快速于某事 8 I got to get faster at doing sth 我得更快速于做某事 [Sb] got to get more [sth] 得得到更多 序号 句子 翻译 连读音标 1 I got to get more than that 我得得到更多，比手里拥有的更多 2 I got to get more clothes 我得有/得到更多衣服 3 I got to get more money 我得得到/拥有更多钱 [Sb] got to get started [doing sth] 开始做某事，多指需要一段时间过程的事情，不是一瞬间就能搞定的 序号 句子 翻译 连读音标 1 I got to get started writing my report 我得开始写我的报告 2 I got to get started working on my project 我得开始做我的项目 3 I got to get started planning my wedding 我得开始筹划婚礼 4 I got to get started moving these boxes 我得开始搬这些盒子了 5 I got to get started cooking dinner 我得开始做饭了 [Sb] got to get [adv]副词/[prep]介词 序号 句子 翻译 连读音标 1 I got to get up 我得起床了 2 You got to get up early tomorrow 你明早得早起 3 I got to get started planning my wedding 我得开始筹划婚礼 4 I got to get started moving these boxes 我得开始搬这些盒子了 5 I got to get started cooking dinner 我得开始做饭了 [Sb] got to get back…某人得回去、回家 序号 句子 翻译 连读音标 1 I got to get back 我得回家 （有时候说回家不一定非要有home） 2 You got to get back to work[sth] 你得回去工作了 3 She’s got to get back on that horse 她得再坚持一次（俚语，之前从马上掉下来一次，再次回到马上） 4 He’s got to get back soon. 他得马上回来 5 I got to get back in the game 我得回到老行当（爱好，工作，喜好) 算是重操旧业 [Sb] got to get there…某人得到达某处 序号 句子 翻译 连读音标 1 I got to get there at 4 我得4点到那 2 You got to get there on time 你得回去工作了 3 She’s got to get there in time 她得及时到那 4 He’s got to get there before it’s too late 他赶紧到那儿，不然就晚了 [Sb] got to get out… 某人得出去/跑走/避免、摆脱 序号 句子 翻译 连读音标 1 I got to get out of here 我得离开这 2 She’s got to get out of work 她得摆脱工作（一起看电影，她工作很忙，要是想去需要先摆脱工作） 3 He’s got to get out of this relationship 他得摆脱这段关系的纠缠 4 You got to get out of bed 你得离开床（滚下床） [Sb] got to get [to smw] / [to the smw] /[smw] 某人得去某个地方 序号 句子 翻译 连读音标 1 I got to get to school 我得去学校 2 You got to get to work 你得去上班 3 He’s got to get home. 他得回家 4 We got to get to the hospital 我们得去医院 5 You got to get to the part where [SVO]主谓宾 你得去把（电视，剧集等）看到哪个段落，哪一集 [Sb] got to get [Sb][sth] 某人得给某个人送某个东西 序号 句子 翻译 连读音标 1 I got to get to you a gift 我得给你送个礼物 2 You got to get him a girlfriend 你得给他找个女朋友 3 We got to get them a car 我们得给他弄辆车 4 We got to get to the hospital 我们得去医院 5 They got to get me a job 他们得给我找个工作 [Sb] got to get [Sb][smw] 某人得送某个人去某个地方 序号 句子 翻译 连读音标 1 I got to get you to school 我得送你去学校 2 You got to get me home 你得送我回家 3 We got to get them a car 我们得给他弄辆车 4 I got to get you out of here. 我得让你离开这儿 5 I got to get this off the wall. 我得把这东西从墙上弄下来作 6 She’s got to get all this stuff into the luggage 她得把所有东西塞进行李箱 MarMar 29th 序号 句子 翻译 连读音标 1 I don’t know what to do 这个看起来也很好 2 Give it to him 把这个给他吧 3 I made an important decision today 我今天做了个很重要的决定 4 I have to leave early last night 差不多是时候了 Mar 30th 序号 句子 翻译 连读音标 1 This one looks good too 这个看起来也很好 2 I tried to talk to him 我试着想跟他聊(但他不听) 3 It’s hard to tell 这不好说 4 It’s about time 差不多是时候了 5 I can’t tell, can you 我看不出来，你可以吗 6 I’ve decided to move forward with it 我决定继续前进 Mar 31st 序号 句子 翻译 连读音标 1 What do you mean 你想表达什么，你什么意思 2 We could do that 当有人提议我们一起做一件事时，好啊，我们可以做.. 事 3 Don’t let your guard down 别放松警惕 4 It might take a while 这可能需要一段时间 5 It won’t take too long 不会花费太长时间的 6 Don’t tell me the answer 不要告诉我答案 7 I’ve decided to move forward with it 我决定继续前进 AprApr 4th 序号 句子 翻译 连读音标 1 Yep, pretty much 对，差不多 2 Keep pushing, come on 用力推，使劲 3 I always keep people at distance 我一直都跟别人保持距离 4 They have deep pocket 他们有的是钱 5 I got a backup plan 我已经留了后手 6 You guys got to keep pace 你们得跟我节奏 Apr 5th 序号 句子 翻译 连读音标 1 Stop being stupid 别傻了 2 I couldn’t help but notice 我无法不注意到 3 We’ll stop by on weekends 我们周末回过来的 4 You’re very upbeat today 你今天这是出奇的活跃啊 5 Can you stop being so loud 你不能小点声吗 6 Can you help me 能帮我一下吗 Apr 6th 序号 句子 翻译 连读音标 1 We need to take a step back 咱们需要退一步 2 I have to stop by my place first 我得先回家一趟 3 I need to go pick up my friend 我要去接我的朋友 4 I have to make up for past mistakes 我必须弥补我过去的错误 5 Can you grab me a coke 能给我带个可乐吗 6 Don’t rub my fact in it 别在伤口上撒盐 Apr 7th 序号 句子 翻译 连读音标 1 He didn’t show up for work 他没来上班 2 She dressed up for her interview 她为面试打扮的 3 You need to stand up for yourself 你要维护你自己 4 I got a backup plan 我已经留了后手 5 Can you stop moping 别再这么消沉了好吗 6 I bought my son a popup book 我给我儿子买了本立体故事书 Apr 11st 序号 句子 翻译 连读音标 1 I’d take christmas alone any day 我宁愿自己过圣诞节 2 I take classes on line 我在网上上课 3 Why don’t you ask questions 你怎么不问问题 4 I’ll take care of it 我觉得你很可爱 5 You look gorgeous 你看起来好迷人 6 You look great too 你看起来也很棒 Apr 12nd 序号 句子 翻译 连读音标 1 He gets a big kick out of it 他从这件事中收货很多乐趣 2 He wears thick glasses 他带着厚厚的眼镜 3 You look good 你气色不错啊 4 I think you look cute 我觉得你很可爱 5 Is this a trick question 你问的这个问题是个陷阱吗 6 I bought a new bookcase from IKEA 我从宜家买了个新书柜 Apr 13rd 序号 句子 翻译 连读音标 1 They make good pizza here 他们这的Pizza很不错 2 I’ve got an electric guitar 我得到了一把电吉他 3 He’s a very romantic guy 他是个很浪漫的人 4 Who’s milk carton is this 这盒奶是谁的 5 It’s all a big coverup 这全是演示 6 That’s a big cat 那只猫真肥 Apr 14th 序号 句子 翻译 连读音标 1 Either the dog goes or I go 让狗离开，要么我走 2 He sent me a gag gift for christmas 他送了我一个搞怪的圣诞礼物 3 What do you say, big guy 你怎么看哥们 4 Can we at least hug goodbye 我们能至少拥抱一下来告别吗 5 He took credit for my work 他把我的功劳占为己有 6 These are big cups 这些杯子好大 Apr 18th 序号 句子 翻译 连读音标 1 She’s so great 她真好 2 This is so unfair 这个太不公平了 3 This is sick 真变态 4 I leave for work at seven in the morning 我早上七点去上班 5 I live for dance 我是为了跳舞而生 6 Breath through the pain 咬咬牙 Apr 19th 序号 句子 翻译 连读音标 1 I lost Monica’s shoes 我把莫妮卡的鞋子丢了 2 yes, she is 她确实是 3 Let show them who’s boss 让他们看看谁才是老板 4 What does she do? 她是做什么的 5 Why is she here 她为什么在这 6 How long has she been in the bathroom 她在洗手间多长时间了 Apr 20th 序号 句子 翻译 连读音标 1 These are nice shoes 这鞋子不错 2 I think he’s shy 我想他是害羞 3 I really like this shirt 我特别喜欢这件衣服 4 This is because she doesn’t like you 这是因为她不喜欢你 5 How is she doing 她现在状态怎么样啊 6 What she like 她人怎么样啊 Apr 21st 序号 句子 翻译 连读音标 1 Go and have fun 去好好地玩 2 Houseflies live for a day 果蝇只活一天 3 What kind of food are they serving 他们提供哪些种类的食物 4 It’s cruel twist of fate 这是个残酷的命运反转 5 I have to leave for work 我得走了去上班了 6 I have faith in you 我对你有信心 Apr 25th 序号 句子 翻译 连读音标 1 Of course she likes me 他当然喜欢我啊 2 She hasn’t, has she 她没有，对吧 3 How is that possible 怎么可能这样 4 Give it back 把它还给我 5 It’s hard to say goodbye 说再见真不容易 6 Give me my credit card 把我的信用卡给我 Apr 26th 序号 句子 翻译 连读音标 1 How could that even be possible 这是怎么可能的啊 2 What are you up to 干啥啊你 3 It’s just another one of his pipe dream 这是他的另一个白日梦 4 Let’s get back to the topic at hand 咱们言归正传 5 Henry’s rock bottom lately 亨利最近想入了人生的谷底 6 Let’s look the big picture 咱们从大局着想 Apr 27th 序号 句子 翻译 连读音标 1 This is my big break 这是我的重大突破 2 This is a public place 这是公共区域 3 It’s no big deal 没什么大不了的 4 It broke down this morning 它今天早晨坏掉了 5 How bad could it be 能坏到哪去呢 6 so, how’d go 怎么样了 Apr 28th 序号 句子 翻译 连读音标 1 I think I should go 我觉得我该走了 2 I think you need to read the subtitle 我想你需要看字幕 3 We can’t stop, we got to keep going 我们不能停，我们得继续 4 oh yeah, big time 是的，相当的 5 You got to give it back 你得换回去 6 good bye 再见 MayMay 2nd 序号 句子 翻译 连读音标 1 Don’t I know you? 我好像在哪见过你 2 I did, didn’t I? 我做了，对吧？ 3 Don’t even try it 想也别想 4 I wouldn’t even care 我一点都不会在乎的 5 Listen to me 你听我说 6 Let’s move on to something else 咱们讨论下个吧 May 3rd 序号 句子 翻译 连读音标 1 Shouldn’t I do something about this 我不应该做些什么吗 2 I don’t mean to be rude 我不是故意冒犯你 3 There’s no reason to do that 没有必要这样 4 I haven’t spoken to him in years 我好几年都没和他说话了 5 Let’s move on to something else 咱们聊下一个话题吧 6 Do you believe in Santa Claus 你相信圣诞老公公吗 May 4th 序号 句子 翻译 连读音标 1 There are plenty of intelligent inventors 有很多聪明的发明家 2 I’m on a international flight to Canada 我正在坐一个国际航班去Canada 3 There are twenty presenters scheduled for today 今天安排了20个演讲者 4 There are identical twins 同卵双胞胎 5 He works in the entertainment industry 他在娱乐圈工作 6 Why won’t he listen to me 他为什么不听我的话 May 5th 序号 句子 翻译 连读音标 1 Why does he do that 他为什么那么做 2 Why doesn’t he come to me 他为什么不来找我 3 Did he mention us 他提到我们了吗 4 There he is 他在那 5 I thought he was nice 我觉得他挺好的啊 6 I think about him all the time 我一直在想他 May 10th 序号 句子 翻译 连读音标 1 I’ll take him to the store 我会带他去商店 2 I’m looking for him 我在找他 3 Let him do what he wants 让他做他想做的 4 Can you tell him for me 你能替我告诉她吗 5 I’ll give him back his book 我会把他的书还给他 6 It’s his, not mine 是他的，不是我的 May 11th 序号 句子 翻译 连读音标 1 They found a gun in his hand 他们在他收找到一把枪 2 This is his office 这是他的办公室 3 When is his birthday 什么时候是他的生日 4 Don’t push her 别逼她/别推她 5 I walked her out to the bus stop 我把她送到了车站 6 I wanna make her breakfast 我想给她做早餐 May 12th 序号 句子 翻译 连读音标 1 He really told her off 他臭骂了她一顿 2 I went to the mall with her 我跟她一起去了商场 3 You’ve got to call her 你得给她打个电话 4 Is it her birthday today 今天是她的生日吗 5 I think his idea’s good 我觉得他的主意挺好 6 Is this his wallet 这是他的钱包吗 May 16th 序号 句子 翻译 连读音标 1 Get in the car 上车 2 It’s not in there 不在那里 3 This is my first night in BJ 这是我在北京的第一夜 4 He’s out in the hallway 他在外面的走廊 5 It hit me right in the eye 正好打到我的眼睛 6 What’s that in the car 车里那个是什么 May 17th 序号 句子 翻译 连读音标 1 This is a important day for me 这对我是一个重要的日子 2 Martin said the milk is rotten 马丁说牛奶已经过期了 3 Would you like some sweetener for your coffee 你想加一些甜味剂给你的咖啡吗 4 Can you draw the curtains 你能拉上那个窗帘吗 5 I wanna help lighten the load 我想帮忙分担一些重量 6 I’ve written a letter to him 我已经给他写信了 May 18th 序号 句子 翻译 连读音标 1 I need to buy a hair straightener 我需要买一个直发加班 2 I just got a new kitten 我刚刚买了一只小猫 3 Have you seen my mittens 你看到我的连指手套了吗 4 Have you eaten yet 你吃饭了吗 5 I lost a button 我丢了一个扣子 6 Are you certain that he left 你确定他已经走了吗 May 19th 序号 句子 翻译 连读音标 1 The dentist is going to whiten my teeth 牙医将会给我的牙齿美白 2 It’s disheartening news 这是个令人沮丧的消息 3 Please enlighten me 请指引我 4 I wanna shorten my bangs 我想剪短我的刘海 5 The wall is crooked, it needs to be straightened 这堵墙歪了，需要重新调整 6 The horror movie we saw was frightening 我们看过的那个恐怖片很可怕 May 23rd 序号 句子 翻译 连读音标 1 What about you 那你呢 2 Can I get you something to drink 你想要喝点什么吗 3 That’s what you said 你就是这么说的啊 4 There’s something that you should know 有些事情你应该知道 5 Look at you, you’re mess 看看你，你一团糟 6 I thought you left already 我以为你已经走了 May 24th 序号 句子 翻译 连读音标 1 I got you flowers 我给你买了花 2 Don’t you wanna know? 你不想知道吗 3 Is that what you’re saying 你说的是这个意思吗 4 What did you do 你做了什么 5 Would you give it a rest 你能不能别折腾了 6 How could you do that to me 你怎么能这样对我 May 25th 序号 句子 翻译 连读音标 1 Hey, I’m glad you’re here 嘿，幸亏你来了 2 Should you be doing that 你应该这么做吗 3 I told you yesterday that I’m busy today 我昨天就跟你说了我今天很忙 4 He said you wanted to go home 他说了你想回家 5 I’m sorry I stood you up last night 不好意思昨天晚上放了你鸽子 6 Why would you do that 你为什么那么做 May 26th 序号 句子 翻译 连读音标 1 Did you sleep okay 你睡得好吗 2 How did you do that 你是怎么做的 3 I don’t need your pity 我不需要你的可怜 4 I brought you some books 我给你带了书 5 Why can’t you go 你为什么不能去 6 Don’t let your guard down 你别放松警惕 May 30th 序号 句子 翻译 连读音标 1 What are you talking about? 你在说什么啊 2 What’s going on 最近怎么样 3 What are you doing here 你在这里做什么 4 I’m tell you, this guys mean business 我跟你讲，他们是玩真的 5 Yeah, that’s right, keep walking 没错，继续走 6 I’m having the time of my life 我正在享受一生中最快乐的时光 May 31st 序号 句子 翻译 连读音标 1 What are you saying? 你什么意思啊 2 Quit being such a wuss 别做胆小鬼了 3 What are you looking at 你看什么呢 4 What are you trying to do 你想做什么 5 When are we starting 我们什么时候开始 6 I’m getting you home 我送你回家 JunJun 1st 序号 句子 翻译 连读音标 1 Hey, I’m talking to you 嘿，我正和你讲话呢 2 He’s going into the house 他正要走进那个房子 3 I’ve been waiting all day 我等了一整天 4 Stop shouting at me 别冲我嚷嚷 5 They’re fighting again 他们又吵起来了 6 When are we meeting 我们什么时候见面 Jun 2nd 序号 句子 翻译 连读音标 1 He keeps hitting on her 他一直在搭讪她 2 I’m putting out the cigarette 我正在把烟灭了 3 What’s he eating 他在吃什么 4 This is exciting 这个好刺激 5 I was putting on my jacket 我当时在穿夹克 6 He keeps putting it off 他一直在拖延 Jun 6th 序号 句子 翻译 连读音标 1 They aren’t coming, are they？ 他们不回来了，对吧？ 2 She couldn’t have done that 他不会做那样的事的 3 She would have asked for permission 他本来可以先征求许可的 4 I would have done it differently 如果是我我不会这么做 5 It’d been done before 早就有人做过了 6 You shouldn’t have said anything 你本来什么都不应该讲的 Jun 7th 序号 句子 翻译 连读音标 1 Where have you been ? 你到哪去了？ 2 Why are you so annoying? 你为什么这么生气？ 3 Doesn’t he know 他不知道吗？ 4 When have you ever cared about me? 你什么时候在乎过我？ 5 She would told me if she could 如果可以的话她一定会告诉我的 6 He wasn’t even here when it happened 事情发生的时候他不在这里 Jun 8th 序号 句子 翻译 连读音标 1 You need not have done that 你不需要做那件事 2 They haven’t had a chance 他们一直没有机会 3 It will do for now 暂时这样就可以了 4 It couldn’t have been him 不可能是他 5 Where’s our food 我们的吃的在哪 6 He wouldn’t have done that to you [如果是他]他不会对你这么做的 Jun 9th 序号 句子 翻译 连读音标 1 It had better be good 最好是好事 2 Where has she been？ 她到哪去了 3 It would be nice if you could cut me some slack 你要是对我要求松一点就好了 4 It couldn’t have been her 不可能是她 5 There is a good restaurant on the corner 街角有一家好吃的饭店 6 When have I ever led you wrong? 我什么时候带你走过弯路 Jun 13th 序号 句子 翻译 连读音标 1 Who did you talk to? 你和谁说过了 2 What did you do? 你做了什么 3 When did you go? 你是什么时候去的 4 Where did you put it? 你放哪儿去了 5 Why did you do that ? 你为什么这么做了 6 How did you do that? 你是怎么做到的 Jun 14th 序号 句子 翻译 连读音标 1 Who do you talk to? 你平时和谁说啊 2 What do you do? 你是做什么的 3 When do you go? 你什么时候要去 4 Where do you put it? 你平时放哪 5 Why do you do that ? 你为什么这么做 6 How do you do that? 这是怎么做到的 Jun 15th 序号 句子 翻译 连读音标 1 You got to get ahead 你得想办法出人头地 2 I wanted to talk about the future 我想聊聊未来 3 I don’t know if that’s good idea 我不知道那是不是一个好主意 4 You should come to the party 你应该参加那个聚会 5 Let me give it a shot 让我试一试 6 You want to give me a crack at it 让我试试好吗","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"English","slug":"Life/English","permalink":"https://dayarch.top/categories/Life/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://dayarch.top/tags/English/"}]},{"title":"SpringMVC之RequestMapping注解","slug":"SpringMVC之RequestMapping注解","date":"2016-01-26T02:49:59.000Z","updated":"2019-12-19T13:34:55.755Z","comments":true,"path":"/p/springmvc-requestmapping-annotation.html","link":"","permalink":"https://dayarch.top/p/springmvc-requestmapping-annotation.html","excerpt":"SpringMVC之RequestMapping注解 什么是RequestMapping注解 在SpringMVC的API中我们发现对@interface RequestMapping 有如下的定义： *Annotation for mapping web requests onto specific handler classes and/or handler methods. Provides a consistent style between Servlet and Portlet environments, with the semantics adapting to the","text":"SpringMVC之RequestMapping注解 什么是RequestMapping注解在SpringMVC的API中我们发现对@interface RequestMapping 有如下的定义： *Annotation for mapping web requests onto specific handler classes and/or handler methods. Provides a consistent style between Servlet and Portlet environments, with the semantics adapting to the concrete environment. * 翻译过来的意思就是通过在在类和方法上的限制来匹配request RequestMapping的几大属性在Spring4.2.4的API中发现RequestMapping有八大属性来mappingURL请求 value *In a Servlet environment this is an alias for path(). For example @RequestMapping(“/foo”) is equivalent to @RequestMapping(path=”/foo”). *在Servlet中value就是表示path，表示请求的路径的mapping, 支持通配符形式 method The HTTP request methods to map to, narrowing the primary mapping: *GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE. ***Http请求中有以上几种方式，我们可以通过加入method来限制mapping范围 params Same format for any environment: a sequence of “myParam=myValue” style expressions, with a request only mapped if each such parameter is found to have the given value. Expressions can be negated by using the “!=” operator, as in “myParam!=myValue”. “myParam” style expressions are also supported, with such parameters having to be present in the request (allowed to have any value). Finally, “!myParam” style expressions indicate that the specified parameter is not supposed to be present in the request. *请求参数中必须有key*等于某个value或者key必须不等于某个value，多个条件是与**的关系。 headers Same format for any environment: a sequence of “My-Header=myValue” style expressions, with a request only mapped if each such header is found to have the given value. Expressions can be negated by using the “!=” operator, as in “My-Header!=myValue”. “My-Header” style expressions are also supported, with such headers having to be present in the request (allowed to have any value). Finally, “!My-Header” style expressions indicate that the specified header is not supposed to be present in the request. Also supports media type wildcards (), for headers such as Accept and Content-Type. For instance,will match requests with a Content-Type of “text/html”, “text/plain”, etc. *和params属性类似，支持通配符匹配。 1@RequestMapping(value = \"/something\", headers = \"content-type=text/*\") name Assign a name to this mapping. Supported at the type level as well as at the method level! When used on both levels, a combined name is derived by concatenation with “#” as separator.给mapping命名，支持在类和方法上使用该属性，联合起来的name用#来分隔 consumes *The consumable media types of the mapped request, narrowing the primary mapping. The format is a single media type or a sequence of media types, with a request only mapped if the Content-Type matches one of these media types. Examples: consumes = &quot;text/plain&quot; consumes = {&quot;text/plain&quot;, &quot;application/*&quot;} *Expressions can be negated by using the “!” operator, as in “!text/plain”, which matches all requests with a Content-Type other than “text/plain”. *consumes数组里面可以是一个或多个值，只要匹配到他们其中一个即可。 produces he producible media types of the mapped request, narrowing the primary mapping. The format is a single media type or a sequence of media types, with a request only mapped if the Accept matches one of these media types. Examples: produces = &quot;text/plain&quot; produces = {&quot;text/plain&quot;, &quot;application/*&quot;} produces = &quot;application/json; charset=UTF-8&quot; *It affects the actual content type written, for example to produce a JSON response with UTF-8 encoding, “application/json; charset=UTF-8” should be used. Expressions can be negated by using the “!” operator, as in “!text/plain”, which matches all requests with a Accept other than “text/plain”. *指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 path In a Servlet environment only: the path mapping URIs (e.g. “/myPath.do”). Ant-style path patterns are also supported (e.g. “/myPath/.do”). At the method level, relative paths (e.g. “edit.do”) are supported within the primary mapping expressed at the type level. Path mapping URIs may contain placeholders (e.g. “/${connect}”) * 以上所有属性都是来限制mapping要求的，但是常用的是params、method、consumes. 验证属性 valuevalue支持通配符的表现形式, ?表示匹配文件名中的一个字符, * 表示匹配任意一个或多个字符, ** 表示匹配多层路径的一个或多个字符, @PathVariable算是URL参数的占位符。 @RequestMapping(value=&quot;/?/testValue1/{id}&quot;) public String testValue1(@PathVariable(&quot;id&quot;) String id){ System.out.println(&quot;value测试&quot; + id); return SUCCESS; } URL: http://localhost:8080/springMVC1/demo/a/testValue1/28Result: value测试28 现在我们遇到一种情况，如果我们的id是1.2.0007.9 这种类型的字符，如果在还向上面那样来传参数只会的到1.0这样的结果，于是我们需要用到正则表达式： @RequestMapping(value=&quot;/?/testValue1/{id：.*}&quot;) public String testValue1(@PathVariable(&quot;id&quot;) String id){ System.out.println(&quot;value测试&quot; + id); return SUCCESS; } 写成{id:.*} 或 {id:.+} 都可以。 methodjsp部分代码如下： &lt;dl&gt; &lt;dt&gt;Test method&lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;demo/testMethod_GET&quot;&gt;Method_GET&lt;/a&gt; &lt;/dd&gt; &lt;dd&gt; &lt;form action=&quot;demo/testMethod_POST&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Method_POST&quot;/&gt; &lt;/form&gt; &lt;/dd&gt; &lt;dd&gt; &lt;form action=&quot;demo/testMethod_DELETE&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Method_DELETE&quot;/&gt; &lt;/form&gt; &lt;/dd&gt; &lt;dd&gt; &lt;form action=&quot;demo/testMethod_PUT&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Method_PUT&quot;/&gt; &lt;/form&gt; &lt;/dd&gt; &lt;/dl&gt;GET和POST方法很好理解，可是在DELETE方法和PUT方法中我们却加入了一个hidden类型的input，值分别为DELETE和PUT，为什么要加这个隐藏域，我们先来看一下Spring中org.springframework.web.filter.HiddenHttpMethodFilter类的一段源码： public static final String DEFAULT_METHOD_PARAM = &quot;_method&quot;; private String methodParam = DEFAULT_METHOD_PARAM; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)throws ServletException, IOException { String paramValue = request.getParameter(this.methodParam); if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; StringUtils.hasLength(paramValue)) { String method = paramValue.toUpperCase(Locale.ENGLISH); HttpServletRequest wrapper = new HttpMethodRequestWrapper(request, method); filterChain.doFilter(wrapper, response); } else { filterChain.doFilter(request, response); } }这段代码的主要意思就是如果_method中存在值，并且是post方法，那我们的servlet对这个方法进行处理，为了完成这个功能我们需要进一步在web.xml中配置这个org.springframework.web.filter.HiddenHttpMethodFilter，如下： &lt;!-- org.springframework.web.filter.HiddenHttpMethodFilter 可以将post请求转为PUT和DELETE请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;现在我们来看JAVA后台controller中的代码，如下： @RequestMapping(value=&quot;/testMethod_GET&quot;, method=RequestMethod.GET) public String testMethod_GET(){ System.out.println(&quot;This is GET method&quot;); return SUCCESS; } @RequestMapping(value=&quot;/testMethod_POST&quot;,method=RequestMethod.POST) public String testMethod_POST(){ System.out.println(&quot;This is POST method&quot;); return SUCCESS; } @RequestMapping(value=&quot;/testMethod_DELETE&quot;, method=RequestMethod.DELETE) public String testMethod_DELETE(){ System.out.println(&quot;This is DELETE method&quot;); return SUCCESS; } @RequestMapping(value=&quot;/testMethod_PUT&quot;, method=RequestMethod.PUT) public String testMethod_PUT(){ System.out.println(&quot;This is PUT method&quot;); return SUCCESS; } paramsjsp部分代码如下： &lt;dl&gt; &lt;dt&gt;Test params&lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;demo/testParams?username&amp;age=10&quot;&gt;testParams&lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;Java的Controller代码如下： @RequestMapping(value=&quot;/testParams&quot;, params={&quot;username&quot;,&quot;age!=0&quot;}) public String testParams(){ System.out.println(&quot;testParams&quot;); return SUCCESS; }params={“username”,”age!=0”}代表请求参数中必须有username和age这两个参数，同时age不能等于0. headersheaders属性同params类似，都是可以以数组的形式来进行约束。需要什么样的请求参数可以通过开发者工具来查看请求中都有什么样的参数。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://dayarch.top/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"annotation","slug":"annotation","permalink":"https://dayarch.top/tags/annotation/"}]},{"title":"Maven Project","slug":"Maven-Project","date":"2016-01-21T09:28:06.000Z","updated":"2019-11-01T09:05:15.895Z","comments":true,"path":"/p/maven-project-structure.html","link":"","permalink":"https://dayarch.top/p/maven-project-structure.html","excerpt":"创建Maven Web Project 什么是Maven 在Apache Maven 官网上的说明是：Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information. 翻译过来的基本意思就是：Maven是基于项","text":"创建Maven Web Project 什么是Maven在Apache Maven 官网上的说明是：Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information. 翻译过来的基本意思就是：Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工 具。 使用Maven管理项目的好处 对第三方依赖库进行统一的版本管理。 只要用了Maven就不用再为每个项目复制spring.jar和hibernate.jar了，Maven会在你需要的时候，自动把这些第三方依赖库找到，你需要编译，Maven就把这些jar包放到classpath里，你需要打包，Maven2就帮你把需要的jar包都复制到WEB- INF/lib/目录下。 统一项目的目录结构 可以保证所有项目的目录结构都是一样的，目录结构统一的好处就是，你要找源代码就去src/main/java/下，你要找需要放到classpath下的资源，就去src/main/resources/下，你要找单元测试对应的代码和资源，就去src/test/下。每个目录下放什么东西，程序编译，发布的时候，每个目录起什么作用都很清楚明了，不会出现打开项目找不到要找的文件的情况。 统一软件构建阶段 Maven2把软件开发的过程划分成了几个经典阶段，比如你先要生成一些java代码，再把这些代码复制到特定位置，然后编译代码，复制需要放到 classpath下的资源，再进行单元测试，单元测试都通过了才能进行打包，发布。 支持多种插件 在http://maven.apache.com/和http://mojo.codehaus.org/上可以找到大量的Maven2插件，通过这些插件可以完成多种多样的扩展功能。 以上只是概念性的东西，陆续会用实例证明以上好处 下载及安装Maven 访问Maven 下载： 以Windows 环境为例，将下载的apache-maven-3.3.9-bin.zip 解压到某一磁盘目录下，apache-maven-3.3.9 作为MAVEN_HOME 目录， 新建本地Maven仓库（Repository），编辑apache-maven-3.3.9\\conf\\setting.xml 文件，在本地建立仓库（任意一次盘文件夹下即可） 环境变量可配置也可不配置，如果用到命令行必须要配置环境变量。 新建系统变量MAVEN_HOME, 并指定目录：E:\\Java_Web\\apache-maven-3.3.9-bin\\apache-maven-3.3.9 编辑系统变量Path，增加%MAVEN_HOME%\\bin; 命令行下（cmd）检测Maven 版本： mvn -v Eclipse下配置Maven 现在新版本的Eclipse已经集成了Maven插件，在Windows-Preferences-Maven节点下的Installations添加Maven, 最后勾选上添加的Maven。 在Windows-Preferences-Maven节点下的User Setting设置setting.xml 文件 ### 新建Maven Web Project 鼠标邮件New Maven Project 选择Artifact ID 填写required text pom.xml 上鼠标邮件run as Maven install, 会发现关于这个项目的war包在Maven仓库中已经生成 常用MVN命令 mvn help:system 自动在本用户下创建 ~/.m2/repository mvn clean compile 清理编译 mvn clean test 清理测试 mvn clean package 清理打包 mvn clean install 清理将打包好的jar存入 本地仓库 注意是本地仓库 mvn archetype:generate 使用Archetype生成项目骨架 mvn clean deploy 根据pom中的配置信息将项目发布到远程仓库中 Maven项目目录结构说明 src/main/java :正式内容包路径 src/mian/resources :正式的配置文件路径 src/test/java :测试包路径 src/test/resources :测试的配置文件路径 src/main/webapp : war 资源目录 更多更多关于IntelliJ IDEA 下创建Maven项","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://dayarch.top/tags/Maven/"}]},{"title":"English","slug":"English","date":"2016-01-15T09:43:37.000Z","updated":"2019-11-01T08:39:34.656Z","comments":true,"path":"/p/spoken-english.html","link":"","permalink":"https://dayarch.top/p/spoken-english.html","excerpt":"连读 1. You’re gonna wanna get more experiences before you apply before 可以读成 /b fɔr/， you和apply之间加w的音 2. I just wanted to have a look at her resume before you hired her wanted to 读成 /wa nI tə/， nt+vowel,省t wanted=/wɑntɪd/=/wɑnɪd/, at her 读成/æ dər/ hired her 同理不发","text":"连读 You’re gonna wanna get more experiences before you apply before 可以读成 /b fɔr/， you和apply之间加w的音 I just wanted to have a look at her resume before you hired her wanted to 读成 /wa nI tə/， nt+vowel,省t wanted=/wɑntɪd/=/wɑnɪd/, at her 读成/æ dər/ hired her 同理不发h的音 *Give up or make decision because you can’t have it both ways * give up or 读成/gɪ vʌ pər/ , because 读成/kɔz/, 同时注意 can’t和can的读音区别 Didn’t it seem kinda cold last night Didn’t it /dɪ dɪn nɪ/ And your daddy didn’t understand？ / ə njər dæ di dɪ ‘ə nʌn dər sdænd?/ How does he expect me to buy stuff / hɑu dʌ ziks bekt mi də bɑi sdʌf?/ You’re probably gonna wanna train the new intern because he is hopeless** probable可以省略中间的b的音 /‘prɑbəli/ new intern之间加w的音， because he is /kɔ zɪs/ Look I’m really tired, so can we go home? look I’m /lʊ kai m/ Who else wants to see a movie? who else 中间有w的音 see a 中间有j的音 Oh,we do, but not just yet. /Ouwi dµ, bʌ’ nɑ’ dʒʌ sje’/ But it won’t work out /bʌ’ɪ’ woun’ wər kɑu’/ This might be a bad idea be a 中间有j的音 idea中间也有j的音 But I’m gonna do it anyway What if I had taken that job at Merrill Lynch? /wʌ dɪ fɑi hæ’ tei kɪn ðæ’ dʒɑ bæ’ meər rəl lintʃ? / Well, why didn’tyou take the job? /Wel wɑi dɪ ‘ən tʃµ teik ðə dʒɑb/ Do you not wanna be seen with me? /də jμ nɑ’ wɑ nəbi sin wɪθ mi?/ ** we’renot gonna hide it anymore.** /wər nɑ’ gʌ nə hɑi dɪ dæ ni mɔr / Here, let me give it a shot 让我试一试 give it a shot /ɡɪ vɪ də ʃɑ/ When are we gonna hang out? 我们什么时候出去玩一玩 when are we /we nar wi/ This isn’t what I wanted wanted /wɑnɪd/ Matt can’t be that fat, can he? 重音： can’t、 that， can he /cæni/ It’d’ve been nice to go out today It’d’ve = It would have /I’ dI dIv/ when am I going to get promoted when am I /we nə maɪ/ Is it a school night and she has a lot of homework to do? /ɪ zɪ də sguəl nɑi’ ən ᵗʃi hæ zə lɑ də houmwərk tə dµ/ When’s her birthday? /wen tsər bərθ dei/ Would you give it a rest 你省省吧，休息一下吧， （不要喋喋不休了，能停停吗） He is gonna wish he was never born wish he /wɪʃi/ 此处省略h could you… hold out that ring and ask me to marry you? /kʊ dʒµ… houl dɑu’ ðæ’ riŋ ŋən… æs mi də mæ rijµ?/ that 咬舌停顿，略读 How much is it? /hɑu mʌ tʃɪ zɪ’ ?/ 重音在is上 I thought that it mattered what I said or where I said it /ɑi θɔ’ ðæ dɪ’ mædərd wʌdɑi sed, ɔr weərrɑise dɪ’/ He knows what it’s about /hi nou zwʌ dɪtsə bɑu’/ You wanted it to be a surprise. / jµ wanɪ dɪ’ tə bi jə sә’praiz / I never had a bike of my own /ɑine vər hæ də bɑi kə mɑi ʲoun / Not really, I got to drag him around, too! / nɑ’rɪlli, ɑi gɑ’ tə dræg hɪ mə rɑun’ tµ! / (注意是gɑ’ tə， 表示“我也有拖着他跑的”， 不是“我得拖着他跑”) I’m sorry we can’t store your childhood things anymore. /ɑim sɔr ri wi kæn’ tsdɔr jər tʃɑild hʊ’ θiŋ ze nimɔr./ ** I used to love to play restaurant.** /ɑi jµs tə lʌv tə plei res dər rɔn’/ She’s not as pretty as she was when she was 29 /ʃis nɑ dəz prɪ di ʲæ ʃi wʌz wen ᵗʃi wʌz twe ni nɑin/ Ms. Greene would like to establish some ground rules before she comes out /mɪs grin wʊ’ lɑik tµ ʷɪs dæblɪʃ sʌm grɑun’ ruəlz bə fɔr ʃi kʌm zɑu’/ No, I love it.Thank you /nouʷɑi lʌvɪ’ θæŋkjµ/ Now that you’re a couple, we don’t get two presents from you guys? /nɑuðæ’ jər rə kʌpəl, wi doun’ge’ tµprezɪnᵗs frʌ mjµ gɑiz?/ you have got to try this cheesecake /jµhæv gɑ’ tə trɑi ðɪs tʃiz keik / Somebody sent it to us /sʌmbɑ di se nɪ’ tµ ʷʌs/ I’ll be right with you /ɑlbi rɑi’ wɪ θjµ / I was not staring at her /ɑiwʌz nɑ’ tsdeər riŋ ŋæ’ hər/ In college, Ross used to wear leg warmers! / ɪn kɑ lɪdʒ, rɔs jµs tə weər le gwɑər mərz/ Monica couldn’t tell time ’til she was 13 /mɑ nɪ kə kʊ ‘ən tel tɑi mʌn tɪl ʃi wʌz θər tin/ We used to be very close / wi jµs tə bi ve ri klous/ It’s not a big deal! /ɪts nɑ də bɪ’ diəl/ What did you say when you made up your vows? / wʌ dɪ dʒµ sei we njµ mei dʌ’ jər vɑuz?/ I am supposed to be writing my vows and all I have is this! /ɑim sʌ pous tə bi rɑi diŋ mɑi vɑuz ə nɑl lɑihæv ɪz ðɪs./ Those boots are amazing /ðouz bµ tsɑər rə mei ziŋ/ 金牌音标 /v/ 同“飞”的口型，喉咙震动 never ever over very give have love everything every even move believe leave everybody haven live five everyone whatever drive leaving moving alive movie giving forever lovely given evening cover seven leaving loved voice above evil save government forgive private /ð/ 舌头放在上下齿之间或者舌头顶在牙齿上，喉咙震动 the than those that other this these there then they mother father another together brother though either rather others /ʒ/ /ʃ/ 英文单词以sion sure sual rsion为结尾的包含ʒ音，同she的口型，嘟起嘴唇，喉咙震动, 注意不同于汉语的“湿” conclusion confusion decision division occasion provision television visionexposure measure pleasure disclosure, enclosure, leisure, treasure*usual visual casual *aversion conversion dispersion immersion perversion versionaction cooperation inflation situation appreication /ai/ /au/ /n/ 发/n/ 舌头要贴上颚 /ai/ 阿姨 behind bind blind wind find mind /au/ 啊屋 /aun/ 联想“云”字bound hound count mount pound found down brown town downtown /‘ən/ /ə/ 嘴巴全部放松喉咙震动， 很懒很放松的“饿” certain certainly fountain(喷泉，泉水) mountain curtain（窗帘） shorten written bitten gotten sweeten（减轻，使变甜） forgottten kitten(小猫) mitten(手套)/tən/ 通常drop t /‘əl/ /ə/ 嘴巴全部放松喉咙震动， 很懒很放松的“饿” /l/ 舌尖向上卷碰到牙齿, 嘴唇不动， 拉长“楼”的音 *people able pull bicycle table uncle principle deal heal meal rural actural formal legal * /r/ 舌头向后上转是正常的r（在末尾） 动作回去就是r的另一个发音（在开头）， 通常r 既在末尾又要在开头都发音， 如teacher is /titʃɚr rIs/ r在开头： rain ring read ride role roomr在末尾: wider easier higher dear poker /t/ /d/ 清辅音和浊辅音就是喉咙有没有震动,用气弹那么一下talked take top installed leged learnt student /ʊ/ 类似于“饿”的读音， 但是没有“饿”这个音喉咙那么用力 good look book took hood cook could would should put /i/ /ɪ/ 将“叶”字分解. *it, fit hit bit itch(痒) lip sit * 美语口语2016.3.2 Future WorldJ: ** Did u hear the Apple Pay is coming to China? It means we can *pay with our Iphone, isn’t that nifty* pay with: 用… 支付; nifty: /‘nɪfti/ X: That’s pretty slick, who would’ve thought that one day we could make payments with a mobile phone? Technology seems to make our lives better and better, what do u think the future has in store for us over the next 50 years slick 等同 nifty，表示高科技的小物件比较酷who would’ve thought that one day… 谁能想到有一天…sth has/have in store for 等同于 sth will happen in the future J: I think *things** will continue to get smaller, Maybe one day our cellphone will be the size of a grain of rice* things 日常的东西cellphone 在美国手机经常用这个词the size of a grain of rice 米粒儿一样的大小 X: * That’d be pretty cool! Maybe it will be implanted in our bodies, we’ll see a greater integration between man and machine* That’d be pretty cool 一种猜测，虚拟语气implant 植入integration 集成 IC卡（Integrated Circuit Card） J: I think VR(virtual reality) is the next big thing, I bet stem cell research will make great strides as well, maybe we can grow a new in the lab(laboratory) organ instead of transplanting some else’s the next big thing 成为主流，something that is not popular now, but will be popular and mainstream in the futuremake great strides 取得更大进步stem cell 干细胞 X: I’d rather work than become a *couch potato*** couch potato 沙发土豆 指懒人 2016.3.7 Online LearningX: I thought you were supposed to have class now? what are you doing at your home? were supposed to 本应该干什么却没干 J: I’m having class, can’t you see? have class 上课 X: What do you mean? you’re at home on your computer what do you mean? 什么意思？ 期待对方给予答案on your computer 面对电脑. I’m on my computer 我正在用电脑. on the internet 上网. I’m on the bus 我在公交车上 J: Come on, *get with the times,** a lot of people are taking classes online now, it’s perfect for workaholics(工作狂) like me, not only that, you can go online and learn just about anything, right now, i’m studying economics. The best thing is I can choose the time I want to study, the time isn’t set in stone* get with the times 跟上时代的潮流take class = have class 上课 (where are you taking class? i’m taking class online)not only that 不仅如此just about anything 几乎所有的事情/东西， just在这里指几乎economy 经济 economics 经济学 economist 经济学家set in stone 设置在石头上，表示“固定,永久不变的”， isn’t set in stone 不固定 X: I had no idea that you could learn online have no idea 是完全不知道， i don’t know 有时候还表示一些不确定在里面 J: You should jump on the bandwagon and study online too jump on the bandwagon 跟上潮流. keep up with trend, trend本身就是一个大的趋势，所以千万不要写big trend， 从汉语的解释big就是累赘 X: I’d love to, Maybe next semester I can pick some online classes, Right now my *thesis** is driving me bonkers* thesis /‘θisɪs/ 比较正式的论文drive me bonkers/nuts/crazy 让我抓狂 J: What do you so stressed about? I thought you had the whole semester to get it done stress about 抓狂（什么东西压着你） X: Yeah, I did, but I procrastinated until the very last minute, Now i’m paying the price procrastinate /pro’kræstɪnet/ 耽搁、延迟pay the price 付出代价 J: Just take it easy, Rome is not built in a day, you know? Rome is not built in a day 罗马不是一天建成的 J: * Good thing you are here, my computer crashed, now i can’t boot it, I have to finish my homework by the end of the day, can you help me out， I’m really pressed for time with this homework* good thing 幸亏， 类似于thanks god.crashed 可以表示电脑死机boot 启动 boot an electronic device (启动电子设备)by the end of the day 截止到今天help me out 帮我渡过难关/困难pressed for time 时间紧迫 X: * You scratch my back, I will scratch your back, it’s only fair* you scratch my back, i’ll scratch your back 你挠挠我都后背，我挠挠你的后背，指互帮互助 J: Alright, you win， It works, you really are *a Jack of all trades*** a Jack of all trades 某人各种工作都干得很好，一个什么都会做的人 表示什么都会 X: So you are gonna *renege on our deal? *that’s cold renege on our deal/go back on your words/go back on your promise 反悔that’s cold 一种心理描述， “太不靠谱了” 心灰意冷 2016.3.10 Visiting a friend in the hospitalJ: What a pleasant surprise I’m so happy to see you 表示非常高兴 X: How ya doin’, Sis? I thought I’d pay you a visit, I bet you are pretty lonely here in the hospital all by yourself How are you doing? 在口语中可以说 How ya doin’, 表示问候“怎么样了”pay a visit to sb = pay sb a visit (拜访某人) J: That’s so sweet of you, my mom just left a few minutes ago, I’m surprised you didn’t bump into her as you were coming up so sweet of you = so kind of you (你真好)bump into sb (偶然遇到某人， 强调偶然性) X: Oh rats, That would’ve been great to catch up with her, I haven’t seen her in ages, anyways, how’d your operation go? oh rats 真可惜，很可惜catch up with sb (Talk with someone who you haven’t seen in a long time 和很久没见的人唠嗑聊天)I haven’t see her in ages (我好久没见到她了， long time no see)How’d (did) your operation/holiday/birthday go? (… 过得怎么样)？ J: It was success, The doctor said I will be back to normal in no time, Although, i’m feeling a little woozy(头晕) from the anesthesia(麻药) I will be back to normal in no time = I’ll get back on my feet soon = I’ll fully recover soonanesthesia /,ænəs’θiʒə/ 麻药 X: That’s a relief, I would’ve come earlier had I known That’s a relief (那我就放心了) J: Two days ago, I was helpig my mom do the dishes when I slipped and fell on my knee,Thankfully, we didn’t have to call ambulance, my mom rushed me to the ER(emergency room) do the dishes 洗碗thankfully 非常幸运地rush sb to smw = send sb smw quickly (飞速的把某人送到某地) X: Good thing your mom was there to help you out. I brought you some stuff to munch on, beef jerky, your favorite munch on = to snack on = to eatbeef jerky 牛肉干 pork jerky 猪肉干 J: This will make me feel even better, I should stay in the hospital a little longer, I don’t mind being pampered by you pamper /‘pæmpɚ/ to take really good care of someone 精心照料 X: Is there anything I can do for you (常用口语， 我能为你做些什么事情吗)J: You can go pick up some medicine for me at drug store, take this prescription and get me three bottles of painkillers and three bottles of penicillin, The drug store is on the first floor to the left of entrance, on your way back, help me ask the nurse on duty, if I’ll be able to come home tomorrow drug store = pharmacy （药房）prescription 处方， painkiller 止痛药， penicillin 青霉素The drug store is on the first floor to the left of entrance （注意描绘方位）on your way back 在你回来的路上on duty 值班 2016.3.14 Negotiating with LandlordsL: After seeing the apartment, are you satisfied with everything? be satisfied with 对… 满意look for a house/place 找房子 X: I think so, I just have a few questions if you don’t mind if you don’t mind 如果你不介意，一种非常客气的说法，可以放在句子开头也可以放在句子末尾 L: Okay, shoot shoot 非常口语化的表达“请直说，但说无妨，问吧” X: I’m on the fence about choosing the big room or the small room, they are both very nice I’m on the fence about sth/doing sth 表示“不大确定，还在犹豫”to sit on the fence “墙头草“的意思 he is to sit on the fence L: If I were you, I’d pick the bigger room, it’s closer to the bathroom and the view is facing the city, it’s really the best of both worlds the view is facing the city 窗子冲着市区景色it’s really the best of both worlds 两全其美 X: You’re right, I’m a sucker for beautiful scenery, Okay, i’m sold, the big room it is, what’s the next step? I’m a sucker for sth 我对… 没有抵抗力i’m sold 我要了/我买了the big room it is 就是这个大房间了， .. it is 表示就是.. 了 Pizza it is 就是披萨了 L: If you are sure you’d like to live here, we require that all of tenants sign a one year lease agreement, then I need your John Hancock here lease agreement 租约， 通常连用John Hancock 签名 = autograph (所有签名的单词都可以通用在任何场合) X: There you go, are we finished?L: That’s it, here is your key, you’re free to move in anytime, if you have any question, please give us a call and we’ll glad to assit you move in 搬进来，入住 L: Hello, Mr. Gao, how is the new apartment?X: Well.. it’s great, but there is a slight problem slight problem 小问题，一种委婉的说法 L： What’s the matter?X: There’s a huge pest(害虫、虫子、有害之物) problem in the kitchen, I’m worried that it might come into my room *L: *What kind of pests are we talking about?X: Roaches roach (蟑螂) 全程cockroach L: I’m very sorry to hear that, have you tried cleaning the kitchen thoroughly(彻底地，完全地)X: That’s why I came here, isn’t there something that you can do?L: I’m afraid notX: But you are my landlord, I thought your slogan was “above and beyond the call of duty” slogan 口号above and beyond the call of duty 竭尽全力做某事，全心全意做某事 L: You mustn’t have read the fine print in the contract. it says here on line 217 that we are not responsible for any bug infestations fine print 小字体 large print 大字体infestation /ɪnfɛs’teʃən/ 感染，侵扰 X: I see， in that case, I’ll have to hire a prefessional to get rid of the bugs in that case 那么，在这种情况下get rid of 清除.. 2016.3.16 House of CardsJ: Hi,Xiaogao, why do you have those bags under your eyes, have you not been sleeping well lately? bags under one’s eyes = to have dark shadows under one’s eyes, usually from a lack of sleep (由于睡眠不足导致的黑眼圈) X: You can say that you can say that (你可以这么说） 等同于yes，表示肯定 J: Care to elaborate? care to elaborate = can you please explain? 能解释一下吗？ 详细说说？ X: I’ve been binging on House of Cards lately, season 4 came out last week, and my eyes have been glued to the screen ever since binge on sth/doing sth = to over indulge in sth 过渡做某事， 这里指疯狂追剧纸牌屋binge drinking (酗酒，豪饮)come out 上映， 多用于影片one’s eyes have been glued to the screen = to be infatuated with a movie or show to the point where you don’t want to do anything 眼睛贴在屏幕上了，意指沉迷于电影或电视节目而无心做其他事 J: Season 4 is already out? I just remember just a few years ago when the first season came out back in early 2013. It seems like just yesterday It seems like just yesterday （used to refer to something that isstill fresh in one’s memory） 恍如昨日的感觉 X: Yeah, I’m hooked on it, I think it is so cool that Netflix was able to make such a successful online-only web television series, They really broke new grounds Be hooked on sth = to be addicted to sth 沉迷于某事，上瘾hook uponline-only web television 只在网络上播放的网剧break new grounds （to accomplish something that hasn’t been accomplished before） 完成从未被完成过的事，常指开创新局面 J: Did you know the first season received nine prime time Emmy Award nominations, The whole world seems like to love this political drama receive .. award 获得.. 奖项political drama （A drama series that has a political background） 有政治背景的剧集 X: I think Kevin Spacey and Robin Wright’s acting is outstanding! The first three seasons kept me on the edge of my seat during each episode. I love Neve Campbell’s performance in season 4! She’s one of my favorite actresses of all time. outstanding 这里指演技出神入化，很棒[Something] keeps you on the edge of your seat = [something] is very suspenseful 非常具有悬念的某事 这里指很刺激of all time 一直以来 J: So, how is season 4? I heard there are some similarities(相似之处) between season 4 and the American election campaign. Is that true?X: That’s right! There certainly are parallels（相似之处） between season 4’s script and the 2016 primary campaign. Are you sure you want me to go into specifics? It might spoil（剧透） it for you? Go into specifics = talk about something in detail (详细说，仔细解释) J: On second thought, I think you’d better wait until I watch itmyself. on second thought 经过再一次考虑 X: Well, all I can say is get ready for more suspense and nail-biting drama! It’s so fun to watch Frank Underwood climb up the ladder of power! all that I can say is = what I can say is （具体查看语法定语从句）nail-biting (咬指甲，指非常刺激的剧情)climb up the ladder = to ascend in rank, power, or status （字面爬上梯子，意指达到某种权力) 2016.3.23 Artificial IntelligenceJ： I didn’t know you played Go(围棋)X: I don’t, but I really wanna learn it, Did you hear about the amazing archievement of Google’s AI robot AplhaGo? hear about 听说archievement 成就，非常大的词汇，表示很了不起的成果 J: I heard about it, why are you so excited? *X: *Because it’s the first AI program that could beat a professional player at the most complex board game mankind（人类） has ever created. board game 棋盘游戏 J: I thought computers have been able to beat humans at chess for a long time, what’s the big deal? for a long time = in ageswhat’s the big deal? 有什么大不了的，多大的事 X: You’re right, but there is a huge difference between chess and Go, computers could easily beat humans because it’s way less complicated. computers don’t need to be smart to win at chess, they just need to be fast, a computer can use technique called brute forceto(BF) win at chess, this is not possible with Go, AlphaGo use reall AI called deep learning in order to solve problem. there is a huge difference between A and B (A 和 B有很大的不同)way less complicated (此处的way相当于very /much)deep learning (深度学习)win at sth （赢得什么/取胜） J: I think I understand now, but why does this matter for mankind? why does this matter for mankind? (但此事为何对人类事关重要？) X: such as complex weather conditions,disease control, and global warming issuesJ: I heard the AI robot only won 4 out of 5 matches. Does that mean that AI has room for improvement? 4 out of 5 五分之四 四分之三：three fourths= three quarters 五分之三：three fifths 分数的表达法：分子用基数词,分母要用序数词,分子大于1时,分母的序数词后加s.对于四分之一,常用quarter来表示.sth has room for improvement （sth 还有进步空间） X: That’s right. The robot isn’t perfect, but it certainly impressed the entire world. Some of AlphaGo’s moves were described as “beautiful” by Go fans. sth impressed sb （.. 给某人留下深刻印象）AlphaGo’s moves 此处的move表示棋路 J: This is getting scary. Are robots going to take over the world? take over (控制/接管) X： Although Google’s AI victory marked a major milestone for artificial intelligence, the world is still a long way away from mimicing true human intelligence. mark a major milestone (标识一个重要的里程碑)mimic /‘mɪmɪk/ vt. 模仿，摹拟A long way away from… = 与…差得很远 2016.3.28 HoroscopeJ: We’ve already talked about the first six zodiac signs, I think it’s time we talk about the last six . Pop quiz first six 前六个 last six 后六个pop quiz 考考你 X: These people love justice(公正) and fairness（公平）， they also work well with other people work well with sb 非常融洽的和某人合作、 配合默契 J: Libras are known to be cooperative(有合作精神的), they don’t like violence（暴力） or injustice（不公正） of any kind.X: Scorpios seem quiet and cool on the outside, but they are actually really emotional(内心感情丰富) and passionate(富有激情) on the inside on the outside 外表 on the inside 内心 J: I heard they make really great leaders, they don’t like being lied to, so make sure you’re always honest to a Scorpio make great leaders 非常会做领导 注意make的用法 X: Sagittarius are deep thinkers deep thinkers 思想家/思想者 J: They are really extroverted and optimistic, it’s hard for a Sagittarius to feel down， we’ve finally reached the last three zodiac signs(星座) extroverted/introverted (外向的/内向的)optimistic/pessimistic （乐观的/悲观的）feel down (不开心，情绪低落)reach 到达， 到达了最后三个，就代表剩下三个 X: These people is known for their professionalism and traditional values , they are really serious people professionalism and traditional values （专业精神和传统价值观）serious people (严肃认真的人， 高冷) J: Let’s move on, it should not surprise you that the symbol of Aquarius the water bearer, they can also be boisterous and energetic. They love to lend a helping hand to those in need. it should not surprise you (毫无疑问，不会让你感到惊讶)boisterous /ˈbɔɪ.stɚ.əs/ 喧闹的, 精力旺盛的lend a helping hand to sb 帮助某人 X: The Pisces is a very gentle and affectionate(深情的，有爱心的) person. They are there for you when you need to spill your guts. Why would I want to be like you? spill your guts 说心里话why would I wannt to be like you? 为什么我要像你一样？ 十二星座 Aries /ˈer.iːz/ 白羊座 Taurus /ˈtɔːr.əs/ 金牛座 Gemini /ˈdʒem.ə.naɪ/ 双子座 cancer /ˈkæn.sɚ/ 巨蟹座 Leo /ˈliː.oʊ/ 狮子座 Virgo /ˈvɝː.ɡoʊ/ 处女座 Libra /ˈliː.brə/ 天秤座 Scorpio /ˈskɔːr.pi.oʊ/ 天蝎座 Sagittarius /ˌsædʒ.əˈter.i.əs/ 射手座 Capricorn /ˈkæp.rə.kɔːrn/ 摩羯座 Aquarius /əˈkwer.i.əs/ 水瓶座 Pisces /ˈpaɪ.siːz/ 双鱼座 2016.3.30 Airport EnglishXiaogao is at the airport checking in(办理登机), Jingjing plays the part of the airline employeeJ: Hello sir, where are you flying today? (您此行飞往何处？)X: I’m headed to Detroit. be headed to smw 前往某地， 不能指从外地回家Head to = to go to 去（往）某地 J： Can I please see your passport? do you have any goods to declare? declare 申报， 指过海关的申报 X： Here’s my passport, no goods to declare this time.J: Okay, will you be checking in any bags? check in (既可以指办理登机，也可以指托运行李，此处是后者) X: Yes, Just this oneJ: Please place it on the scale, oh *your bag is overweight（超重）, I’m afraid you’ll have to pay a small fee*** place it on the scale(秤: a device to measure weights) 把它放在秤上pay a small fee (此处要用fee， tip指吃完饭给的小费)I’m afraid that （恐怕…） I’m afraid of (害怕…) 注意二者的区别 X: That’s fine, here you go(给你)J: Here’s your boarding pass, you’ll begin boarding at 10:05 at gate D12 boarding pass (登机牌) X: Thanks ma’am ma’am /mɑːm/ 对女士饿一种礼貌的称呼，不在乎结婚与否 Xiao Gao is going through the security check. Jing Jing plays the part of the customs agent go through 通过security check 安检 J: Please take your laptop out of your bag and place it in a bin(指安检的小盒子)X: No problem, should I take my shoes off too?J: Yes, sir, you can put your shoes in another bin, please step through the metal detector. step through （走过） 注意和go through的区别metal detector （金属探测器） X: I’m gonna have to pat your down, do you have any metal items in your pockets? pat one’s down (很形象的说明“搜查身体”， 原意是拍拍你的身体) to search someone’s clothes for items they shouldn’t have J: No, I think it might be the belt buckle, it’s made of metal. belt buckle (皮带扣) X: You are free to go, don’t forget to grab your things grab sth （拿上某物）grab a bite to eat/ grab sth to eat Xiao Gao is onthe airplane getting ready to take off. Jing Jing plays the part of the stewardess(指空姐) Flight attendants/stewardess 空乘人员 J: Here is a hot towel(毛巾) for you.Would you care for a pair of head phones? care for sth (需要…)head phones (耳机) X: I will take a pair(指一对耳机)， BTW， could I have a cup of water, please?J: Coming right up, and here’s some peanuts(花生) and pretzels（椒盐脆饼） for you to snack on. coming right up (马上送过来)snack on = munch on (食用, 当零食吃) X: Thanks! Those are my favorite! favorite 此处是形容词作名词，直接单数形式 The captain makes an announcement（机长开始广播）Good morning ladies and gentlemen. This is your captain speaking. We have been cleared for takeoff(名词：起飞). We’ll be leaving in just a few minutes. Please sit down and fasten your seatbelts. We expect to arrive in Detroit in 12 hours. Thank you for flying with Happy Airlines. Flight attendants, prepare for takeoff! 扩展翻译 哪里是落地签办理处？Where can I find the visa on arrival office? 我在28号安检口等待安检I’m waiting at gate 28 for a security check 可以免费托运多重的行李？What’s the heaviest amount of luggage that we can check for free? 转机时是否需要取行李?行李可以直达目的地吗？Do I have to grab my luggage during connecting flights? Can we send my luggage directly to my destination? 紧急出口在哪儿？Where’s the emergency exit? 2016.4.6 CampingJ: What are you gonna do for the weekend? what are you gonna do/what are you plans/what you have in mind for the weekend? 周末打算做什么 X: I haven’t decided yet, it’s still up in the air as to whether I’ll go camping with my friends or go bike riding through the countryside(郊外). I haven’t decided yet. （注意加上yet更加完整，表示“我还没有决定”）sth is still up in the air （某事还没决定，此处是事没确定）sb is on the fence about sth （某人还在犹豫某事， 此处是人在犹豫）as to （至于…. ） J: Both of those things sound really tiring. why don’t you stay in town and hang out with your friends? tiring: sth is tiring that makes you tired.注意hang out 和 play的区别, play跟多的是指小朋友之间的玩耍，hang out 指逛街之类的 X: I’m an outdoorsman, I love nature, and besides, lately the weather has taken a turn for the better. outdoorsman （户外运动控）take a turn （转个弯，变化） 多数用于天气/身体 take a turn for the better/worse J: I guess different things make us happy, I use my weekend to catch some shuteye catch some shuteye (补觉) X: I think you’d really like camping,how about we both go camping this weekend?J: I don’t know, is it expensive?X: Not at all, but I’d appreciate some help with gas money. it’s a long drive out to the campsite(度假营地) not at all (一点也不，注意连读)I’d appreicate some help … 非常委婉客气的说法It’s a long drive out to the campsite/hospital/my mom house (去..的路程很远) J: I’ll spring for gas, can I help with anything else? spring (作动词讲意思：拿出..东西) pay for = spring for the ticket/dinner X: I’ll let you set up a tent, you’ll love it set up a tent = pitch a tent （搭帐篷） J: It sounds like I’m getting the raw end of the deal, I heard that can be a lot of work get the raw end of the deal (raw 生的， is not fair， 意思是吃了亏，拿到了不好的一端) X: Don’t worry, I’ll help you through it. so are we on for the weekend? I’ll help you throught it = I’ll help you out (我会帮你搞定它)are we on .. (我们说定了..嘛？) are we on for tonight/the weekend? （说好今晚/周末？） J: we’re on 说定了 J: You should have looked at the weather report before we left.I can’t believe it’s raining right now, this is the pits I can’t believe it’s raining/April 4This is the pits (pit: the hole in the ground, 表示不理想的情况， 太糟糕了) X: Don’t worry, we still have a good time, hurry up and pitch the tent before we get any wetter. hurry up and pitch the tent before we get any wetter (快来，在我们淋湿之前把帐篷打起来，注意此处比较级的运用，更加地道) J: There a lot of poles(杆子), I don’t know what to do first.X: There is nothing to it, watch me, there, all done there is nothing to it (没难度，很简单) J: I guess that wasn’t so bad, so what are we supposed to do now? it’s too cold and wet to be outside right now.X: How about we make dinner in tent? I brought a portable stove and some ramen portable （唯一表示“便携式”的单词）ramen 拉面 J: Now you’re talking, cooking is right up my alley, ok, Xiaogao, just sit back and relax, i’m gonna cook up a mean bowl of noodles. you’re talking (太好了，很同意这么做，表示赞成)sth is right up one’s alley = sb is good at stha mean bowl/dish of sth (一碗特别好吃的…) X: Hey, you should come camping more often! You seem like a pro! pro 此处表示专家， 注意和professor的区别， 此处不能用professor， pro表示很专业more ofen 表示“经常” J: What can I say? I guess I’m just good at everything I do! what can I say (我能说什么呢？ 很炫耀的一种说法)I’m good at everything I do = I’m a Jack of all trades (我什么事都能做好， 我是个全才) 2016.4.11 30-day ChallengeX: My friends and I are gonna go see Zootopia and then go grab a bite to eat, you in? grab a bite to eat 吃点东西A: you in? B: yes, I’m in / no, I’ll pass J: I’ll passX: What? I thought you were dying to see that movie be dying to do sth = Yearning to do something (非常/渴望想做某事) J: I do really wanna see that movie, but I’ve got other plans, Lately I’ve been helping people at the old folks’ home old folks’ home = nursing home (敬老院，前者多用于口语中) X: Why would you do that instead of going to the movies? That doesn’t make sense make sense (有意义)That doesn’t make sense (根本没道理，讲不通) J: I made a commitment to myself that I will do something good every day for 30days, I recently attented a TED seminar（专题讨论会） by Matt, He talked about the benefits of doing something for 30 days straight. make a commitement (做承诺)注意此处Straight的用处 X: Oh yeah, tell me about it. tell me about it = care to elaborate J: He said it’s a greate way to improve yourself-confidence. It’s also a great way to force yourself to do something that you’ve always wannted to do, but never got around to actually doing improve yourself-confidence (注意：提升自信心要用improve)push sb to do sth = force sb to do sthget around to doing sth (抽时间做某事) 在肯定句中： finally get around to doing sth 在否定句中： never get around to doing sth X: Oh, that sounds like something I should do…J: I think you’d love it. You can pick something that you’re willing to do for 30 days, for example, writing a 50,000-word short story. Every day you just have to write 1667 words, but the tough part is that you can’t go to sleep until you’ve finished what you promised yourself you’d do. the tough part (最艰难的部分) X: I think I’ll give this a shot.Okay, have fun helping the old people. I’m off to the movies! give it/this a shot （试一试）have fun doing sth (有兴趣做某事)I’m off (我走了，可用于结束一天的工作指“下班”) J: * You look a lot thinner than the last time we met.* package some pounds （变胖） X: I took your advice and decided to go on a diet for 30 days. So far, I’ve stuck to my diet really well. go on a diet (节食、减肥)stick to doing sth/sth （坚持做某事） J: That’s great! So, tell me about it? What exactly are you doing? what exactly are you doing? (你到底做了什么) X: * I promised myself that I would eat healthy for at least 30 days. I also promised myself to get lots of exercise by walking and going to the gym.*J: How are you making sure that you eat heathy?X: * I weigh all of my food on a digital scale before I eat it. Then I calculate the amount of calories. Right now, I only eat about 1900 calories a day. It’s really helped me slim down.* digital scale (电子秤) 关联2016.3.30 Airport English 中 place it on the scaleslim down (瘦身，瘦下来) J: I can see that! You look like a completely different person! (你简直像换了一个人，注意completely的使用)X: By the way, are you still sticking to your commitment?J: My 30-day commitment ended two weeks ago, but I felt so good about myself that I decided to keep it as a healthy habit. I still try to do one good thing every day. I love it! 2016.4.18 Getting Money BackX: Can I talk to you for a minute? I’d like to pick your brains about something. pick someone’s brains (询问/征求某人意见) Can I get your advice? J: I’m all ears, what’s up? I’m all ears (浑身上下都是耳朵，指在认真听，洗耳恭听) X: I lent my friend 500RMB two weeks ago, and he still hasn’t paid me back, I’m at a loss of what to do borrow sth from sb (从某人借某物)lend sth to sb (借给某人某物)pay me back (还钱给我)I’m at a loss [of]… 我困惑.. 不知道怎么办 I don’t know what to do. J: You could give him the benefit of the doubt, maybe he forget about the money give sb the benefit of the doubt (暂且相信某人 站在对方的立场上想，给某人一次证明自己的机会) X: * That’s a lot of money to forget about. I’m really starting to get angry now.*J: I suggest you sit down with him and have a heart-to-heart talk. whatever you do, don’t lash out and accuse him of stealing your money, he really might have forgotten. heart-to-heart talk (坦诚的，开诚布公的谈话)lash out (用言语攻击、狠批) don’t lash out (不要说伤人的话，不要情绪太冲动失控)accuse sb of doing sth (谴责/斥责/指控某人做某事， 不见得有证据的指控/斥责) X: I think I’d better keep him at arm’s length from now on keep sb at arm’s length (和某人保持距离) J: Don’t jump to conclusions so fast, talk to him about it first, and then draw your conclusion. jump to conclusions (妄下结论)draw one’s conclusion (下结论) X: Okay, I’ll keep you posted keep you posted (告知某人某事，我会保持更新消息， 有消息就告诉你, 可以用在邮件书写中) J: Were you able to get your money back? get money back (还钱) X: Yeah, but it was no walk in the park. a walk in the park (轻而易举)a pain in the neck (脖子上有疼痛，指不顺利，有麻烦)twists and turns (故事上的“曲折”) The story is twists and turns J: What do you mean?X: I asked him if he could give me my money back, and he told me that it had completely slipped his mind. slip one’s mind (忘得一干二净) J: So did he give the money back to you thenX: He only gave me 300. He said he will give me the other 200 next week once he gets paid. But then I remembered that he was going on vacation next week, so I called him on his bluff call sb bluff （揭穿某人） J: Did he come clean? come clean (变得清晰 指说真话 老实交代) X: Yes, he apologized and gave me the other 200 the next day. He said he has been really tight for cash lately. tight for cash (手头紧) J: It sounds like youburied the hatchet with him? bury the hatchet (埋掉战争、斧头, 指“和解；冰释前嫌”) X: Yeah, I decided to let bygones be bygones. Now we’re back to being good friends,just like before. let bygones be bygones (过去的事就让过去吧， 既往不咎) J: * I’m glad you listened to me and were able to remain friends with him.* remain friends (维持朋友关系) X: what would I do without you? 2016.4.20 Taxi EnglishJJ is visiting NewYork for the first time. XG plays the part of the taxi driver.JJ: Thanks so much for stopping, do you know how to get to Times Square(时代广场) from here? how to get to smw from here? 从这怎样去smw XG： Hop in, so, is this your first time to The Big Apple? hop in （上车）/ hop out (下车) hop本意是“跳”NYC(NewYork city 别称叫The Big Apple) JJ： Yeah, it sure is, I never thought NewYork was this big, It reminds me of ShangHai,China It sure is (当然了，确实是这样)this （此处表示强调， 增强描述语气）remind sb of sth （让某人想起某事） XG: You’re from China, eh? wow, that’s a long way from NewYork. when did you land? it’s a long way from swm (距离某地很远)when did you land (什么时候到的) = when did you arrive JJ: Last night, I’m still a little jet lagged I’m still a little jet lagged (我现在仍然有点时差疲劳) tired from the time difference between two placesi’m lagging (通常是指“我网络延迟”) XG： Well, welcome to Manhattan(曼哈顿) ， where else are you gonna see while you’re here?JJ: *I’m planning on visiting Central Park(中央公园) and of course , the Empire State Building(帝国大厦), maybe you can tell me some good places to visit? * I’m planning on doing sth (正打算某事) XG： It’d be my pleasure, I think you should add the Statue of Liberty(自由女神) to your list, it’s a must-see must-see(必看的[地方]) must-do(必做的[事情]) JJ： tha’s a greate idea.XG: If you’re into animals, you should check out the Bronx ZOO(布朗克斯动物园), The 9/11 memorial is also a place you can’t miss, and since you’re laddy, I bet you like shopping, right? be into sth (特别喜欢某物/事)check out (去看看， 在酒店结账退房也可以用check out)A place you can’t miss (非要去看不可的地方)The 9/11 memorial is also a place you can’t miss (注意句子结构用法) JJ： That’s rightXG： Well， you’ll love downtown Manhattan(曼哈顿闹市区)， there’s enough shopping malls there to keep you busy for days. but make sure you save some money for Coney island(康尼岛), there’s a lot of things to do, If you have enough energy, You should check out NewYork’s night life, You won’t be disappointed.JJ: Thanks so much, those are some great tips!(小攻略)XG： Here we are, Times Square! That’ll be $32.50（thirty two dollars and fifty cents）JJ: Here’s $35, keep the change. By the way, can you tell me how to get to the music store? keep the change = You can keep the tip(留着小费吧) XG： Sure, walk two blocks east. You’ll see it on your right.Good luck walk two blocks east (向东走两条街， 注意之路方向词的用法) 扩展： 纽约市共分为五区〈Borough〉：布朗〈The Bronx〉、布鲁克林〈Brooklyn〉、曼哈顿〈Manhattan〉、皇后〈Queens〉、及李奇文(又称为列治文)〈Richmond (Staten Island)〉。 put your arm out (伸出手，想象叫出租车的样子) 2016.4.25 Vacation EnglishXiao Gao is checking into a hotel(办理入住酒店). Jing Jing plays the part of the front desk employeeJJ: How may I help you?XG: I have a reservation under the name Gao A: I have a reservation. B: under which name (用哪个名字预定的) JJ： Wait a moment while I’ll look you up, XG, is that right? look [sth] up (查询) XG： Yes, that’s rightJJ: It looks like you have booked a queen size bed? queen size bed （大床房） King size bed (超级大床房) XG： BTW, could you tell me some fun things to do around here? it’s my first time to Miami.JJ: You asked the right person, I used to work as a tour guide before getting this job at the hotel, I think you should check out Miami beach, it’s a great place to get a tan, At Miami beach, you can go on a speed boat tour, afterwards（然后）, you should take a boat to the Bahamas(巴哈马)， it’s a paradise, you’ll love the restaurants and bars there you asked the right person (你问对人了)get a tan (晒的美黑) (tan 既可以是名词， 也可以是动词 I’m tanning now)get a sunburnt(晒红， 就是指晒伤了)sea sick (晕船)go on a speed boat(快艇)/sth tour (来一个…游)it’s a paradise (就是一个天堂啊) XG： thanks, I’m gonna get my swim suit on and hit the beach swim suit (泳衣)you look good in the suit. the suit looks nice on you (注意介词in和on的使用)hit the beach (奔向海滩，注意动词hit的使用，指去哪) XG is at a restaurant at the Bahamas. Jing Jing plays the part of the restaurant employeeJJ： Sir, table for one? table for one/two (一位/两位吗)A: how many? (几位？) B: table for six (六个人) XG Yes, PleaseJJ: Smoking or non? (您想坐吸烟区还是非吸烟区)XG： Non, pleaseJJ: right this way, *Can I get started off with a something to drink?*** right this way (这边请)Can I get started off(start off 就相当于start) with a something to drink? XG: How about a martini(马丁尼)JJ: Coming right up, do u still need a minute to look at the menu? coming right up (马上就来) XG： What are your specials today? (今天的特价菜是什么？)JJ： Today our specials are steak（牛排） and potatoes（土豆） and roasted salmon（烤三文鱼）. Do any of those sound good?XG： I’ll go with the steak please. I’ll have / go with + 菜名 （我要点什么.. ） JJ： Okay, I’ll be right back with your order. （您的单很快就来）JJ: How are we doing? Can I get you another martini? how are we doing (怎么样，外国像国内需要叫服务员，他们会四处走来照顾顾客需求) XG： No, thank you, I’m feeling a bit tipsy already. I’ll take the check, though. I’m feeling a bit tipsy already(我感觉有点微醺了) / I’m feeling a little tipsy/woozy (I think I’ve caught a buzz). I gotta foot the bill.I’ll take the check ， though(我要买单了, though就算是一种语气词“了”) JJ： You got it. Here you are. I’ll be back to pick that up in a few minutes.(我过一会回来拿） you got it (没问题) 扩展： 四大洋： the Pacific [pə’sɪfɪk] Ocean (太平洋),the Atlantic [ət’læntɪk] (Ocean)(大西洋),the Indian Ocean(印度洋),the Arctic [‘ɑrktɪk] Ocean (北冰洋) Hurricane crashed the Florida last week (飓风上周袭击了弗罗里达州) 2016.5.4 House Warming PartyJJ: XG, how’s the guest list coming along? how’s [sth] coming along? (sth进展的怎么样，还没有结束) XG： It’s pretty good, I’ve already thought of 30 people who we should invite.JJ: I think you should limit your guest list, after all we’re on a tight budget. hosting so many people could be really expensive. on a tight budget (预算有限) 注意和tight for cash的理解区别hosting (邀请) XG： You’re right, what about invitations? maybe we should use social media instead of paper invitations in order to cut down on costs what about（直接提出选择、想法） 和 how about（有了一个，提出另外一个）cut down on costs (减少开支) JJ： Good idea, make sure you request an RVSP so that we can play for foods and drinks better. RVSP (Répondez s’il vous plait(French for “please respond”) 敬请回复,收到请回复) XG： Speaking of food, I think we should have finger foods that people can munch on while they mingle. speaking of [sth] (说道sth)saying [sth] （比如sth）finger foods (foods that are convenient to eat with your hands 能用手拿着吃的方便食物)mingle (Mingle = to socialize 陌生人之间的社交) JJ: I was thinking we should hire a catering service to provide our food . that way we can focus on decorating our new home, we want it to look nice when the guests arrive. catering service (a service that provides food for an event or party 为特定活动提供餐饮服务) XG： Great party huh？JJ： Yeah， it sure is, the music is great, and the food is even better. it sure is (确实，给与肯定) XG： Who do you know here? (你都认识这里的谁，注意表达)JJ： I’m JJ’s friend, we went to school together. we went to school together (可以表示我们过去时同学) XG： Oh cool. Xiao Gao and I are on the same basketball team. Nice to meet you. I’m Bob, by the way. 注意口语对话中 by the way 的使用， 顺便介绍一下自己 JJ： I’m Jennifer. Nice to meet you too. Did you get to go on a tour of the place yet? It’s such a nice home. I’m so happy for them go on a tour of the place (在这个房子里四处转转了吗？) 联想 go on a speed boat tour (来一个快艇游) 注意灵活使用 XG： Yeah, I’m surprised at how much space they have. Anyways, would you like to go grab some refreshments（零食，点心）? I see you’re almost done with your drink. The turkey is splendid（非常好）. sb is done with sth (某人的sth快做完了/sth快没了) I’m done with my work. JJ： I’m a vegan（ 严格素食主义者）, so I don’t eat meat. But I’ll join you for some more spirits. spirits (we just use the word “spirits” to refer to liquor(酒) in general, so we only use it in plural(复数) form (spirits). We can’t say “I’d like a spirit”, instead we should say specifically what kind you want, such as “I’d like a shot of vodka” or “I’d like a glass of whiskey”) XG: Do you think I could get your phone number? You seem like a really cool person. We’re always looking for more members on our basketball team. It’s open to both guys and girls. Think you’d be interested? 在国外要异性电话就是对对方有好感， 委婉一些可以提出一些借口如（You seem like a really cool person） 2016.5.9 Obsessive Compulsive Disorder （OCD）JJ： Quit biting your nails, it’s a bad habit.XG: It’s a bad habit, I’ve done it since I was a kid.JJ: Sounds like you got OCD, do you do it a lot?XG: Yeah, pretty often, do you ever tweak out about things like that? tweak out about sth = freak out about sth = worry about sth JJ: Sometimes, when I’m about to put my earbuds(塞入式耳机) in to listen to music, I always have to make sure that the R and L are in the correct ear. be about to do sth(马上要做某事) I’m about to leave. (我马上要离开) XG： Do you know what else drive me nuts? After I set the alarm at night to wake me up in the morning, I gotta check again like 5 minutes later to make sure I acturally set it. drive sb nuts/crazy/bonkers/up the wall 让某人抓狂 JJ： Year, sometimes I have to make sure over and over that I locked the door at night before I sleep. over and over (反复，一遍又一遍） XG： I can’t stand it when someone doesn’t completely clean the blackboard in school, I feel really weird in class and keep looking at. I can’t stand it (我不能忍受) JJ： I remember when I was going to school and our test grades would be out for us to look at, I would never go and see my score.XG: Sounds like we’re both a little OCD. Hey, what does OCD stand for anyway?JJ: You tell me! Why don’t you go home and do some research about it?XG: Geez, is being bossy one of your OCD habits too? (天哪，难道发号施令也是你的强迫症症状之一吗？)JJ: So, what did you find out about OCD?XG: it stands for Obsessive Compulsive Disorder, Basicly it’s when you have a lot of anxiety and you do a lot of repetitive behaviors to make the anxiety go away. (大致就是说你有很多的焦虑，并且必须通过重复某种行为才让这种焦虑消失。) JJ: What kinds of behaviors are you talking about? Did you find out about anything newXG: Yeah I did. Do you know what hoarders(囤积控) are? herder (牧人) JJ: * I think so. Aren’t they the people who have to round up a bunch(群) of sheep?* round up sth (收集 聚集 归拢 ) XG： * No, those are called herders（牧人）, I’m talking about hoarders! H-O-A-R-D-E-R-S. Hoarders! Hoarding is when you keep a lot of things and don’t throw them away, even if they are worthless or meaningless.*JJ： I don’t know, Xiao Gao… Your room is pretty messy（杂乱的）. Do you think you might …. messy (指家，办公室，头发杂乱的，小朋友吃饭弄得哪里都是也可以用 ) XG： Hey! My room is messy but it’s not that bad!JJ： Anyways, do a lot of people suffer from this disorder?XG： It’s fairly（相当） common. Actually, it’s the fourth-most diagnosed mental（心理的） disorder. One in fifty people have been diagnosed with it in the United States.JJ： Uh oh! We’re doomed! We probably have it too! You’re so dead (你死定了) We’re doomed（我们死定了） XG： Don’t worry! I think we’re okay. I also learned that just because you might have some obsessive behaviors, doesn’t mean that you have OCD.JJ： Is it treatable?XG： Yes. The good news is that this mental disorder is treatable with therapy(治疗，疗法) and medication! 2016.5.11 At The CrossroadsJJ: Hey,XG why do you look so stressed out? do you have a lot of homework or something? stressed out (抓狂)or something 放在问句的结尾类似汉语的“..吧/吗” XG： Well， it’s just it, school’s going fine this year… but I’m not sure about next year. well, it’s just it (就是这么回事)I’m not sure about sth (不确定sth) JJ： I don’t get it, you said school’s going fine now, why do you have an issue at school year? I don’t get it (我没明白) = I don’t understandYou got it (多数是回答对话指“没问题”) XG: The way things are looking now, I don’t think I’ll be able to fork up enough money for tuition next year. the way things are looking now (照目前来看)fork up money = pay a large amount of money. JJ: That’s not good, so what are you gonna do?XG: I was planning on working at a factory this summer and saving up some money and maybe take out a student loan, that way, I should be able to go to school next year. take out a [student] loan (申请助学贷款)that way (那样的话)save up (储蓄， 存储) JJ： Problem solved, right? what are you worrying about? worry about sth = tweak out about sth = freak out about sth XG: I got a job offer to work as an English teacher, I wouldn’t be able to go to school on such a low salary, but I think it would be really fun, so now I’m having second thoughts, Maybe I should take the teaching English position instead. have second thoughts (犹豫，再加思索)on second thought (经过再次思考)instead 放在句尾使用 JJ： You have to think this through carefully, On one hand the English teaching job is fun, that’s right, but on the other hand you wouldn’t be able to fulfill your long term goal of getting a bachelor’s degree, I don’t think it’s in your best interests to take the English teaching job think sth through [carefully] (充分的考虑某事)on one hand … on the other hand … （一方面… 另一方面…）fulfill your long term goal (完成/实现长远目标， fulfill 可以指完成目标、需求、愿望)in one’s best interests (对某人最好的利益， 是某人最好的选择) XG： *But I think that teaching job will help me in the future to land a better job, don’t you think it will look good on my resume, if I had some teaching experience. * land a job (获得工作)注意experience是经验的时候不可数 JJ： It might help, but I think having a bachelor’s degree on your resume will look even better. you really have to weight the pros and cons 在简历上用 on resumeweight the pros and cons (权衡利弊) XG： *But working in the factory will be so boring, I’d much rather do something that would make me happy, it’s always been one of my dreams * I would rather do sth(我宁愿做sth) JJ: Well, that’s part of growing up and being responsible. This experience will make you a better and more responsible person in the future. Trust me, a bachelor’s degree is worth much more than a temporary English teaching job. Plus, you don’t even know for sure if you’ll like teaching English. Anyways, you could always make learning English your hobby at night when you come home from work. Next semester at school, maybe you could take an English elective class. If you’re certain you really like teaching English, then next semester maybe you could tutor a child on the weekend and at the same time make some extra money? that’s part of growing up （这就是成长的一部分）A is worth much more than B (A比B更有价值/意义)elective class (选修课) mandatory class(必修课)tutor a child (指导孩子，做家教) XG： Okay, you’ve convinced me. I’m gonna do what’s best for myself and work hard to earn enough money to pay for school! Thanks so much, Jing Jing. you’ve convinced me (你说服了我) 2016.5.16 Left and Right HandednessJJ: Have you ever wondered how hard it must be for people who are left-handed(左撇子) to use a computer, the computer mouse is made for right-handed(右撇子) people. Have you ever wondered … （你有没有想过…）mouse (鼠标)， wireless mouse (hamster仓鼠， 因为没有尾巴.) XG: Year, it must be hard, my sister is lefty and she seems to do alright. lefty (左撇子， 比left-handed 更加口语化) JJ： So do people choose to be left-handed or is it something that they’re born with? something that they’re born with (他们与生俱来的，他们生来就有的) XG： The actual reasons why some people are left-handed are still a little vague（谜）, but scientists think that it has to do with people’s genetics（遗传学，基因学） and the environment they grew up in. Studies also show that about 15% of the population is left-handed. vague (谜)the environment they grew up in (注意in不能丢掉， 成长在环境中)studies/study/research show[s] 研究表明 JJ： So besides holding a pen with their left hand, are there any other differences between left-handers and right-handers?XG： Actually, yes.JJ： I heard left-handed people are kinda clumsy（笨拙的）, is that true?XG： No, it’s not. There are a lot of social stigmas（社会偏见） about left-handed people that are completely false.In reality, left-handed people tend to be more athletic（运动的）. Also, left-handed people seem to have better problem-solving skills. social stigmas (社会偏见，指根深蒂固的偏见) —— To be a nonreader carries a social stigma.bias about/against sth (对某事有偏见) bias toward/against sb (对某人.. 的偏见)outright wrong (完全没有根据的错误) JJ: Wow, I kinda wish I were left-handed nowXG: Did you know that a lot of famous people were left-handed? Like Barak Obama and Prince William of England.JJ: That’s really interesting. I’m gonna go home and see what I can learn about right-handed people now. Take care! A: see ya B: take care / A: take care B: see ya （对话中双方） XG： See ya.JJ： So, did you find out anything about right-handed people? find out sth （调查/查询到sth） XG： Well, there’s one major plus to being a right-handed person: most items in life are geared towards right-handed people. Everything from water bubblers to door handles.Other than that, there’s really no intellectual advantage to being right-handed. plus (在此处指“好处，优点”)gear toward sb (专门为sb制造的)water bubblers (饮水机) water fountain (户外饮水泉)other than that (除此之外) JJ： * So, do right-handed people use the right side of their brain and left-handed people use the left?*XG： No, it’s actually the opposite. Right-handed people are left-brain oriented and vice versa. money oriented (金钱导向的)vice versa (反之亦然) XG： Are there any people that can use both left and right hands equally well?JJ： Yes, these people are called ambidextrous（ 双手都使用得非常灵巧的）. It’s incredibly rare, but you can actually teach yourself to become ambidextrous.XG： Really? So you mean I could teach myself how to use my left hand to do things?JJ： Yes, but don’t expect it to be a cinch. You might have grey whiskers by the time you master it. a cinch = walk in a park = a piece of cakehave grey whiskers (白发苍苍，指变老的时候) XG: Cool,well,I’m gonna go practice some left-handed food eating. You coming? you coming? (你来吗) 2016.5.23 Personality TraitsXG: Ouch! I just got bit again by another skeeter(蚊子)! I think summer is just around the corner. Summer is just around the corner (夏天就要来了) JJ： Yeah, you must have sweet blood.XG： Well, all I know is that my blood type is “A”, I’m not sure if it’s sweet or not.JJ： Oh, you know your blood type eh? Did you know that there’s been a lot of research done about blood type in relation to personality?XG： No, I didn’t,can you enlighten me? enlighten me (给我讲讲，让我明白受教) JJ： As you know,there are four possible blood types that a human being can have: A, B, AB, and O. Since you’re A, let me tell you a few things about your personality.XG： Okay, give it your best shot. Let me give it a shot (让我试一试)give it your best shot (你来试试吧) JJ： Most type As are sensitive to the needs of others and are good listeners.XG： Yeah, well,doesn’t this describe everyone?JJ： * Hold on! I’m not done yet! You’re also detail-oriented, creative and inventive. On the outside, you seem really calm, but on the inside, you are filled with anxiety and worry.* on the outside (在外表看来) on the inside (在内心看来) XG： You’re lying! I think you are describing me on purpose. … on purpose (… 是故意的) JJ： I’m not kidding! The research really shows this. Also, type As are usually shy and sensitive, and a lot of them are perfectionists（完美主义者）.XG： That’s me to a T! .. to a T (表示准确极了，完全精准的描述) JJ： Romantically,type As work best with other type As and ABs. Romantically (感情上说) XG： What do type As end up doing for jobs?JJ: Common type A career choices include accountants, librarians, economists, computer programmers and writers.XG: I was once a computer programmer! Does it say anything about us being really stressed out(压力大)?I’m usually pretty tense（紧张） during the day.JJ： Yes it does,actually. Most type As often bottle up anxiety in order to get along with others. Many of them are tense, impatient, and unable to sleep well. bottle up emotions [anxiety] (把焦虑藏起来，想象瓶子装起来一个东西并且把瓶塞塞上，在感情藏在心里，不告诉别人，也不释放出来) XG： Ahh! It’s like you’re reading my mind! What blood type are you? Tell me now!! read my mind (读心) JJ： That’s for you to determine. Go home and research all the different blood types, then let’s see if you can guess it correctly!XG: Okay, Jingjing, I’ve done my research. I think I know which blood type you are.JJ: Oh yeah? Which one?XG: You’re a type B!JJ: You’re right.But how did you come to that conclusion? come to that conclusion. (怎么得出这个结论，有一个循序渐进的过程在里面) XG: Well, it said type Bs are easygoing(随和的), creative, original and flexible.JJ： Can you say something more concrete（具体的）?XG： Well, it says that type Bs are globally-oriented people. Also, it says that you learn best through listening. On top of that（并且）, it says you are goal-oriented and ambitious. on top of that (并且) JJ： It’s true, I am good at listening, that’s why I like working on the radio.XG： * It also said you aren’t a very picky person, and you don’t worry about little things too much.* a picky person (一个挑剔的人，计较的人) JJ: Yup, for example, I don’t say anything to you when you come to work dressed like a slob (没有条理，邋遢的人).XG: Hey! That wasn’t very nice.JJ: How about romance-wise? romance-wise (感情方面，感情角度)time-wise (时间方面，时间角度) XG： Type Bs do best with other type Bs and ABs. do best with others = work together well. JJ: Anything else?XG: Basically, you are thoughtful like type As and ambitious like Os. It’s a very interesting blood type. But do you know what the smoking gun was that made me convinced you were blood type B? smoking gun (让你破案的线索，确凿证据， 想象冒烟的枪，破案的线索) JJ： No, what was it?XG： Common career choices for type B, such as cooks, military leaders（军官）, talk show hosts and journalists!JJ： That’s me,indeed! Good job, Greg! So we talked about blood type As and blood type Bs, but do you remember me telling you there was also a blood type AB? do you remember sb doing sth XG: Yeah, Ido, I found them to be the most interesting of all!JJ: Me too. Not surprisingly, they have both A and B traits(特性).Sometimes they’re shy and outgoing（外向的，extroverted）, hesitant and confident.XG: Type ABs often stand out like a sore thumb among other types. They are trustworthy and like to help others. stand out like a sore thumb （杰出，突出，鹤立鸡群）trustworthy (可靠的) JJ： They also think logically and are determined to do things correctly. think logicaly/emotionally/rationally (逻辑、感性、理性) XG： Type ABs can find a soul mate with any other blood type. soul mate （灵魂伴侣） JJ： Did you know that both John F. Kennedy and Marilyn Monroe are type ABs?XG： Yeah, what a coincidence! What’s even more interesting is that only about 2%～5% of the population are blood type AB. what a coincidence (太巧了) JJ： They’re really charming（迷人的，可爱的） and popular. They don’t sweat the small stuff. sweat the small stuff (不拘小节，不纠结于小事情, 不为小事烦心) XG： So what do type ABs usually do for work?JJ： Well, some common type AB careers are bartenders（调酒师）, lawyers, teachers and sales people（销售）.XG： There’s never a dull moment in a type ABs life. If you can find one for a friend, consider yourself lucky! Well, we’ve talked about A, B, and AB. We haven’t even said a thing about type O yet. There’s never a dull moment in sth (在sth上一点也不单调) There’s never a dull moment in GFGconsider yourself lucky (你实在太幸运了) JJ： Type Os are really unique. They’re responsible, decisive（有决心的）, organized（有条理的）, and practical（务实的）.XG： That’s right. Type Os are shot callers. They often end up being bankers,politicians, gamblers（赌徒）, investment brokers（投资经纪人）, and pro athletes shot caller (法令开枪的人，指“决策人”) JJ： They tend to be loners（独行侠） or leaders and are self-reliant（自立的） and daring（勇敢的）.XG： They cope with stress better than any other blood types and don’t get sick that much. cope with sth (处理sth) （可以再也不用handle了， 欧耶） JJ： They also have a strong build （健康的体魄）and like to stay active.XG： Being hard-headed（头脑清晰冷静的） and determined to succeed helps them to reach their goals. be determined to do sth (决心要做某事)reach one’s goal (实现目标) JJ： They’re also really creative and are often the center of attention. the center of attention (关注的焦点) Children offen wanna be the center of attention. XG: That’s right, they are the social butterflies that you meet in life from time to time. social butterfly (善于交际的，没有贬义)from time to time (不时，有时） JJ： What I found most interesting is that they seem to use their five senses better than the other blood types.XG： Well, now we know a lot more about different blood types. I’m still surprised at how accurately it described me. be surprised at sth (吃惊… ) 2016.6.1 Awesome Brand New Book Is OutJW: Hey, Anya. How’s it hanging? What are you doing how’s it hanging? = what’s going on? = how you’re doing ? （最近怎么样） AY: I’m listening to Going for Gold. Normally I’d be studying the book, but I’ve already gone through the whole thing normally (一般来说)Go through the whole thing = to finish something entirely, front to back (完成某事) JW: Oh, I love Going for Gold. I can’t imagine life without it. I can’t imagine life without it (标准句型，注意使用，“不敢想象生活没有它会怎样”) AY： Me too. I bought Jing Jing and Xiao Gao’s first book last year. Also, I listen to their show using an app on my phone. I like to look at the script（文本） on WeChatJW： :I get home from work pretty late at night, but Jing Jing always hosts an evening show online for those of us who like to self-study（自学）. I’ve gotten so much out of it. I’ve learned so many native phrases(用语，短语)! I’ve gotten so much out of it (我觉得收获很大) AY: This is the best program I’ve ever listened to. It totally changed the way I study English. I wasn’t learning native stuff in the past, in fact it was mostly Chinglish（中式英语）. By following Going for Gold, not only have I learned how to express myself, but I’ve learned correct pronunciation and have gained confidence in speaking. gain confidence (获得自信) improve confidence (提升自信) JW： The first book was awesome because it came with an MP3 CD. The second book is even better because you can download the dialogues for free. I’m definitely buying the second book so I can keep learning. sth1 came with sth2 (sth1随身附带sth2) AY： :I’ve already passed the show on to several of my friends, classmates, and even family members. I really liked watching Xiao Gao’s videos that he used to post on Weibo. I hope he posts more in the future. It was a great way to learn! pass sth on to sb = to share [something] with other people (多指口头分享)post (发布东西) JW： I heard there was a way to get an autographed copy of the new book. Is that true? autographed copy of the new book (新书的签名版) AY： Yeah, we just have to follow Jing Jing’s Weibo account and forward comments about the book, then we’ll be eligible for a raffle（抽奖）. They’ll announce the winners on the weekend. be eligible for sth/doing sth (有资格做某事) JW： I heard this book is a limited edition. I’d better hurry up and buy it! limited edition (限量版)I’d better hurry up and buy it! (我得赶紧入手) AY： Yeah, what are you waiting for? Next Monday will be the first class of the new book. I’m gonna participate more in the WeChat challenges each week, because the more I practice, the better I get. This is another reason why I love this radio show so much!JW： Hey, we forgot the most important part: Going for Gold is free! We can learn so many things without paying anything. That is so awesome! so much feedback (注意用much) 2016.6.6 Bad HabitsJJ: Pee yew! What’s that awful smell? Pee yew (咿呀, 口语化的表达， 通常和 what’s that awful smell 什么味道这么难闻) XG: Don’t look at me! I took a shower today! take a shower (洗澡，指淋浴) shower 也可以当动词使用， I showered today (我今天洗澡了) JJ： No, I mean… something smells like smoke. *XG： *Oh, I recently picked up a bad habit. I started smoking a few weeks ago pick up a bad habit （养成一个坏习惯） JJ： Really? Why did you start doing that? Why did you start doing that (你是怎样开始的？ ) XG： I bummed a cigarette from my friend one day. After that, I got hooked. bum (to ask someone for something without intending to pay for it), (有一天我从我朋友那儿顺了一根烟)get hooked [on sth] ([对某事]上瘾) JJ： Well, I think you should kick the habit! kick the habit (改掉那个习惯) XG： I want to, but it’s really hard!JJ： You know what they say: Bad habits are like comfortable beds, easy to get into, hard to get out of. you know what they say [that]…(俗话说…) XG: You can say that again. So, do you have any suggestions on how to quit? you can say that again (你说的太对了，用以表示“肯定”)suggestions on … (…的建议) JJ： I heard the patch（戒烟贴片） works really well. Why don’t you give it a try and see if it helps?XG： Okay, I’ll give it a shot. Talk to you later!JJ： Hey, Xiaogao.Were you able to quit smoking yet?XG： * Yes, thank God! It was really hard, but I finally did it.* It was really hard, but I finally did it (可以常用，表示经过一番努力取得成功，很有成就感的感脚) JJ： I’m sure it was, after all, old habits die hard. So did you use the patch? old habits die hard (旧习难改) XG： No, the patch was a rip off, so I didn’t buy it. sth is a rip off (…太贵了) JJ： So how did you do it?XG： I went cold turkey. It’s the cheapest and most effective method there is. go/went code turkey (采用简单粗暴的方法, 立刻完全停止做某事，不借助任何药物的帮助，也不给自己留时间慢慢来) JJ： Wow, good for you! How do you feel now? Did you have any withdrawals? withdrawal (副作用，瘾。因为没有获得足够自己已经上瘾的物质，例如咖啡因、尼古丁、酒精等，而造成的难受的感觉)phisical suffering XG： For the first three days I had a headache,after that it was smooth sailing. smooth sailing (一帆风顺) JJ： Well, I’m glad you’ve given yourself a new lease of life. In the future, don’t bum anymore cigarettes! a new lease of life=新面貌，在经历一段艰辛后迎来的崭新生活don’t bum anymore cigarettes (以后可别再沾烟了) XG: I learned my lesson, I won’t make that mistake again! I learned my lesson.=吸取了教训。指某人犯过一次错误后，不会再犯类似的错误。I won’t make that mistake again = 我不会再犯那样的错 2016.6.13 Getting Along with Co-workersXG: Ohhh, Jingjing! I have been having the worst time at work lately! My co-workers are driving me up the wall. drive sb nuts/crazy/up the wall/bonkers/ lose sb’s nerve JJ: Well, you came to the right person. You know I’m always here to listen when you want to vent your feelings. So what’s up? Who is bothering you and why? you came to the right person (你问对人了)vent one’s feelings (吐槽，发泄情绪) XG： Well, my cube mate, Jerry, smacks gum all day. It’s so distracting（分心的） and discourteous（无礼的）! cubicle的口语化简称 cube (指办公室的工位)smack gum (嚼口香糖出声音)slurp smack （都指出声音的咀嚼东西） JJ： Have you ever thought about asking him to not chew so loudly? Or how about asking your boss if you can change cubicles? have you ever thought about sth XG: I’ve thought about that, but we’re working on the same project together, I don’t want to make him upset. Anyways, I can live with this problem, but there’s some other things at work that are making me lose my nerve too. work on sthmake sb upset （让某人心烦）live with sth (忍受sth)lose my nerve （忍无可忍，让我抓狂） JJ： Yeah? Like what? like what（什么事？）, like who（比如谁？）, like when（什么时候） XG： My other co-worker, Bob, takes all the credit for the work I do. I designed a website last week for our company, Bob only edited two pictures, but he told everyone that he did the whole thing! It’s so unfair! take all the credit for sth （抢功占为己有） JJ： Yeah, I feel you. That’s happened to me a couple times too. I suggest you tell Bob that he isn’t being a team player. You have a right to tell him how much it upset you, but be careful not to lose your temper and start screaming at him. He probably doesn’t realize what he did. I feel you (我理解你 I understand you)you have a/every/the right to do sthlose one’s temper (失态，发脾气)scream/yell at sb （大吼大叫某人） XG： You’re probably right. Wow, you sure know a lot about this kind of situation.Can you give me some more advice? can you give me some more advice? = can I pick your brains? JJ: I tell you what, it’s almost lunch time. Let’s go sit down at a restaurant and I’ll tell you some rules of thumb for dealing with difficult people at work. a rule of thumb=经验法则，为适宜的行为提供指导deal with sb （和某人相处，打交道） Jingjing and Xiaogao sit down at a restaurant and begin their conversationJJ: Alright, Xiaogao, rule number one: when you’re at work, make sure you always carry your own weight.That means you should always do what’s asked of you and try not to let other co-workers pick up the slack. carry your own weight (做好分内的事，不能要求别人为你做)pick up the slack (替别人做他们应该做但没有做的) XG: Okay, that I can do. But what about when my co-workers are in a grumpy mood? Sometimes I want to lash out at them. grumpy（mood）=脾气暴躁，生气或不友善lash out at sb （向某人发火）， yell at sb, lay into sb(痛斥某人)I am so gonna do (我特别想做) JJ: That brings me to rule number two: no matter how other people act at work, you should always maintain a professional attitude. That means you should talk to people with respect at all times. If something bothers you, you can talk to your boss or the HR department. maintain a professional attritude (保持专业的态度) XG： I have another co-worker who sits close to me, her name is Amanda. She’s always on the phone with her boyfriend talking up a storm. It’s really distracting, just like Jerry chewing his gum(没有复数形式，本身就是复数). What should I do about that? She’s a girl, is it okay to confront her about it? She’s always on the phone with her boyfriend talking up a storm,It’s really distracting (她总是和她的男朋友煲电话粥。这真的很让人分心)talk up a storm (滔滔不绝的讲)confront sb (直面某人) JJ： Of course it’s okay. Just remember to stay professional and ask nicely. She probably doesn’t realize that she’s being a chatterbox. If you ask her nicely I’m sure she’ll keep her voice down. She probably doesn’t realize that she’s being a chatterbox (她可能没有意识到自己一直在喋喋不休)keep her voice down XG: Thanks for all your advice. I have to get back to work now, wish me luck.JJ: One last thing, Xiaogao. Just remember that the most important thing at work is getting along with your co-workers. If you have a bad relationship with them, then you will start to hate your job, or maybe your coworkers will despise(鄙视) you. A happy workplace is a healthy workplace! XG： Got it. Okay, I gotta run. Talk to you later!JJ： Hey, Xiaogao! You didn’t pay the bill! Waaaaiiit! Oh… forget it! pay the bill (买单)forget it （算了吧） 2016.6.20 A Fork in a RoadXG: Hey, Jing Jing,why do you look so vexed? vexed = annoyed (心烦意乱的) JJ: I’ve come to a fork in the road, I don’t know what to do. Can you give me some advice? Come to a fork in the road = be in a position where you must make a tough decision (人生做重要决定的关口)give sb some advice/pointers/tips （给某人建议） XG： Sure, I’ll trymy best. What’s up?JJ： Well, I’ve been working as an RN at an ICU unit for the past four years, but I feel like I’ve hit a plateau. It’s the same thing over and over, the night shift is really taking a toll on me. But three years ago, a teacher got me thinking, and I started to look into nursing overseas. I began to study professional English with the hopes of one day working as a nurse abroad. RN (Registered Nurse) 注册护士ICU (Intensive Care Unit) 重症监护室hit a plateau = to be unable to make any more progress (到达瓶颈处)overcome / break out/ surmount the plateau 克服瓶颈night shift/day shift (夜班/白班)take a toll on sb = If something takes its/a toll, it causes suffering, deaths, or damageget one thinking (启发，给了某人一个灵感)look into (钻研，研究) XG： It sounds like a no-brainer.What’s holding you back? no-brainer = requiring no thought; an easy decision (不需要费脑子的决定)hold sb back = make [one] hesitate （让人犹豫不决） JJ： I took a test in Singapore from the SNB and passed with flying colors. Just as I was about to make my next move, my parents and boyfriend complained that I shouldn’t go abroad to be a nurse. They’re worried that I won’t be able to adapt to the way of life and work environment over there. And once I go to work abroad, I’ll lose my job here in China. My parents don’t have really high expectations of me, they’ve never demanded that I find a super high paying job. As long as I am near their side they’ll be happy. pass with flying colors (高分通过)have high expectations of/on sb (对某人有很高的期待) XG： Well I think that might be the problem right there. Look at what you’re saying: it will make your parents happy if you stay at the same hospital. Did they ever consider what would make you happy? If you’ve studied English so hard and are able to pass the Singapore test, why should they be worried about you not being able to adapt to life abroad? I think that might be the problem right there (我觉得这可能就是问题的所在)be adapt to env/sth (适应…) JJ: What they don’t know is, Singapore was just my first step. My ultimate goal is to go to America to work as an RN. I’m confused about that too. Should I first use Singapore as a stepping stone and work there for a bit, or should I go directly to the United States to work? ultimate goal (终极目标，最终目标)stepping stone (垫脚石，敲门砖) XG： That’s a tough call. Considering you’re only 27 years old, you’re still young and can do many things. If you wait any longer, you might miss your chance. I think going to Singapore first would be a good idea because you can prepare for what it feels like to work abroad. You might also learn important skills there that will help you when you go to the United States to work. I’m 32 years old. I’m preparing to start my second Master’s degree. I had to make this decision on my own.Taking a risk and coming to China was the best decision I ‘ve ever made in my life. tough call = a hard decisionmake a call = make a decisionyou never too old to learn sth newtake a risk (冒险) JJ： Okay, I’m starting to feel better now. But what if I can’t find a job anywhere?XG: Unless people stop becoming sick, you’ll be able to find a job as a nurse anywhere on Earth. Good luck to you! 2016.6.22 Saying GoodbyeXG: Well, Jingjing, I’m afraid I’m going to have to cut my stay short here in Beijing. cut my stay short (提前离开) We had to cut short our holiday because Richard was ill. JJ: What? You mean you’re gonna split(离开)? Why? I thought you liked it here?XG： Don’t worry, I’ll be back. I’m just going home to straighten out my visa. strainghten sth out / out sth = to solve a problem or to deal successfully with a confusing situation (解决问题) Once we get these problems straightened out, we should be all right.straighten sb out = to improve someone’s behaviour I thought that once he got a girlfriend that would straighten him out. JJ: Oh, okay, phew! Well, when are you coming back? phew (那还好，哎呀，你吓死我了，语气词，指松了一口气) XG: Probably in a month or so. But I have to leave soon. My visa expires in a couple of days so it’s a race against the clock to get back home as soon as possible. Probably in a month or so (一个月左右，注意 or so)race against the clock=分秒必争，指着急 JJ: Oh, I see. Well, when you come back hopefully you’ll have all the time in the world. It’s no fun being pressed for time. Hey, do you have anyone that will send you to the airport? have all time in the world (有大量的时间; 指不必担心或有压力)It’s no fun being pressed for time(这么紧迫实在太痛苦了)pressed for time (时间紧迫) XG: No, I was gonna take a cab there. Unless… take a cab (坐出租车) JJ： Of course I’ll take you! You know you don’t have to ask that! 注意You know you don’t have to ask that! 语气 XG： Really? You’re the greatest!JJ： I know I am! What time does your flight leave? I know I am (比较骄傲的说：我也这么认为的)What time does your flight[交通工具] leave? （你的航班几点起飞） XG： Nine in the morning, do you think you can handle that? handle (搞定，此处以为来得及吗) JJ： I’ll be at your place at 6:00 on the dot. See you then! on the dot/sharp(准时准点，只能用在整点, 如7:00 on the dot，不能说7:15 on the dot XG： I must say, Jingjing. I have to take my hat off for you, you said you’d be at my place at 6:00 sharp and you were. I really appreciate it! I got to say/ I got to tell you (老实说)take my hat for sb (脱帽致敬)I really appreciate it JJ: No problem, you know I always keep my word. Well, right now it’s only 7:00. You still have some time to kill before your plane leaves. keep my word (说话算话)you have my word (保密 不泄密) renege on our deal/go back on your words/go back on your promise 反悔have some time to kill=有空闲时间来消磨 XG: Okay, let’s go get a cup of coffee. It’s my treat. (Xiaogao saysto the coffee shop worker) Two cups of coffee please. It’s my treat (我请客) JJ: Wow! This coffee is so strong! It just about knocked my socks off! I don’t usually drink coffee this early in the morning. knock one’s socks off=（通常指口味或气味）非常浓烈。例如，一杯二锅头会“knock XG: Yeah, this is some good stuff. You know, Jingjing, I’m really gonna miss you.JJ: Now is not the time to get all emotional. Here, I brought you a going away gift. 现在还不是催泪的时候。看，我给你带了一个告别礼物 XG: A gift? Why did you do that?JJ: It’s common for Chinese to give a gift when someone is coming or going. You didn’t know?XG: * No, I didn’t. That’s so nice of you. Can I open it?*JJ: Be my guest. be my guest = of course 请便 XG: Cool! A new watch! I needed a new one!JJ: * I’m glad you like it.*(The loud speaker at the airport says Now boarding flight1423 to Detroit.) That’s my flight. I gotta bounce(颠了，离开). Thanks for everything,Jingjing. I’ll see you when I get back. 2016.6.27 Meeting Someone at The AirportM: Hey! Long time no see! Thanks so much for picking me up! pick up sb/skill/knowledge/friend JJ: No problem! Your plane was a little late coming in. You must be beat! You must be beat (你一定累了吧) I’m beat 反义 I’m wired M: I’m fine, I chugged a bunch of coffee on the plane, so now I’m wired. chug （a drink）=灌（饮料） drink a lot of sth very quicklywired=相其兴奋的 JJ: So? How was your trip? Tell me all about it.M: I had a great time. It was really nice to see my family. I just wish that I could have stayed a little longer.JJ: Well, you know what they say:all good things must come to an end. You should just be happy that you even got to go on vacation at all. I’ve been working here the past month, lucky you! you know what they say, all good things must come to an end (一切美好的事物都会有尽头，天下无不散的筵席)go on vacation M: That’s true! Oh, I almost forgot, I got a present for you while I was in America. Here you go, hope you like it! here you go 就是给你.. there you go 有点类似归还东西 JJ: Thanks… but what is it?M: It’s a voodoo doll（巫毒娃娃）.JJ： A what doll?M: A voodoo doll. I bought it in New Orleans（新奥尔良） where voodoo is heavily practiced（盛行）. This doll will bring you luck and protection. I hope it works!JJ： Cool, I love it! I hope you didn’t spend too much money on it?M: Nah, in New Orleans they’re a dime a dozen. a dime a dozen=常见而便宜的东西 JJ: Okay, that’s good. Let’s hit the road now. We should get back home before the sun goes down. hit the road (上路)sun goes down (太阳落山) M: Well, we finally made it.Thanks again for the ride, Jingjing. give me a ride (载我一程) JJ： Don’t mention it.M: By the way, can I give you some gas money?JJ: Don’t worry about it. Just take me to the airport next month when I go to see my parents and we’ll be even. we’ll be even (我们就扯平了) M: Okay, cool. Hey, why don’t you come in and drink a glass of lemonade(柠檬水) with me before you go home? It’s the least I could do for you.JJ： That sounds like it will hit the spot! It seems like this heat wave will never end! Hey, while we’re at it how about we watch a DVD too? hit the spot (正中要害，正合我意)heat wave (热浪，不能用hot， hot weather, heat wave) M: I’d love to, but I have to wake up at the crack of dawn tomorrow to go to work. crack of dawn (破晓) JJ： Really? Geez（天啊）, I never knew you were such an early bird. early bird/night owl M: Yup… Don’t you wake up early to go to work too?JJ: Not as early as you. I’m more of a night owl. I like staying up late and working on my computer. I’m more of a night owl (我其实是个夜猫子) M: Oh… Well, let’s go inside and get that ice cold glass of lemonade that’s waiting for us! dog days of summer (had nothing to do，闲着，像夏天狗热了躺在地上什么也不干) 2016.7.4 Don’t text and driveM: Ah! Jingjing! I’m in a grind! I’m in a grind/bind (我好痛苦，不方便，尴尬， 指精神情感的，不是身体上的) JJ: What’s the matter? You look like you’ve seen a ghost! （你看起来像见了鬼一样）M: Yeah, I just got in a wreck. My parents are gonna bite my head off. get in a wreck (出了车祸，基本上就是报销了，成本大于2000美元)fender bender (车祸，成本小于2000美元，可以修理)bite sb head off (yell at sb, 大喊大叫，指非常生气) JJ： Really? Are you okay? How about your car?M: I’m fine, but my car is totaled! They gave that car to me last year when I graduated college, it cost thirty grand! I don’t know what to do! totaled (“完蛋了”， 不能直接说totaled，需要结合上下文， I wrecked my car totally)grand (1000美元) JJ： Just stay calm! Accidents happen. I’m sure it wasn’t your fault. stay calm (保持冷静) M: Actually it was. I really goofed up, Jingjing. I was texting and driving. I wasn’t paying attention to the road. goofed up/messed up/screw up (出大错，搞砸了)text (可以动词使用， I’ll text you， 我会给你发信息) JJ： Mark! What’s gotten into you? That doesn’t seem like something you’d do! what’s gotten into you (你是怎么想的？ 脑袋进水了吗) M: I know. I don’t know what I was thinking. Jingjing, what am I supposed to do?! what am I supposed to do (what should I do? 但是前者更常用，表达更好一点) JJ： Look, you need to be blunt with your parents and tell them what happened. I’m sure they’ll forgive you! After all, they’re your parents. be blunt with sb (坦率的说，不顾及对方感受，有点简单粗暴，只是如实说出来) M: Okay, I’m gonna go home now and spill the beans. spill the beans (如是说，更强调实话实说，注意和be blunt with sb 的区别) JJ： So? How did it go with your parents? Are they ticked off? ticked off (生气，之前忍了几次了 这次彻底爆发了， 忍无可忍) M: No. They were more worried than anything. They were just happy I wasn’t hurt. The good news is that the insurance will cover the cost of the car. cover the cost of the car (保险公司将会赔付我汽车的损失) JJ: Wow, it sounds like they are letting you off pretty easy. What’s the catch? let sb off pretty easy(放你一马，很容易的放过你)what’s the catch (有什么条件) M: The catch is that they are making me pay the deductable(抵扣款), and they told me I’m not allowed to send text for a month.JJ： No text messages? I think I would go bananas! I love sending texts. I bet you can’t wait for this month to go by, huh? go bananas (疯掉了，但是没有伤害的，no harm) M: That’s right, next month I’ll be like a dog with two tails. Although, I swear I’ll never send another text while driving again. I’ll be like a dog with two tails (恢复自由了，指非常高兴) JJ： Look on the bright side, at least you’ll save a lot of money this month by not having to send texts. Texting can be expensive. look on the bright/down/dark side (往好处/坏处想) M: That’s true! I never thought about that. With all this left over money(省下来的钱), I think I might go buy some books that I’ve been wanting to read.JJ： See, Mark. This whole ordeal（磨难） has turned out to be a blessing in disguise. turn out to be a blessing in disguise (因祸得福) M: Hey, how come you always seem to cheer me up? Do you have magical powers or something? cheer sb up (鼓励某人，激励某人) JJ： No, I’m just awesome!（我就是天才，比较骄傲的口吻） That’s all… 英语语法定语从句定语从句相关基本概念 定语从句的定义：用作定语的从句叫定语从句 定语从句结构：先行词 + 引导词 + 定语从句 先行词：被定语从句所修饰的名词或代词 定语从句的位置：紧跟先行词（名词或代词）之后 引导词：引导定语从句的词（包括关系代词和关系副词） 关系代词：that/who/whom/which/as 关系副词：when/where/why 引导词的功能 连接先行词和定语从句。（相当于桥梁） *I like the book which I bought. * 在定语从句中充当一定的成分（关系代词充当主语或宾语，关系副词充当状语）。 *This is the man who studied with me. *（关系代词做主语） This is the man with whom I studied. * (关系代词做宾语, 将介词提前) 定语从句类型定语从句有限制性和非限制性两种。限制性定语从句是先行词不可缺少的部分，去掉它主句意思往往不明确；非限制性定语从句是先行词的附加说明，去掉了也不会影响主句的意思，它与主句之间通常用逗号分开，以下是简单例子说明： This is the house which I bought last month （限制性定语从句） The house, which I bought last month, is very nice (非限定性定语从句) (一) 限制性定语从句（主句和定语从句之间无逗号隔开） The man who you’re talking to is my friend. The man to whom you’re talking is my friend. I need a pencil with which I can write a letter I need a piece of paper on which I can write a letter The man (*who/whom/that** 都可以) I talked about at the meeting is from Peking University. * The man about whom I talked at the meeting）is from Peking University. The palace (which/that 都可以) I often pay a visit to was built in the 17th century. The palace to which I often pay a visit was built in the 17th century 总结： 介词可以放到关系代词之前也可以放在句子末尾，放在关系代词之前是很地道的书写方式，介词只能加宾语，于是只有 介词+which 和 介词+whom两种形式， who在定语从句中既可以做主语也可以做宾语，作宾语可以与whom互换，但是如果有介词，必须要用whom， 另外paper单独指论文，一页纸要用a piece of paper, 北京大学要用Peking University，BJ University指北京的大学。 (二) 非限制性定语从句 （主句和定于从句之间有逗号分隔）当当先行词是专有名词或物主代词和指示代词所修饰时，其后的定语从句通常是非限制性的 Charles Smith, who was my former teacther, retired last year My house, which I bought last month, has got a lovely garden The novel, which I have reading three times, is very touching 非限制性定语从句还能将整个主句作为先行词,对其进行修饰,这时从句谓语动词要用第三人称单数 He seems not to have grasped what I meant, which greatly upsets me 他似乎没抓住我的意思，这使我心烦 由介词+关系代词（whom/which）引导 I live in a house far away from city, in front of which is a big tree. 其中far away from city 做后置定语 There is an apple tree standing there at the gate, on which are many apples 由“代词/名词+of+whom/which”或“of which/ whom +名词/代词”(先行词指人用whom,指物用which)引导。One, some, any, none,all, both, several, many, most, neither, either等词、数词、分数或百分比与of whom或of which连用。 He has five children, two of whom are abroad. (He has five children, and two of them are abroad. 外国人不喜欢重复，所以将连词去掉并且把them换成which， 因为这里which就是指代them) We have three books, none of which is/are interesting. (We have three books, but none of them is/are interesting 道理同上) whose引导非限定性定语从句 The house, whose window faces South, is mine 注意： 关系代词that和关系副词why不能引导非限制性定语从句 引导词（关系代词）that/which/who用法详解（一） 当先行词是物时，关系代词(that/which)只用that的情况 当先行词被序数词或形容词最高级修饰时，只能用that, 当然that也可以省略This is the best film that has been shown this year.This is the first book that I borrow from the libraryHe is the first student that/who came to school today (student 是人，所以可以用who) 当先行词为两个或两个以上分别指人和物的名词时，只能用thatHe talked about the teachers and the school that he had visited. 当先行词本身是all的，只能用thatAll that(what) I want to say to you is “Thank you” (all that=what)Go over all that (what) we learned 先行词为something, anything, nothing, everything, thing时, 只能用thatI’ll tell you anything that I know. 当先行词前有all, much, little, many, (a) few, every, some, any, no, only, the very, one of, the only, the last, the next等修饰语时This is one of the books in which I’m very interested （有介词就要用which）This is the only book that I read.He is the only one of the boys that likes playing the piano. 当先行词在以who或which开头的特殊疑问句中时，用that引导以避免混淆．Who is the man that is talking with the lady?Which of you that know the answer can come to the front? 当先行词是在定语从句中作表语时，用thatHe likes the girl that sheused to be. （二）当先行词是物时，关系代词(that/which)只用which的情况 作介宾且介词置于引导词之前时．The room in which he lives is very large. 引导非限定性定语从句时（主，宾都用which,都不能省略）Football, which is a very interesting game, is played all over the world.The house, which I visited yesterday, is very large. which指整个句子的内容或部分内容，引导非限定性定语从句He always makes fun of me, which upsets me. （三）其他特殊情况 先行词是these, those指人时，关系代词只用whoThose who are playing over there are my students 先行词是人称代词(he, she…)时，关系代词只用whoHe who doesn’t reach the Great Wall is not a true man 不定代词someone, anyone,everyone, no one, somebody, anybody, everybody作先行词时，关系代词用whoAnybody who breaks the rules would be pubnished (注意是breaks，Anybody在意思上指“全部”， 语法上只做第三人称单数用) 先行词是the only one of +可数名词复数，在定语从句中作主语时，定语从句中的谓语用单数形式, 因为此时限定的是the only one 注意以下两个例句定语从句speak的形式区别He is the only one of the students who(口语)/that speaks Japanese in our classHe is one of the students who speak Japanese in our class 当先行词是the way, 在定语从句中充当方式状语时（the way表＂以…方式／方法＂），引导词通常用that或省略，也可用in which．I don’t like the way (that) you speakI don’t like the way in which you speak 关系代词或关系副词在从句中充当一个句子成分，因此要注意避免从句中句子成分的重复出现This isthe most beautiful place that I have visited it. (错误: it重复，that在这里已经做宾语 ）his isthe most beautiful place thatI have visited 定语从句中关系代词或关系副词的选择取决于它们在从句中所充当的句子成分。如作主语和宾语用关系代词；作状语，用关系副词I’ll never forget the day when I went abroad myself.我永远记得我独自在国外的日子, （这里的the day 是一个抽象的概念，指一段日子）I’ll never forget the days that we spent together.我永远不会忘记我们一起度过的那些天/日子, (这里的the days是一个具体的概念) the day (minute)等表时间的单数名词后+关系副词when （表抽象的一段时间）the days(minutes)等表时间的复数名词后+关系代词that 、which （表具体的一段时间） 定从经典组合（介词+关系代词）十大难点Note: 介词+关系代词主要看结构（一） 介词+which在定语从句中分别作时间、地点和原因状语，代替相应的关系副词when,where和why，介词+which合化 when/where/why I still remember the day on which(when) I first came to school （我仍然记得当初来学校的那一天） 理解： I came to school on the day.2. The factory in which(where) I work is a large one. (我工作的工厂是一个大工厂)理解： factory不可能做work的宾语（工作工厂）， 是在工厂工作， I work in the factory3. This is the reason for which(why) he was late (这就是他为什么迟到的原因)理解： reason不可能做late的宾语， be late for因为什么迟到 （二） 介词+which（指物）/ whom（指人）在定语从句中作地点状语，表示存在关系，定语从句主谓一般要倒置。 打南边来了一个喇嘛；背上背着一个胖娃娃 They arrived at a farm house, in front of which sat a small boy 他来到一处农舍，(农舍)前边坐着一个小男孩。 理解： a small boy sat in front of the farm house（此时a small boy是主语， sat 是谓语）, 地点状语做主语之后，主谓倒装， a small boy 做sat的宾语2. I saw a man,on the head of whom stood a bird.理解： 道理同上 a bird stood on the head of a man. 地点状语在前，主谓倒装 （三） 介词+ which（指物）/ whom（指人）在定语从句中作目的、方式或地点状语。这种结构中的介词一般受动词或介词后的名词所制约。找定语从句里的动词看它应该搭配什么介词 Could you tell me for whom you brought this coat (你能告诉我这件衣服是给谁买的吗？) 理解： buy sth for sb, for whom 在此处是目的，指给某人2. The man, from whom I learned the news, is an engineer. (这人是一位工程师，我是从他那里得到这消息的。)理解： learn sth from sb ，此处是方式 （四） 介词+which/whom，用于被动结构的定语从句中，作状语，说明动作的发出者。 被动的使用是为了更加强调动作发出者的厉害 The wolf by which the sheep was killed was shot (伤害羊的那只狼被打死了) 理解： the sheep was killed by the wolf, 上面句子中的which就是表示the wolf.2. The man by whom the wolf was shot was a good hunter. 打死狼的那人是个好猎手。理解： the wolf was shot by the man, 上面句子中的whom表示the man 倒装句英语倒装结构的六大形式详解（一） 否定副词位于句首时的倒装在正式文体中，never, seldom, rarely, little,hardly, scarcely, no sooner, no longer, nowhere 等含有否定意义的副词若位于句首，则其后要用部分倒装： I shall never forgive him -&gt; Never shall I forgive him. 我永远不会宽恕他。 He seldom goes out for dinner -&gt; Seldom does he go out for dinner. 他很少出去吃饭。 She hardly has time to listen to music -&gt; Hardly does she have time to listen to music. 她几乎没时间听音乐。 He little realizes how important this meeting is -&gt; Little doeshe realize how important this meeting is. 他不甚明白这个会议的重要性 We had no sooner reached the airport than the plane took off -&gt; No sooner had we reached the airport than the plane took off. 我们刚到机场,飞机就起飞了。 注意： in no time(立即，马上)位于句首时，其后无需用倒装语序： In no time he worked out the problem. 他马上就算出了那道题。 (二) only+状语”位于句首时的倒装当一个状语受副词only的修饰且置于句首时，其后用部分倒装语序： Only then did he realize that he was wrong. 到那时他才意识到他错了。 Only in this way are you able to do it well. 你只有用这种方法才能把它做好。 Only when he returned home did he realize what had happened. 当他回到家里时，才知道出了什么事。 (三) so+adj. / adv.”位于句首时的倒装副词so后接形容词或副词位于句首时，其后用部分倒装 The weather was so cold that we had to stay at home. -&gt; So cold was the weather that we had to stay at home. 天气太冷，我们只好呆在家里。 Light travels so fast that we can hardly imagine its speed -&gt; So fastdoes light travel that we can hardly imagine its speed. 光速很快，我们几乎没法想像它的速度。 The attack was so sudden that we had no time to escape -&gt; So suddenwas the attack that we had no time to escape. 袭击来得非常突然，我们来不及逃跑。 总结： 此类型的原句就是so…that (如此.. 以至于..) (四) so+助动词+主语”倒装当要表示前面提出的某一肯定的情况也同样适合于后者 You are young and so am I. (你年轻，我也年轻) 注意： 不能省略and, so am I 是一个句子，需要连接She likes music and so do I. (她喜欢音乐，我也喜欢）If he can do it,so can I. (要是他能做此事，我也能) 注意“逗号”的使用， 条件从句若前面提出某一否定的情况，要表示后者也属于同样的否定情况，则应将其中的so改为neither或norYou aren’t young and neither am I. (你不年轻，我也不年轻)She hasn’t read it and nor have I. (她没有读它，我也没有读)注意该结构与表示强调或同意的“so+主语+特殊动词”结构的区别, 此种情况不需要倒装A: “It was cold yesterday.(昨天很冷)” B: “So it was. (的确很冷)”A: “Father, you promised.(爸爸，你答应过的)” B: “Well,so I did. （嗯，是答应过）”注意： so + adj/adv 基本可以互换such a/an + adj + n, such开头的也要倒装，但是互换有时会改变表达情感 （五） 由not only…but also引出的倒装当not only…but also位于句首引出句子时，not only 后的句子通常用部分倒装形式， but also 后面正常语序 Not only is he a teacher, but also he is a poet. (他不仅是一位教师，而且是一位诗人)Not only did he speak more correctly, but also he spoke more easily. (不仅他讲得更正确，也讲得更不费劲了) 注意： not only .. but also 中but also不一定非要连在一起，也可以只留but或只留also ： Not only is he a teacher, but he is also a poet (这样写更舒服地道) (六) 虚拟条件句的省略与倒装当if引导的虚拟条件从句中含有had, were, should等时，如将if省略，则要将had, were, should等移到主语前，构成倒装句 If you had come yesterday, you would have seen him. -&gt; Had you come yesterday, you would have seen him.If you should require anything give me a ring. -&gt; Should you require anything give me a ring.If it were not for your help,I would still be homeless. -&gt; Were it not for your help, I would still be homeless. (要不是你帮助，我会仍然无家可归)省略if后提前的had不一定是助动词If I had money, I would buy it. -&gt; Had I money, I would buy it. (此处的had是实意动词) （七） As 引导的让步状语从句倒装as作“虽然”解，引导让步状语从句时，必须将表语、状语或动词原形提到as前面。此时应注意几点： 若提前的表语是没有形容词修饰的单数可数名词，要省略不定冠词； 若提前的是动词原形(多为不及物动词)，与之连用的通常是may, might, will, would等，且这些词都要保留在原来的位置上(主语后)； though有时也可像as这样使作倒装， although绝对不能倒装** Tired（形容词） as I was, I tried to help them. 虽然我很累，我还是努力帮助他们。 =Although I was tired, I tried to help them.Try（动词） as he would, he couldn’t open the door. 他试过多次了, 却仍打不开那门。 =Although he would try, he couldn’t open the door.Search(动词） as they would, they would find nobody in the house. 无论怎样搜查，他们在房子里仍然没有找到一个人。 =Although they would search, they would find nobody in the house.Hard(副词） as (though) they tried, they couldn’t make her change her mind. 尽管他们做了很大努力，却没法让她改变主意。 =Although they tried hard, they couldn’t make her change her mind.Boy(名词无冠词） as he was, he behaved like a girl. 他虽是个男孩，但举止却像个女孩。 =Although he was a boy, he behaved like a girl. 状语从句状语主要是用来修饰动词和形容词的，以表明动作发生或状态存在的时间、地点、原因、目的、结果等。状语从句即指在主从复合句中用作状语的从句。状语从句主要用来修饰主句或主句的谓语（一） 时间状语从句时间状语从句用表示时间的连词连接一个句子作状语，这样的主从复合句就是时间状语从句, 常用引导词：when, as, while, as soon as, before, after, since , till, until 由when,while, as引导的时间状语从句的区别用法 when引导的从句的谓语动词可以是延续性的动词，又可以是瞬时动词, 并且when有时表示“就在那时”When she came in, I stopped eating.她进来时，我在吃饭。(瞬时动词) [came in 此时是瞬间动词， 她进来我有注意到她，吃饭停了一下]When I lived in the countryside, I used to carry some water for him.当我的住在农村时，我常常为他担水。（延续性的动词） [live in 是延续性动词，一直在住着]We were about to leave when he came in.我们就要离开，就在那时他进来了。（就在那时） 总结： when 引导的从句有激活主句的感觉，从句的内容要平行并列主句. While引导的从句的谓语动作必须是延续性的，并强调主句和从句的动作同时发生（或者相对应）。并且while有时还可以表示对比My wife was reading the newspaper, while I was watching TV. 我妻子在看报纸，我在看电视。(was reading是延续性的动词，并且was reading和was watching同时发生)I like playing football while you like playing basketball.我喜欢踢足球，而你喜欢打篮球。 (此处表示对比) 总结： while后面始终要加延续性动词 As表示“一边……一边”，as引导的动作是延续性的动作，一般用于主句和从句动作同时发生；as也可以强调“一先一后。We always sing as we walk.我们总是边走边唱。（as表示“一边……一边”） [这里强调我们持续这样很长时间，像是一辈子的习惯]As we was going out, it began to snow. 当我们出门时，开始下雪了。（as强调句中两个动作紧接着先后发生，而不强调开始下雪的特定时间） 总结： as表示的持续性甚至是一种习惯 Note: 主从复合句，要强调的东西在前面写，这也是英文的的使用习惯，强调的东西始终放在第一位 . 由before和after引导的时间状语从句的区别用法 before引导的从句不再用否定式的谓语，并且当before引导的从句位于主句之后，有时译成“就，才”或“ 还没来得及… 就”。还要注意主句和从句之间的时间关系。当主句用将来时，从句总是用现在时；如果before引导的从句谓语用的是过去时，则主句动词多用过去完成时，这样以便体现动作发生的先后It will be four days before they come back. （主将从现，一一对应） (他们要过四天才能回来)Einstein almost knocked me down before he saw me. （几乎同时发生） (爱因斯坦几乎把我撞倒才看到我)My father had left for Canada just before the letter arrived. （主过完从过） (我父亲恰好在信到之前去加拿大了) leave for smw (离开去某地)They had not been married four months before they were divorced. (他们结婚还不到四个月就离婚了) after表示主句动作发生在从句动作之后。主句和从句的动作的时间关系正好与before引导的从句相反After you think it over, please let me know what you decide. (你仔细考虑过以后，告诉我你是怎样决定的)After we had finished the work, we went home. (完成工作之后，我们回家了) （从句用过去完成时，主句用一般过去时） till或until引导的时间状语从句的区别 till和until一般情况下两者可以互换，但是在强调句型中多用until,但是注意注意注意：①如果主句中的谓语动词是瞬时动词时，必须用否定形式；②如果主句中的谓语动词是延续性动词时，用肯定或否定形式都可以，但表达的意思不同。③till不可以用在句首，而until可以放在句首。I didn’t go to bed until（till）my father came back. (直到我父亲回来我才上床睡觉。)It was not until the meeting was over that he began to teach me English. (直到散会之后他才开始教我英语)I worked until he came back.我工作到他回来为止。（前肯意为否）I didn’t work until he came back.他回来我这才开始工作。（前否意为肯）Please wait until I arrived.在我到达之前请等我。 since引导的时间状语从句的用法 since引导的从句的谓语动词可以是延续性的动词，又可以是瞬时动词。一般情况下，从句谓语动词用一般过去时，而主句的谓语动词用现在完成时。但在It is ＋时间＋since从句的句型中，主句多用一般现在时I have been in Beijing since you left. （主现完从过去） (自从你离开以来，我一直在北京了)Where have you been since I last saw you? （主现完从过去） (自上次我和你见面以后，你到哪里去了？)It is four years since my sister lived in Beijing. (我妹妹不在北京住有四年了)（今日重点句型，表示相反意思） 在时间状语从句中 当主句是一般将来时或祈使句表示将来的意义时，时间状语从句用一般现在时I’ll let him know as soon as she comes.（主将从现） (她一来，我就会让你知道) （二） 原因状语从句用表示原因的连词连接一个句子作状语，这样的主从复合句就是原因状语从句，原因状语从句通常由because, since, as,for 引导 项目 位置 内涵 语气 能否回答why because(因为) 主句前或者后，通常放在后面为好 直接因果关系，或一些不太想说的原因 强 能 as(由于) 主句前或者后 双方都知道的原因 弱 不能 since/now that (既然) 主语前 双方都知道原因 弱 不能 for (因为) 句中，通常由逗号隔开 补充说明原因或推断的依据 弱 不能 because表示直接原因，语气最强。Because引导的原因状语从句多放在主句之后。回答由why提出的问题，只能用because。I was absent from the meeting because I was ill. as和since语气较弱，一般用来表示明显的原因,即众所周知或当事人都知道，由as和since引导的原因状语从句多放在句首As it is raining, we will not go to the park. (PS:下雨就在眼前，都知道)Now that/ Since everybody is here, let’s begin our meeting. for有时也可引出表示原因的分句，但它只能位于后面，对前一分句加以解释或推断It must have rained last night, for the ground is wet． (三) 目的状语从句*用表示目的的连词连接一个句子作状语，这样的主从复合句就是目的状语从句，目的状语从句通常由so that, in order to , in case, for fear * I hired a boat so that I could go fishing. (我租了一条船去钓鱼) Take your raincoat in case it rains (should rain). (带上雨衣以防下雨) He studied hard in order that he could pass the exam. (他努力学习是为了能通过考试) 注意： in case 和 for fear 的区别： in case 指“假如某种情况出现,我们要……” 同时发生的可能性非常大不可避免,for fear指“我们要……以免某种情况出现”,前者强调主语的能动性 He worked hard for fear that he might be fired by the boss (他拼命地干活惟恐被老板解雇) He walked fast for fear that he should be late. (他快走,以免迟到) 注意： so that既可引导目的状语从句，又可引导结果状语从句。区别这两种从句的办法有两个 目的状语从句里往往带有情态动词can, could, may, might等,从意思上看，目的状语从句往往表示的目的很明确Speak clearly so that they may understand you. (目的状语从句)Jack is badly ill so that he has to rest. (结果状语从句) （四） 条件状语从句用表示条件的连词连接一个句子作状语，这样的主从复合句就是条件状语从句，引导条件状语从句的从属连词主要有if, unless，as long as, 激活条件 Don’t come unless I telephone (除非我打电话，否则你别来) If you watch carefully you will **see how to do it (如果你仔细看，你会看出该怎样做) I’ll help you with your English if I am free tomorrow (如果我明天有空，我就帮你辅导英语) He won’t be late unless he is ill (除非他病了，否则他不会迟到) 注意： 祈使句连词要在中间 在条件状语从句里，谓语动词通常用现在时态表示将来的动作或状态（主将从现），但是条件是不可能发生或实现的就是虚拟语气了，“If I were you ” （五） 结果状语从句引导结果状语从句的从属连词主要有so that, so…that，such…that等 在由so…that引导的结果状语从句中，so是副词，与形容词连用。其结构是: “…so + 形容词（副词）+ that + 从句 The hall is so big that it can hold 2,000 people (这个大厅大得能容纳2000人) Mother lives so far away that we hardly ever see her (妈妈住得太远了我们都无法常见面) He shut the window with such force that the glass broke (他关窗子用力太大，玻璃都震破了) 在由such…that引导的结果状语从句中，such是形容词，它修饰的可以是单数或复数可数名词，也可以是不可数名词；名词前面可以带形容词，也可不带。如果是单数可数名词，前面需加不定冠词a或an It was such a hot day that nobody wanted to do anything (天太热了，没人愿意干活) He made such rapid progress that he did very well in the mid-term. (他进步很快，期中表现非常好) 如果名词前由many, much, little, few等词修饰时，只能用so, 不用such, 即“多多少少只能用so” Soon there were so many deer(单复数一样) that they ate up all the wild roses (很快就聚集了许多鹿，啃光了所有的野玫瑰) He has so little time that he can’t go to the cinema with you (他几乎没时间跟你们去电影院) so…that…句型的否定形式可用简单句too…to…或not…enough to代替 He is so young that he can’t go to school = He is too young to go to school 当so/such…that结构中的so或such放在句首时，主句用倒装语序 So proud was he that he never listened to any advice (他太骄傲了以致于从来听不进任何建议) (六) 让步状语从句 项目 位置 注意事项 though 句首,或句末 放在句末，做副词，意为“可是，不过” ,不可与but连用，可与yet,still连用 even though 通常放在句中链接主从句 even if 通常放在句中链接主从句 although 句首或句中 在句首需要有逗号，在句中不需要逗号，不可与but连用，可与yet,still连用 引导让步状语从句的从属连词主要有although, though, even though，even if（即使） Though we are poor, we are still happy. 我们虽然穷，但是很快活。 He went out even though it was raining. 尽管下着雨，他还是出去了。 It’s hard work, I enjoy it though. 工作很辛苦，可我乐意干 The speech is good, it could be better though. 这次演讲不错，虽然还可以再好一点 Although Princeton has a world famous university, it is still a small quiet town. 普林斯顿虽然有一所闻名世界的大学，但仍然是个安静的小镇。 He often helps me with my English although he is pretty busy. 尽管他相当忙，但还是常常帮助我学英语。 Although the book was old , we decided to buy it . 尽管这本书很旧，我们还是决定买。 Though she was busy with her work, yet she managed to find time to stay with her family 虽然她忙于工作,但她还是挤出时间与家人在一起. She was busy with her work ,and yet she managed to find time to stay with her family (这里是副词and yet ==but ) She was busy with her work , yet she managed to find time to stay with her family （这里是连接词,解释为：虽然,但是=but ） 连词while有时也可表示“尽管”、“虽然”，引导让步状语从句 While we don’t agree with each other, we continue to be friends. 尽管我们意见不同，我们还是朋友 whatever, whoever, however, whenever, wherever等引导让步状语从句, 歌词中多见 Don’t lose heart whatever you do. 不管你做什么，都不要灰心。 Whoever you are, you can’t pass this way. 不管你是谁，你都不能从这里通过 as也可引导让步状语从句，但要将名词、形容词或副词等提到as前，若提前的是单数可数名词，要省略a或an，引导让步状语从句 Teacher as he is, he can’t know everything. 虽然是老师，他也不可能什么都懂。 Though引导的让步状语从句可用部分倒装，倒装后位于句首的名词之前不用冠词a或an Poor though I am ,I can afford it. 我虽穷，但这东西还是买得起的。 习语 as though (好像，仿佛)，even though (即使，纵然)， 有一种虚拟在里面, 不确定是否是某种情况 She closed her eyes as though she were tired. 她闭上眼，仿佛很疲劳似的。He is an honest man, I must say, even though I has opposed him. 尽管我反对他，我还得说他是个诚实的人。 (七) 地点状语从句注意区分where引导的定语从句与状语从句 You’d better make a mark where you have any questions. (状语从句)你最好在有疑问的地方做个记号。 You’d better make a mark at the place where you have any questions. (定语从句) 你最好在有疑问的地方做个记号。 Where引导状语从句—副词性从句 当Where引导状语从句时，Where前没有表示地点的先行词，Where是从属连词，Where引导的从句修饰主句的谓语动词 The famous scientist grew up where he was born and in 1930 he came to Shanghai. (这位知名的科学家就在出生地成长，1930年来到上海。)评析：句中“the famous scientist grew up “这一部分是该句的主句，Where到句子最后是地点状语从句，where前没有表示地点的先行词. She found her passport where she lost it . (她在她丢护照的地方找到了护照。)评析：”passport”是主句 found 后的宾语，它并不是从句中lost的地点，因此 where 引导的是地点状语从句，从属连词where引导的从句修饰主句的谓语动词 found 。 Where引导定语从句—形容词性从句 当where 引导定语从句时，Where前有表示地点的先行词，where 引导的从句修饰先行词，Where是关系副词，在从句中作地点状语 He’s got himself into a dangerous situation where is likely to lose control over the plane . (他在飞机上失去控制，处于极其危险的境地。)评析：situation 是先行词，其后是Where引导的定语从句。 This is the place where Luxun once lived . (这是鲁迅曾经生活过的地方。)评析： the place 是先行词，其后是 where引导的定语从句 ，where 在从句中作地点状语。 在有些情况下,where引导的定语从句可转换为where引导的地点状语从句. A tall building was put up at the place where there used to be a desert.＝A tall building was put up where there used to be a desert. (在以前曾是沙漠的地方盖起了一幢高楼.) where引导宾语从句、表语从句、主语从句———名词性从句 This is where Luxun once lived. 这是鲁迅曾经住的地方(where 引导表语从句) I don’t know where Luxun once lived .我不清楚鲁迅曾经住在哪里。(where 引导宾语从句) She was free to go to where she liked . 她可以去任何她喜欢的地方。(where 引导宾语从句) Where Mary was born is Beijing . 玛利出身的地方是北京。(where 引导主语从句) 学后感 先行词是地点类的名词 place situation case， 后面的where引导定语从句 where 出现在什么地方就是充当什么成分 主句动词后面除了宾语和表语，剩下的就是状语 状语用来修饰的是主句的动词 课后习题 有志者事竟成。 Where there is a will, there is a way. 书在你原来放的地方。 The book is where you left it. 她回到了她刚才坐的地方。 She is back to where she sat just now. 请呆在原处。 Please stay where you are. 这就是他曾工作过的农场。 This is the farm where he once worked. （八） 比较状语从句常见的引导词有： as…as,not so (as)…as, than, the more…the more等 the more + 主谓， the more + 名词 + 主谓 The harder you work, the more progress you will make. 你越努力，取得的进步就越大。 The more you study, the more knowledge you can get. 你学的知识越多，你的知识越丰富。 not so/as … as 之间只能是形容词原级，不可以是比较级和最高级 The work is not so difficult as you imagine. 这工作不像你想像的那么困难。 He doesn’t work as hard as she (does). 他工作不像她那样努力。 表示倍数的三种句型 倍数＋as many +可数名词复数+as 倍数+as much+不可数名词+as 倍数+as+形容词原级+名词+as I have twice as many books as you do. 我拥有的书是你的两倍。 It is reported that the United States uses twice as much energy as the whole of Europe. 据报道美国人使用的能源是整个欧洲的两倍。 I can rent three times as big a room as yours in my city using that money. 用那些钱我能在我们的城市租一个三倍大的房间。 注意： adj + a/an + 名词 （九） 方式状语从句常见的引导词有：as ,as if ，as though ** as if 从句用陈述语气的情况,当说话者认为句子所述的是真实的或极有可能发生或存在的事实时 ** It sounds as if it is raining．听起来像是在下雨。 He talks as if he is drunk．从他谈话的样子来看他是醉了。 as if 从句用虚拟语气的情况,当说话人认为句子所述的是不真实的或极少有可能发生或存在的情况时。从句虚拟语气动词时态的形式如下 如果从句表示与现在事实相反，谓语动词用一般过去时 You look as if you didn’t care． 你看上去好像并不在乎。 He talks as if he knew where she was． 他说话的样子，好像他知道她在哪里似的。 从句表示与过去事实相反，谓语动词用“had＋过去分词” He talks about Rome as if he had been there before． 他说起罗马来好像他以前去过罗马似的。 The girllistened as if she had been turned to stone． 那女孩倾听着，一动也不动，像已经变成了石头似的。 从句表示与将来事实相反，谓语动词用“would／could／might＋动词原形” He opened his mouth as if he would say something． 他张开嘴好像要说什么。 It looks as if it might snow．看来好像要下雪了。 注意： as if /though引导的从句常用虚拟语气，表示非真实情况，但如果从句中陈述的情况很可能实现，也可用陈述语气 （十） 状语从句的省略当时间、条件、让步、方式和比较状语从句的主语与主句一致或为it 或 there且谓语动词含be动词时，从句中的主语和谓语可以一起省去 Don’t speak until spoken to.( 省略了you are) 你不要讲话，除非让你讲话。 I have no money. If any, I will lend yousome. 我手里没有钱，有的话，我会借给你的。( 省略了there is) Though cold, he still wore a shirt. 尽管很冷，他却只穿一件短袖。 ( 省略了it was) 强调句（一） 区分强调句与其他类型从句（主、定、状） 强调句与主语从句的区别 It is true that he is honest. (主语从句) 他真的很诚实。 True he is honest (去掉It is … that 之后不成句子，所以是主语从句，强调句去掉仍然成句子如： It is Mr Fu that is honest) It is known to all that China is a country with a long history. (主语从句) 众所周知，中国是一个历史悠久的国家。It was here that he fell off his bicycle.(强调句) 这正是他从自行车上摔下来的地方。 总结： “It is / was + 形容词 / 分词 / + that从句”是主语从句，它译成中文时不可加上“正是……”“就是……”之类字眼， 含有定语从句的强调句型 (在被强调的名词后再设计一个以该名词为先行词的定语从句，这时不要把定语从句当作强调句)。 It was this school where (in which) he once studied that gave him a chance of teaching.正是这所他曾经学习过的学校给了他教学的机会。 总结： 这种句子先写主干： It was this school…. that gave him a chance of teaching 强调句型与状语从句的区别 It was at 7:00 that I arrived.(强调句型，强调时间状语at 7:00)正是在7:00时， 我到了。 It was 7:00 when I arrived.(时间状语从句，在7:00前无介词at) 当我到达时， 时间是7:00。 It was two years ago that I began to learn drawing.(强调句型，前后时态一致) 正是在两年前我开始学习绘画。 It is(has been) two years since I began to learn drawing.(since引导的时间状语从句，前后时态不一致) 自从我学习绘画以来已经有两年了。 It was two years before they came to see us.(时间状语从句) 过了两年后他们才来看我们。 It was two years later that they came to see us.(强调句型) 正是两年后他们才来看我们的。 It won’t be long before we graduate from the school. (时间状语从句) 不久我就将毕业了。 It will be two years before we graduate from this university. (时间状语从句) 再过两年我们就将大学毕业了。 总结： 可以看先行词，如果是引导时间的词since before after 就是时间状语从句， that是强调句 （二） 强调三关 常用句式 sb1 cut sb1 off sb1截断了sb2的来源（多只经济来源） My daddy cut me off 我老爸断了我的经济来源sth cut sb off (sth断了)Machine cut me off (电话断了) sb is dumb blonde that has no common sense 某人是没有常识的金发女郎（世界观及价值观与常人不同） I knew it was stupid and I shouldn’t have done it 我知道这事情很蠢我也不该这么做 shouldn’t have done, 本来不该做的事情做了，同理，should have done,本该做的事情没做，口语中使用频率很高.You shouldn’t have said that. sb is at rock bottom 某人在很惨/低谷的时候 I think it is the best thing that could’ve ever happened to you get out on one’s way 自力更生 We should get out on our way. How does he expect me to do sth 责备的语气，怎么可以这样？太过分了 How does my boss expect me to work overtime tune (曲调，调整，使一致) tune in(收听) America tuned in to watch six very attractive singles navigate relationships and life in New York Citystay tuned (不要换台，不要走开， DJ常用语) clip 小段音频或视频， next clip， clip section 2 wind(wound) up doing == end up doing 最终.. Right in the very beginning 就在一开始 *we really just fell in love and adored（倾慕） each other instantly * sitcom = situation comedy （情景喜剧） Who have the best chemistry of the group? chemistry: 化学反应，相互吸引，并非配合的默契 take sb under one’s … he graciously took me under his wings. be filthy rich filthy /‘fɪlθi/ 肮脏的，污秽的，猥亵的， 是指有铜臭的那种感觉 Tom is filthy rich. I don’t want to go into sth 我不想详细的解释/讲这件事， 因为懒/麻烦不愿意说 It won’t work out …行不通 have words 达成一致 His mind is blown/ sb blew his mind 脑袋爆炸，指信息量很大，一时接受不了 But not yet …还没怎样，但是要快了 I expect(预测)/look forward to(期盼) it will rain today What if I … 如果我…. 通常接过去时/过去完成时 What if I was still fat （过去时）What if I had had the guts(勇气) to quit my job （过去完成时）What if…? 主要有三种用法，此处表示假设，意思是“要是……将会怎么样”。此外，它还可以表示邀请或建议，意思是“如果……如何？”What if…? 还可以表示某事不重要，常常与so连用，意为“就算……那又怎样？What if you join us for lunch? 同我们一起吃晚饭怎么样 （表示邀请/建议）So what if we’re a little late? 就算我们迟到一小会又怎样 （表示某事不重要） golden years 黄金年代 prime time 黄金时间 That’s for sure 那毋庸置疑， 可以在自己说的句子末尾加上这句话， 也可以在别人说过话之后说这句话表示肯定和认可 Don’t dwell (不要沉溺于过去) dwell /dwɛl/ (vi. 居住；存在于；细想某事)move on / look forward 是其反义词 表示向前看 casual Friday 通常所说的happy Friday, 指工作族不用在星期五穿西装打领带那么不自由 only if/if only only if 的only 是重点，”只有如果(当…)”,if only 的if是重点”如果…就好了(既然假设就虚拟)” You guys really think that I’m that shallow (你们真的那么认为我那么肤浅/浅薄吗？) wear a tie (戴领带) sb have a knack for sth 某人有… 天分 knack /næk/ n. 诀窍；本领；熟练技术；巧妙手法 I have a knack for stocks 我有炒股票的天分/潜质 quit my job 放弃我的工作，表示辞职 I have to admit, *the horoscope stuff really caught my attention. 我不得不承认，星座运势这东西引起了我的兴趣 Virgos have a strong attention to detail, they are known to take good care of people 处女座及其关注细节，他们是公认的擅长照顾别人 Do you have some studying(homework) to do? Do you not wanna be seen with me? 和 Don’t you wanna be seen with me? (两者表达的意思不一样， 前者在当时的对话情景猜测到对方的意思) I’m about to leave (我马上要离开， 指下一秒将要做某事) *you may frown upon that. * （你可能心里头不舒服，表示表情上，内心里（暗暗）不满，不同意， 而disapprove,disagree 表示言语上的不同意） You are so fired. ！ 你铁定被解雇了 有点你会被解雇的很惨的意思 you are so dead 你死定了 what are you [doing] 句型扩展 what are you trying to say. (你想说什么)情景应用： A: 说了半天也说不明白，或者在纠结该不该说 B: what are you trying to say? 你现在正在尝试要说什么？ what do you want to say? (你想说什么)情景应用： A: 跑到B面前说“Can I talk to you?” B: what do you want to say? 你想要说什么？ what are you doing saying this （你说这个干什么，带有责备语气）情景应用： 一般情况下，句型 what are you doing [doing] 带有责备的情感在里面 what are you doing talking to her about that? 你和她谈论那个干什么？ Please bear in mind 请记住 Please bear in mind that I love you forever. Twist the knife 往伤口上撒盐，揭伤疤 They’re all twisting the knife. Split the cost 分摊成本，类似于中国的AA制 you can’t be too careful in your work A：你出门还带刀自我保护，太夸张了吧 B：You can’t be too careful.（现在世道这么乱，再怎么小心也不为过, 小心使得万年船） Do you mind if we switch places？ （becasue I get off next 可说可不说） 类似于在电梯中请求互换位置 mean to do sth 有意做某事 故意做某事 // run into sb 不小心撞到别人，偶遇别人=bump into Oops, I did not mean to run into you like that, sir 哎呀！我没成想要这么碰到你的，对不起，先生。 school night/work night school night 明早还要上学work night 明天要上班以上两种句型的理解：上班(上学)期间，不是放假期间，晚上不要玩疯，要做准备，为了第二天工作、学习 Is it a school night and she has a lot of homework to do? Bring ’em on 放马过来 还想说什么就说吧 girl/boy scouts 美国12岁以下孩子的一个real life的锻炼活动， 猜测类似夏令营， 为了筹办活动买girl/boy scouts cookies Tell sb good luck with sth. 表示“祝某人在某事上有好运”，口语中经常使用。 A: Tom will have an exam tomorrow. 汤姆明天有个考试。 B: Tell him good luck with that. 帮我祝他好运。 I can let it go for eight. (结合上下文是8000元成交的意思， 其中let it go， 可以想象养了好久的宠物要走了，舍不得，此处理解为“勉强成交，非常不情愿的让价”) We stand firm at $10 (我们坚决付十块， stand firm at … 坚定..立场) I’m over it (不在乎，无所谓了) hold out sth （伸出手里的东西，直直的拿着…） Engagement ring 结婚戒指 poker face （ 一本正经的面容, 面无表情的人） a man-to-man talk (一对一的，坦率的,直言不讳的; 畅所欲言的) count on sb (依赖/指望某人) Don’t count on me (别指望我)You can count on us (你可以指望/依赖我们) toe the line (脚靠着线，不要越界，循规蹈矩，遵守规则) thread the needle (有balance的意思 也有讽刺这个东西很难， “线穿针眼”) it’s like thread the needle. (这个东西很难) think outside the box (创新思维，摆脱思维定式) I have bigger fish to fry (有更大、重要的事情要处理) 通常会说 I have bigger fish *sb is heartless * ( 某人无情无义) she/he gets on one knee （单膝跪地求婚） take a knee (教练：围起来听教练讲话) We’re engaged 我们订婚了 engagement ring 订婚戒指 We’re dying out here! ( 我们等得快急死了！) be likely to do sth. (表示“很有可能做某事”，强调可能性) It is likely to rain. 好像快要下雨了。be unlikely to (不大可能，不再发生)These tactics are unlikely to be helpful to you (这种方法对你未必有用)He is very ill and unlikely to recover (他病得很重，不大可能恢复健康了) lose one’s temper （失态） the box that it came in （包装的箱子） shake hand (握手) Parents shouldn’t play favorites （父母不应偏心） I’m the favorite (我是父母喜欢的那一个) I’m kind/sort of （kina）tired （我有点累，比I’m a little bit tired更地道） clever/smart/resourceful/competent 在美国clever带有“小聪明”的意思，也有指动物的聪明， 在英国clever可以指人的聪明， 所以夸人聪明还是用smart比较合适resourceful 形容人比较足智多谋，资源分丰富competent/incompetent 有能力的和没有能力的 形容人 *get the hell out of here * （滚出去 也有强调的意思， 要读的快和地道才有感觉） check clear/bounce (形容支票是可以支出钱或不能支出钱) I can’t wait to see everything again! （ 我都等不及要再次看到它们了！） can’t wait to do sth.表示“迫不及待要做某事”，口语中的使用频率很高。 can’t/couldn’t help doing sth. (情不自禁做某事) I can’t help laughing. (我忍不住大笑) hit 常用短语总结： hit on sb (撩妹，泡妞) —— Cindy never realizes when boys are hitting on her(Cindy 总是浑然不知有男生在追她) hit on sth (灵机一动想到sth) —— He hit on an idea that would be a perfect surprise (他灵机一动，想到了完美的生日趴体惊喜) hit smw (上路去哪) —— Let’s hit the road after staying here for a night (我们在这呆一晚就上路吧) hit the sack/hay (就寝、睡觉) —— Tina was so tired that she hit the sack soon after long hours works （Tina 实在是太累了，长时间工作以后早早睡觉去了） hit the nail[指甲、钉子] (说话中肯，一针见血) —— He always hit the nail on the head so all people found him extremly reliable （他说话总是一针见血，所有人都觉得他很靠谱） hit the jackpot (中头彩) —— Jocelin is the perfect girl for me, I’ve hit the jackpot in life being with her (Jocelin是我的真命天女，能和她在一起真是我这辈子最大的福分) hit it off well (一拍即合) —— We all thought the two of you would hit it off well （我们大家都认为你们会相处愉快） hit the bottle (酗酒) —— He started to hit the bottle to relieve stress. (他开始用酗酒来释放压力) hit the light (开灯) —— Would you please hit the light for me? （请问你可以帮我开一下灯么？） hit the big (做到，成功) —— We hit the big (我们成功了) hit the book (啃书，用工读书) —— I got an exam tomorrow. so I got to hit the books tonight. （我明天有个考试，今晚我要念书呢） hit the roof (暴跳如雷，大怒) —— My parents would hit the roof if he knew that I wrecked his car （如果我爸发现我毁了他的车，一定会暴跳如雷的） hit me (场景： 对酒吧调酒师说hit me, 指再来一杯) *ground rules = basic rule * (基本规则) Are there ground rules (有什么基本的规则吗？ 如在玩游戏前做好规则) I’m just saying (A: you’re so handsome, I’m just saying. 为了避免尴尬的局面，可以说I’m just saying.) He really told her off (他臭骂了她一顿) shave a head (理发) *on top of * (并且 另外) *reduce anxiety * (减少、降低焦虑，注意动词的使用) fixate on sth (提起sth) Why does everyone keep fixating on that? (为什么大家都绕着这个话题打转？ ) *of course it was a line * (显然这是骗你的) live off (以…为食料；靠…生活；住在…之外) You can’t live off your parents all the time (你不能一直靠你父母生活) 是（is）, 有（there be）, 时（when） (万能转换) loudly 和 loud 的区别 loudly 有吵闹的声音大的感觉speak loud and clear 为某人支付费用 cover for you (暂时帮你付，回头你需要归还) I forgot my wallet, can you cover me? (我忘记带钱包了，能先临时帮我付一下吗？)pay for you (帮你付，不需要你还) She gives him a withering look （她用一个绝望或失望的眼神看了他一眼） You had one job (就让你干了一件事还干不好的意思) *beyond one’s grasp, beyond one’s capatibility , out of reach, out of control 区别 * beyond one’s grasp (鞭长莫及，有能力，但是远水解不了近渴的感觉) I can’t help him because it’s beyond my graspbeyond one’s capatibility (超出某人的能力范围) The work is difficult and beyond my capatibility (工作太难超出了我的能力范围，也可以直接说 it’s beyond me)out of reach (指空间距离的不能及) I’m in BJ， teaching in SH is out of reachout of control (某物不可控) The fire is out of control (大火失去了控制) a family of three (三口之家) *have yet to do sth * (used for saying that something has not happened or been done up to the present time, especially when you think it should have happened or been done) As for accommodation, the resort has yet to announce the price of a stay in its hotel rooms. (至于膳宿，度假胜地还没有公布酒店的费用) trial run/flight/version (试运行/试飞/试用版本) turn over in one’s mind (Think about something thoroughly) My father gave me some advice that I’ve been turning over in my mind ever since (我父亲教导过我一句话，我至今还念念不忘) web celebrity (网红， celebrity也可以指名声名气) *You have got to do sth * (强烈建议做某事， got 要加重音) You’ve got to try this. I’m not that much of … (我还没那么…,还没到..程度，也算是一种谦虚的说法) I’m not that much of an artistI’m not that much of a sweet tooth (我不那么喜欢吃甜食) This is the best sth/sb I have ever done This is the best radio show I have ever listened to.This is the best movie I have ever seen Sth is addressed to you* (sth是邮寄给你的) This is not addressed to you (这不是邮寄给你的)注意名词动词的读音区分 vt. 演说；从事；忙于；写姓名地址；向…致辞；与…说话；提出；处理 n. 地址；演讲；致辞；说话的技巧；称呼 send away send away for sth (request another sth) 想象“让快递小哥送过来sth” ** I’ll be right with you.** (等等，我马上就来) Wait a few minutes and I’ll be right with you. (请等一下，我马上就来) sink one’s teeth into sth/sb bite to sth/sbI can’t wait to sink my teeth into that delicious-looking dessert(餐后甜点) you madeThe dog sunk his teeth into the little boy’s arm. get a chance to do something energetically or productivelyI want to give the students a project they can really sink their teeth into.I’m so bored at work. I would like something I can sink my teeth into. first-tier city (一线城市) take sb/sth for granted (把…当成理所当然) So many of us take clean water for granted.Children often take their parents for granted. slow motion hair shake (慢动作甩头发) It’s a running gag （不停出现的笑点） gag me (short for gag me with a spoon) Shit i have so much homework. Gag meee! (杀了我吧，恶心死我吧) stare at sb ( 盯着某人看， 不是很礼貌的行为) Don’t stare wafer thin ice (很危险了) you’re standing on thin ice （你很危险了，“别嘚瑟了，再触碰底线就死定了”） sth rules (sth很给力，指很过瘾) movie rules / water rules *leg warms * (秋裤) You shush （你闭嘴吧） 口语中，You shush或者Shush的使用频率很高，说话者用来让对方“闭嘴”或者“安静一下Shush! I want to hear the weather. (安静！我要听天气预报)Shush! Here he comes. I’ll talk to you later. (嘘！他来了。我一会儿再跟你说)Don’t shush me. (让对方安静的意思)注意： Shush与Shut up所表达的含义相同，但Shush的语气比较委婉和客气，而Shut up则比较粗鲁，一般是急了的情况下用这种表达来让对方“住口” *one hit wonder * (one hit wonder，指代一个歌手或者组合只有一首成功的单曲) There are lots of singers are one hit wonder tell each other secrets (互相揭穿秘密) freshman sophomore junior senior (大一大二大三大四) *valley girl * （说话声音比较大，比较兴奋的女孩，会让周围的人觉得很吵 ） 英语中没有学哥小妹，只需要说来自同一个学校就可以了， he was my friend from college 或者 alumni /ə’lʌmnaɪ/ 校友 to make matters worse (更糟糕的是) tough cookie = a difficult people (难相处的人) wedding vows （very serious promise， 现在多数在结婚时候用了） 婚姻誓词 flash back episode (回顾片段 电影中的回忆片段) *steal one’s thunder * (抢了谁的风头) Your roof, your rules (你的地盘你做主) a blessing in disguise (塞翁失马，因祸得福) word on the street (小道消息) *second mother tongue * （第二母语） serve for sth （服务../用来做..） show off (炫耀，显摆) Reading makes a full man; conference a ready man;and writing an exact man (读书使人充实；交谈使人机敏；笔记使人精确) learn from the past (从历史/过去中学习) Those are way too expensive (way too + adj 太…) He’s a pushover (他是一个容易被掌控使唤的人) He’s a buzzkill (他是一个扫兴的人) i’m not doing it/sth (正在否认不做什么) I’m not returning them, you’ll see (you’ll see 等着看吧，尾语) 成语短语总结 不管三七二十一 &lt;——&gt; 瞻前顾后 rain or shine &lt;——&gt; take a look around You have to carry out(贯彻，执行) your plan, rain or shine. Buddy, just keep going， I’ll be along with you, rain or shine. If you take a look around, you will miss a lot of oppotunities that were supposed to belong to you. 不寒而栗 Make one’ s teeth chatter(使卡嗒卡嗒作声). Make one’s flesh(肉体) creep The mysterious /mɪ’stɪrɪəs/ sound in the dark made Lily’s teeth chatter. The news that fake vaccines were being sold to different provinces in China made my teeth chatter. 不可救药 &lt;——&gt; 微感不适 beyond remedy(补救，治疗，赔偿) &lt;——&gt; To feel off color Robert’s laziness is beyond remedy. Tom feels off color 不可同日而语 &lt;——&gt; 相提并论 can’t be mentioned on the same day &lt;——&gt; place on par John’s idea is different from Jean’s, they can’t be mentioned on the same day. Both of things can not be placed on par. 生词表 序号 单词 音标 词性和解释 1 ditch /dɪtʃ/ vt. 在…上掘沟；把…开入沟里；丢弃 n. 沟渠；壕沟 2 custod /‘kʌstədi/ n. 保管；监护；拘留；抚养权 3 alcoholic /,ælkə’hɔlɪk/ adj. 酒精的，含酒精的 n. 酒鬼，酗酒者 4 revelation /‘rɛvə’leʃən/ n. 启示；揭露；出乎意料的事；被揭露的真相 5 massage /mə’sɑːʒ n. 按摩；揉 vt. 按摩；揉 6 horoscope /‘hɔrəskop n. 占星术；星象；十二宫图 7 nonsense /‘nɑnsɛn/ n. 胡说；废话 8 charming /‘tʃɑrmɪŋ/ adj. 迷人的；可爱的 9 arrogant /‘ærəɡən/ adj. 自大的，傲慢的 10 oops /uːps/ （表示惊讶或后悔）哎哟… 11 taboo /təˈbuː/ 禁忌 12 dash /dæʃ/ 连字符”-“ 13 underscore /ˌʌn.dɚˈskɔːr/ 下划线”_” 14 money-oriented / -ɔːr.i.en.t̬ɪd/ 导向钱的, 注意连字符的使用 15 detail-oriented / -ɔːr.i.en.t̬ɪd/ 导向细节的， 注意连字符的使用，可能几百年后就是一个单词，中间没有连字符 16 alley / ˈæl.i/ 小街, 小巷，胡同, （尤指两边有树或灌木的）小径… 17 stove / stoʊv/ （用于取暖的）炉，火炉, 炉灶… 18 ramen /ˈrɑː.men/ 日式拉面 方便面 19 drip-&gt;dribble /drɪp/ /ˈdrɪb.əl/ 滴嗒-&gt;滴滴答答 frequentative form 反复动词 20 murmur /ˈmɝː.mɚ/ 轻声说, 低声说 ,喃喃自语 frequentative form 反复动词 21 jerk /dʒɜːk/ （美俚) foolish person 蠢人.阿呆,笨瓜,不懂世故 （适合好朋友之间用，有点幼稚，可爱的感觉） 22 seminar /ˈsem.ə.nɑːr/ 专题讨论会, 研讨会… 23 bluff /blʌf/ 以假象欺骗，蒙，唬 24 bury /ˈber.i/ 埋, 埋葬，安葬, 掩埋 25 hatchet /ˈhætʃ.ɪt/ 小斧头 26 cosmetic /kɑːzˈmet̬.ɪk/ adj. 美容的；化妆用的 n. 化妆品；装饰品 27 sentimental /‘sɛntə’mɛntl/ adj. 伤感的；多愁善感的；感情用事的；寓有情感的 28 bend（过去时bent”弯曲的”） /bɛnd/ vt. 使弯曲；使屈服；使致力；使朝向 vi. 弯曲，转弯；屈服；倾向；专心于 n. 弯曲 29 daisy /‘deɪzɪ/ n. 雏菊；菊科植物；极好的东西 adj. 极好的；上等的 30 tassel /‘tæsl/ n. 流苏；缨；穗 vt. 用流苏装饰；摘下…穗 31 step-dad, step-mom, step-brother, step-sister 继父,继母,继兄,继女 32 asbestos /æz’bestɒs / n.石棉 33 ceiling /‘siːlɪŋ/ 天花板 34 oven /‘ʌvən/ n. 烤箱 35 bulb /bʌlb/ n. 电灯泡 36 bittersweet /‘bɪtɚ,swit/ adj. 苦乐参半的；又苦又甜的 n. 又苦又甜的东西；蜀羊泉 37 narcissist /nɑr’sɪsɪst/ n. 自我陶醉者 自恋的人 38 narcissism /‘nɑrsɪ’sɪzə/ n. [心理] 自恋，自我陶醉 39 downhill /,daʊn’hɪl/ adv. 下坡；向下；每况愈下 adj. 下坡的；容易的 n. 下坡；滑降 40 punchline /‘pʌntʃlaɪn/ n. 笑点；结尾警语；妙语如珠 41 bald /bɔld/ adj. 秃顶的；光秃的；单调的；无装饰的 vi. 变秃 42 therapy /‘θɛrəpi/ n. 治疗，疗法 43 tuition /tʊ’ɪʃən/ n. 学费；讲授 44 tutor /‘tʊtɚ/ vt. 辅导；约束 n. 导师；家庭教师；助教 vi. 当家庭教师；（美）在家庭教师指导下学习 45 scooter /ˈskuː.t̬ɚ/ n. 单脚滑行车 46 ambidextrous /‘æmbə’dɛkstrəs/ n. 旁观者 47 onlooker = spectator /‘ɑnlʊkɚ/ adj. 双手灵巧的；怀有二心的 48 vague /veɡ/ adj. 模糊的；含糊的；不明确的；暧昧的 49 genetics /dʒə’nɛtɪks/ n. 遗传学 50 clumsy /‘klʌmzi/ adj. 笨拙的 51 stigma /‘stɪɡmə/ n. [植] 柱头；耻辱；污名；烙印；特征 52 gasp /ɡæsp/ vi. 喘气；喘息；渴望 vt. 气喘吁吁地说；喘着气说话 n. 喘气 (很惊讶的场景，倒吸一口气) 53 creamy /‘krimi/ adj. 奶油色的；乳脂状的；含乳脂的 54 hypocrite /‘hɪpə’krɪ/ n. 伪君子；伪善者 55 foreshadow /fɔrˈʃæd·oʊ/ vt. 预示；成为…的前兆，做铺垫 n. 预兆，铺垫 56 cliche /kliːˈʃeɪ/ n. 陈词滥调；[印刷] 铅版；陈腐思想 adj. 陈腐的 a saying or remark that is very often made and is therefore not original and not interesting ,想象剧情中的甩头发太普遍了，烂大街了 57 conversationalist /ˌkɑːn.vɚˈseɪ.ʃən.əl.ɪst/ n. 健谈的人 someone who enjoys or is good at talking with people 58 intently /ɪnˈtent·li/ adv. 专心地；一心一意地；心无旁骛地 in a way that shows great attention to something 59 pathetic /pəˈθet̬.ɪk/ adj. 可怜的，悲哀的；感伤的；乏味的","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"English","slug":"Life/English","permalink":"https://dayarch.top/categories/Life/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://dayarch.top/tags/English/"}]},{"title":"Hexo在github上搭建自己的博客","slug":"buildGithubBlog","date":"2015-08-09T12:01:29.000Z","updated":"2019-11-07T05:16:06.555Z","comments":true,"path":"/p/build-github-pages-blog.html","link":"","permalink":"https://dayarch.top/p/build-github-pages-blog.html","excerpt":"引言 长时间在某平台上写博客记录些什么，但是近期该平台陆陆续续出现一些小问题，让写博客这么愉快的事情总是充斥着各种插曲，稍稍不爽，于是乎开始准备搭建自己的的博客，通过查阅资料用了两天时间初步搭建起来，收获颇丰，所以趁热打铁记录整个过程，搭建过程参考了非常多前辈们的blog，先真诚的道一声“感谢”，文章末尾会给出相关的参考链接。可搭建博客的框架很多，参考静态博客框架对比，选择你看上眼的，本文选择Hexo，为什么选择它，我只能说对比之后喜欢. 为什么选择github平台？ 为什么选择github平台，我们通过下面的两组问题就可以得到答案了. 博友们是否在编写博客的时候遇到过以下问题： 1.","text":"引言长时间在某平台上写博客记录些什么，但是近期该平台陆陆续续出现一些小问题，让写博客这么愉快的事情总是充斥着各种插曲，稍稍不爽，于是乎开始准备搭建自己的的博客，通过查阅资料用了两天时间初步搭建起来，收获颇丰，所以趁热打铁记录整个过程，搭建过程参考了非常多前辈们的blog，先真诚的道一声“感谢”，文章末尾会给出相关的参考链接。可搭建博客的框架很多，参考静态博客框架对比，选择你看上眼的，本文选择Hexo，为什么选择它，我只能说对比之后喜欢. 为什么选择github平台？为什么选择github平台，我们通过下面的两组问题就可以得到答案了. 博友们是否在编写博客的时候遇到过以下问题： 博客平台升级维护 没有网络（比博客升级和维护还惨） 不够定制化 github上搭建自己的博客当然是有很多好处的： 学着用github，享受github的便利，上面有很多大牛，眼界会开阔很多 顺便看看github工作原理，最好的团队协作流程 自我认为开源是一种趋势，github上有良好的开源氛围与精神 定制化的博客，可以按照自己的喜好来做更改 即便离线我也可以按照Markdown语法来编写博客，有网络时上传即可 一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成，可读性强 搭建过程按照下面的过程逐步进行，细心理解领会，你会发现搭建过程很简单, 下文都是在Windows 环境进行搭建。 前期准备工作安装Hexo很简单，但是需要下面两样东东的支持： Node.js Git 在Windows 环境安装真的是太简单了，基本上是无脑下一步 Hexo安装在某个磁盘目录下新建一个文件夹，然后鼠标右键单击【Git Bash】, 进入下图： 执行下面命令安装Hexo： $ npm install -g hexo-cli 查看一下安装的Hexo版本（本人安装的是3.1.1） hexo的命令要怎么用？必须help命令来帮忙 安装好后就需要初始化Hexo来创建项目了 $ hexo init 该文件夹下会生成以下文件： scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能 source 存放博客正文内容 source/_drafts 草稿箱 source/_posts 文件箱 themes 存放皮肤的目录 themes/landscape 默认的皮肤 _config.yml 全局的配置文件 db.json 静态常量 项目创建完毕，就要启动了 $ hexo server 这个地方可能会遇到错误， 因为server在Hexo 3的版本被分离出来，需要单独安装： $ npm install hexo-server –save 这样重新启动就好了. 这时端口4000被打开了，我们能过浏览器打址，http://localhost:4000/ 我们可以使用下面命令来创建新page来写博客了 $ hexo new myNewPage 创建好myNewPage.md文件会自动放在source/_posts目录下，生成的md后缀的文件需要采用Markdown进行编写，然后刷新页面，你就会发现你的新文章了，是不是有点小激动，还有更好的，往下看。 更改Hexo主题安装好的Hexo我们都是一样的在source/themes默认主题landscape, 是不是觉得不够爽， 那就选择主题, 这里面应该有你想要的那一款吧。 执行下面命令将选好的主题clone到自己的hexo空间 $ git clone https://github.com/A-limon/pacman.git themes/pacman 这样你会发现pacman这个主题就在你的themes文件下了，想让自己博客指定主题，只需要修改hexo的主题文件_config.yml 中的theme属性即可 theme: pacman 重新启动，刷新你的页面，主题变了吧。 配置和使用Github我们如何让本地git项目与远程的github建立联系呢？用SSH keys开始菜单处单击【Git Bash】** 首先我们需要检查你电脑上现有的ssh key： $ cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用git， 接下来需要生成SSH keys $ ssh-keygen -t rsa -C “邮件地址@youremail.com”Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 注意: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」 系统要求输入密码和确认密码： $ Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;$ Enter same passphrase again:&lt;再次输入加密串&gt; 最后看到下面界面就生成了SSH keys 按照log提示找到id_rsa.pub文件，复制里面的内容，然后将SSH keys添加到github上，登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys 可以通过下面命令来进行测试是否成功 $ ssh -T git@github.com 现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。 $ git config –global user.name “your name”$ git config –global user.email “username@gmail.com“ 至此SSH keys设置成功 发布博客到Github我们的终极目标是将博客发布到github上，我们还是需要有一些准备工作要做。在github上新建username.github.io的repository，至于为什么请参考github pages 本地新建一个文件夹，该文件夹下右键单击【Git Bash】 执行命令 $ git clone git@github.com:username/username.github.io.git 这样就在本地生成了自己的repository 怎样发布到github上去，我们同样要修改hexo下的_config.yml文件，在最后deployment处增加这样两行 deploy:type: githubrepo: git@github.com:username/username.github.io.git 然后执行命令进行静态化，将所有文件静态化到public文件夹下 $ hexo generate 然后进行部署 $ hexo deploy 这个地方可能又遇到问题了，提示【hexo ERROR Deployer not found: github】，同样是3以上版本的问题，按照下面操作即可： $ npm install hexo-deployer-git –save 然后将上面说到的部署文件的type由github改为git deploy:type: gitrepo: git@github.com:username/username.github.io.git 重新生成静态文件，然后发布，这样在浏览器中输入username.github.io就可以到你在github上的博客了， 有没有小激动？ 最后小伙伴们哪里看不懂或哪里有问题欢迎留言，我进行补充或回答, 更多问题可以参考官网文档Docs . 最后真的感激前辈们的博文指点，下面提供我参考过的一些链接： 如何搭建一个独立博客——简明GithubPages与Hexo教程 Hexo在github上构建免费的Web应用 搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门 用Jekyll在github上写博客——《搭建一个免费的，无限流量的Blog》的注脚","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://dayarch.top/tags/GitHub-Pages/"}]}]}
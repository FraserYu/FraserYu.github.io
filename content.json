{"meta":{"title":"日拱一兵","subtitle":"Quick notes","description":"Java后端技术博客，用有趣的方式解读技术","author":"tanθ","url":"https://dayarch.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-14T04:31:25.233Z","updated":"2019-11-14T04:31:25.233Z","comments":true,"path":"404.html","permalink":"https://dayarch.top/404.html","excerpt":"404 Not Found **由于更改了文章链接，原有链接丢失，但内容依旧在**试试在本站通过搜索关键字找到相关文章","text":"404 Not Found **由于更改了文章链接，原有链接丢失，但内容依旧在** 试试在本站通过搜索关键字找到相关文章"},{"title":"关于我","date":"2019-10-31T12:27:35.000Z","updated":"2019-11-01T23:45:30.022Z","comments":true,"path":"about/index.html","permalink":"https://dayarch.top/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-10-31T12:18:29.000Z","updated":"2019-10-31T12:44:03.895Z","comments":true,"path":"categories/index.html","permalink":"https://dayarch.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-31T12:18:52.000Z","updated":"2019-10-31T12:44:13.682Z","comments":true,"path":"tags/index.html","permalink":"https://dayarch.top/tags/index.html","excerpt":"","text":""},{"title":"留言交流","date":"2019-11-03T12:15:27.885Z","updated":"2019-11-03T12:15:27.885Z","comments":true,"path":"comments/index.html","permalink":"https://dayarch.top/comments/index.html","excerpt":"为了更好的跟踪大家留言问题，留言方式选用 Gitalk, 大家只需登录 Github 账号即可留言，欢迎大家来踩☕️","text":"为了更好的跟踪大家留言问题，留言方式选用 Gitalk, 大家只需登录 Github 账号即可留言，欢迎大家来踩☕️"},{"title":"我的朋友们「友链添加在底部」","date":"2019-10-31T07:45:38.000Z","updated":"2019-11-26T02:24:36.839Z","comments":true,"path":"friends/index.html","permalink":"https://dayarch.top/friends/index.html","excerpt":"需要添加友链，请在下方留言，需要以下内容： * 头像外链（如有白名单设置，请为 https://dayarch.top 开白名单） * 网站/博客名称 * 两个描述你或网站的 tag * 网站/博客 https URL 地址","text":"需要添加友链，请在下方留言，需要以下内容： 头像外链（如有白名单设置，请为 https://dayarch.top 开白名单） 网站/博客名称 两个描述你或网站的 tag 网站/博客 https URL 地址"},{"title":"网站维护日志","date":"2019-12-15T13:07:07.586Z","updated":"2019-12-15T13:07:07.586Z","comments":true,"path":"website/index.html","permalink":"https://dayarch.top/website/index.html","excerpt":"待升级/修复内容： * 文章底部 github-badge * 添加社交链接和RSS * 「关于」页面自定义改造 * 添加其他渠道链接 2019.12.13: * 「优化」完成文章相关链接指向功能 2019.11.7: * 「优化」完成博客备份功能 2019.11.4: * 「修复」网站统计访问人数不显示问题 * 「修复」移动端首页动态字体显示不全问题 2019.11.3: * 「新增」站内导航新增豆瓣读书 * 「新增」右下角即时聊天工具 * 「新增」站点运行时间 * 「新增」站点字数统计 2019.11.2: * 「","text":"待升级/修复内容： 文章底部 github-badge 添加社交链接和RSS 「关于」页面自定义改造 添加其他渠道链接 2019.12.13: 「优化」完成文章相关链接指向功能 2019.11.7: 「优化」完成博客备份功能 2019.11.4: 「修复」网站统计访问人数不显示问题 「修复」移动端首页动态字体显示不全问题 2019.11.3: 「新增」站内导航新增豆瓣读书 「新增」右下角即时聊天工具 「新增」站点运行时间 「新增」站点字数统计 2019.11.2: 「新增」添加百度/谷歌站长以及分析工具 「新增」增加鼠标点击💥效果 「新增」首页动态文字效果 「新增」添加文章 sidebar 音乐插件 2019.11.1: 「优化」更换博客主题，以及更改颜色样式"}],"posts":[{"title":"Java equals 和 hashCode 面试那点事","slug":"Java-equals-和-hashCode-面试那点事","date":"2019-12-17T12:41:51.000Z","updated":"2019-12-17T12:53:53.046Z","comments":true,"path":"/p/java-equals-hashcode.html","link":"","permalink":"https://dayarch.top/p/java-equals-hashcode.html","excerpt":"前言 上一篇文章 如何妙用 Spring 数据绑定？ ，灵魂追问 环节留下了一个有关 equals 和 hashcode 问题 。基础面试经常会碰到与之相关的问题，这不是一个复杂的问题，但很多朋友都苦于说明他们二者的关系和约束，于是写本文做单独说明，本篇文章将循序渐进 ( 通过举例，让记忆与理解更轻松 ) 说明这些让你有些苦恼的问题，Let’s go ……. 面试问题 1. Java 里面有了 == 运算符，为什么还需要 equals ？ == 比较的是对象地址，equals 比较的是对象值 先来看一看 Object 类中 equals 方法: 1 2 3 public boole","text":"前言上一篇文章 如何妙用 Spring 数据绑定？ ，灵魂追问 环节留下了一个有关 equals 和 hashcode 问题 。基础面试经常会碰到与之相关的问题，这不是一个复杂的问题，但很多朋友都苦于说明他们二者的关系和约束，于是写本文做单独说明，本篇文章将循序渐进 ( 通过举例，让记忆与理解更轻松 ) 说明这些让你有些苦恼的问题，Let’s go ……. 面试问题1. Java 里面有了 == 运算符，为什么还需要 equals ？ == 比较的是对象地址，equals 比较的是对象值 先来看一看 Object 类中 equals 方法: 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 我们看到 equals 方法同样是通过 == 比较对象地址，并没有帮我们比较值。Java 世界中 Object 绝对是”老祖宗” 的存在，== 号我们没办法改变或重写。但 equals 是方法，这就给了我们重写 equals 方法的可能，让我们实现其对值的比较: 1234@Overridepublic boolean equals(Object obj) &#123; //重写逻辑&#125; 新买的电脑，每个电脑都有唯一的序列号，通常情况下，两个一模一样的电脑放在面前，你会说由于序列号不一样，这两个电脑不一样吗？ 如果我们要说两个电脑一样，通常是比较其「品牌/尺寸/配置 」(值) ，比如这样: 1234@Overridepublic boolean equals(Object obj) &#123; return 品牌相等 &amp;&amp; 尺寸相等 &amp;&amp; 配置相等&#125; 当遇到如上场景时，我们就需要重写 equals 方法。这就解释了 Java 世界为什么有了 == 还有equals 这个问题了. 2. equals相等 和 hashcode 相等问题关于二者，你经常会碰到下面的两个问题: 两个对象 equals 相等，那他们 hashCode 相等吗？ 两个对象 hashCode 相等，那他们 equals 相等吗？ 为了说明上面两个问题的结论，这里举一个不太恰当的例子，只为方便记忆，我们将 equals 比作一个单词的拼写；hashCode 比作一个单词的发音，在相同语境下: sea / sea 「大海」，两个单词拼写一样，所以 equals 相等，他们读音 /siː/ 也一样，所以 hashCode 就相等，这就回答了第一个问题: 两个对象 equals 相等，那他们 hashCode 一定也相等 sea / see 「大海/看」，两个单词的读音 /siː/ 一样，显然单词是不一样的，这就回答了第二个问题: 两个对象 hashCode 相等，那他们 equals 不一定相等 查看 Object 类的 hashCode 方法: 1public native int hashCode(); 继续查看该方法的注释，明确写明关于该方法的约束 其实在这个结果的背后，还有的是关于重写 equals 方法的约束 3. 重写 equals 有哪些约束？关于重写 equals 方法的约束，同样在该方法的注释中写的很清楚了，我在这里再说明一下: 赤橙红绿青蓝紫，七彩以色列；哆来咪发唆拉西, 一曲安哥拉 ，这些规则不是用来背诵的，只是在你需要重写 equals 方法时，打开 JDK 查看该方法，按照准则重写就好 4. 什么时候需要我们重写 hashCode？为了比较值，我们重写 equals 方法，那什么时候又需要重写 hashCode 方法呢？ 通常只要我们重写 equals 方法就要重写 hashCode 方法 为什么会有这样的约束呢？按照上面讲的原则，两个对象 equals 相等，那他们的 hashCode 一定也相等。如果我们只重写 equals 方法而不重写 hashCode 方法，看看会发生什么，举个例子来看: 定义学生类，并通过 IDE 只帮我们生成 equals 方法: 123456789101112131415public class Student &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125;&#125; 编写测试代码: 12345678910111213141516171819Student student1 = new Student();student1.setName(\"日拱一兵\");student1.setAge(18);Student student2 = new Student();student2.setName(\"日拱一兵\");student2.setAge(18);System.out.println(\"student1.equals(student2)的结果是：\" + student1.equals(student2));Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();students.add(student1);students.add(student2);System.out.println(\"Student Set 集合长度是：\" + students.size());Map&lt;Student, java.lang.String&gt; map = new HashMap&lt;Student, java.lang.String&gt;();map.put(student1, \"student1\");map.put(student2, \"student2\");System.out.println(\"Student Map 集合长度是：\" + map.keySet().size()); 查看运行结果: 123student1.equals(student2)的结果是：trueStudent Set 集合长度是：2Student Map 集合长度是：2 很显然，按照集合 Set 和 Map 加入元素的标准来看，student1 和 student2 是两个对象，因为在调用他们的 put (Set add 方法的背后也是 HashMap 的 put)方法时， 会先判断 hash 值是否相等，这个小伙伴们打开 JDK 自行查看吧 所以我们继续重写 Student 类的 hashCode 方法: 1234@Overridepublic int hashCode() &#123; return Objects.hash(name, age);&#125; 重新运行上面的测试，查看结果: 123student1.equals(student2)的结果是：trueStudent Set 集合长度是：1Student Map 集合长度是：1 得到我们预期的结果，这也就是为什么通常我们重写 equals 方法为什么最好也重写 hashCode 方法的原因 如果你在使用 Lombok，不知道你是否注意到 Lombok 只有一个 @EqualsAndHashCode 注解，而没有拆分成 @Equals 和 @HashCode 两个注解，想了解更多 Lombok 的内容，也可以查看我之前写的文章 Lomok 使用详解 另外通过 IDE 快捷键生成重写方法时，你也会看到这两个方法放在一起，而不是像 getter 和 setter 那样分开 以上两点都是隐形的规范约束，希望大家也严格遵守这个规范，以防带来不必要的麻烦，记忆的方式有多样，如果记不住这个文字约束，脑海中记住上面的图你也就懂了 5. 重写 hashCode 为什么总有 31 这个数字？细心的朋友可能注意到，我上面重写 hashCode的方法很简答， 就是用了 Objects.hash 方法，进去查看里面的方法: 1234567891011public static int hashCode(Object a[]) &#123; if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result;&#125; 这里通过 31 来计算对象 hash 值 在 如何妙用 Spring 数据绑定？ 文章末尾提到的在 HandlerMethodArgumentResolverComposite 类中有这样一个成员变量: 12private final Map&lt;MethodParameter, HandlerMethodArgumentResolver&gt; argumentResolverCache = new ConcurrentHashMap&lt;MethodParameter, HandlerMethodArgumentResolver&gt;(256); Map 的 key 是 MethodParameter ，根据我们上面的分析，这个类一定也会重写 equals 和 hashCode 方法，进去查看发现，hashCode 的计算也用到了 31 这个数字 12345678910111213141516@Overridepublic boolean equals(Object other) &#123; if (this == other) &#123; return true; &#125; if (!(other instanceof MethodParameter)) &#123; return false; &#125; MethodParameter otherParam = (MethodParameter) other; return (this.parameterIndex == otherParam.parameterIndex &amp;&amp; getMember().equals(otherParam.getMember()));&#125;@Overridepublic int hashCode() &#123; return (getMember().hashCode() * 31 + this.parameterIndex);&#125; 为什么计算 hash 值要用到 31 这个数字呢？我在网上看到一篇不错的文章，分享给大家，作为科普，可以简单查看一下:String hashCode 方法为什么选择数字31作为乘子 总结如果还对equals 和 hashCode 关系及约束含混，我们只需要按照上述步骤逐步回忆即可，更好的是直接查看 JDK 源码；另外拿出实际的例子来反推验证是非常好的办法。如果你还有相关疑问，也可以留言探讨. 灵魂追问 Thread 类就没有重写 equals 方法，你还知道哪些情况没必要重写 equals 方法吗？ 从上面 HandlerMethodArgumentResolverComposite 类中定义的 Map 成员变量，你注意到哪些知识点，比如 final，ConcurrentHashMap，初识容量，为什么要这样写？你能解释出原因吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://dayarch.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Spring 数据绑定剖析","slug":"Spring-数据绑定剖析","date":"2019-12-12T11:59:04.000Z","updated":"2019-12-16T04:30:41.731Z","comments":true,"path":"/p/spring-data-binding-mechanism.html","link":"","permalink":"https://dayarch.top/p/spring-data-binding-mechanism.html","excerpt":"前言 在剖析完 「Spring Boot 统一数据格式是怎么实现的？ 」文章之后，一直觉得有必要说明一下 Spring’s Data Binding Mechanism 「Spring 数据绑定机制」。 默认情况下，Spring 只知道如何转换简单数据类型。比如我们提交的 int、String 或 boolean类型的请求数据，它会自动绑定到与之对应的 Java 类型。但在实际项目中，远远不够，因为我们可能需要绑定更复杂的对象类型。 我们需要了解 Spring 数据绑定机制，这样我们就可以更灵活的做全局配置或自定义配置，进而让我们的 RESTful API 更简洁，可读性也更好。本文依旧先","text":"前言在剖析完 「Spring Boot 统一数据格式是怎么实现的？ 」文章之后，一直觉得有必要说明一下 Spring’s Data Binding Mechanism 「Spring 数据绑定机制」。 默认情况下，Spring 只知道如何转换简单数据类型。比如我们提交的 int、String 或 boolean类型的请求数据，它会自动绑定到与之对应的 Java 类型。但在实际项目中，远远不够，因为我们可能需要绑定更复杂的对象类型。 我们需要了解 Spring 数据绑定机制，这样我们就可以更灵活的做全局配置或自定义配置，进而让我们的 RESTful API 更简洁，可读性也更好。本文依旧先通过示例代码说明实现，然后进行源码分析，带领大家了解这个机制是如何生效的，知其所以然， Let’s go…… Spring 数据绑定日期绑定先来看下面一小段代码 1234567891011@RestController@RequestMapping(\"/bindings/\")@Slf4jpublic class BindingController &#123; @GetMapping(\"/&#123;date&#125;\") public void getSpecificDateInfo(@PathVariable LocalDateTime date) &#123; log.info(date.toString()); &#125;&#125; 当我们用 Postman 请求这个 API 1http://localhost:8080/rgyb/bindings/2019-12-10 12:00:00 如我们所料，抛出数据类型转换异常因为 Spring 默认不支持将 String 类型的请求参数转换为 LocalDateTime 类型，所以我们需要自定义 converter 「转换器」完整整个转换过程 自定义转换器 StringToLocalDateTimeConverter，使其实现 org.springframework.core.convert.converter.Converter&lt;S, T&gt; 接口，在重写的 convert 方法中实现我们自定义的转换逻辑 1234567public class StringToLocalDateTimeConverter implements Converter&lt;String, LocalDateTime&gt; &#123; @Override public LocalDateTime convert(String s) &#123; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\", Locale.CHINESE); return LocalDateTime.parse(s, formatter); &#125;&#125; 将转换器注册到上下文中: 1234567@Configurationpublic class UnifiedReturnConfig implements WebMvcConfigurer &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new StringToLocalDateTimeConverter()); &#125;&#125; 重新访问上面链接，查看控制台，按照预期得到相应转换结果: 1c.e.unifiedreturn.api.BindingController : 2019-12-10T12:00 知道了这个，比如我们常用的枚举类型也可以应用这种方式做数据绑定 枚举类型绑定同样的套路，自定义转换器 1234567public class StringToEnumConverter implements Converter&lt;String, Modes&gt; &#123; @Override public Modes convert(String s) &#123; return Modes.valueOf(s); &#125;&#125; 将其添加至上下文，请小伙伴们自行尝试吧，知道了这个，我们再也不用在 RESTful API 内部做数据转换了，我们做到了全局控制，同时让整个 API 看起来更加清晰简洁 绑定对象在某些情况下，我们希望将数据绑定到对象，这时我们可能马上联想起来使用 @RequestBody 注解，该注解通常用于获取 POST 请求体，并将其转换相应的数据对象 在实际业务场景中，除了请求体中的数据，我们同样需要请求头中的数据，比如 token ，token 中包含当前登陆用户的信息，每一次 RESTful 请求我们都需要从 header 中获取 token 数据处理实际业务，这种场景，上文提到的 Converter 以及 @RequestBody 显然不能满足我们的需求，此时我们就要换另一种解决方案 : HandlerMethodArgumentResolver 首先我们需要自定义一个注解 LoginUser (运行时生效，作用于参数上) 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.PARAMETER)public @interface LoginUser &#123;&#125; 然后自定义 LoginUserArgumentResolver ，使其实现 HandlerMethodArgumentResolver 接口 1234567891011121314151617181920212223242526public class LoginUserArgumentResolver implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter methodParameter) &#123; //判断参数是否有自定义注解 LoginUser 修饰 return methodParameter.hasParameterAnnotation(LoginUser.class); &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = (HttpServletRequest) nativeWebRequest.getNativeRequest(); LoginUserVo loginUserVo = new LoginUserVo(); String token = request.getHeader(\"token\"); if (Strings.isNotBlank(token))&#123; //通常这里需要编写 token 解析逻辑，并将其放到 LoginUserVo 对象中 //logic &#125; //在此为了快速简洁的做演示说明，省略掉解析 token 部分，直接从 header 指定 key 中获取数据 loginUserVo.setId(Long.valueOf(request.getHeader(\"userId\"))); loginUserVo.setName(request.getHeader(\"userName\")); return loginUserVo; &#125;&#125; 依旧将自定义的 LoginUserArgumentResolver 添加到上下文中 1234@Overridepublic void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123; resolvers.add(new LoginUserArgumentResolver());&#125; 编写 API: 1234@GetMapping(\"/id\")public void getLoginUserInfo(@LoginUser LoginUserVo loginUserVo) &#123; log.info(loginUserVo.toString());&#125; 通过 Postman 请求，在 header 中设置好相应的 K-V，如下图 1http://localhost:8080/rgyb/bindings/id 发送请求，查看控制台，得到预期结果 1c.e.unifiedreturn.api.BindingController : LoginUserVo(id=111111, name=rgyb) 相信到这里，你已经了解了基本的使用，接下来我们进行源码分析，透过现象看本质 (希望可以打开 IDE 跟着步骤查看) Spring 数据绑定源码分析首先我们需要了解我们自定义的 LoginUserArgumentResolver 是如何被加载到上下文中的，在你看过 HttpMessageConverter转换原理解析 和 Springboot返回统一JSON数据格式是怎么实现的？后，你也许已经有了眉目，同加载 MessageConverter 如出一辙，在 RequestMappingHandlerAdapter 类中，同样有添加 ArgumentResolver 的方法，该方法会把系统内置的 resolver 和用户自定义的 resolver 都加载到上下文中，关键代码展示如下: 1234567891011121314151617private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList(); resolvers.add(new RequestParamMethodArgumentResolver(this.getBeanFactory(), false)); //其他内置 resolver resolvers.add(new RequestResponseBodyMethodProcessor(this.getMessageConverters(), this.requestResponseBodyAdvice)); ... ... if (this.getCustomArgumentResolvers() != null) &#123; resolvers.addAll(this.getCustomArgumentResolvers()); &#125; ... ... return resolvers;&#125; 在 HttpMessageConverter转换原理解析 文章中有一段调用栈跟踪，我再次粘贴在此处，并用红框做出标记，其实我们在分析 messageConverter 时已经悄悄的路过了我们本节要说的内容 我们进入相应的类中瞧一瞧: 到这里你应该猛的了解这背后的道理了吧 接下来，我们来验证我们天天用的 @RequestBody 注解是不是这个套路呢？处理该注解的类是 RequestResponseBodyMethodProcessor，查看其类图，发现其依旧实现了 HandlerMethodArgumentResolver 接口 打开该类，你会看到下图代码，重点地方我已标记出来 整体处理流程如出一辙，只不过在里面调用了 messageConverter 来解析 JSON 数据。 总结本文说的 Converter 和 ArgumentResolver 以及在 Spring MVC 中常用的 @InitBinder 注解整体过程都如出一辙，大家都可以按照这个思路来查看具体的实现。另外，在我们完成日常编码工作时，都可以从 Spring 现有的处理方式中摸索到一些解决方案，但前提是你了解 Spring 底层的一些调用过程 最后希望小伙伴打开 IDE 切实查看相应代码，你一定还会有新发现，我们可以一起探讨。本文代码已上传，公众号回复「demo」，打开链接查看 「spring-boot-unified-return」文件夹内容即可，也可以顺路回顾以前 Spring Boot 统一返回格式的代码实现 灵魂追问 如上图所示，在追中源码时，发现HandlerMethodArgumentResolverComposite 是 HandlerMethodArgumentResolver 的实现类之一，其中有一个 Map 类型的成员变量，通常我们使用 Map，key 的类型多数为 String 类型，但看到这个 Map 中有这样的 key 你马上想到的是什么？基础面试经常会问 equals 和 hashcode 的问题，下一篇文章会借着这个类来分析说明一下你总困惑的这件小事 对于 Spring Boot 的整个调用过程，你能描述出整体流程吗？ Spring 内置多少个 Resolver？你可以跟踪调试获取到","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"Spring Data Binding","slug":"Spring-Data-Binding","permalink":"https://dayarch.top/tags/Spring-Data-Binding/"}]},{"title":"Lombok 使用教程详解","slug":"Lombok-使用教程详解","date":"2019-11-25T05:34:12.000Z","updated":"2019-11-25T05:41:24.129Z","comments":true,"path":"/p/lombok-usage.html","link":"","permalink":"https://dayarch.top/p/lombok-usage.html","excerpt":"前言 在 Java 应用程序中存在许多重复相似的、生成之后几乎不对其做更改的代码，但是我们还不得不花费很多精力编写它们来满足 Java 的编译需求 比如，在 Java 应用程序开发中，我们几乎要为所有 Bean 的成员变量添加 get() ,set() 等方法，这些相对固定但又不得不编写的代码浪费程序员很多精力，同时让类内容看着更杂乱，我们希望将有限的精力关注在更重要的地方。 Lombok 已经诞生很久了，甚至在 Spring Boot Initalizr 中都已加入了 Lombok 选项， 这里我们将 Lombok 做一下详细说明: Lombok 官网的介绍：Project Lom","text":"前言在 Java 应用程序中存在许多重复相似的、生成之后几乎不对其做更改的代码，但是我们还不得不花费很多精力编写它们来满足 Java 的编译需求 比如，在 Java 应用程序开发中，我们几乎要为所有 Bean 的成员变量添加 get() ,set() 等方法，这些相对固定但又不得不编写的代码浪费程序员很多精力，同时让类内容看着更杂乱，我们希望将有限的精力关注在更重要的地方。 Lombok 已经诞生很久了，甚至在 Spring Boot Initalizr 中都已加入了 Lombok 选项， 这里我们将 Lombok 做一下详细说明: Lombok 官网的介绍：Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again. Early access to future java features such as val, and much more. 直白的说： Lombok 是一种 Java™ 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注解实现这一目的，且看: Bean 的对比传统的 POJO 类是这样的 通过Lombok改造后的 POJO 类是这样的 一眼可以观察出来我们在编写 Employee 这个类的时候通过 @Data 注解就已经实现了所有成员变量的 get() 与 set() 方法等，同时 Employee 类看起来更加清晰简洁。Lombok 的神奇之处不止这些，丰富的注解满足了我们开发的多数需求。 Lombok的安装查看下图，@Data的实现，我们发现这个注解是应用在编译阶段的 这和我们大多数使用的注解，如 Spring 的注解（在运行时，通过反射来实现业务逻辑）是有很大差别的，如Spring 的@RestController 注解 一个更直接的体现就是，普通的包在引用之后一般的 IDE 都能够自动识别语法，但是 Lombok 的这些注解，一般的 IDE 都无法自动识别，因此如果要使用 Lombok 的话还需要配合安装相应的插件来支持 IDE 的编译，防止IDE 的自动检查报错，下面以 IntelliJ IDEA 举例安装插件。 在Repositories中搜索Lombok，安装后重启IDE即可 在Maven或Gradle工程中添加依赖 至此我们就可以应用 Lombok 提供的注解干些事情了。 Lombok注解详解Lombok官网提供了许多注解，但是 “劲酒虽好，可不要贪杯哦”，接下来逐一讲解官网推荐使用的注解(有些注解和原有Java编写方式没太大差别的也没有在此处列举，如@ Synchronized等) @Getter和@Setter该注解可应用在类或成员变量之上，和我们预想的一样，@Getter 和 @Setter 就是为成员变量自动生成 get 和 set 方法，默认生成访问权限为 public 方法，当然我们也可以指定访问权限 protected 等，如下图： 成员变量name指定生成set方法，并且访问权限为protected；boolean类型的成员变量 female 只生成get方法，并修改方法名称为 isFemale()。当把该注解应用在类上，默认为所有非静态成员变量生成 get 和 set 方法，也可以通过 AccessLevel.NONE 手动禁止生成get或set方法，如下图： @ToString该注解需应用在类上，为我们生成 Object 的 toString 方法，而该注解里面的几个属性能更加丰富我们想要的内容, exclude 属性禁止在 toString 方法中使用某字段，而of属性可以指定需要使用的字段，如下图： 查看编译后的Employee.class得到我们预期的结果，如下图 @EqualsAndHashCode该注解需应用在类上，使用该注解，lombok会为我们生成 equals(Object other) 和 hashcode() 方法，包括所有非静态属性和非transient的属性，同样该注解也可以通过 exclude 属性排除某些字段，of 属性指定某些字段，也可以通过 callSuper 属性在重写的方法中使用父类的字段，这样我们可以更灵活的定义bean的比对，如下图： 查看编译后的Employee.class文件，如下图： @NonNull该注解需应用在方法或构造器的参数上或属性上，用来判断参数的合法性，默认抛出 NullPointerException 异常 查看NonNullExample.class文件，会为我们抛出空指针异常，如下图： 当然我们可以通过指定异常类型抛出其他异常，lombok.nonNull.exceptionType = [NullPointerException | IllegalArgumentException] , 为实现此功能我们需要在项目的根目录新建lombok.config文件： 重新编译NonNullExample类，已经为我们抛出非法参数异常： @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor以上三个注解分别为我们生成无参构造器，指定参数构造器和包含所有参数的构造器，默认情况下，@RequiredArgsConstructor, @AllArgsConstructor 生成的构造器会对所有标记 @NonNull 的属性做非空校验。 无参构造器很好理解，我们主要看看后两种，先看 @RequiredArgsConstructor 从上图中我们可以看出， @RequiredArgsConstructor 注解生成有参数构造器时只会包含有 final 和 @NonNull 标识的 field，同时我们可以指定 staticName 通过生成静态方法来构造对象 查看Employee.class文件 当我们把 staticName 属性去掉我们来看遍以后的文件: 相信你已经注意到细节 @AllArgsConstructor 就更简单了，请大家自行查看吧 @Data介绍了以上的注解，再来介绍 @Data 就非常容易懂了，@Data 注解应用在类上，是@ToString, @EqualsAndHashCode, @Getter / @Setter 和 @RequiredArgsConstructor合力的体现，如下图： @Builder函数式编程或者说流式的操作越来越流行，应用在大多数语言中，让程序更具更简介，可读性更高，编写更连贯，@Builder就带来了这个功能，生成一系列的builder API，该注解也需要应用在类上，看下面的例子就会更加清晰明了。 编译后的Employee.class文件如下： 妈妈再也不用担心我 set 值那么麻烦了，流式操作搞定： @Log该注解需要应用到类上，在编写服务层，需要添加一些日志，以便定位问题，我们通常会定义一个静态常量Logger，然后应用到我们想日志的地方，现在一个注解就可以实现： 查看class文件，和我们预想的一样： Log有很多变种，CommonLog，Log4j，Log4j2，Slf4j等，lombok依旧良好的通过变种注解做良好的支持： 我实际使用的是 @Slf4j 注解 val熟悉 Javascript 的同学都知道，var 可以定义任何类型的变量，而在 java 的实现中我们需要指定具体变量的类型，而 val 让我们摆脱指定，编译之后就精准匹配上类型，默认是 final 类型，就像 java8 的函数式表达式，()-&gt;System.out.println(“hello lombok”); 就可以解析到Runnable函数式接口。 查看解析后的class文件： @Cleanup当我们对流进行操作，我们通常需要调用 close 方法来关闭或结束某资源，而 @Cleanup 注解可以帮助我们调用 close 方法，并且放到 try/finally 处理块中，如下图： 编译后的class文件如下，我们发现被try/finally包围处理，并调用了流的close方法 其实在 JDK1.7 之后就有了 try-with-resource，不用我们显式的关闭流，这个请大家自行看吧 总结Lombok的基本操作流程是这样的： 定义编译期的注解 利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器 利用tools.jar的javac api处理AST(抽象语法树) 将功能注册进jar包 Lombok 当然还有很多注解，我推荐使用以上就足够了，这个工具是带来便利的，而不能被其捆绑，“弱水三千只取一瓢饮，代码千万需抓重点看”，Lombok 能让我更加专注有效代码排除意义微小的障眼代码（get，set等），另外Lombok生成的代码还能像使用工具类一样方便（@Builder）。 更多内容请查看官网：https://www.projectlombok.org/ 灵魂追问 为什么只有一个整体 @EqualsAndHashCode 注解？而不是 @Equals 和 @HashCode？这涉及到一个规范哦 如果把三种构造器方式同时应用又加上了 @Builder 注解，会发生什么？ 你的灯还亮着吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"https://dayarch.top/tags/Lombok/"}]},{"title":"SDKMAN 统一灵活管理多版本Java","slug":"多版本Java统一灵活管理","date":"2019-11-14T00:51:02.000Z","updated":"2019-11-14T01:24:50.504Z","comments":true,"path":"/p/multiple-java-management.html","link":"","permalink":"https://dayarch.top/p/multiple-java-management.html","excerpt":"近两年，Java 版本升级频繁，感觉刚刚掌握 Java8，写本文时，已听到 java14 的消息，无论是尝鲜新特性(Java12 中超级香的一个功能)，还是由于项目升级/兼容需要，我们可能都要面临管理多个 Java 版本的情 另外 Oracle 自 Java11 开始，更改了用户协议，任何商用都会收费。在写本文时，得到消息「微软宣布加入 OpenJDK」，打不过就选择 OpenJDK。随便 G 一下，当个故事了解就可以 配置单个 Java 环境变量本身没什么技术含量可言，但当需要管理多个 Java 版本，重复配置环境变量显然是非常枯燥的，按照传统的配置方式我们又不能灵活的切换 Java 版","text":"近两年，Java 版本升级频繁，感觉刚刚掌握 Java8，写本文时，已听到 java14 的消息，无论是尝鲜新特性(Java12 中超级香的一个功能)，还是由于项目升级/兼容需要，我们可能都要面临管理多个 Java 版本的情 另外 Oracle 自 Java11 开始，更改了用户协议，任何商用都会收费。在写本文时，得到消息「微软宣布加入 OpenJDK」，打不过就选择 OpenJDK。随便 G 一下，当个故事了解就可以 配置单个 Java 环境变量本身没什么技术含量可言，但当需要管理多个 Java 版本，重复配置环境变量显然是非常枯燥的，按照传统的配置方式我们又不能灵活的切换 Java 版本 那要如何轻松管理与使用多个版本 Java？ 多版本 Java 管理显然我们不是第一个有这种困境的人，我所知道的现有方案有三种: Jabba jenv sdkman 本文主要说明如何通过 sdkman 打破我们面临的困境，帮助我们灵活配置与使用 Java sdkman 介绍SDKMAN 是一个用于在大多数基于 Unix 系统上管理 多个软件开发工具包 (Java, Groovy, Scala, Kotlin and Ceylon. Ant, Gradle 等) 的并行版本的工具 。 它提供了一个方便的命令行接口 (CLI) 和 API，用于安装、切换、删除和列出候选对象。本文主要通过管理 Java 来说明 sdkman 的使用 sdkman 安装在类 unix 平台上安装 sdkman 非常容易。它可以顺利的安装在Mac OSX、Linux、WLS、Cygwin、Solaris和FreeBSD 上，同时还支持Bash和 ZSH shell。 只需打开一个新终端机并输入: 1$ curl -s \"https://get.sdkman.io\" | bash 按照相应的指令提示，完成相应的操作后继续输入: 1$ source \"$HOME/.sdkman/bin/sdkman-init.sh\" 到这里我们就可以验证 sdk 的安装版本了: 1$ sdk version 上图红色框标记显示我当前 sdkman 的版本，每次执行 sdk version 命令时，都会检查是否会有新版本，如果要更新输入 y 就可以 有些系统发行版本不包含 zip 和 unzip，如果安装时遇到相关错误，可以输入如下命令安装 zip 和 unzip 1$ sudo apt-get install zip unzip 从上面的安装命令上可以看出，sdkman 默认的安装路径是在$HOME/.sdkman 下，我们也可以自定义安装路径，只需要指定 SDKMAN_DIR 变量值就好了: 1$ export SDKMAN_DIR=\"/usr/local/sdkman\" &amp;&amp; curl -s \"https://get.sdkman.io\" | bash 到这里 sdkman 的安装就结束了，我们来看看如何使用 sdkman 使用教程命令行下学习一个新玩意当然是查看它的 help 命令，输入: 1$ sdkman help 感觉上图按颜色区分内容后，sdkman 的使用说明也就结束了，我们按照上面的图来详细说明一下使用教程 sdk list先来输入: 1$ sdk list 绿色的标记就是 sdkman 集成的所有可用的 candidate，通过按回车「enter」按键，会看到更多可用 candidate 我们指定 candidate，输入: 1$ sdk list java 从上图中可以看到所有 java 可用的版本 version，以及标识 indentifier，以及状态 status，我已经安装了 java 12 和 11 有了这些信息做铺垫，我们可以安装任意 sdkman 内置的软件开发包了，继续以 java 为例 sdk install回看 sdkman help 命令的输出，使用 install 命令，我们再安装一个 Java 最新 13.0.1.j9 版本 从上图你可以看出，绿色标记的内容是 list 命令结果中的 version 值，但是报错不可用，输入indentifier 编号才能正常下载，这里需要注意 安装完后，status 就会编程 installed 状态 sdk current当安装多个版本的 java 时，我们输入下面命令获取当前正在用 candidate 的版本 1$ sdk current java sdk use了解了当前使用版本，如果我们想切换到其他版本, 可以输入: 1$ sdk use java 12.0.2.j9-adpt 注意⚠️: 这里同样是指定的 indentifier 的值 sdk default如果我们想指定某个版本为默认版本，可以输入: 1$ sdk default java jdk1.8.0_162.jdk 注意⚠️: 这里同样是指定的 indentifier 的值 sdk uninstall当我们想卸载某个版本可以输入: 1$ sdk uninstall java 12.0.2.j9-adpt 注意⚠️: 这里同样是指定的 indentifier 的值 sdk upgrade如果我们想升级某个 candidate，可以输入: 1$ sdk upgrade java sdk flush使用 sdkman 时间变长也会慢慢产生很多缓存内容，我们可以输入清理广播消息: 1$ sdk flush broadcast 清理下载的 sdk 二进制文件(长时间使用后清理，可以节省出很多空间): 1$ sdk flush archives 清理临时文件内容: 1$ sdk flush temp 到这里 sdkman 的基本使用就已经介绍完了，其实这些命令都不用急，想不起来的时候执行 sdk help 来临时查看一下就好 sdkman 卸载如果我们不喜欢 sdkman 了，我们也可以轻松的卸载掉它: 12$ tar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman$ rm -rf ~/.sdkman 最后打开你的 .bashrc、.bash_profile 和/或者 .profile，找到并删除下面这几行。 12#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!![[ -s \"/home/dudette/.sdkman/bin/sdkman-init.sh\" ]] &amp;&amp; source \"/home/dudette/.sdkman/bin/sdkman-init.sh\" 我用的 zshrc，找到 .zshrc 文件删除掉上面内容即可 到这里基于 Unix 系统的，有关 sdkman 的安装，使用及下载都已经介绍完了，可以上手试一试了，相信很多小伙伴用的是 Windows，除了 jenv， sdkman 和 Jabba 都有 windows 用户的解决方案: sdkman windows 解决方案在 sdkman 官网首页同样为 windows 用户提供了解决方案，小伙伴们找到如下位置查看即可 我看了一下过程，也是很简单，由于手头没有 windows 电脑，这个请小伙伴们自行尝试吧，有问题欢迎留言 灵魂追问 你现在用的 Java 版本是多少？ 有跟随新版本尝试更多新特性吗？ 你的灯还亮着吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://dayarch.top/tags/JDK/"}]},{"title":"HttpMessageConverter转换原理解析","slug":"HttpMessageConverter转换原理解析","date":"2019-11-07T10:15:50.000Z","updated":"2019-11-08T09:01:22.470Z","comments":true,"path":"/p/spring-boot-messageconverter.html","link":"","permalink":"https://dayarch.top/p/spring-boot-messageconverter.html","excerpt":"Java Web 人员经常要设计 RESTful API（如何设计好的RESTful API），通过 json 数据进行交互。那么前端传入的 json 数据如何被解析成 Java 对象作为 API入参，API 返回结果又如何将 Java 对象解析成 json 格式数据返回给前端，其实在整个数据流转过程中，HttpMessageConverter 起到了重要作用；另外在转换的过程我们可以加入哪些定制化内容？ HttpMessageConverter 介绍 org.springframework.http.converter.HttpMessageConverter 是一个策略接口，接口说明如下","text":"Java Web 人员经常要设计 RESTful API（如何设计好的RESTful API），通过 json 数据进行交互。那么前端传入的 json 数据如何被解析成 Java 对象作为 API入参，API 返回结果又如何将 Java 对象解析成 json 格式数据返回给前端，其实在整个数据流转过程中，HttpMessageConverter 起到了重要作用；另外在转换的过程我们可以加入哪些定制化内容？ HttpMessageConverter 介绍org.springframework.http.converter.HttpMessageConverter 是一个策略接口，接口说明如下： Strategy interface that specifies a converter that can convert from and to HTTP requests and responses. 简单说就是 HTTP request (请求)和response (响应)的转换器。该接口有只有5个方法，简单来说就是获取支持的 MediaType（application/json之类），接收到请求时判断是否能读（canRead），能读则读（read）；返回结果时判断是否能写（canWrite），能写则写（write）。这几个方法先有个印象即可： 12345boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType);boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType);List&lt;MediaType&gt; getSupportedMediaTypes();T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;void write(T t, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException; 缺省配置我们写 Demo 没有配置任何 MessageConverter，但是数据前后传递依旧好用，是因为 SpringMVC 启动时会自动配置一些HttpMessageConverter，在 WebMvcConfigurationSupport 类中添加了缺省 MessageConverter： 12345678910111213141516171819202122232425262728293031protected final void addDefaultHttpMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) &#123; StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(); stringConverter.setWriteAcceptCharset(false); messageConverters.add(new ByteArrayHttpMessageConverter()); messageConverters.add(stringConverter); messageConverters.add(new ResourceHttpMessageConverter()); messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;()); messageConverters.add(new AllEncompassingFormHttpMessageConverter()); if (romePresent) &#123; messageConverters.add(new AtomFeedHttpMessageConverter()); messageConverters.add(new RssChannelHttpMessageConverter()); &#125; if (jackson2XmlPresent) &#123; ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.xml().applicationContext(this.applicationContext).build(); messageConverters.add(new MappingJackson2XmlHttpMessageConverter(objectMapper)); &#125; else if (jaxb2Present) &#123; messageConverters.add(new Jaxb2RootElementHttpMessageConverter()); &#125; if (jackson2Present) &#123; ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json().applicationContext(this.applicationContext).build(); messageConverters.add(new MappingJackson2HttpMessageConverter(objectMapper)); &#125; else if (gsonPresent) &#123; messageConverters.add(new GsonHttpMessageConverter()); &#125; &#125; 我们看到很熟悉的 MappingJackson2HttpMessageConverter ，如果我们引入 jackson 相关包，Spring 就会为我们添加该 MessageConverter，但是我们通常在搭建框架的时候还是会手动添加配置 MappingJackson2HttpMessageConverter，为什么？ 先思考一下： 当我们配置了自己的 MessageConverter， SpringMVC 启动过程就不会调用 addDefaultHttpMessageConverters 方法，且看下面代码 if 条件，这样做也是为了定制化我们自己的 MessageConverter 1234567891011protected final List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; if (this.messageConverters == null) &#123; this.messageConverters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(); configureMessageConverters(this.messageConverters); if (this.messageConverters.isEmpty()) &#123; addDefaultHttpMessageConverters(this.messageConverters); &#125; extendMessageConverters(this.messageConverters); &#125; return this.messageConverters; &#125; 类关系图在此处仅列出 MappingJackson2HttpMessageConverter 和 StringHttpMessageConverter 两个转换器，我们发现， 前者实现了 GenericHttpMessageConverter 接口, 而后者却没有，留有这个关键印象，这是数据流转过程中关键逻辑判断 数据流转解析数据的请求和响应都要经过 DispatcherServlet 类的 doDispatch(HttpServletRequest request, HttpServletResponse response) 方法的处理 请求过程解析看 doDispatch 方法中的关键代码： 1234567// 这里的 Adapter 实际上是 RequestMappingHandlerAdapterHandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;// 实际处理的handlermv = ha.handle(processedRequest, response, mappedHandler.getHandler()); mappedHandler.applyPostHandle(processedRequest, response, mv); 从进入handle之后我先将调用栈粘贴在此处，希望小伙伴可以按照调用栈路线动手跟踪尝试： 123456789101112readWithMessageConverters:192, AbstractMessageConverterMethodArgumentResolver (org.springframework.web.servlet.mvc.method.annotation)readWithMessageConverters:150, RequestResponseBodyMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)resolveArgument:128, RequestResponseBodyMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)resolveArgument:121, HandlerMethodArgumentResolverComposite (org.springframework.web.method.support)getMethodArgumentValues:158, InvocableHandlerMethod (org.springframework.web.method.support)invokeForRequest:128, InvocableHandlerMethod (org.springframework.web.method.support) // 下面的调用栈重点关注，处理请求和返回值的分叉口就在这里invokeAndHandle:97, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation)invokeHandlerMethod:849, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)handleInternal:760, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)handle:85, AbstractHandlerMethodAdapter (org.springframework.web.servlet.mvc.method)doDispatch:967, DispatcherServlet (org.springframework.web.servlet) 这里重点说明调用栈最顶层 readWithMessageConverters 方法中内容： 1234567891011121314151617181920212223242526272829303132333435363738// 遍历 messageConvertersfor (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123; Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(); // 上文类关系图处要重点记住的地方，主要判断 MappingJackson2HttpMessageConverter 是否是 GenericHttpMessageConverter 类型 if (converter instanceof GenericHttpMessageConverter) &#123; GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter; if (genericConverter.canRead(targetType, contextClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = genericConverter.read(targetType, contextClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125; else if (targetClass != null) &#123; if (converter.canRead(targetClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125;&#125; 然后就判断是否canRead，能读就read，最终走到下面代码处将输入的内容反序列化出来： 1234567891011121314151617181920212223242526272829protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException &#123; try (JsonParser p = p0) &#123; Object result; JsonToken t = _initForReading(p); if (t == JsonToken.VALUE_NULL) &#123; // Ask JsonDeserializer what 'null value' to use: DeserializationContext ctxt = createDeserializationContext(p, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); &#125; else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) &#123; result = null; &#125; else &#123; DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(p, cfg); JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) &#123; result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser); &#125; else &#123; result = deser.deserialize(p, ctxt); &#125; ctxt.checkUnresolvedObjectId(); &#125; // Need to consume the token too p.clearCurrentToken(); return result; &#125; &#125; 到这里从请求中解析参数过程就到此结束了，趁热打铁来看将响应结果返回给前端的过程 返回过程解析在上面调用栈请求和返回结果分叉口处同样处理返回的内容： 12345writeWithMessageConverters:224, AbstractMessageConverterMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)handleReturnValue:174, RequestResponseBodyMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)handleReturnValue:81, HandlerMethodReturnValueHandlerComposite (org.springframework.web.method.support)// 分叉口invokeAndHandle:113, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation) 重点关注调用栈顶层内容，是不是很熟悉的样子，完全一样的逻辑, 判断是否能写canWrite，能写则write： 12345678910111213141516171819202122232425262728293031323334for (HttpMessageConverter&lt;?&gt; messageConverter : this.messageConverters) &#123; if (messageConverter instanceof GenericHttpMessageConverter) &#123; if (((GenericHttpMessageConverter) messageConverter).canWrite( declaredType, valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); if (outputValue != null) &#123; addContentDispositionHeader(inputMessage, outputMessage); ((GenericHttpMessageConverter) messageConverter).write( outputValue, declaredType, selectedMediaType, outputMessage); if (logger.isDebugEnabled()) &#123; logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\"); &#125; &#125; return; &#125; &#125; else if (messageConverter.canWrite(valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); if (outputValue != null) &#123; addContentDispositionHeader(inputMessage, outputMessage); ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage); if (logger.isDebugEnabled()) &#123; logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\"); &#125; &#125; return; &#125;&#125; 我们看到有这样一行代码： 123outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); 我们在设计 RESTful API 接口的时候通常会将返回的数据封装成统一格式，通常我们会实现 ResponseBodyAdvice 接口来处理所有 API 的返回值，在真正 write 之前将数据进行统一的封装 12345678910111213141516171819@RestControllerAdvice()public class CommonResultResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123; @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return true; &#125; @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (body instanceof CommonResult) &#123; return body; &#125; return new CommonResult&lt;Object&gt;(body); &#125;&#125; 整个处理流程就是这样，整个实现过程细节还需小伙伴自行追踪发现，文章开头我们说过 添加自己的 MessageConverter 能更好的满足我们的定制化，都有哪些可以定制的呢？ 定制化空值处理请求和返回的数据有很多空值，这些值有时候并没有实际意义，我们可以过滤掉和不返回，或设置成默认值。比如通过重写 getObjectMapper 方法，将返回结果的空值不进行序列化： 1234567converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); return super.getObjectMapper(); &#125;&#125; XSS 脚本攻击为了保证输入的数据更安全，防止 XSS 脚本攻击，我们可以添加自定义反序列化器： 1234567891011121314//对应无法直接返回String类型converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); // XSS 脚本过滤 SimpleModule simpleModule = new SimpleModule(); simpleModule.addDeserializer(String.class, new StringXssDeserializer()); super.getObjectMapper().registerModule(simpleModule); return super.getObjectMapper(); &#125;&#125; 细节分析canRead 和 canWrite 的判断逻辑是什么呢？ 请看下图： 客户端 Request Header 中设置好 Content-Type（传入的数据格式）和Accept（接收的数据格式），根据配置好的MessageConverter来判断是否 canRead 或 canWrite，然后决定 response.body 的 Content-Type 的第一要素是对应的request.headers.Accept 属性的值，又叫做 MediaType。如果服务端支持这个 Accept，那么应该按照这个 Accept 来确定返回response.body 对应的格式，同时把 response.headers.Content-Type 设置成自己支持的符合那个 Accept 的 MediaType 总结与思考站在上帝视角看，整个流程可以按照下图进行概括，请求报文先转换成 HttpInputMessage, 然后再通过 HttpMessageConverter 将其转换成 SpringMVC 的 java 对象，反之亦然。 将各种常用 HttpMessageConverter 支持的MediaType 和 JavaType 以及对应关系总结在此处： 类名 支持的JavaType 支持的MediaType ByteArrayHttpMessageConverter byte[] application/octet-stream, */* StringHttpMessageConverter String text/plain, */* MappingJackson2HttpMessageConverter Object application/json, application/*+json AllEncompassingFormHttpMessageConverter Map&lt;K, List&lt;?&gt;&gt; application/x-www-form-urlencoded, multipart/form-data SourceHttpMessageConverter Source application/xml, text/xml, application/*+xml 最后思考这样一个问题：为什么 HttpMessageConverter 在写的过程中，先判断 canWrite 后判断是否有 responseBodyAdvice 的数据封装呢？ 如果先进行 responseBodyAdvice 的数据封装后判断 canWrite 会怎样呢？ 提高效率工具依旧介绍写该文章用到的一些好的工具 processonProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作，同时您可以把作品分享给团队成员或好友，无论何时何地大家都可以对作品进行编辑、阅读和评论 SequenceDiagramSequenceDiagram 是 IntelliJ IDEA 的一个插件，有了这个插件，你可以 生成简单序列图。 单击图形形状来导航代码。 从图中删除类。 将图表导出为图像。 通过“设置”&gt;“其他设置”&gt;“序列”从图表中排除类 方便快速的定位方法和理解类的调用过程","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"HTTP","slug":"HTTP","permalink":"https://dayarch.top/tags/HTTP/"},{"name":"MessageConverter","slug":"MessageConverter","permalink":"https://dayarch.top/tags/MessageConverter/"}]},{"title":"Java12 Collectors.teeing 的使用详解","slug":"Java12-Collectors-teeing-的使用详解","date":"2019-11-05T08:43:32.000Z","updated":"2019-11-07T06:36:13.203Z","comments":true,"path":"/p/jdk12-collectors-teeing-api-usage.html","link":"","permalink":"https://dayarch.top/p/jdk12-collectors-teeing-api-usage.html","excerpt":"前言 在 Java 12 里面有个非常好用但在官方 JEP 没有公布的功能，因为它只是 Collector 中的一个小改动，它的作用是 merge 两个 collector 的结果，这句话显得很抽象，老规矩，我们先来看个图: 管道改造经常会用这个小东西，通常我们叫它「三通」，它的主要作用就是将 downstream1 和 downstream2 的流入合并，然后从 merger 流出 有了这个形象的说明我们就进入正题吧 Collectors.teeing 上面提到的小功能就是 Collectors.teeing API, 先来看一下 JDK 关于该 API 的说明，看着觉得难受的直接忽","text":"前言在 Java 12 里面有个非常好用但在官方 JEP 没有公布的功能，因为它只是 Collector 中的一个小改动，它的作用是 merge 两个 collector 的结果，这句话显得很抽象，老规矩，我们先来看个图: 管道改造经常会用这个小东西，通常我们叫它「三通」，它的主要作用就是将 downstream1 和 downstream2 的流入合并，然后从 merger 流出 有了这个形象的说明我们就进入正题吧 Collectors.teeing上面提到的小功能就是 Collectors.teeing API, 先来看一下 JDK 关于该 API 的说明，看着觉得难受的直接忽略，继续向下看例子就好了: 1234567891011121314151617181920212223242526272829303132333435363738/** * Returns a &#123;@code Collector&#125; that is a composite of two downstream collectors. * Every element passed to the resulting collector is processed by both downstream * collectors, then their results are merged using the specified merge function * into the final result. * * &lt;p&gt;The resulting collector functions do the following: * * &lt;ul&gt; * &lt;li&gt;supplier: creates a result container that contains result containers * obtained by calling each collector's supplier * &lt;li&gt;accumulator: calls each collector's accumulator with its result container * and the input element * &lt;li&gt;combiner: calls each collector's combiner with two result containers * &lt;li&gt;finisher: calls each collector's finisher with its result container, * then calls the supplied merger and returns its result. * &lt;/ul&gt; * * &lt;p&gt;The resulting collector is &#123;@link Collector.Characteristics#UNORDERED&#125; if both downstream * collectors are unordered and &#123;@link Collector.Characteristics#CONCURRENT&#125; if both downstream * collectors are concurrent. * * @param &lt;T&gt; the type of the input elements * @param &lt;R1&gt; the result type of the first collector * @param &lt;R2&gt; the result type of the second collector * @param &lt;R&gt; the final result type * @param downstream1 the first downstream collector * @param downstream2 the second downstream collector * @param merger the function which merges two results into the single one * @return a &#123;@code Collector&#125; which aggregates the results of two supplied collectors. * @since 12 */public static &lt;T, R1, R2, R&gt;Collector&lt;T, ?, R&gt; teeing(Collector&lt;? super T, ?, R1&gt; downstream1, Collector&lt;? super T, ?, R2&gt; downstream2, BiFunction&lt;? super R1, ? super R2, R&gt; merger) &#123; return teeing0(downstream1, downstream2, merger);&#125; API 描述重的一句话非常关键: Every element passed to the resulting collector is processed by both downstream collectors 结合「三通图」来说明就是，集合中每一个要被传入 merger 的元素都会经过 downstream1 和 downstream2 的加工处理 其中 merger 类型是 BiFunction，也就是说接收两个参数，并输出一个值，请看它的 apply 方法 123456789101112@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123; /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u);&#125; 至于可以如何处理，我们来看一些例子吧 例子为了更好的说明 teeing 的使用，列举了四个例子，看过这四个例子再回看上面的 API 说明，相信你会柳暗花明了 计数和累加先来看一个经典的问题，给定的数字集合，需要映射整数流中的元素数量和它们的和 12345678910111213141516class CountSum &#123; private final Long count; private final Integer sum; public CountSum(Long count, Integer sum) &#123; this.count = count; this.sum = sum; &#125; @Override public String toString() &#123; return \"CountSum&#123;\" + \"count=\" + count + \", sum=\" + sum + '&#125;'; &#125;&#125; 通过 Collectors.teeing 处理 1234567CountSum countsum = Stream.of(2, 11, 1, 5, 7, 8, 12) .collect(Collectors.teeing( counting(), summingInt(e -&gt; e), CountSum::new));System.out.println(countsum.toString()); downstream1 通过 Collectors 的静态方法 counting 进行集合计数 downstream2 通过 Collectors 的静态方法 summingInt 进行集合元素值的累加 merger 通过 CountSum 构造器收集结果 运行结果: CountSum{count=7, sum=46} 我们通过 teeing 一次性得到我们想要的结果，继续向下看其他例子: 最大值与最小值通过给定的集合， 一次性计算出集合的最大值与最小值，同样新建一个类 MinMax，并创建构造器用于 merger 收集结果 12345678910111213141516class MinMax &#123; private final Integer min; private final Integer max; public MinMax(Integer min, Integer max) &#123; this.min = min; this.max = max; &#125; @Override public String toString() &#123; return \"MinMax&#123;\" + \"min=\" + min + \", max=\" + max + '&#125;'; &#125;&#125; 通过 teeing API 计算结果: 1234567MinMax minmax = Stream.of(2, 11, 1, 5, 7, 8, 12) .collect(Collectors.teeing( minBy(Comparator.naturalOrder()), maxBy(Comparator.naturalOrder()), (Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) -&gt; new MinMax(a.orElse(Integer.MIN_VALUE), b.orElse(Integer.MAX_VALUE))));System.out.println(minmax.toString()); downstream1 通过 Collectors 的静态方法 minBy，通过 Comparator 比较器按照自然排序找到最小值 downstream2 通过 Collectors 的静态方法 maxBy，通过 Comparator 比较器按照自然排序找到最大值 merger 通过 MinMax 构造器收集结果，只不过为了应对 NPE，将 BiFunction 的两个入参经过 Optional 处理 运行结果: MinMax{min=1, max=12} 为了验证一下 Optional，我们将集合中添加一个 null 元素，并修改一下排序规则来看一下排序结果: 12345MinMax minmax = Stream.of(null, 2, 11, 1, 5, 7, 8, 12) .collect(Collectors.teeing( minBy(Comparator.nullsFirst(Comparator.naturalOrder())), maxBy(Comparator.nullsLast(Comparator.naturalOrder())), (Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) -&gt; new MinMax(a.orElse(Integer.MIN_VALUE), b.orElse(Integer.MAX_VALUE)))); downstream1 处理规则是将 null 放在排序的最前面 downstream2 处理规则是将 null 放在排序的最后面 merger 处理时，都会执行 optional.orElse 方法，分别输出最小值与最大值 运行结果: MinMax{min=-2147483648, max=2147483647} 瓜的总重和单个重量接下来举一个更贴合实际的操作对象的例子 1234567891011121314151617181920212223242526272829303132333435// 定义瓜的类型和重量class Melon &#123; private final String type; private final int weight; public Melon(String type, int weight) &#123; this.type = type; this.weight = weight; &#125; public String getType() &#123; return type; &#125; public int getWeight() &#123; return weight; &#125;&#125;// 总重和单个重量列表class WeightsAndTotal &#123; private final int totalWeight; private final List&lt;Integer&gt; weights; public WeightsAndTotal(int totalWeight, List&lt;Integer&gt; weights) &#123; this.totalWeight = totalWeight; this.weights = weights; &#125; @Override public String toString() &#123; return \"WeightsAndTotal&#123;\" + \"totalWeight=\" + totalWeight + \", weights=\" + weights + '&#125;'; &#125;&#125; 通过 teeing API 计算总重量和单个列表重量 123456789101112131415List&lt;Melon&gt; melons = Arrays.asList(new Melon(\"Crenshaw\", 1200), new Melon(\"Gac\", 3000), new Melon(\"Hemi\", 2600), new Melon(\"Hemi\", 1600), new Melon(\"Gac\", 1200), new Melon(\"Apollo\", 2600), new Melon(\"Horned\", 1700), new Melon(\"Gac\", 3000), new Melon(\"Hemi\", 2600));WeightsAndTotal weightsAndTotal = melons.stream() .collect(Collectors.teeing( summingInt(Melon::getWeight), mapping(m -&gt; m.getWeight(), toList()), WeightsAndTotal::new));System.out.println(weightsAndTotal.toString()); downstream1 通过 Collectors 的静态方法 summingInt 做重量累加 downstream2 通过 Collectors 的静态方法 mapping 提取出瓜的重量，并通过流的终结操作 toList() 获取结果 merger 通过 WeightsAndTotal 构造器获取结果 运行结果: WeightsAndTotal{totalWeight=19500, weights=[1200, 3000, 2600, 1600, 1200, 2600, 1700, 3000, 2600]} 继续一个更贴合实际的例子吧: 预约人员列表和预约人数12345678910111213141516171819202122232425262728293031323334353637383940class Guest &#123; private String name; private boolean participating; private Integer participantsNumber; public Guest(String name, boolean participating, Integer participantsNumber) &#123; this.name = name; this.participating = participating; this.participantsNumber = participantsNumber; &#125; public boolean isParticipating() &#123; return participating; &#125; public Integer getParticipantsNumber() &#123; return participantsNumber; &#125; public String getName() &#123; return name; &#125;&#125;class EventParticipation &#123; private List&lt;String&gt; guestNameList; private Integer totalNumberOfParticipants; public EventParticipation(List&lt;String&gt; guestNameList, Integer totalNumberOfParticipants) &#123; this.guestNameList = guestNameList; this.totalNumberOfParticipants = totalNumberOfParticipants; &#125; @Override public String toString() &#123; return \"EventParticipation &#123; \" + \"guests = \" + guestNameList + \", total number of participants = \" + totalNumberOfParticipants + \" &#125;\"; &#125;&#125; 通过 teeing API 处理 12345678910var result = Stream.of( new Guest(\"Marco\", true, 3), new Guest(\"David\", false, 2), new Guest(\"Roger\",true, 6)) .collect(Collectors.teeing( Collectors.filtering(Guest::isParticipating, Collectors.mapping(Guest::getName, Collectors.toList())), Collectors.summingInt(Guest::getParticipantsNumber), EventParticipation::new ));System.out.println(result); downstream1 通过 filtering 方法过滤出确定参加的人，并 mapping 出他们的姓名，最终放到 toList 集合中 downstream2 通过 summingInt 方法计数累加 merger 通过 EventParticipation 构造器收集结果 其中我们定义了 var result 来收集结果，并没有指定类型，这个语法糖也加速了我们编程的效率 运行结果: EventParticipation { guests = [Marco, Roger], total number of participants = 11 } 总结其实 teeing API 就是灵活应用 Collectors 里面定义的静态方法，将集合元素通过 downstream1 和 downstream2 进行处理，最终通过 merger 收集起来，当项目中有同时获取两个收集结果时，是时候应用我们的 teeing API 了 灵魂追问 Collectors 里面的静态方法你应用的熟练吗？ 项目中你们在用 JDK 的版本是多少？ Lambda 的使用熟练吗？ 你的灯还亮着吗？","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://dayarch.top/tags/Java/"},{"name":"JDK源码","slug":"JDK源码","permalink":"https://dayarch.top/tags/JDK%E6%BA%90%E7%A0%81/"}]},{"title":"Java并发死锁解决思路","slug":"Java并发死锁解决思路","date":"2019-10-18T06:01:20.000Z","updated":"2019-11-07T06:36:28.719Z","comments":true,"path":"/p/java-concurrency-dead-lock.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-dead-lock.html","excerpt":"写在前面 上一篇文章共享资源那么多，如何用一把锁保护多个资源？ 文章我们谈到了银行转账经典案例，其中有两个问题: 1. 单纯的用 synchronized 方法起不到保护作用(不能保护 target) 2. 用 Account.class 锁方案，锁的粒度又过大，导致涉及到账户的所有操作(取款，转账，修改密码等)都会变成串行操作 如何解决这两个问题呢？咱们先换好衣服穿越回到过去寻找一下钱庄，一起透过现象看本质，dengdeng deng……. 来到钱庄，告诉柜员你要给铁蛋儿转 100 铜钱，这时柜员转身在墙上寻找你和铁蛋儿的账本，此时柜员可能面临三种情况: 1. 理想状态:","text":"写在前面上一篇文章共享资源那么多，如何用一把锁保护多个资源？ 文章我们谈到了银行转账经典案例，其中有两个问题: 单纯的用 synchronized 方法起不到保护作用(不能保护 target) 用 Account.class 锁方案，锁的粒度又过大，导致涉及到账户的所有操作(取款，转账，修改密码等)都会变成串行操作 如何解决这两个问题呢？咱们先换好衣服穿越回到过去寻找一下钱庄，一起透过现象看本质，dengdeng deng……. 来到钱庄，告诉柜员你要给铁蛋儿转 100 铜钱，这时柜员转身在墙上寻找你和铁蛋儿的账本，此时柜员可能面临三种情况: 理想状态: 你和铁蛋儿的账本都是空闲状态，一起拿回来，在你的账本上减 100 铜钱，在铁蛋儿账本上加 100 铜钱，柜员转身将账本挂回到墙上，完成你的业务 尴尬状态: 你的账本在，铁蛋儿的账本被其他柜员拿出去给别人转账，你要等待其他柜员把铁蛋儿的账本归还 抓狂状态: 你的账本不在，铁蛋儿的账本也不在，你只能等待两个账本都归还 放慢柜员的取账本操作，他一定是先拿到你的账本，然后再去拿铁蛋儿的账本，两个账本都拿到(理想状态)之后才能完成转账，用程序模型来描述一下这个拿取账本的过程: 我们继续用程序代码描述一下上面这个模型: 12345678910111213141516class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; // 锁定转出账户 synchronized(this) &#123; // 锁定转入账户 synchronized(target) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; &#125; 这个解决方案看起来很完美，解决了文章开头说的两个问题，但真是这样吗？ 我们刚刚说过的理想状态是钱庄只有一个柜员(既单线程)。随着钱庄规模变大，墙上早已挂了非常多个账本，钱庄为了应对繁忙的业务，开通了多个窗口，此时有多个柜员(多线程)处理钱庄业务。 柜员 1 正在办理给铁蛋儿转账的业务，但只拿到了你的账本；柜员 2 正在办理铁蛋儿给你转账的业务，但只拿到了铁蛋儿的账本，此时双方出现了尴尬状态，两位柜员都在等待对方归还账本为当前客户办理转账业务。 现实中柜员会沟通，喊出一嗓子 老铁，铁蛋儿的账本先给我用一下，用完还给你，但程序却没这么智能，synchronized 内置锁非常执着，它会告诉你「死等」的道理，最终出现死锁 Java 有了 synchronized 内置锁，还发明了显示锁 Lock，是不是就为了治一治 synchronized 「死等」的执着呢？😏 解决方案如何解决上面的问题呢？正所谓知己知彼方能百战不殆，我们要先了解什么情况会发生死锁，才能知道如何避免死锁，很幸运我们可以站在巨人的肩膀上看待问题 Coffman 总结出了四个条件说明可以发生死锁的情形: Coffman 条件互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不可剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P1，P2，···，Pn}中的 P1 正在等待一个 P2 占用的资源；P2 正在等待 P3 占用的资源，……，Pn 正在等待已被 P0 占用的资源。 这几个条件很好理解，其中「互斥条件」是并发编程的根基，这个条件没办法改变。但其他三个条件都有改变的可能，也就是说破坏另外三个条件就不会出现上面说到的死锁问题 破坏请求和保持条件每个柜员都可以取放账本，很容易出现互相等待的情况。要想破坏请求和保持条件，就要一次性拿到所有资源。 作为程序猿你一定听过这句话: 任何软件工程遇到的问题都可以通过增加一个中间层来解决 我们不允许柜员都可以取放账本，账本要由单独的账本管理员来管理 也就是说账本管理员拿取账本是临界区，如果只拿到其中之一的账本，那么不会给柜员，而是等待柜员下一次询问是否两个账本都在 123456789101112131415161718192021222324252627282930313233343536373839404142//账本管理员public class AccountBookManager &#123; synchronized boolean getAllRequiredAccountBook( Object from, Object to)&#123; if(拿到所有账本)&#123; return true; &#125; else&#123; return false; &#125; &#125; // 归还资源 synchronized void releaseObtainedAccountBook(Object from, Object to)&#123; 归还获取到的账本 &#125;&#125;public class Account &#123; //单例的账本管理员 private AccountBookManager accountBookManager; public void transfer(Account target, int amt)&#123; // 一次性申请转出账户和转入账户，直到成功 while(!accountBookManager.getAllRequiredAccountBook(this, target))&#123; return; &#125; try&#123; // 锁定转出账户 synchronized(this)&#123; // 锁定转入账户 synchronized(target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; finally &#123; accountBookManager.releaseObtainedAccountBook(this, target); &#125; &#125;&#125; 破坏不可剥夺条件上面已经给了你小小的提示，为了解决内置锁的执着，Java 显示锁支持通知(notify/notifyall)和等待(wait)，也就是说该功能可以实现喊一嗓子 老铁，铁蛋儿的账本先给我用一下，用完还给你 的功能，这个后续将到 Java SDK 相关内容时会做说明 破坏环路等待条件破坏环路等待条件也很简单，我们只需要将资源序号大小排序获取就会解决这个问题，将环路拆除 继续用代码来说明: 123456789101112131415161718192021222324class Account &#123; private int id; private int balance; // 转账 void transfer(Account target, int amt)&#123; Account smaller = this Account larger = target; // 排序 if (this.id &gt; target.id) &#123; smaller = target; larger = this; &#125; // 锁定序号小的账户 synchronized(smaller)&#123; // 锁定序号大的账户 synchronized(larger)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; &#125; 当 smaller 被占用时，其他线程就会被阻塞，也就不会存在死锁了. 附加说明在实际业务中，关于 Account 都会是数据库对象，我们可以通过事务或数据库的乐观锁来解决的。另外分布式系统中，账本管理员这个角色的处理也可能会用 redis 分布式锁来解决. 在处理破坏请求和保持条件时，我们使用的是 while 循环方式来不断请求锁的时候，在实际业务中，我们会有 timeout 的设置，防止无休止的浪费 CPU 使用率 另外大家可以尝试使用阿里开源工具 Arthas 来查看 CPU 使用率，线程等相关问题，github 上有明确的说明 总结计算机的计算能力远远超过人类，但是他的智慧还需要有带提高，当看待并发问题时，我们往往认为人类的最基本沟通计算机也可以做到，其实不然，还是那句话，编写并发程序，要站在计算机的角度来看待问题 粗粒度锁我们不提倡，所以会使用细粒度锁，但使用细粒度锁的时候，我们要严格按照 Coffman 的四大条件来逐条判断，这样再应用我们这几个解决方案来解决就好了 灵魂追问 破坏请求和保持条件时，处理能力的瓶颈在账本管理员那里，那你觉得这种处理方式会提高并发量吗？ 破坏请求保持条件的方法和破坏环路等待的方法，你觉得那种方式更好 破坏请求和保持条件时，如果代码换成下面的样子会发生什么？ 12345678910111213141516171819public void transfer(Account target, int amt)&#123; // 一次性申请转出账户和转入账户，直到成功 while(accountBookManager.getAllRequiredAccountBook(this, target))&#123;&#125; try&#123; // 锁定转出账户 synchronized(this)&#123; // 锁定转入账户 synchronized(target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; finally &#123; accountBookManager.releaseObtainedAccountBook(this, target); &#125; &#125;&#125; 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"死锁","slug":"死锁","permalink":"https://dayarch.top/tags/%E6%AD%BB%E9%94%81/"},{"name":"锁粒度","slug":"锁粒度","permalink":"https://dayarch.top/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"}]},{"title":"Spring Boot 自定义starter 全面教程","slug":"Spring-Boot-自定义starter-全面教程","date":"2019-10-15T11:35:53.000Z","updated":"2019-11-07T06:24:19.750Z","comments":true,"path":"/p/spring-boot-starter-custom.html","link":"","permalink":"https://dayarch.top/p/spring-boot-starter-custom.html","excerpt":"写在前面 我们每次构建一个 Spring 应用程序时，我们都不希望从头开始实现具有「横切关注点」的内容；相反，我们希望一次性实现这些功能，并根据需要将它们包含到任何我们要构建的应用程序中 横切关注点 横切关注点: 指的是一些具有横越多个模块的行为 (来自维基百科的介绍) 说白了就是多个项目或模块都可以用到的内容，比如一个 SDK 在Spring Boot中，用于表示提供这种横切关注点的模块的术语是 starter，通过依赖 starter 可以轻松使用其包含的一些功能特性，无论你的工作中是否会构建自己的 starter，你都要具有构建 「starter」的思想，本文将结合 Spring","text":"写在前面我们每次构建一个 Spring 应用程序时，我们都不希望从头开始实现具有「横切关注点」的内容；相反，我们希望一次性实现这些功能，并根据需要将它们包含到任何我们要构建的应用程序中 横切关注点 横切关注点: 指的是一些具有横越多个模块的行为 (来自维基百科的介绍) 说白了就是多个项目或模块都可以用到的内容，比如一个 SDK 在Spring Boot中，用于表示提供这种横切关注点的模块的术语是 starter，通过依赖 starter 可以轻松使用其包含的一些功能特性，无论你的工作中是否会构建自己的 starter，你都要具有构建 「starter」的思想，本文将结合 Spring Boot 官方标准构建一个简单的 starter 自定义 starter在我们深入了解如何自定义 starter 之前，为了更好的理解我们每一步在干什么，以及 starter 是如何起作用的，我们先从宏观角度来看 starter 的结构组成到底是什么样的 通常一个完整的 starter 需要包含下面两个组件: Auto-Configure Module Starter Module 如果你看下面这两个组件的解释有些抽象，大概了解一下，阅读完该文章回看这里就会豁然开朗了 Auto-Configure ModuleAuto-Configure Module (自动配置模块) 是包含自动配置类的 Maven 或 Gradle 模块。通过这种方式，我们可以构建可以自动贡献于应用程序上下文的模块，以及添加某个特性或提供对某个外部库的访问 Starter ModuleSpring Boot Starter 是一个 Maven 或 Gradle 模块，其唯一目的是提供 “启动” 某个特性所需的所有依赖项。可以包含一个或多个 Auto-Configure Module (自动配置模块)的依赖项，以及可能需要的任何其他依赖项。这样，在Spring 启动应用程序中，我们只需要添加这个 starter 依赖就可以使用其特性 ⚠️: Spring 官方参考手册建议将自动配置分离，并将每个自动配置启动到一个独立的 Maven 或 Gradle 模块中，从而将自动配置和依赖项管理分离开来。如果你没有建立一个供成千上万用户使用的开源库，也可以将二者合并到一个 module 中 You may combine the auto-configuration code and the dependency management in a single module if you do not need to separate those two concerns 命名来自 Spring 官方的 starter 都是 以 spring-boot-starter 开头，比如: spring-boot-starter-web spring-boot-starter-aop 如果我们自定义 starter 功能名称叫acme，那么我们的命名是这样的: acme-spring-boot-starter acme-spring-boot-autoconfigure 如果 starter 中用到了配置 keys，也要注意不要使用 Spring Boot 使用的命名空间，比如(server，management，spring) Parent Module 创建先来全局看一下项目结构:一级目录结构: 12345.├── pom.xml├── rgyb-spring-boot-autoconfigure├── rgyb-spring-boot-sample└── rgyb-spring-boot-starter 二级目录结构: 1234567891011.├── pom.xml├── rgyb-spring-boot-autoconfigure│ ├── pom.xml│ └── src├── rgyb-spring-boot-sample│ ├── pom.xml│ └── src└── rgyb-spring-boot-starter ├── pom.xml └── src 创建一个空的父亲 Maven Module，主要提供依赖管理，这样 SubModule 不用单独维护依赖版本号，来看 pom.xml 内容: 12345678910111213&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 添加其他全局依赖管理到这里，submodule默认不引入这些依赖，需要显式的指定 --&gt;&lt;/dependencyManagement&gt; Auto-Configure Module 构建新建类 GreetingAutoConfiguration 12345678@Configurationpublic class GreetingAutoConfiguration &#123; @Bean public GreetingService greetingService(GreetingProperties greetingProperties)&#123; return new GreetingService(greetingProperties.getMembers()); &#125;&#125; 我们用 @Configuration 注解标记类 GreetingAutoConfiguration，作为 starter 的入口点。这个配置包含了我们需要提供starter特性的所有 @Bean 定义，在本例中，为了简单阐述问题，我们只将 GreetingService Bean 添加到应用程序上下文 GreetingService 内容如下: 123456789@AllArgsConstructorpublic class GreetingService &#123; private List&lt;String&gt; members = new ArrayList&lt;&gt;(); public void sayHello()&#123; members.forEach(s -&gt; System.out.println(\"hello \" + s)); &#125;&#125; 在 resources 目录下新建文件 META-INF/spring.factories (如果目录 META-INF 不存在需要手工创建)，向文件写入内容: 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ top.dayarch.autoconfigure.GreetingAutoConfiguration Spring 启动时会在其 classpath 中所有的 spring.factoreis 文件，并加载里面的声明配置，GreetingAutoConfiguration 类就绪后，我们的 Spring Boot Starter 就有了一个自动激活的入口点 到这里这个 “不完全的 starter” 已经可以使用了。但因为它是自动激活的，为了个让其灵活可用，我们需要让其按照我们的意愿来激活使用，所以我们需要条件注解来帮忙 条件配置为类添加两个条件注解: 123456@Configuration@ConditionalOnProperty(value = \"rgyb.greeting.enable\", havingValue = \"true\")@ConditionalOnClass(DummyEmail.class)public class GreetingAutoConfiguration &#123; ...&#125; 通过使用 @ConditionalOnProperty 注解，我们告诉 Spring，只有属性 rgyb.greeting.enable 值被设置为 true 时，才将 GreetingAutoConfiguration (以及它声明的所有 bean ) 包含到应用程序上下文中 通过使用 @ConditionalOnClass 注解，我们告诉Spring 只有类 DummyEmail.class 存在于 classpath 时，才将 GreetingAutoConfiguration (以及它声明的所有 bean ) 包含到应用程序上下文中 多个条件是 and/与的关系，既只有满足全部条件时，才会加载 GreetingAutoConfiguration 如果你对条件注解的使用还不是很明确，可以查看我之前的文章: @Conditional注解，灵活配置 Spring Boot 配置属性管理上面使用了 @ConditionalOnProperty 注解，实际 starter 中可能有非常多的属性，所以我们需要将这些属性集中管理: 1234567891011121314@Data@ConfigurationProperties(prefix = \"rgyb.greeting\")public class GreetingProperties &#123; /** * GreetingProperties 开关 */ boolean enable = false; /** * 需要打招呼的成员列表 */ List&lt;String&gt; members = new ArrayList&lt;&gt;();&#125; 我们知道这些属性是要在 application.yml 中使用的，当我们需要使用这些属性时，为了让 IDE 给出更友好的提示，我们需要在 pom.xml 中添加依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这样当我们 mvn compile 时，会在生成一个名为 spring-configuration-metadata.json JSON 文件，文件内容如下: 生成的内容在接下来的内容中用到，且看 提升启动时间对于类路径上的每个自动配置类，Spring Boot 必须计算 @Conditional… 条件值，用于决定是否加载自动配置及其所需的所有类，根据 Spring 启动应用程序中 starter 的大小和数量，这可能是一个非常昂贵的操作，并且会影响启动时间，为了提升启动时间，我们需要在 pom.xml 中添加另外一个依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这个注解会生成一个名为 spring-autoconfigure-metadata.properties Property 文件，其内容如下: 这样，Spring Boot 在启动期间读取这些元数据，可以过滤出不满足条件的配置，而不必实际检查这些类，提升启动速度 到这里关于 Auto-Configure Module 就构建完了，我们需要继续完成 Starter Module 的构建 Starter Module 构建Starter Module 的构建很简单了，你可以认为它就是一个空 module，除了依赖 Auto-Configure Module，其唯一作用就是为了使用 starter 功能特性提供所有必须依赖，所以我们为 starter module 的 pom.xml 文件添加如下内容: 123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.dayarch.learnings&lt;/groupId&gt; &lt;artifactId&gt;rgyb-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 在此处添加其他必要依赖，保证starter可用 --&gt;&lt;/dependencies&gt; 同样在 resources 目录下新建文件 META-INF/spring.providers , 其内容如下: 1providers: rgyb-spring-boot-autoconfigure 该文件主要作用是说明 starter module 的依赖信息，多个依赖以逗号分隔就好，该文件不会影响 starter 的使用，可有可无 Starter Module 就可以这么简单，将两个 module 分别 mvn install 到本地 Maven Repository，接下来我们创建 sample module 引入这个 starter 依赖时就会从本地 Maven Repository 中拉取 创建 Sample Module我们可以通过 Spring Initializr 正常初始化一个 Spring Boot 项目 (rgyb-spring-boot-sample)，引入我们刚刚创建的 starter 依赖，在 sample pom.xml 中添加依赖: 12345&lt;dependency&gt; &lt;groupId&gt;top.dayarch.learnings&lt;/groupId&gt; &lt;artifactId&gt;rgyb-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 接下来配置 application.yml 属性 123456rgyb: greeting: enable: true members: - 李雷 - 韩梅梅 在我们配置 YAML 的时候，会出现下图的提示，这样会更友好，当然为了规范，属性描述最好也用英文描述，这里为了说明问题用了中文描述: 编写测试类我们编写测试用例: 1234567@Autowired(required = false)private GreetingService greetingService;@Testpublic void testGreeting() &#123; greetingService.sayHello();&#125; 测试结果如下: 12hello 李雷hello 韩梅梅 总结到这里完整的 starter 开发就结束了，希望大家了解其构建过程，目录结构及命名等标准，这样有相应的业务需求时都可以开发自己的 starter 被其他人应用起来 starter 开发好了，别人可以手动添加依赖引入 starter 的相关功能，那我们如何像 Spring Initializr 一样，通过下来菜单选择我们的 starter 呢，这样直接初始化好整个项目，接下来的文章我们会模仿 Spring Initializr 自定义我们自的 Initializr 知识点说明Dependency optinal 为什么 Auto-Configure Module 的 dependency 都是 optional = true 呢？这涉及到 Maven 传递性依赖的问题，详情请看 Maven 依赖传递性透彻理解 spring.factories Spring Boot 是如何加载这个文件并找到我们的配置类的下图是 Spring Boot 应用程序启动的调用栈的一部分，我添加了断点: 打开 SpringFactoriesLoader 类，映入眼帘的就是这个内容: 这两张图应该足够说明问题了，是 SPI 的一种加载方式，更细节的内容请大家自己去发现吧 实际案例这里推荐查看 mybatis-spring-boot-starter 这个非 Spring 官方的案例，从中我们: 模仿其目录结构 模仿其设计理念 模仿其编码规范 另外，本文的案例我已上传，公众号回复「demo」，打开链接，查看 customstarter 目录下内容即可 灵魂追问 在生成 spring-autoconfigure-metadata.properties 文件时，为什么 @ConditionalOnProperty 的内容没有被写进去 如果我们要将依赖上传至 remote central repository，你知道怎样搭建自己的 maven repository 吗？ 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"Starter","slug":"Starter","permalink":"https://dayarch.top/tags/Starter/"}]},{"title":"Maven 依赖传递性透彻理解","slug":"Maven-optional-依赖透彻理解","date":"2019-10-11T07:36:38.000Z","updated":"2019-11-07T06:36:38.010Z","comments":true,"path":"/p/maven-dependency-optional-transitive.html","link":"","permalink":"https://dayarch.top/p/maven-dependency-optional-transitive.html","excerpt":"写在前面 本来想写一篇「如何自定义Spring Boot Starter」，但是为了更好理解 Starter 的一些设计理念和其中的关键点，所以提前将一些细节内容单独提取出来讲解说明 在 Maven pom.xml 中，你经常会看到依赖项中有类似下面的代码: 1 2 3 4 5 6 7 sample.ProjectA Project-A 1.0 compile tru","text":"写在前面本来想写一篇「如何自定义Spring Boot Starter」，但是为了更好理解 Starter 的一些设计理念和其中的关键点，所以提前将一些细节内容单独提取出来讲解说明 在 Maven pom.xml 中，你经常会看到依赖项中有类似下面的代码: 1234567&lt;dependency&gt; &lt;groupId&gt;sample.ProjectA&lt;/groupId&gt; &lt;artifactId&gt;Project-A&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 这里的 &lt;optional&gt;true&lt;/optional&gt; 是什么意思呢？ optional 关键字的奥秘老规矩，画个图说明问题: 由于 project C 使用到了两个来自 project A 的类 (OptionalFeatureAClass) 和 project B 的类 (OptionalFeatureBClass). 如果 project C 没有依赖 packageA 和 packageB，那么编译将会失败。 project D 依赖 project C，但是对于 project D 来说，类 (OptionalFeatureAClass) 和类 (OptionalFeatureBClass) 是可选的特性，所以为了让最终的 war/ejb package 不包含不必要的依赖，使用&lt;optional&gt; 声明当前依赖是可选的, 默认情况下也不会被其他项目继承(好比 Java 中的 final 类，不能被其他类继承一样) 如果 project D 确实需要用到 project C 中的 OptionalFeatureAClass 怎么办呢？那我们就需要在 project D 的 pom.xml 中显式的添加声明 project A 依赖，继续看下图: Project D 需要用到 Project A 的 OptionalFeatureAClass，那么需要在 Project D 的 pom.xml 文件中显式的添加对 Project A 的依赖 到这也就很好理解为什么 Maven 为什么要设计 optional 关键字了，假设一个关于数据库持久化的项目(Project C), 为了适配更多类型的数据库持久化设计，比如 Mysql 持久化设计(Project A) 和 Oracle 持久化设计(Project B)，当我们的项目(Project D) 要用的 Project C 的持久化设计，不可能既引入 mysql 驱动又引入 oracle 驱动吧，所以我们要显式的指定一个，就是这个道理了 实际案例在 spring-boot-actuator pom.xml 文件中，有超过 20 个依赖是 optional 因为 Spring Boot 不可能将没必要的依赖也打包到你最终的 jar package 中，所以用到 spring boot actuator 的项目最终生成的 jar package 中不会包含这 20 多个依赖 jar，如果你要用到哪一个，显式的加入到你的项目就好了 在接下来的文章，自定义 Spring Boot Starter 也是这个策略，因为 starter 是包含特定功能为其他项目服务用的，类似本文的 Project C 的角色了，到这里你理解 optional 的奥秘了吗？ 反向应用如果 Project C 引入的依赖没有加 &lt;optional&gt;true&lt;/optional&gt;，Project D 又需要依赖 Project C，但只用到 Project A 的类怎么办呢？Maven 也是有解决办法的，使用 exclusion 关键字，不多说，上一段代码就懂了: 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;top.dayarch.demo&lt;/groupId&gt; &lt;artifactId&gt;Project-C&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;top.dayarch.demo&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 总结到这里，在你今后设计功能性依赖时，你应该明白怎样设计依赖关系了, 我这里推荐使用 optional 的形式，简单来说，你设计的依赖什么菜都有，想吃什么菜自己 “抱蔡明” 就好，接下来我们就模拟官方标准创建自定义的 starter…… 灵魂追问 有很多童鞋项目组用的构建工具时 Gradle，你知道 Gradle 中是怎样表示的吗？ 自定义 starter，你知道官方标准 starter 的结构是什么样的吗？ 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://dayarch.top/tags/Maven/"}]},{"title":"锁保护资源，synchronized方法就够了吗","slug":"锁保护资源，synchronized方法就够了吗","date":"2019-10-10T06:17:23.000Z","updated":"2019-11-07T06:38:28.104Z","comments":true,"path":"/p/java-concurrency-lock-resource.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-lock-resource.html","excerpt":"写在前面 上一篇文章原子性问题的宏观理解 带领大家了解了锁和资源的模型，有了这篇文章的铺垫，相信理解这一篇文章就非常轻松了 当我们要保护单个资源并对其进行修改其实很简单，只需按照下图分三步走 1. 创建受保护资源 R 的锁 2. 加锁进入临界区 3. 解锁走出临界区 上图的关键是「R1 的锁保护 R1」的指向关系是否正确 如果都是保护单个资源这样简单，程序猿的世界该有多美好，可惜并不是，通常我们需要保护多个资源 保护多个资源 保护多个没有关系的资源 如果多个资源没有关系，那就是保护一个资源模型的复制，同样非常简单，且看下图: 比如现实中银行取款和修改密码操作。 银行取","text":"写在前面上一篇文章原子性问题的宏观理解 带领大家了解了锁和资源的模型，有了这篇文章的铺垫，相信理解这一篇文章就非常轻松了 当我们要保护单个资源并对其进行修改其实很简单，只需按照下图分三步走 创建受保护资源 R 的锁 加锁进入临界区 解锁走出临界区 上图的关键是「R1 的锁保护 R1」的指向关系是否正确 如果都是保护单个资源这样简单，程序猿的世界该有多美好，可惜并不是，通常我们需要保护多个资源 保护多个资源保护多个没有关系的资源如果多个资源没有关系，那就是保护一个资源模型的复制，同样非常简单，且看下图: 比如现实中银行取款和修改密码操作。银行取款操作对应的资源是「余额」, 修改密码操作对应的资源是「密码」，余额和密码两个资源完全没有关系，所以各自用自家的锁保护自家的资源就好了 如果多个资源没有关系，程序猿的世界该有多美好，可惜并不是，我们保护的资源多数情况都有关联关系 保护多个关系的资源拿经典的银行转账案例来说明，账户 A 给账户 B 转账，账户 A 余额减少 100 元，账户 B 余额增加 100 元，这个操作要是原子性的，那么资源「A 余额」和资源「B 余额」就这样”有了关系”，先来看程序: 1234567891011class Account &#123; private int balance; // 转账 synchronized void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; 用 synchronized 直接保护 transfer 方法，然后操作资源「A 余额」和资源「B 余额」就可以了 ⚠️: 真的是这样吗？ 先停止向下看，在你的笔记本上按照文章开头的三步走来画个图看一看，是否和下图一样呢？ 我们通常容易忽略锁和资源的指向关系，我们想当然的用锁 this 来保护 target 资源了，也就没有起到保护作用 假设 A，B，C 账户初始余额都是 200 原，A 向 B 转账 100，B 向 C 转账 100 我们期盼最终的结果是:账户 A 余额: 100 元账户 B 余额: 200 元账户 C 余额: 300 元 假线程 1「A 向 B 转账」与线程 2「B 向 C 转账」两个操作同时执行，根据 JMM 模型可知，线程 1 和线程 2 读取线程 B 当前的余额都是 200 元: 线程 1 执行 transfer 方法锁定的是 A 的实例(A.this)，并没有锁定 B 的实例 线程 2 执行 transfer 方法锁定的是 B 的实例(B.this)，并没有锁定 C 的实例 所以线程 1 和线程 2 可以同时进入 transfer 临界区，上面你认为对的模型其实就会变成这个样子: 还记得 happens-before 规则 这篇文章提到的监视器锁规则和传递性规则吗？ ####监视器锁规则 对一个锁的解锁 happens-before 于随后对这个锁的加锁####传递性规则如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C 资源 B.balance 存在于两个”临界区”中，所以这个”临界区”对 B.balance 来说形同虚设，也就不满足监视器锁规则，进而导致传递性规则也不生效，说白了，前序线程的更改结果对后一个线程不可见 这样最终导致: 账户 B 的余额可能是 100: ** 线程 1 写 B.balance 100(balance = 300) **先于 线程 2 写 B.balance(balance = 100)，也就是说线程 1 的结果会被线程 2 覆盖，导致最终账户 B 的余额为 100 账户 B 的余额可能是 300: 与上述情况相反，线程 1 写 B.balance 100(balance = 300) 后于 线程 2 写 B.balance(balance = 100)，也就是说线程 2 的结果线程 1 覆盖，导致最终账户 B 的余额为 300 就是不能得到我们理想结果 200，感觉生活无比的艰难，那怎么办呢？ 正确姿势上面的问题就是为资源创建的锁不能保护所有关联的资源，那我们就想办法解决这个问题，来看下面代码: 123456789101112class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; synchronized(Account.class) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; 我们将 this 锁变为 Account.class 锁，Account.class 是虚拟机加载 Account 类时创建的，肯定是唯一的(双亲委派模型解释了为何该对象是唯一的)， 所有 Account 对象都共享 Account.class, 也就是说，Account.class 锁能保护所有 Account 对象，我们将上面程序再用模型解释一下 总结到这里关于锁和资源的关系你应该了解的更加透彻了，单个资源和多个无关联资源的情形都很好处理，为各自资源创建相应的锁就好，如果多个资源有关联，为了让锁起到保护作用，我们需要将锁的粒度变大，比如将 this 锁变成了 Account.class 锁。 转账业务非常常见，并发量非常大，如果我们将锁的粒度都提升到 Account.class 这个级别(分久必合)，假设每次转账业务都很耗时，那么显然这个锁的性能是比较低的，所以接下来的文章，我们还会继续优化这个模型，选择合适的锁粒度，同时能保护多个有关联的资源， 我们的锁粒度虽然大，但是我们保障了账户的安全，所以并发编程可以先保证事情做对，遇到瓶颈了，慢慢优化改变相应的模型就好了，当然熟练理解这个模型以后，一步到位的并发编程模型当然是极好的…… 灵魂追问 还记得 happens-before 的几个原则吗？ 偏向锁，轻量锁，重量锁是不是和我们这节内容有异曲同工之处呢？ 提前想一下，我们如何来优化这个模型呢？ 附加说明如果你对这篇文章理解有些困难，可以按照下面的顺序回忆前序文章相关内容 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 EasyExcel 读取 excel 真的很easy 红黑树，超强动静图详解，简单易懂 提高效率工具 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://dayarch.top/tags/%E9%94%81/"}]},{"title":"EasyExcel读取Excel实际应用","slug":"EasyExcel读取Excel实际应用","date":"2019-10-07T10:32:34.000Z","updated":"2019-12-15T13:04:40.165Z","comments":true,"path":"/p/easyexcel-read.html","link":"","permalink":"https://dayarch.top/p/easyexcel-read.html","excerpt":"写在前面 Java 后端程序员应该会遇到读取 Excel 信息到 DB 等相关需求，脑海中可能突然间想起 Apache POI 这个技术解决方案，但是当 Excel 的数据量非常大的时候，你也许发现，POI 是将整个 Excel 的内容全部读出来放入到内存中，所以内存消耗非常严重，如果同时进行包含大数据量的 Excel 读操作，很容易造成内存溢出问题 但 EasyExcel 的出现很好的解决了 POI 相关问题，原本一个 3M 的 Excel 用 POI 需要100M左右内存, 而 EasyExcel 可以将其降低到几 M，同时再大的 Excel 都不会出现内存溢出的情况，因为是逐行读取 E","text":"写在前面Java 后端程序员应该会遇到读取 Excel 信息到 DB 等相关需求，脑海中可能突然间想起 Apache POI 这个技术解决方案，但是当 Excel 的数据量非常大的时候，你也许发现，POI 是将整个 Excel 的内容全部读出来放入到内存中，所以内存消耗非常严重，如果同时进行包含大数据量的 Excel 读操作，很容易造成内存溢出问题 但 EasyExcel 的出现很好的解决了 POI 相关问题，原本一个 3M 的 Excel 用 POI 需要100M左右内存, 而 EasyExcel 可以将其降低到几 M，同时再大的 Excel 都不会出现内存溢出的情况，因为是逐行读取 Excel 的内容 (老规矩，这里不用过分关心下图，脑海中有个印象即可，看完下面的用例再回看这个图，就很简单了) 另外 EasyExcel 在上层做了模型转换的封装，不需要 cell 等相关操作，让使用者更加简单和方便，且看 简单读假设我们 excel 中有以下内容: 我们需要新建 User 实体，同时为其添加成员变量 123456789101112131415@Datapublic class User &#123; /** * 姓名 */ @ExcelProperty(index = 0) private String name; /** * 年龄 */ @ExcelProperty(index = 1) private Integer age;&#125; 你也许关注到了 @ExcelProperty 注解，同时使用了 index 属性 (0 代表第一列，以此类推)，该注解同时支持以「列名」name 的方式匹配，比如: 12@ExcelProperty(\"姓名\")private String name; 按照 github 文档的说明: 不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配 如果读取的 Excel 模板信息列固定，这里建议以 index 的形式使用，因为如果用名字去匹配，名字重复，会导致只有一个字段读取到数据，所以 index 是更稳妥的方式 如果 Excel 模板的列 index 经常有变化，那还是选择 name 方式比较好，不用经常性修改实体的注解 index 数值 所以大家可以根据自己的情况自行选择 编写测试用例 12345@Testpublic void readExcel()&#123; String fileName = TestUtils.getPath() + \"excel\" + File.separator + \"users1.xlsx\"; EasyExcel.read(fileName, User.class, new UserExcelListener()).sheet().doRead();&#125; EasyExcel 类中重载了很多个 read 方法，这里不一一列举说明，请大家自行查看；同时 sheet 方法也可以指定 sheetNo，默认是第一个 sheet 的信息 上面代码的 new UserExcelListener() 异常醒目，这也是 EasyExcel 逐行读取 Excel 内容的关键所在，自定义 UserExcelListener 继承 AnalysisEventListener 123456789101112131415161718192021222324252627282930@Slf4jpublic class UserExcelListener extends AnalysisEventListener&lt;User&gt; &#123; /** * 批处理阈值 */ private static final int BATCH_COUNT = 2; List&lt;User&gt; list = new ArrayList&lt;User&gt;(BATCH_COUNT); @Override public void invoke(User user, AnalysisContext analysisContext) &#123; log.info(\"解析到一条数据:&#123;&#125;\", JSON.toJSONString(user)); list.add(user); if (list.size() &gt;= BATCH_COUNT) &#123; saveData(); list.clear(); &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; saveData(); log.info(\"所有数据解析完成！\"); &#125; private void saveData()&#123; log.info(\"&#123;&#125;条数据，开始存储数据库！\", list.size()); log.info(\"存储数据库成功！\"); &#125;&#125; 到这里请回看文章开头的 EasyExcel 原理图，invoke 方法逐行读取数据，对应的就是订阅者 1；doAfterAllAnalysed 方法对应的就是订阅者 2，这样你理解了吗？ 打印结果: 从这里可以看出，虽然是逐行解析数据，但我们可以自定义阈值，完成数据的批处理操作，可见 EasyExcel 操作的灵活性 自定义转换器这是最基本的数据读写，我们的业务数据通常不可能这么简单，有时甚至需要将其转换为程序可读的数据 性别信息转换比如 Excel 中新增「性别」列，其性别为男/女，我们需要将 Excel 中的性别信息转换成程序信息: 「1: 男；2:女」 首先在 User 实体中添加成员变量 gender: 12@ExcelProperty(index = 2)private Integer gender; EasyExcel 支持我们自定义 converter，将 excel 的内容转换为我们程序需要的信息，这里新建 GenderConverter，用来转换性别信息 123456789101112131415161718192021222324252627282930public class GenderConverter implements Converter&lt;Integer&gt; &#123; public static final String MALE = \"男\"; public static final String FEMALE = \"女\"; @Override public Class supportJavaTypeKey() &#123; return Integer.class; &#125; @Override public CellDataTypeEnum supportExcelTypeKey() &#123; return CellDataTypeEnum.STRING; &#125; @Override public Integer convertToJavaData(CellData cellData, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; String stringValue = cellData.getStringValue(); if (MALE.equals(stringValue))&#123; return 1; &#125;else &#123; return 2; &#125; &#125; @Override public CellData convertToExcelData(Integer integer, ExcelContentProperty excelContentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123; return null; &#125;&#125; 上面程序的 Converter 接口的泛型是指要转换的 Java 数据类型，与 supportJavaTypeKey 方法中的返回值类型一致 打开注解 @ExcelProperty 查看，该注解是支持自定义 Converter 的，所以我们为 User 实体添加 gender 成员变量，并指定 converter 12345/** * 性别 1：男；2：女 */@ExcelProperty(index = 2, converter = GenderConverter.class)private Integer gender; 来看运行结果: 数据按照我们预期做出了转换，从这里也可以看出，Converter 可以一次定义到处是用的便利性 日期信息转换日期信息也是我们常见的转换数据，比如 Excel 中新增「出生年月」列，我们要解析成 yyyy-MM-dd 格式，我们需要将其进行格式化，EasyExcel 通过 @DateTimeFormat 注解进行格式化 在 User 实体中添加成员变量 birth，同时应用 @DateTimeFormat 注解，按照要求做格式化 123456/** * 出生日期 */@ExcelProperty(index = 3)@DateTimeFormat(\"yyyy-MM-dd HH:mm:ss\")private String birth; 来看运行结果: 如果这里你指定 birth 的类型为 Date，试试看，你得到的结果是什么？ 到这里都是以测试的方式来编写程序代码，作为 Java Web 开发人员，尤其在目前主流 Spring Boot 的架构下，所以如何实现 Web 方式读取 Excel 的信息呢？ web 读简单 Web很简单，只是将测试用例的关键代码移动到 Controller 中即可，我们新建一个 UserController，在其添加 upload 方法 12345678910@RestController@RequestMapping(\"/users\")@Slf4jpublic class UserController &#123; @PostMapping(\"/upload\") public String upload(MultipartFile file) throws IOException &#123; EasyExcel.read(file.getInputStream(), User.class, new UserExcelListener()).sheet().doRead(); return \"success\"; &#125;&#125; 其实在写测试用例的时候你也许已经发现，listener 是以 new 的形式作为参数传入到 EasyExcel.read 方法中的，这是不符合 Spring IoC 的规则的，我们通常读取 Excel 数据之后都要针对读取的数据编写一些业务逻辑的，而业务逻辑通常又会写在 Service 层中，我们如何在 listener 中调用到我们的 service 代码呢？ *先不要向下看，你脑海中有哪些方案呢？ * 匿名内部类方式匿名内部类是最简单的方式，我们需要先新建 Service 层的信息:新建 IUser 接口: 123public interface IUser &#123; public boolean saveData(List&lt;User&gt; users);&#125; 新建 IUser 接口实现类 UserServiceImpl: 1234567891011@Service@Slf4jpublic class UserServiceImpl implements IUser &#123; @Override public boolean saveData(List&lt;User&gt; users) &#123; log.info(\"UserService &#123;&#125;条数据，开始存储数据库！\", users.size()); log.info(JSON.toJSONString(users)); log.info(\"UserService 存储数据库成功！\"); return true; &#125;&#125; 接下来，在 Controller 中注入 IUser: 12@Autowiredprivate IUser iUser; 修改 upload 方法，以匿名内部类重写 listener 方法的形式来实现: 12345678910111213141516171819202122232425262728293031@PostMapping(\"/uploadWithAnonyInnerClass\") public String uploadWithAnonyInnerClass(MultipartFile file) throws IOException &#123; EasyExcel.read(file.getInputStream(), User.class, new AnalysisEventListener&lt;User&gt;()&#123; /** * 批处理阈值 */ private static final int BATCH_COUNT = 2; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); @Override public void invoke(User user, AnalysisContext analysisContext) &#123; log.info(\"解析到一条数据:&#123;&#125;\", JSON.toJSONString(user)); list.add(user); if (list.size() &gt;= BATCH_COUNT) &#123; saveData(); list.clear(); &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; saveData(); log.info(\"所有数据解析完成！\"); &#125; private void saveData()&#123; iUser.saveData(list); &#125; &#125;).sheet().doRead(); return \"success\"; &#125; 查看结果: 这种实现方式，其实这只是将 listener 中的内容全部重写，并在 controller 中展现出来，当你看着这么臃肿的 controller 是不是非常难受？很显然这种方式不是我们的最佳编码实现 构造器传参在之前分析 SpringBoot 统一返回源码时，不知道你是否发现，Spring 底层源码多数以构造器的形式传参，所以我们可以将为 listener 添加有参构造器，将 Controller 中依赖注入的 IUser 以构造器的形式传入到 listener : 1234567891011121314@Slf4jpublic class UserExcelListener extends AnalysisEventListener&lt;User&gt; &#123; private IUser iUser; public UserExcelListener(IUser iUser)&#123; this.iUser = iUser; &#125; // 省略相应代码... private void saveData()&#123; iUser.saveData(list); //调用 userService 中的 saveData 方法 &#125; 更改 Controller 方法: 12345@PostMapping(\"/uploadWithConstructor\")public String uploadWithConstructor(MultipartFile file) throws IOException &#123; EasyExcel.read(file.getInputStream(), User.class, new UserExcelListener(iUser)).sheet().doRead(); return \"success\";&#125; 运行结果: 同上 这样更改后，controller 代码看着很清晰，但如果后续业务还有别的 Service 需要注入，我们难道要一直添加有参构造器吗？很明显，这种方式同样不是很灵活。 其实在使用匿名内部类的时候，你也许会想到，我们可以通过 Java8 lambda 的方式来解决这个问题 Lambda 传参为了解决构造器传参的痛点，同时我们又希望 listener 更具有通用性，没必要为每个 Excel 业务都新建一个 listener，因为 listener 都是逐行读取 Excel 数据，只需要将我们的业务逻辑代码传入给 listener 即可，所以我们需用到 Consumer&lt;T&gt; ，将其作为构造 listener 的参数。 新建一个工具类 ExcelDemoUtils，用来构造 listener: 12345678910111213141516171819202122232425262728293031323334353637383940public class ExcelDemoUtils &#123; /** * 指定阈值 * @param consumer * @param threshold * @param &lt;T&gt; * @return */ public static &lt;T&gt; AnalysisEventListener&lt;T&gt; getListener(Consumer&lt;List&lt;T&gt;&gt; consumer, int threshold) &#123; return new AnalysisEventListener&lt;T&gt;() &#123; private LinkedList&lt;T&gt; linkedList = new LinkedList&lt;T&gt;(); @Override public void invoke(T t, AnalysisContext analysisContext) &#123; linkedList.add(t); if (linkedList.size() == threshold)&#123; consumer.accept(linkedList); linkedList.clear(); &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; if (linkedList.size() &gt; 0)&#123; consumer.accept(linkedList); &#125; &#125; &#125;; &#125; /** * 不指定阈值，阈值默认为10 * @param consumer * @param &lt;T&gt; * @return */ public static &lt;T&gt; AnalysisEventListener&lt;T&gt; getListener(Consumer&lt;List&lt;T&gt;&gt; consumer)&#123; return getListener(consumer, 10); &#125; 我们看到，getListener 方法接收一个 Consumer&lt;List&lt;T&gt;&gt; 的参数，这样下面代码被调用时，我们的业务逻辑也就会被相应的执行了: 1consumer.accept(linkedList); 继续改造 Controller 方法: 123456789101112@PostMapping(\"/uploadWithLambda\")public String uploadWithLambda(MultipartFile file) throws IOException &#123; AnalysisEventListener&lt;User&gt; userAnalysisEventListener = ExcelDemoUtils.getListener(this.batchInsert(), 2); EasyExcel.read(file.getInputStream(), User.class, userAnalysisEventListener).sheet().doRead(); return \"success\";&#125;private Consumer&lt;List&lt;User&gt;&gt; batchInsert()&#123; //其他业务逻辑只需要添加到该方法中即可 return users -&gt; iUser.saveData(users);&#125; 运行结果: 同上 到这里，我们只需要将业务逻辑定制在 batchInsert 方法中: 满足 Controller RESTful API 的简洁性 listener 更加通用和灵活，它更多是扮演了抽象类的角色，具体的逻辑交给抽象方法的实现来完成 业务逻辑可扩展性也更好，逻辑更加清晰 总结到这里，关于如何使用 EasyExcel 读取 Excel 信息的基本使用方式已经介绍完了，还有很多细节内容没有讲，大家可以自行查阅 EasyExcel Github 文档去发现更多内容 除了读取 Excel 的读取，还有 Excel 的写入，如果需要将其写入到指定位置，配合 HuTool 的工具类 FileWriter 的使用是非常方便的，针对 EasyExcel 的使用，如果大家有什么问题，也欢迎到博客下方探讨 完整代码请在公众号回复「demo」，点开链接，查看「easyexceldemo」文件夹的内容即可 感谢非常感谢 EasyExcel 的作者 🌹🌹，让 Excel 的读写更加方便 灵魂追问 除了 Consumer，如果需要返回值的业务逻辑，需要用到哪个函数式接口呢？ 当出现复杂表头的时候要如何处理呢？ 将 DB 数据写入到 Excel 并下载，如何实现呢？ 从 EasyExcel 的设计上，你学到了什么，欢迎博客下方留言讨论 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 面试并发volatile关键字时，我们应该具备哪些谈资？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"https://dayarch.top/tags/Excel/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"EasyExcel","slug":"EasyExcel","permalink":"https://dayarch.top/tags/EasyExcel/"},{"name":"POI","slug":"POI","permalink":"https://dayarch.top/tags/POI/"}]},{"title":"面试volatile关键字时，我们应该具备哪些谈资？","slug":"面试volatile关键字时，我们应该具备哪些谈资？","date":"2019-09-29T12:03:33.000Z","updated":"2019-11-07T06:38:33.111Z","comments":true,"path":"/p/java-concurrency-volatile.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-volatile.html","excerpt":"写在前面 在 可见性有序性，Happens-before来搞定 文章中，happens-before 的原则之一: volatile变量规则 对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读 按理说了解了这个规则，对 volatile 的使用就已经足够了，但是面试官可是喜欢刨根问到底的，为了更透彻的了解 volatile 的内存语义与读写语义，为了面试多一些谈资进而获得一些加分项，同时尽早填补前序文章留下的坑，于是乎这篇文章就这样尴尬的诞生了 happens-before 之 volatile 变量规则 下面的表格你还记得吗？","text":"写在前面在 可见性有序性，Happens-before来搞定 文章中，happens-before 的原则之一: volatile变量规则 对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读 按理说了解了这个规则，对 volatile 的使用就已经足够了，但是面试官可是喜欢刨根问到底的，为了更透彻的了解 volatile 的内存语义与读写语义，为了面试多一些谈资进而获得一些加分项，同时尽早填补前序文章留下的坑，于是乎这篇文章就这样尴尬的诞生了 happens-before 之 volatile 变量规则下面的表格你还记得吗？(是的，你记得😂) 能否重排序 第二个操作 第二个操作 第二个操作 第一个操作 普通读/写 volatile 读 volatile 写 普通读/写 - - NO volatile 读 NO NO NO volatile 写 - NO NO 上面的表格是 JMM 针对编译器定制的 volatile 重排序的规则，那 JMM 是怎样禁止重排序的呢？答案是内存屏障 内存屏障 (Memory Barriers / Fences)无论你听过这个名词与否都没关系，很简单，且看 为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序 这句话有点抽象，试着想象内存屏障是一面高墙，如果两个变量之间有这个屏障，那么他们就不能互换位置(重排序)了，变量有读(Load)有写(Store)，操作有前有后，JMM 就将内存屏障插入策略分为 4 种: 在每个 volatile 写操作的前面插入一个 StoreStore 屏障 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障 在每个 volatile 读操作的后面插入一个 LoadStore 屏障 1 和 2 用图形描述以及对应表格规则就是下面这个样子了: 3 和 4 用图形描述以及对应表格规则就是下面这个样子了: 其实图形也是表格内容的体现，只不过告诉大家内存屏障是如何禁止指令重排序的，所以大家只要牢记表格内容即可 一段程序的读写通常不会像上面两种情况这样简单，这些屏障组合起来如何使用呢？其实一点都不难，我们只需要将这些指令带入到文章开头的表格中，然后再按照程序顺序拼接指令就好了 来看一小段程序: 1234567891011121314public class VolatileBarrierExample &#123; private int a; private volatile int v1 = 1; private volatile int v2 = 2; void readAndWrite()&#123; int i = v1; //第一个volatile读 int j = v2; //第二个volatile读 a = i + j; //普通写 v1 = i + 1; //第一个volatile写 v2 = j * 2; //第二个volatile写 &#125;&#125; 将屏障指令带入到程序就是这个样子: 我们将上图分几个角度来看: 彩色是将屏障指令带入到程序中生成的全部内容，也就是编译器生成的「最稳妥」的方案 显然有很多屏障是重复多余的，右侧虚线框指向的屏障是可以被「优化」删除掉的屏障 到这里你应该了解了 volatile 是如何通过内存屏障保证程序不被”擅自”排序的，那 volatile 是如何保证可见性的呢？ volatile 写-读的内存语义回顾一下之前文章内容中的程序，假定线程 A 先执行 writer 方法，随后线程 B 执行 reader 方法，: 12345678910111213141516171819public class ReorderExample &#123; private int x = 0; private int y = 1; private volatile boolean flag = false; public void writer()&#123; x = 42; //1 y = 50; //2 flag = true; //3 &#125; public void reader()&#123; if (flag)&#123; //4 System.out.println(\"x:\" + x); //5 System.out.println(\"y:\" + y); //6 &#125; &#125;&#125; 到这里你是否还记得之前说过的 JMM，是的，你还记得😂，当线程 A 执行 writer 方法时，且看下图: 线程 A 将本地内存更改的变量写回到主内存中 volatile 读的内存语义:当读一个 volatile 变量时, JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 所以当线程 B 执行 reader 方法时，图形结构就变成了这个样子: 线程 B 本地内存变量无效，从主内存中读取变量到本地内存中，也就得到了线程 A 更改后的结果，这就是 volatile 是如何保证可见性的 如果你看过前面的文章你就不难理解上面的两张图了，综合起来说: 线程 A 写一个volatile变量, 实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了(其对共享变量所做修改的)消息 线程 B 读一个 volatile 变量,实质上是线程 B 接收了之前某个线程发出的(在写这个 volatile 变量之前对共享变量所做修改的)消息。 线程 A 写一个 volatile 变量, 随后线程 B 读这个 volatile 变量, 这个过程实质上是线程 A 通过主内存向线程B 发送消息。 到这里，面试 volatile 时，你应该有一些谈资了，同时也对 volatile 的语义有了更深层次的了解 彩蛋之前的文章提到过这样一句话: 从内存语义的角度来说, volatile 的写-读与锁的释放-获取有相同的内存效果；volatile 写和锁的释放有相同的内存语义; volatile 读与锁的获取有相同的内存语义 记住文中最后两张图， 当我们说到 synchronized 的时候，你就会猛的理解这句话的含义了, 感兴趣的可以自己先了解 synchronized 的写-读语义 接下来我们就聊一聊锁相关的内容了，敬请期待… 灵魂追问 如果 volatile 写之后直接 return，那还会生成 StoreLoad 指令吗？ synchronized 是怎样逐步被优化的？ 提高效率工具 tool.luhttps://tool.lu 是一款集成了非常多功能的在线工具，基本满足日常开发所需 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 解决原子性问题？你首先需要的是宏观理解 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"volatile","slug":"volatile","permalink":"https://dayarch.top/tags/volatile/"}]},{"title":"解决原子性问题？你首先需要的是宏观理解","slug":"解决原子性问题？你首先需要的是宏观理解","date":"2019-09-19T02:05:31.000Z","updated":"2019-11-07T06:47:16.338Z","comments":true,"path":"/p/java-concurrency-atomic.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-atomic.html","excerpt":"上一篇文章 可见性有序性，Happens-before来搞定，解决了并发三大问题中的两个，今天我们就聊聊如何解决原子性问题 原子性问题的源头就是 线程切换，但在多核 CPU 的大背景下，不允许线程切换是不可能的，正所谓「魔高一尺，道高一丈」，新规矩来了: 互斥: 同一时刻只有一个线程执行 实际上，上面这句话的意思是: 对共享变量的修改是互斥的，也就是说线程 A 修改共享变量时其他线程不能修改，这就不存在操作被打断的问题了，那么如何实现互斥呢？ 锁 对并发有所了解的小伙伴马上就能想到 锁 这个概念，并且你的第一反应很可能就是使用 synchronized，这里列出来你常见的 syn","text":"上一篇文章 可见性有序性，Happens-before来搞定，解决了并发三大问题中的两个，今天我们就聊聊如何解决原子性问题 原子性问题的源头就是 线程切换，但在多核 CPU 的大背景下，不允许线程切换是不可能的，正所谓「魔高一尺，道高一丈」，新规矩来了: 互斥: 同一时刻只有一个线程执行 实际上，上面这句话的意思是: 对共享变量的修改是互斥的，也就是说线程 A 修改共享变量时其他线程不能修改，这就不存在操作被打断的问题了，那么如何实现互斥呢？ 锁对并发有所了解的小伙伴马上就能想到 锁 这个概念，并且你的第一反应很可能就是使用 synchronized，这里列出来你常见的 synchronized 的三种用法: 123456789101112131415161718public class ThreeSync &#123; private static final Object object = new Object(); public synchronized void normalSyncMethod()&#123; //临界区 &#125; public static synchronized void staticSyncMethod()&#123; //临界区 &#125; public void syncBlockMethod()&#123; synchronized (object)&#123; //临界区 &#125; &#125;&#125; 三种 synchronized 锁的内容有一些差别: 对于普通同步方法，锁的是当前实例对象，通常指 this 对于静态同步方法，锁的是当前类的 Class 对象，如 ThreeSync.class 对于同步方法块，锁的是 synchronized 括号内的对象 我特意在三种 synchronized 代码里面添加了「临界区」字样的注释，那什么是临界区呢？ 临界区: 我们把需要互斥执行的代码看成为临界区 说到这里，和大家串的知识都是表层认知，如何用锁保护有效的临界区才是关键，这直接关系到你是否会写出并发的 bug，了解过本章内容后，你会发现无论是隐式锁/内置锁 (synchronized) 还是显示锁 (Lock) 的使用都是在找寻这种关系，关系对了，一切就对了，且看 上面锁的三种方式都可以用下图来表达: 线程进入临界区之前，尝试加锁 lock()， 加锁成功，则进入临界区(对共享变量进行修改)，持有锁的线程执行完临界区代码后，执行 unlock()，释放锁。针对这个模型，大家经常用抢占厕所坑位来形容: 在学习 Java 早期我就是这样记忆与理解锁的，但落实到代码上，我们很容易忽略两点: 我们锁的是什么？ 我们保护的又是什么？ 将这两句话联合起来就是你的锁能否对临界区的资源起到保护的作用？所以我们要将上面的模型进一步细化 现实中，我们都知道自己的锁来锁自己需要保护的东西 ，这句话翻译成你的行动语言之后你已经明确知道了: 你锁的是什么 你保护的资源是什么 CPU 可不像我们大脑这么智能，我们要明确说明我们锁的是什么，我们要保护的资源是什么，它才会用锁保护我们想要保护的资源(共享变量) 拿上图来说，资源 R (共享变量) 就是我们要保护的资源，所以我们就要创建资源 R 的锁来保护资源 R，细心的朋友可能发现上图几个问题: LR 和 R 之间有明确的指向关系我们编写程序时，往往脑子中的模型是对的，但是忽略了这个指向关系，导致自己的锁不能起到保护资源 R 的作用(用别人家的锁保护自己家的东西或用自己家的锁保护别人家的东西)，最终引发并发 bug，所以在你勾画草图时，要明确找到这个关系 左图 LR 虚线指向了非共享变量我们写程序的时候很容易这么做，不确定哪个是要保护的资源，直接大杂烩，用 LR 将要保护的资源 R 和没必要保护的非共享变量一起保护起来了，举两个例子来说你就明白这么做的坏处了 编写串行程序时，是不建议 try…catch 整个方法的，这样如果出现问是很难定位的，道理一样，我们要用锁精确的锁住我们要保护的资源就够了，其他无意义的资源是不要锁的 锁保护的东西越多，临界区就越大，一个线程从走入临界区到走出临界区的时间就越长，这就让其他线程等待的时间越久，这样并发的效率就有所下降，其实这是涉及到锁粒度的问题，后续也都会做相关说明 作为程序猿还是简单拿代码说明一下心里比较踏实，且看: 123456789101112131415161718public class ValidLock &#123; private static final Object object = new Object(); private int count; public synchronized void badSync()&#123; //其他与共享变量count无关的业务逻辑 count++; &#125; public void goodSync()&#123; //其他与共享变量count无关的业务逻辑 synchronized (object)&#123; count++; &#125; &#125;&#125; 这里并不是说 synchronized 放在方法上不好，只是提醒大家用合适的锁的粒度才会更高效 在计数器程序例子中，我们会经常这么写: 123456789101112public class SafeCounter &#123; private int count; public synchronized void counter()&#123; count++; &#125; public synchronized int getCount()&#123; return count; &#125;&#125; 下图就是上面程序的模型展示: 这里我们锁的是 this，可以保护 this.count。但有些同学认为 getCount 方法没必要加 synchronized 关键字，因为是读的操作，不会对共享变量做修改，如果不加上 synchronized 关键字，就违背了我们上一篇文章 happens-before 规则中的监视器锁规则: 对一个锁的解锁 happens-before 于随后对这个锁的加锁也就是说对 count 的写很可能对 count 的读不可见，也就导致脏读 上面我们看到一个 this 锁是可以保护多个资源的，那用多个不同的锁保护一个资源可以吗？来看一段程序: 123456789101112public class UnsafeCounter &#123; private static int count; public synchronized void counter()&#123; count++; &#125; public static synchronized int calc()&#123; return count++; &#125;&#125; 睁大眼睛仔细看，一个锁的是 this，一个锁的是 UnsafeCounter.class, 他们都想保护共享变量 count，你觉得如何？下图就是行面程序的模型展示: 两个临界区是用两个不同的锁来保护的，所以临界区没有互斥关系，也就不能保护 count，所以这样加锁是无意义的 总结 解决原子性问题，就是要互斥，就是要保证中间状态对外不可见 锁是解决原子性问题的关键，明确知道我们锁的是什么，要保护的资源是什么，更重要的要知道你的锁能否保护这个受保护的资源(图中的箭头指向) 有效的临界区是一个入口和一个出口，多个临界区保护一个资源，也就是一个资源有多个并行的入口和多个出口，这就没有起到互斥的保护作用，临界区形同虚设 锁自己家门能保护资源就没必要锁整个小区，如果锁了整个小区，这严重影响其他业主的活动(锁粒度的问题) 本文以 synchronized 锁举例来说明如何解决原子性问题，主要是帮助大家建立宏观的理念，用于解决原子性问题，这样后续你看到无论什么锁，只要脑海中回想起本节说明的模型，你会发现都是换汤不换药，学习起来就非常轻松了. 到这里并发的三大问题 有序性，可见性，原子性都有了解决方案，这是远看并发，让大家有了宏观的概念；但面试和实战都是讲求细节的，接下来我们由远及近，逐步看并发的细节，顺带说明那些面试官经常会问到的问题 灵魂追问 多个锁锁一个资源一定会有问题吗？ 什么时候需要锁小区，而不能锁某一户呢？ 银行转账，两人互转和别人给自己转，用什么样的锁粒度合适呢？ 提高效率工具 推荐阅读 这次走进并发的世界，请不要错过 学并发编程，透彻理解这三个核心是关键 并发Bug之源有三，请睁大眼睛看清它们 可见性有序性，Happens-before来搞定 基础面试，为什么面试官总喜欢问String？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://dayarch.top/tags/%E9%94%81/"}]},{"title":"有序性可见性，Happens-before来搞定","slug":"有序性可见性，Happens-before来搞定","date":"2019-09-12T10:24:22.000Z","updated":"2019-11-08T08:51:44.745Z","comments":true,"path":"/p/java-concurrency-happens-before-rule.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-happens-before-rule.html","excerpt":"写在前面 上一篇文章并发 Bug 之源有三，请睁大眼睛看清它们 谈到了可见性/原子性/有序性三个问题，这些问题通常违背我们的直觉和思考模式，也就导致了很多并发 Bug * 为了解决 CPU，内存，IO 的短板，增加了缓存，但这导致了可见性问题 * 编译器/处理器擅自优化 ( Java代码在编译后会变成 Java 字节码, 字节码被类加载器加载到 JVM 里, JVM 执行字节码, 最终需要转化为汇编指令在 CPU 上执行) ，导致有序性问题 初衷是好的，但引发了新问题，最有效的办法就禁止缓存和编译优化，问题虽然能解决，但「又回到最初的起点，呆呆地站在镜子前」是很尴尬的，我们程序的性能就","text":"写在前面上一篇文章并发 Bug 之源有三，请睁大眼睛看清它们 谈到了可见性/原子性/有序性三个问题，这些问题通常违背我们的直觉和思考模式，也就导致了很多并发 Bug 为了解决 CPU，内存，IO 的短板，增加了缓存，但这导致了可见性问题 编译器/处理器擅自优化 ( Java代码在编译后会变成 Java 字节码, 字节码被类加载器加载到 JVM 里, JVM 执行字节码, 最终需要转化为汇编指令在 CPU 上执行) ，导致有序性问题 初衷是好的，但引发了新问题，最有效的办法就禁止缓存和编译优化，问题虽然能解决，但「又回到最初的起点，呆呆地站在镜子前」是很尴尬的，我们程序的性能就堪忧了. 解决方案 作为我们程序猿不想写出 bug 影响 KPI，所以希望内存模型易于理解、易于编程。这就需要基于一个强内存模型来编写代码 作为编译器和处理器不想让外人说它处理速度很慢，所以希望内存模型对他们束缚越少越好，可以由他们擅自优化，这就需要基于一个弱内存模型 俗话说:「没有什么事是开会解决不了的，如果有，那就再开一次」😂 JSR-133 的专家们就有了新想法，既然不能完全禁止缓存和编译优化，那就按需禁用缓存和编译优化，按需就是要加一些约束，约束中就包括了上一篇文章简单提到过的 volatile，synchronized，final 三个关键字，同时还有你可能听过的 Happens-Before 原则(包含可见性和有序性的约束)，Happens-before 规则也是本章的主要内容 为了满足二者的强烈需求，照顾到双方的情绪，于是乎: JMM 就对程序猿说了一个善意的谎言: 「会严格遵守 Happpen-Befores 规则，不会重排序」让程序猿放心，私下却有自己的策略: 对于会改变程序执行结果的重排序,JMM要求编译器和处理器必须禁止这种重排序。 对于不会改变程序执行结果的重排序, JMM对编译器和处理器不做要求 (JMM允许这种重排序)。 我们来用个图说明一下: 这就是那个善意的谎言，虽是谎言，但还是照顾到了程序猿的利益，所以我们只需要了解 happens-before 规则就能得到保证 (图画了好久，不知道是否说明了谎言的所在😅，欢迎留言) Happens-beforeHappens-before 规则主要用来约束两个操作，两个操作之间具有 happens-before 关系, 并不意味着前一个操作必须要在后一个操作之前执行，happens-before 仅仅要求前一个操作(执行的结果)对后一个操作可见, (the first is visible to and ordered before the second) 说了这么多，先来看一小段代码带你逐步走进 Happen-Befores 原则，看看是怎样用该原则解决 可见性 和 有序性 的问题: 12345678910111213class ReorderExample &#123; int x = 0; boolean flag = false; public void writer() &#123; x = 42; //1 flag = true; //2 &#125; public void reader() &#123; if (flag) &#123; //3 System.out.println(x); //4 &#125; &#125;&#125; 假设 A 线程执行 writer 方法，B 线程执行 reader 方法，打印出来的 x 可能会是 0，上一篇文章说明过: 因为代码 1 和 2 没有数据依赖关系，所以可能被重排序 12flag = true; //2x = 42; //1 所以，线程 A 将 flag = true 写入但没有为 x 重新赋值时，线程 B 可能就已经打印了 x 是 0 那么为 flag 加上 volatile 关键字试一下: 1volatile boolean flag = false; 即便加上了 volatile 关键字，这个问题在 java1.5 之前还是没有解决，但 java1.5 和其之后的版本对 volatile 语义做了增强，问题得以解决，这就离不开 Happens-before 规则的约束了，总共有 6 个规则，且看 程序顺序性规则 一个线程中的每个操作, happens-before 于该线程中的任意后续操作第一感觉这个原则是一个在理想状态下的”废话”，并且和上面提到的会出现重排序的情况是矛盾的，注意这里是一个线程中的操作，其实隐含了「as-if-serial」语义: 说白了就是只要执行结果不被改变，无论怎么”排序”，都是对的 这个规则是一个基础规则，happens-before 是多线程的规则，所以要和其他规则约束在一起才能体现出它的顺序性，别着急，继续向下看 volatile变量规则 对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读 我将上面的程序添加两行代码作说明: 12345678910111213141516171819public class ReorderExample &#123; private int x = 0; private int y = 1; private volatile boolean flag = false; public void writer()&#123; x = 42; //1 y = 50; //2 flag = true; //3 &#125; public void reader()&#123; if (flag)&#123; //4 System.out.println(\"x:\" + x); //5 System.out.println(\"y:\" + y); //6 &#125; &#125;&#125; 这里涉及到了 volatile 的内存增强语义，先来看个表格: 能否重排序 第二个操作 第二个操作 第二个操作 第一个操作 普通读/写 volatile 读 volatile 写 普通读/写 - - NO volatile 读 NO NO NO volatile 写 - NO NO 从这个表格 最后一列 可以看出: 如果第二个操作为 volatile 写，不管第一个操作是什么，都不能重排序，这就确保了 volatile 写之前的操作不会被重排序到 volatile 写之后拿上面的代码来说，代码 1 和 2 不会被重排序到代码 3 的后面，但代码 1 和 2 可能被重排序 (没有依赖也不会影响到执行结果)，说到这里和 程序顺序性规则是不是就已经关联起来了呢？ 从这个表格的 倒数第二行 可以看出: 如果第一个操作为 volatile 读，不管第二个操作是什么，都不能重排序，这确保了 volatile 读之后的操作不会被重排序到 volatile 读之前拿上面的代码来说，代码 4 是读取 volatile 变量，代码 5 和 6 不会被重排序到代码 4 之前 volatile 内存语义的实现是应用到了 「内存屏障」，因为这完全够单独写一章的内容，这里为了不掩盖主角 Happens-before 的光环，保持理解 Happens-before 的连续性，先不做过多说明 到这里，看这个规则，貌似也没解决啥问题，因为它还要联合第三个规则才起作用 传递性规则 如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C直接上图说明一下上面的例子 从上图可以看出 x =42 和 y = 50 Happens-before flag = true, 这是规则 1 写变量(代码 3) flag=true Happens-before 读变量(代码 4) if(flag)，这是规则 2 根据规则 3传递性规则，x =42 Happens-before 读变量 if(flag) 谜案要揭晓了: 如果线程 B 读到了 flag 是 true，那么 x =42 和 y = 50 对线程 B 就一定可见了，这就是 Java1.5 的增强 (之前版本是可以普通变量写和 volatile 变量写的重排序的) 通常上面三个规则是一种联合约束，到这里你懂了吗？规则还没完，继续看 监视器锁规则 对一个锁的解锁 happens-before 于随后对这个锁的加锁 这个规则我觉得你应该最熟悉了，就是解释 synchronized 关键字的，来看 1234567891011121314151617public class SynchronizedExample &#123; private int x = 0; public void synBlock()&#123; // 1.加锁 synchronized (SynchronizedExample.class)&#123; x = 1; // 对x赋值 &#125; // 3.解锁 &#125; // 1.加锁 public synchronized void synMethod()&#123; x = 2; // 对x赋值 &#125; // 3. 解锁&#125; 先获取锁的线程，对 x 赋值之后释放锁，另外一个再获取锁，一定能看到对 x 赋值的改动，就是这么简单，请小伙伴用下面命令查看上面程序，看同步块和同步方法被转换成汇编指令有何不同？ 1javap -c -v SynchronizedExample 这和 synchronized 的语义相关，小伙伴可以先自行了解一下，锁的内容时会做详细说明 start()规则 如果线程 A 执行操作 ThreadB.start() (启动线程B), 那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作，也就是说，主线程 A 启动子线程 B 后，子线程 B 能看到主线程在启动子线程 B 前的操作，看个程序就秒懂了 123456789101112131415161718192021222324public class StartExample &#123; private int x = 0; private int y = 1; private boolean flag = false; public static void main(String[] args) throws InterruptedException &#123; StartExample startExample = new StartExample(); Thread thread1 = new Thread(startExample::writer, \"线程1\"); startExample.x = 10; startExample.y = 20; startExample.flag = true; thread1.start(); System.out.println(\"主线程结束\"); &#125; public void writer()&#123; System.out.println(\"x:\" + x ); System.out.println(\"y:\" + y ); System.out.println(\"flag:\" + flag ); &#125;&#125; 运行结果: 123456主线程结束x:10y:20flag:trueProcess finished with exit code 0 线程 1 看到了主线程调用 thread1.start() 之前的所有赋值结果，这里没有打印「主线程结束」，你知道为什么吗？这个守护线程知识有关系 join()规则 如果线程 A 执行操作 ThreadB.join() 并成功返回, 那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回，和 start 规则刚好相反，主线程 A 等待子线程 B 完成，当子线程 B 完成后，主线程能够看到子线程 B 的赋值操作，将程序做个小改动，你也会秒懂的 12345678910111213141516171819202122232425public class JoinExample &#123; private int x = 0; private int y = 1; private boolean flag = false; public static void main(String[] args) throws InterruptedException &#123; JoinExample joinExample = new JoinExample(); Thread thread1 = new Thread(joinExample::writer, \"线程1\"); thread1.start(); thread1.join(); System.out.println(\"x:\" + joinExample.x ); System.out.println(\"y:\" + joinExample.y ); System.out.println(\"flag:\" + joinExample.flag ); System.out.println(\"主线程结束\"); &#125; public void writer()&#123; this.x = 100; this.y = 200; this.flag = true; &#125;&#125; 运行结果: 123456x:100y:200flag:true主线程结束Process finished with exit code 0 「主线程结束」这几个字打印出来喽，依旧和线程何时退出有关系 总结 Happens-before 重点是解决前一个操作结果对后一个操作可见，相信到这里，你已经对 Happens-before 规则有所了解，这些规则解决了多线程编程的可见性与有序性问题，但还没有完全解决原子性问题(除了 synchronized) start 和 join 规则也是解决主线程与子线程通信的方式之一 从内存语义的角度来说, volatile 的写-读与锁的释放-获取有相同的内存效果；volatile 写和锁的释放有相同的内存语义; volatile 读与锁的获取有相同的内存语义，⚠️⚠️⚠️(敲黑板了) volatile 解决的是可见性问题，synchronized 解决的是原子性问题，这绝对不是一回事，后续文章也会说明 附加说明 个人博客会首发原创文章，如文章有密码保护，通过查看文章的创建日期，如果是 1 月份，请公众号回复当前月份数值即可，如回复「1」 多线程系列文章整体会按照我的大纲节奏来写，但是如果大家有什么疑问，也欢迎到我单独建立的多线程系列问题留言汇总 文章中留言，我会统一回复，如果共通疑问很多，我会插入相关章节单独做说明 并发文章的相关代码，我也会同步上传到代码库，公众号回复「demo」，点击链接，找到concurrency 子项目即可 如果文章对你有帮助，烦请小伙伴转发分享给更多朋友，我们一起进步 灵魂追问 同步块和同步方法在编译成 CPU 指令后有什么不同？ 线程有 Daemon(守护线程)和非 Daemon 线程，你知道线程的退出策略吗？ 关于 Happens-before 你还有哪些疑惑呢？ 提高效率工具 MarkDown 表格生成器本文的好多表格是从官网粘贴的，如何将其直接转换成 MD table 呢？那么 https://www.tablesgenerator.com/markdown_tables 就可以帮到你了，无论是生成 MD table，还是粘贴内容生成 table 和内容都是极好的，当然了不止 MD table，自己发现吧，更多工具，公众号回复 「工具」获得 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"Happens-before","slug":"Happens-before","permalink":"https://dayarch.top/tags/Happens-before/"}]},{"title":"并发编程三大问题","slug":"并发编程三大问题","date":"2019-09-04T08:31:34.000Z","updated":"2019-11-07T06:38:00.676Z","comments":true,"path":"/p/java-concurrency-three-questions.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-three-questions.html","excerpt":"写在前面 * 生活中你一定听说过——能者多劳 * 作为 Java 程序员，你一定听过——这个功能请求慢，能加一层缓存或优化一下 SQL 吗？ * 看过中国古代神话故事的也一定听过——天上一天，地上一年 一切设计来源于生活，上一章 学并发编程，透彻理解这三个核心是关键 中有讲过，作为”资本家”，你要尽可能的榨取 CPU，内存与 IO 的剩余价值，但三者完成任务的速度相差很大，CPU > 内存 > IO分，CPU 是天，那内存就是地，内存是天，那 IO 就是地，那怎样平衡三者，提升整体速度呢？ 1. CPU 增加缓存，还不止一层缓存，平衡内存的慢 2. CPU 能者多劳，通过分时","text":"写在前面 生活中你一定听说过——能者多劳 作为 Java 程序员，你一定听过——这个功能请求慢，能加一层缓存或优化一下 SQL 吗？ 看过中国古代神话故事的也一定听过——天上一天，地上一年 一切设计来源于生活，上一章 学并发编程，透彻理解这三个核心是关键 中有讲过，作为”资本家”，你要尽可能的榨取 CPU，内存与 IO 的剩余价值，但三者完成任务的速度相差很大，CPU &gt; 内存 &gt; IO分，CPU 是天，那内存就是地，内存是天，那 IO 就是地，那怎样平衡三者，提升整体速度呢？ CPU 增加缓存，还不止一层缓存，平衡内存的慢 CPU 能者多劳，通过分时复用，平衡 IO 的速度差异 优化编译指令 上面的方式貌似解决了木桶短板问题，但同时这种解决方案也伴随着产生新的可见性，原子性，和有序性的问题，且看 三大问题可见性一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性 谈到可见性，要先引出 JMM (Java Memory Model) 概念, 即 Java 内存模型，Java 内存模型规定，将所有的变量都存放在 主内存 中，当线程使用变量时，会把主内存里面的变量 复制 到自己的工作空间或者叫作 私有内存 ，线程读写变量时操作的是自己工作内存中的变量。 用 Git 的工作流程理解上面的描述就很简单了，Git 远程仓库就是主内存，Git 本地仓库就是自己的工作内存 文字描述有些抽象，我们来图解说明: 看这个场景: 主内存中有变量 x，初始值为 0 线程 A 要将 x 加 1，先将 x=0 拷贝到自己的私有内存中，然后更新 x 的值 线程 A 将更新后的 x 值回刷到主内存的时间是不固定的 刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x=2 就会编程 x=1 这就是线程可见性的问题 JMM 是一个抽象的概念，在实际实现中，线程的工作内存是这样的: 为了平衡内存/IO 短板，会在 CPU 上增加缓存，每个核都只有自己的一级缓存，甚至有一个所有 CPU 都共享的二级缓存，就是上图的样子了，都说这么设计是硬件同学留给软件同学的一个坑，但能否跳过去这个坑也是衡量软件同学是否走向 Java 进阶的关键指标吧…… 小提示从上图中你也可以看出，在 Java 中，所有的实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间共享，这些在后续文章中都称之为「共享变量」，局部变量，方法定义参数和异常处理器参数不会在线程之间共享，所以他们不会有内存可见性的问题，也就不受内存模型的影响 一句话，要想解决多线程可见性问题，所有线程都必须要刷取主内存中的变量怎么解决可见性问题呢？Java 关键字 volatile 帮你搞定，后续章节会分析…… 原子性原子（atom）指化学反应不可再分的基本微粒，原子性操作你应该能感受到其含义: 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 小品「钟点工」有一句非常经典的台词，要把大象装冰箱，总共分几步？ 来看一小段程序: 多线程情况下能得到我们期盼的 count = 20000 的值吗？ 也许有同学会认为，线程调用的 counter 方法只有一个 count++ 操作，是单一操作，所以是原子性的，非也。在线程第一讲中说过我们不能用高级语言思维来理解 CPU 的处理方式，count++ 转换成 CPU 指令则需要三步，通过下面命令解析出汇编指令等信息: 1javap -c UnsafeCounter 截取 counter 方法的汇编指令来看: 解释一下上面的指令，16 : 获取当前 count 值，并且放入栈顶19 : 将常量 1 放入栈顶20 : 将当前栈顶中两个值相加，并把结果放入栈顶21 : 把栈顶的结果再赋值给 count 由此可见，简单的 count++ 不是一步操作，被转换为汇编后就不具备原子性了，就好比大象装冰箱，其实要分三步: 第一步，把冰箱门打开；第二步，把大象放进去；第三步，把冰箱门带上 结合 JMM 结构图理解，说明一下为什么很难得到 count=20000 的结果: 多线程计数器，如何保证多个操作的原子性呢？最粗暴的方式是在方法上加 synchronized 关键字，比如这样: 问题是解决了，如果 synchronized 是万能良方，那么也许并发就没那么多事了，可以靠一个 synchronized 走天下了，事实并不是这样，synchronized 是独占锁 (同一时间只能有一个线程可以调用)，没有获取锁的线程会被阻塞；另外也会带来很多线程切换的上下文开销 所以 JDK 中就有了非阻塞 CAS (Compare and Swap) 算法实现的原子操作类 AtomicLong 等工具类，看过源码的同学也许会发现一个共同特点，所有原子类中都有下面这样一段代码: 1private static final Unsafe unsafe = Unsafe.getUnsafe(); 这个类是 JDK 的 rt.jar 包中的 Unsafe 类提供了 硬件级别 的原子性操作，类中的方法都是 native 修饰的，后面介绍原子类之前也会先说明这个类中的几个方法，这里先简单介绍有个印象即可。 有同学不理解我刚刚提到的线程上下文切换开销很大是什么意思，举 2个例子你就懂了: 你(CPU)在看两本书(两个线程)，看第一本书很短时间后要去看第二本书，看第二本书很短时间后又回看第一本书，并要精确的记得看到第几行，当初看到了什么(CPU 记住线程级别的信息)，当让你 “同时” 看 10 本甚至更多，切换的开销就很大了吧 综艺节目中有很多游戏，让你一边数钱，又要一边做其他的事，最终保证多样事情都做正确，大脑开销大不大，你试试就知道了😊 有序性生活中你问候他人「吃了吗你？」和「你吃了吗？」是一个意思，你写的是下面程序: 1234a = 1；b = 2;System.out.println(a);System.out.println(b); 编译器优化后可能就变成了这样: 1234b = 2;a = 1；System.out.println(a);System.out.println(b); 这个情况，编译器调整了语句顺序没什么影响，但编译器 擅自 优化顺序，就给我们埋下了雷，比如应用双重检查方式实现的单例 一切又很完美是不是，非也，问题出现在 instance = new Singleton();，这 1 行代码转换成了 CPU 指令后又变成了 3 个，我们理解 new 对象应该是这样的: 分配一块内存 M 在内存 M 上初始化 Singleton 对象 然后 M 的地址赋值给 instance 变量 但编译器擅自优化后可能就变成了这样: 分配一块内存 M 然后将 M 的地址赋值给 instance 变量 在内存 M 上初始化 Singleton 对象 首先 new 对象分了三步，给 CPU 留下了切换线程的机会；另外，编译器优化后的顺序可能导致问题的发生，来看: 线程 A 先执行 getInstance 方法，当执行到指令 2 时，恰好发生了线程切换 线程 B 刚进入到 getInstance 方法，判断 if 语句 instance 是否为空 线程 A 已经将 M 的地址赋值给了 instance 变量，所以线程 B 认为 instance 不为空 线程 B 直接 return instance 变量 CPU 切换回线程 A，线程 A 完成后续初始化内容 我们还是画个图说明一下: 如果线程 A 执行到第 2 步，线程切换，由于线程 A 没有把红色箭头执行完全，线程 B 就会得到一个未初始化完全的对象，访问 instance 成员变量的时候就可能发生 NPE，如果将变量 instance 用 volatile 或者 final 修饰(涉及到类的加载机制，可看我之前写的文章: 双亲委派模型：大厂高频面试题，轻松搞定)，问题就解决了. 总结你所看到的程序并不一定是编译器优化/编译后的 CPU 指令，大象装冰箱是是个程序，但其隐含三个步骤，学习并发编程，你要按照 CPU 的思维考虑问题，所以你需要深刻理解 可见性/原子性/有序性 ，这是产生并发 Bug 的源头 本节说明了三个问题，下面的文章也会逐个分析解决以上问题的办法，以及相对优的方案，请持续关注，另外关于并发的测试代码我都会按例上传到 github，公众号回复「demo」——&gt; concurrency 获取更多内容 灵魂追问 为什么用 final 修饰的变量就是线程安全的了呢？ 你会经常查看 CPU 汇编指令吗？ 如果让你写单例，你通常会采用哪种实现？ 提高效率工具 Material Theme UI这是一款 IDEA 的主题插件，安装后，选择 Material Palenight 主题，同时作出如下设置 设置完后，你的 IDEA 就是下面这样，引起极度舒适 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"可见性","slug":"可见性","permalink":"https://dayarch.top/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"},{"name":"原子性","slug":"原子性","permalink":"https://dayarch.top/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"},{"name":"有序性","slug":"有序性","permalink":"https://dayarch.top/tags/%E6%9C%89%E5%BA%8F%E6%80%A7/"}]},{"title":"Mybatis拦截器实现数据加密与解密","slug":"Mybatis拦截器实现数据加密与解密","date":"2019-09-02T00:40:51.000Z","updated":"2019-11-07T06:36:44.351Z","comments":true,"path":"/p/mybatis-interceptor-encrypt-decrypt.html","link":"","permalink":"https://dayarch.top/p/mybatis-interceptor-encrypt-decrypt.html","excerpt":"拦截器介绍 Mybatis Interceptor 在 Mybatis 中被当作 Plugin(插件)，不知道为什么，但确实是在 org.apache.ibatis.plugin 包下面 既然是拦截器，可以拦截哪些内容呢？试想一下…… 当程序写到持久层时，Mybatis 会 执行 指定 SQL 语句，并处理 请求参数 和 返回值。没错，Mybatis 拦截器可以帮助我们处理上述内容，请看官网的 Plugins 的片段, 内容不多 1 2 3 4 5 6 7 8 // 执行 Executor (update, query, flushStatements, commit, rollb","text":"拦截器介绍Mybatis Interceptor 在 Mybatis 中被当作 Plugin(插件)，不知道为什么，但确实是在 org.apache.ibatis.plugin 包下面 既然是拦截器，可以拦截哪些内容呢？试想一下…… 当程序写到持久层时，Mybatis 会 执行 指定 SQL 语句，并处理 请求参数 和 返回值。没错，Mybatis 拦截器可以帮助我们处理上述内容，请看官网的 Plugins 的片段, 内容不多 12345678// 执行Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)// 请求参数处理ParameterHandler (getParameterObject, setParameters)// 返回结果集处理ResultSetHandler (handleResultSets, handleOutputParameters)// SQL语句构建StatementHandler (prepare, parameterize, batch, update, query) 拦截器的使用如果需要实现自定义的拦截器，只需要实现 org.apache.ibatis.plugin.Interceptor 接口，该接口有三个方法： 12345Object intercept(Invocation invocation) throws Throwable;Object plugin(Object target);void setProperties(Properties properties); 我们要实现数据加密，进入数据库的字段不能是真实的数据，但是返回来的数据要真实可用，所以我们需要针对 Parameter 和 ResultSet 两种类型处理，同时为了更灵活的使用，我们需要自定义注解 自定义注解类注解，将注解放在实体类上 123456789/** * 需要加解密的类注解 */@Documented@Inherited@Target(&#123; ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface EncryptDecryptClass &#123;&#125; 字段注解，将注解放在实体字段上 12345678910/** * 加密字段注解 */@Documented@Inherited@Target(&#123; ElementType.FIELD &#125;)@Retention(RetentionPolicy.RUNTIME)public @interface EncryptDecryptField &#123;&#125; 有了这两个注解，我们可以在我们可以标记我们要处理的实体和实体中的字段 自定义参数处理拦截器参考官网，通过 @Intercepts 和 @Signature 的联合使用，指定 ParameterHandler.class 类型，同时通过 @Component 注解注入到容器中，即可在设置参数的时候进行拦截，通过自定义接口 IEncryptDecrypt, 根据 Field 的各种类型自定义加密解密算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Intercepts(&#123; @Signature(type = ParameterHandler.class, method = \"setParameters\", args = PreparedStatement.class),&#125;)@ConditionalOnProperty(value = \"domain.encrypt\", havingValue = \"true\")@Component@Slf4jpublic class ParammeterInterceptor implements Interceptor &#123; @Autowired private IEncryptDecrypt encryptDecrypt; @Override public Object intercept(Invocation invocation) throws Throwable &#123; log.info(\"拦截器ParamInterceptor\"); //拦截 ParameterHandler 的 setParameters 方法 动态设置参数 if (invocation.getTarget() instanceof ParameterHandler) &#123; ParameterHandler parameterHandler = (ParameterHandler) invocation.getTarget(); PreparedStatement ps = (PreparedStatement) invocation.getArgs()[0]; // 反射获取 BoundSql 对象，此对象包含生成的sql和sql的参数map映射 /*Field boundSqlField = parameterHandler.getClass().getDeclaredField(\"boundSql\"); boundSqlField.setAccessible(true); BoundSql boundSql = (BoundSql) boundSqlField.get(parameterHandler);*/ // 反射获取 参数对像 Field parameterField = parameterHandler.getClass().getDeclaredField(\"parameterObject\"); parameterField.setAccessible(true); Object parameterObject = parameterField.get(parameterHandler); if (Objects.nonNull(parameterObject))&#123; Class&lt;?&gt; parameterObjectClass = parameterObject.getClass(); EncryptDecryptClass encryptDecryptClass = AnnotationUtils.findAnnotation(parameterObjectClass, EncryptDecryptClass.class); if (Objects.nonNull(encryptDecryptClass))&#123; Field[] declaredFields = parameterObjectClass.getDeclaredFields(); final Object encrypt = encryptDecrypt.encrypt(declaredFields, parameterObject); &#125; &#125; &#125; return invocation.proceed(); &#125; @Override public Object plugin(Object o) &#123; return Plugin.wrap(o, this); &#125; @Override public void setProperties(Properties properties) &#123; &#125;&#125; 同样新建结果集拦截器 结果集拦截器与参数拦截器基本一样, 只不过类型指定为 ResultSetHandler.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Intercepts(&#123; @Signature(type = ResultSetHandler.class, method = \"handleResultSets\", args=&#123;Statement.class&#125;)&#125;)@ConditionalOnProperty(value = \"domain.decrypt\", havingValue = \"true\")@Component@Slf4jpublic class ResultInterceptor implements Interceptor &#123; @Autowired private IEncryptDecrypt encryptDecrypt; @Override public Object intercept(Invocation invocation) throws Throwable &#123; Object result = invocation.proceed(); if (Objects.isNull(result))&#123; return null; &#125; if (result instanceof ArrayList) &#123; ArrayList resultList = (ArrayList) result; if (CollectionUtils.isNotEmpty(resultList) &amp;&amp; needToDecrypt(resultList.get(0)))&#123; for (int i = 0; i &lt; resultList.size(); i++) &#123; encryptDecrypt.decrypt(resultList.get(i)); &#125; &#125; &#125;else &#123; if (needToDecrypt(result))&#123; encryptDecrypt.decrypt(result); &#125; &#125; return result; &#125; public boolean needToDecrypt(Object object)&#123; Class&lt;?&gt; objectClass = object.getClass(); EncryptDecryptClass encryptDecryptClass = AnnotationUtils.findAnnotation(objectClass, EncryptDecryptClass.class); if (Objects.nonNull(encryptDecryptClass))&#123; return true; &#125; return false; &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; @Override public void setProperties(Properties properties) &#123; &#125;&#125; 加密解密IEncryptDecrypt 接口定义了 加密和解密两个方法， 1234567891011121314151617181920public interface IEncryptDecrypt &#123; /** * 加密方法 * @param declaredFields 反射bean成员变量 * @param parameterObject Mybatis入参 * @param &lt;T&gt; * @return */ public &lt;T&gt; T encrypt(Field[] declaredFields, T parameterObject) throws IllegalAccessException; /** * 解密方法 * @param result Mybatis 返回值，需要判断是否是ArrayList类型 * @param &lt;T&gt; * @return */ public &lt;T&gt; T decrypt(T result) throws IllegalAccessException;&#125; 两个拦截器通过在 YAML 中配置属性，按条件注入，外加自定义加密解密算法，完成全局灵活的配置。核心代码已上传至 Github Demo 问题彩蛋也许应对当前的业务，看了该文章满足了当下需求，我们目前只看到了什么是 Mybatis 拦截器，怎样简单使用，拦截器的其他用法以及其他很多为什么都没有解决，关注公众号，回复“人迹罕至” 读完文章 「程序猿为什么要看源码」后 ，我不会满足眼前的这些基本应用，我会有诸多疑问， 我们日常写 CRUD 的业务，为什么 Executor 中只有 R(query) 和 U(update), 那么C(insert) 和 D(delete) 怎样处理的？ 自定义拦截器是以什么方式被执行的，执行顺序是什么？ 分页也是 Mybatis 拦截器的一种，带有分页的框架是怎样使用拦截器的呢？如 Mybatis Plus, PageHelper 虽然重写了 Inteceptor 接口的 public void setProperties(Properties properties) 方法，但是并没有写什么业务逻辑，这个方法能怎样使用？ ……后续文章也会通过读源码的方式逐步解析这些问题，当然你有相关问题也可以留言交流讨论 提高效率工具依旧推荐在写文章时用到的高效工具，后续相关工具也会在文章中陆续更新，请持续关注 MyBatis Log PluginMyBatis Log Plugin 是 Intelligj IDEA 的一个插件，用来从 Mybatis 输出的 log 中提取出当前调用的 SQL 语句，并将参数封装在 SQL 语句中组成完整的 SQL，这样，当我们调试的时候更加清晰方便，可以轻松定位是否 SQL 又问题 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Mybatis","slug":"Coding/Mybatis","permalink":"https://dayarch.top/categories/Coding/Mybatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://dayarch.top/tags/MyBatis/"}]},{"title":"Java String基础面试","slug":"Java String基础面试","date":"2019-08-31T03:57:49.000Z","updated":"2019-12-17T12:47:59.582Z","comments":true,"path":"/p/java-string-interview.html","link":"","permalink":"https://dayarch.top/p/java-string-interview.html","excerpt":"关于 Java String，这是面试的基础，但是还有很多童鞋不能说清楚，所以本文将简单而又透彻的说明一下那个让你迷惑的 String 在 Java 中，我们有两种方式创建一个字符串 1 2 String x = \"abc\"; String y = new String(\"abc\"); 你常见也常写第一种，很少见第二种，但面试还总问这类问题，双引号和构造器两种形式创建字符串到底有什么差别呢？ 先来看例子 例子 1 1 2 3 4 String a = \"abcd\"; String b = \"abcd\"; System.out.println(a == b); // T","text":"关于 Java String，这是面试的基础，但是还有很多童鞋不能说清楚，所以本文将简单而又透彻的说明一下那个让你迷惑的 String 在 Java 中，我们有两种方式创建一个字符串 12String x = \"abc\";String y = new String(\"abc\"); 你常见也常写第一种，很少见第二种，但面试还总问这类问题，双引号和构造器两种形式创建字符串到底有什么差别呢？ 先来看例子 例子 11234String a = \"abcd\";String b = \"abcd\";System.out.println(a == b); // TrueSystem.out.println(a.equals(b)); // True a == b 结果为 true，是因为 a 和 b 都指向 方法区(method area) 同一个字符串文字，内存引用是同一个 当多次创建相同的字符串文字时，只存储每个不同字符串值的一个副本。这个叫做字符串留驻/留用，Java 中所有编译期字符串常量都会被自动留驻 例子 21234String c = new String(\"abcd\");String d = new String(\"abcd\");System.out.println(c == d); // FalseSystem.out.println(c.equals(d)); // True c==d 结果为 false，因为 c 和 d 的引用指向堆中不同的对象，不同的对象肯定有不同的内存引用 举了两个例子，文字描述有点懵？我们来试图通过图形来理解上述两种情况: 也许你已经看看出来了，一个是在方法区，一个是在堆中，在 JVM 模型中这是两个不同的区域，也许你面试时也经常被问到吧，来看下图: 再次提醒一下，所有 new 的对象都会在 Heap 中，这样以后你就好区分了 运行期字符串留驻上面说的字符串留驻是在编译期，那么运行期可以吗？答案是肯定的，我们需要一个函数来帮忙 1234String c = new String(\"abcd\").intern();String d = new String(\"abcd\").intern();System.out.println(c == d); // Now trueSystem.out.println(c.equals(d)); // True 看到 c == d 结果为 true，你应该理解 intern (英文有拘留，软禁的意思)的作用了，通过调用 intern()方法，就好比把创建的字符串拘留在方法区一样了 在面试时甚至还会问你下面代码创建了几个对象: 1String d = new String(\"abcd\") 如果方法区已存在”abcd”, 那么只创建一个 new String 的对象 如果方法区没有”abcd”, 那么要创建两个对象，一个在方法区，一个在堆中 所以，正常情况下我们没必要使用构造器创建对象，因为这很可能会产生一个额外的没用的对象，但是有例外哦，我们下面说 12String s = \"abcd\";s = s.concat(\"ef\"); 当我们想在字符串 s 后面拼接字符”ef”时，会在堆中创建一个新的对象，并将 s 的引用指向新创建的对象，由于 String 创建的是不可变对象，所以 String 类中的所有方法都不会改变它自身，而是返回一个新的字符串(快打开你的 IDE，看看是否每个操作String 的方法最后都是返回有 return new String 字样)，到这里你也应该理解了一个道理: 如果我们需要一个字符串被修改，我们最好使用 StringBuffer 或者 StringBuilder，否则，由于每次操作字符串都会创建一个新的对象，而旧的对象不会有引用指向它，这样我们会浪费很多垃圾回收的时间 到这里还没完，你有没有想过为什么 String 会被设置/制造成 final？ 为什么 String 类被 final 修饰谈及这个问题我们需要一些倒推的或者相互约束思维来思考 字符串池的需求字符串池(String intern pool)是方法区域中的一个特殊存储区域。当创建一个字符串时，如果该字符串已经存在于池中，那么返回现有字符串的引用，而不是创建一个新对象。所以说，如果一个字符串是可变的，那么改变一个引用的值，将导致原本指向该值的引用获取到错误的值 缓存 hashcode字符串的hashcode在Java中经常使用。例如，在HashMap或HashSet中。不可变保证hashcode始终是相同的，这样就可以在不担心更改的情况下兑现它。这意味着，不需要每次使用hashcode时都计算它。这样更有效率。所以你会在 String 类中看到下面的成员变量的定义: 12/** Cache the hash code for the string */private int hash; // Default to 0 安全性String被广泛用作许多java类的参数，例如网络连接、打开文件等。如果字符串不是不可变的，连接或文件将被更改，这可能导致严重的安全威胁。该方法认为它连接到一台机器上，但实际上并没有。可变字符串也可能导致反射中的安全问题，因为参数是字符串。 不可变对象天生是线程安全的由于不可变对象不能被更改，所以它们可以在多个线程之间自由共享。这消除了同步的需求。 总之，出于效率和安全性的考虑，String 被设计为不可变的。这也是为什么在一般情况下，不可变类是首选的原因。 附加说明关于不可变对象和不可变引用总是有同学搞不清楚 1final User user = new User(); 上面的代码指的是 user 引用不能被更改指向内存的其他地址，但是由于 User 是可变对象，我们可以调用 user 的 setter 方法修改其属性 在String类中包含很多学问，包括你对JVM模型的理解，这也就是为什么面试官为什么喜欢问String，主要考察你的基本功 灵魂追问 String 和基本类型的包装类如 Integer 和 Long 都被 final 修饰，但为什么不建议作为 synchronized 同步块的参数适用呢？ 基本类型自动装箱你知道发生了什么吗？和上一个问题有关系 提高效率工具 Material Theme UI这是一款 IDEA 的主题插件，安装后，选择 Material Palenight 主题，同时作出如下设置 设置完后，你的 IDEA 就是下面这样，引起极度舒适 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://dayarch.top/tags/JVM/"},{"name":"面试","slug":"面试","permalink":"https://dayarch.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"并发编程三大核心","slug":"分工-同步-互斥是并发编程三大核心","date":"2019-08-28T12:29:07.000Z","updated":"2019-11-07T06:37:29.576Z","comments":true,"path":"/p/java-concurrency-core.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-core.html","excerpt":"写在前面 上一篇文章这次走进并发的世界，请不要错过 给大家带了并发编程的开胃菜，接下来我们逐步上正餐，在吃正餐之前，我还要引用那首诗词: 「横看成岭侧成峰，远近高低各不同」，远看看轮廓，近看看细节，不断切换思维或视角来学习 远看并发，并发编程可以抽象成三个核心问题: 分工、同步/协作、互斥 如果你已经工作了，那么你一定听说过或者正在应用敏捷开发模式来交付日常的工作任务，我们就用你熟悉的流程来解释这三个核心问题 分工 将当前 Sprint 的 Story 拆分成「合适」大小的 Task，并且安排给「合适」的 Team Member 去完成 这里面用了两个「合适」，将 Story 拆分","text":"写在前面上一篇文章这次走进并发的世界，请不要错过 给大家带了并发编程的开胃菜，接下来我们逐步上正餐，在吃正餐之前，我还要引用那首诗词: 「横看成岭侧成峰，远近高低各不同」，远看看轮廓，近看看细节，不断切换思维或视角来学习 远看并发，并发编程可以抽象成三个核心问题: 分工、同步/协作、互斥 如果你已经工作了，那么你一定听说过或者正在应用敏捷开发模式来交付日常的工作任务，我们就用你熟悉的流程来解释这三个核心问题 分工 将当前 Sprint 的 Story 拆分成「合适」大小的 Task，并且安排给「合适」的 Team Member 去完成 这里面用了两个「合适」，将 Story 拆分成大小适中，可完成的 Task 是非常重要的。拆分的粒度太粗，导致这个任务完成难度变高，耗时长，不易与其他人配合；拆分的粒度太细，又导致任务太多，不好管理与追踪，浪费精力和资源。(合适的线程才能更好的完成整块工作，当然一个线程可以轻松搞定的就没必要多线程)；安排给合适的人员去完成同样重要，UX-UE 问题交给后端人员处理，很显然是有问题的 (主线程应该做的事交给子线程显然是解决不了问题的，每个线程做正确的事才能发挥作用) 关于分工，常见的 Executor，生产者-消费者模式，Fork/Join 等，这都是分工思想的体现 同步/协作任务拆分完毕，我要等张三的任务，张三要等李四的任务，也就是说任务之间存在依赖关系，前面的任务执行完毕，后面的任务才可以执行，人高级在可以通过沟通反复确认，确保自己的任务可以开始执行。但面对程序，我们需要了解程序的沟通方式，一个线程执行完任务，如何通知后续线程执行 所有的同步/协作关系我们都可以用你最熟悉的 If-then-else 来表示: 12345if(前序任务完成)&#123; execute();&#125;else&#123; wait();&#125; 上面的代码就是说:当某个条件不满足时，线程需要等待；当某个条件满足时，线程需要被唤醒执行，线程之间的协作可能是主线程与子线程的协作，可能是子线程与子线程的合作， Java SDK 中 CountDownLatch 和 CyclicBarrier 就是用来解决线程协作问题的 互斥分工和同步强调的是性能，但是互斥是强调正确性，就是我们常常提到的「线程安全」，当多个线程同时访问一个共享变量/成员变量时，就可能发生不确定性，造成不确定性主要是有可见性、原子性、有序性这三大问题，而解决这些问题的核心就是互斥 互斥 同一时刻，只允许一个线程访问共享变量 来看下图，主干路就是共享变量，进入主干路一次只能有一辆车，这样你是否理解了呢？「天下大事，分久必合」 同样 Java SDK 也有很多互斥的解决方案，比如你马上就能想到 synchronized 关键字，Lock，ThreadLocal 等就是互斥的解决方案 总结资本家疯狂榨取劳动工人的剩余价值，获得最大收益。当你面对 CPU，内存，IO 这些劳动工人时，你就是那个资本家，你要思考如何充分榨取它们的价值 当一个工人能干的活，绝不让两个人来干(单线程能满足就没必要为了多线程)当多个工人干活时，就要让他们分工明确，合作顺畅，没矛盾 当任务很大时，由于 IO 干活慢，CPU 干活快，就没必要让 CPU 死等当前的 IO，转而去执行其他指令，这就是榨取剩余价值，如何最大限度的榨取其价值，这就涉及到后续的调优问题，比如多少线程合适等 分工是设计，同步和互斥是实现，没有好的设计也就没有好的实现，所以在分工阶段，强烈建议大家勾划草图，了解瓶颈所在，这样才会有更好的实现，后续章节的内容，我也会带领大家画草图，分析问题，逐步养成这个习惯 本章内容可以用下面的图来简单概括，叶子结点的内容我们会逐步点亮，现阶段不用过分关注(如果你上来就啃 JDK 源码，也许你会痛苦的迷失，并最终放弃你的进阶之路的) 理解三大核心问题，你要充分结合生活中的实际，程序中的并发问题，基本上都能在实际生活中找得到原型 下一篇文章的内容，我们就要聊聊，引起线程安全的三个问题:「可见性，原子性，有序性」，这涉及到 JMM 的一点内容，可以提前了解一下的，这样我们才能更好的碰撞 灵魂追问 工作中多线程编程的场景多吗？ 想到多线程，只会想到 synchronized 吗？ Java 并发包各个类，你有了解底层实现和设计理念吗？ 提高效率工具 推荐阅读 每天用SpringBoot，还不懂RESTful API返回统一数据格式是怎么实现的？ 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 红黑树，超强动静图详解，简单易懂 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"分工","slug":"分工","permalink":"https://dayarch.top/tags/%E5%88%86%E5%B7%A5/"},{"name":"同步","slug":"同步","permalink":"https://dayarch.top/tags/%E5%90%8C%E6%AD%A5/"},{"name":"互斥","slug":"互斥","permalink":"https://dayarch.top/tags/%E4%BA%92%E6%96%A5/"}]},{"title":"并发编程之初探","slug":"并发编程之初探","date":"2019-08-25T11:45:08.000Z","updated":"2019-11-07T06:38:05.265Z","comments":true,"path":"/p/java-concurrency-metaphor.html","link":"","permalink":"https://dayarch.top/p/java-concurrency-metaphor.html","excerpt":"写在前面 Java 有进阶，其名为并发，并发知识之大，一口吃不下。那好，请您多吃几口，又没说一顿吃完，细嚼慢咽才有味. 所有 Java 书籍都将并发编程放在其高级/进阶篇章中，其重要性不言而喻，学好并发也是自身走入高级行列的必备素质之一 并发/并行，进程/线程 这些概念总是显得过于抽象，因为这是与操作系统沟通用到的词汇，就像我们习惯了使用十进制算法，二进制和 16 进制就需要思维的切换；生活中，我们彼此总是不能互相理解，平静之后，我们知道要换位思考；程序的世界也一样，为了更好的理解问题，你也要站在操作系统的角度来思考问题，但当你尝试理解对方时，是违背自己认知习惯的，所以有些困难在所难免 生","text":"写在前面Java 有进阶，其名为并发，并发知识之大，一口吃不下。那好，请您多吃几口，又没说一顿吃完，细嚼慢咽才有味. 所有 Java 书籍都将并发编程放在其高级/进阶篇章中，其重要性不言而喻，学好并发也是自身走入高级行列的必备素质之一 并发/并行，进程/线程 这些概念总是显得过于抽象，因为这是与操作系统沟通用到的词汇，就像我们习惯了使用十进制算法，二进制和 16 进制就需要思维的切换；生活中，我们彼此总是不能互相理解，平静之后，我们知道要换位思考；程序的世界也一样，为了更好的理解问题，你也要站在操作系统的角度来思考问题，但当你尝试理解对方时，是违背自己认知习惯的，所以有些困难在所难免 生活中你一定说过「杀鸡焉用牛刀？」这句话，并发编程中的各种锁(内置锁/显示锁/偏向锁/轻量锁/重量锁/乐观锁/悲观锁)，看到眼花缭乱，有时候很小的问题却用了很重的锁，这是没有必要的；但是这些锁，没有最好的那个，只有最合适和更高效的那个 JUC (java.util.concurrent) 包随着 JDK 的版本升级内容也变的越来越多，面对琳琅满目的并发类，又有些无从下手，其实他们都有一定的联系，我们需要找到升级的主线，让其变得有迹可循. 谈及并发编程，我还是带有一丝惶恐: 如何将这些抽象的概念变得具象？ 如何将编程问题联系到生活实际? 如何在抽象和具象之间切换思维? 个人觉得这些都是学好并发编程的关键。所以关于并发编程的系列文章，我打算从以上几点出发，将技术问题以幽默风趣具象的方式落地 如何学并发「横看成岭侧成峰，远近高低各不同」，在之前的文章中多次引用了这段诗词，我们学习技术也要这样，远观看轮廓，近观看细节，从不同的角度看待问题，在后续的文章中，也希望大家不要将思维局限，尝试跳入/跳出，抽象/具象 郑重声明，接下来不是广告我希望和大家共同完成并发编程系列有更多的思想碰撞，希望大家在读这个系列的同时也阅读以下书籍逐步形成自己的知识体系，这里附上个人认为的最佳阅读顺序: 1.「Java并发编程实战」 该书籍是值得返回看的，第一遍不需要精度，主要是为了建立一个并发的思想，和关键术语的大致记忆，先阅读第 16 章也是极好的，理解 JMM 是实践并发编程的基础 2. 「码出高效」可直接阅读第七章「并发与多线程」，这个章节更好的将技术问题联系到了生活实际，有了「并发编程实战」的铺底，相信，看这个章节会更有感觉 3. 「Java并发编程之美」 这本书从第 5 章开始，就会有源码分析，有前辈带领读源码，轻松多了，这回让你更加了解本质，同时也会找到 JUC 升级的主线 4. 「Java 并发编程的艺术」这本书会满足你从各个角度看待并发编程问题 慎重，如果你是买书如山倒，读书如抽丝的童鞋，请忽略这点内容，停止你的买书行动，请安心跟踪公众号的内容即可 计划如无特殊异常，会按照 1 周 1 篇的节奏来分享，会控制篇幅大小，给大家留有思考空间，期待大家带着疑问等待下一篇文章的到来，我会从大家更多了解的内容出发，逐步走入并发的世界 并发开胃菜不再多废话，拿出之前收藏的一篇文章作为并发编程的开胃小菜，通过这个形象比喻，希望大家能对并发有个初步的了解: 摘自: https://www.cnblogs.com/CoolRandy/p/3169938.html 觉得图解的很到位，将并发编程的几个核心要素都以具象的形式表达出来了，接下来看看何为 进程（process）和 线程（thread） 1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。 3.进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个 进程，其他 进程 处于非运行状态。 4.一个车间里，可以有很多工人。他们协同完成一个任务。 5.线程 就好比车间里的工人。一个 进程 可以包括多个 线程。 6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个 进程 的内存空间是共享的，每个 线程 都可以使用这些共享内存。 7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个 线程 使用某些共享内存时，其他 线程 必须等它结束，才能使用这一块内存。 8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫 “互斥锁”（Mutual exclusion，缩写 Mutex），防止多个 线程 同时读写某一块内存区域。 9.还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的 线程 使用。 10.这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做 “信号量”（Semaphore），用来保证多个 线程 不会互相冲突。 不难看出，Mutex (互斥锁) 是 Semaphore (信号量)的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为 mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 11.操作系统的设计，因此可以归结为三点：（1）以多 进程 形式，允许多个任务同时运行；（2）以多 线程 形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止 进程 之间和 线程 之间产生冲突，另一方面允许 进程 之间和 线程 之间共享资源。 相信看过这之后就了解了并发编程大概要关注的一些内容了，在后续的文章中，希望大家牢记，你是一个工厂只能有一个车间运行的负责人，如何让工人高效的干活且不出差错，也不起冲突，你就是合格的负责人…… 提高效率工具 [center] 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java-Concurrency","slug":"Coding/Java-Concurrency","permalink":"https://dayarch.top/categories/Coding/Java-Concurrency/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://dayarch.top/tags/thread/"},{"name":"并发","slug":"并发","permalink":"https://dayarch.top/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"SpringBoot统一异常处理","slug":"SpringBoot统一异常处理","date":"2019-08-09T07:13:46.000Z","updated":"2019-11-07T06:37:19.144Z","comments":true,"path":"/p/spring-boot-global-exception.html","link":"","permalink":"https://dayarch.top/p/spring-boot-global-exception.html","excerpt":"话说异常 「欲渡黄河冰塞川，将登太行雪满天」，无论生活还是计算机世界难免发生异常，上一篇文章RESTful API 返回统一JSON数据格式 说明了统一返回的处理，这是请求一切正常的情形；这篇文章将说明如何统一处理异常，以及其背后的实现原理，老套路，先实现，后说明原理，有了上一篇文章的铺底，相信，理解这篇文章就驾轻就熟了 实现 新建业务异常 新建 BusinessException.class 类表示业务异常，注意这是一个 Runtime 异常 1 2 3 4 5 6 7 8 9 @Data @AllArgsConstructor public final class Busine","text":"话说异常「欲渡黄河冰塞川，将登太行雪满天」，无论生活还是计算机世界难免发生异常，上一篇文章RESTful API 返回统一JSON数据格式 说明了统一返回的处理，这是请求一切正常的情形；这篇文章将说明如何统一处理异常，以及其背后的实现原理，老套路，先实现，后说明原理，有了上一篇文章的铺底，相信，理解这篇文章就驾轻就熟了 实现新建业务异常新建 BusinessException.class 类表示业务异常，注意这是一个 Runtime 异常 123456789@Data@AllArgsConstructorpublic final class BusinessException extends RuntimeException &#123; private String errorCode; private String errorMsg;&#125; 添加统一异常处理静态方法在 CommonResult 类中添加静态方法 errorResult 用于接收异常码和异常消息: 1234567public static &lt;T&gt; CommonResult&lt;T&gt; errorResult(String errorCode, String errorMsg)&#123; CommonResult&lt;T&gt; commonResult = new CommonResult&lt;&gt;(); commonResult.errorCode = errorCode; commonResult.errorMsg = errorMsg; commonResult.status = -1; return commonResult;&#125; 配置同样要用到 @RestControllerAdvice 注解，将统一异常添加到配置中: 12345678@RestControllerAdvice(\"com.example.unifiedreturn.api\")static class UnifiedExceptionHandler&#123; @ExceptionHandler(BusinessException.class) public CommonResult&lt;Void&gt; handleBusinessException(BusinessException be)&#123; return CommonResult.errorResult(be.getErrorCode(), be.getErrorMsg()); &#125;&#125; 三部搞定，到这里无论是 Controller 还是 Service 中，只要抛出 BusinessException, 我们都会返回给前端一个统一数据格式 测试将 UserController 中的方法进行改造，直接抛出异常: 1234@GetMapping(\"/&#123;id&#125;\")public UserVo getUserById(@PathVariable Long id)&#123; throw new BusinessException(\"1001\", \"根据ID查询用户异常\");&#125; 浏览器中输入: http://localhost:8080/users/1 在 Service 中抛出异常: 1234567891011121314@Servicepublic class UserServiceImpl implements UserService &#123; /** * 根据用户ID查询用户 * * @param id * @return */ @Override public UserVo getUserById(Long id) &#123; throw new BusinessException(\"1001\", \"根据ID查询用户异常\"); &#125;&#125; 运行是得到同样的结果，所以我们尽可能的抛出异常吧 (作为一个程序猿这种心理很可拍) 解剖实现过程解剖这个过程是相当纠结的，为了更好的说(yin)明(wei)问(wo)题(lan)，我要说重中之重了，真心希望看该文章的童鞋自己去案发现场发现线索还是在 WebMvcConfigurationSupport 类中实例化了 HandlerExceptionResolver Bean 12345678910111213@Beanpublic HandlerExceptionResolver handlerExceptionResolver() &#123; List&lt;HandlerExceptionResolver&gt; exceptionResolvers = new ArrayList&lt;&gt;(); configureHandlerExceptionResolvers(exceptionResolvers); if (exceptionResolvers.isEmpty()) &#123; addDefaultHandlerExceptionResolvers(exceptionResolvers); &#125; extendHandlerExceptionResolvers(exceptionResolvers); HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite(); composite.setOrder(0); composite.setExceptionResolvers(exceptionResolvers); return composite;&#125; 和上一篇文章一毛一样的套路，ExceptionHandlerExceptionResolver 实现了 InitializingBean 接口，重写了 afterPropertiesSet 方法: 123456789101112131415161718192021222324252627282930@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBodyAdvice beans initExceptionHandlerAdviceCache(); ...&#125;private void initExceptionHandlerAdviceCache() &#123; if (getApplicationContext() == null) &#123; return; &#125; List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext()); AnnotationAwareOrderComparator.sort(adviceBeans); for (ControllerAdviceBean adviceBean : adviceBeans) &#123; Class&lt;?&gt; beanType = adviceBean.getBeanType(); if (beanType == null) &#123; throw new IllegalStateException(\"Unresolvable type for ControllerAdviceBean: \" + adviceBean); &#125; // 重点看这个构造方法 ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType); if (resolver.hasExceptionMappings()) &#123; this.exceptionHandlerAdviceCache.put(adviceBean, resolver); &#125; if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123; this.responseBodyAdvice.add(adviceBean); &#125; &#125;&#125; 重点看上面我用注释标记的构造方法，代码很好懂，仔细看看吧，其实就是筛选出我们用 @ExceptionHandler 注解标记的方法并放到集合当中，用于后续全局异常捕获的匹配 123456789101112131415161718192021222324252627282930313233343536373839/** * A constructor that finds &#123;@link ExceptionHandler&#125; methods in the given type. * @param handlerType the type to introspect */public ExceptionHandlerMethodResolver(Class&lt;?&gt; handlerType) &#123; for (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) &#123; for (Class&lt;? extends Throwable&gt; exceptionType : detectExceptionMappings(method)) &#123; addExceptionMapping(exceptionType, method); &#125; &#125;&#125;/** * Extract exception mappings from the &#123;@code @ExceptionHandler&#125; annotation first, * and then as a fallback from the method signature itself. */@SuppressWarnings(\"unchecked\")private List&lt;Class&lt;? extends Throwable&gt;&gt; detectExceptionMappings(Method method) &#123; List&lt;Class&lt;? extends Throwable&gt;&gt; result = new ArrayList&lt;&gt;(); detectAnnotationExceptionMappings(method, result); if (result.isEmpty()) &#123; for (Class&lt;?&gt; paramType : method.getParameterTypes()) &#123; if (Throwable.class.isAssignableFrom(paramType)) &#123; result.add((Class&lt;? extends Throwable&gt;) paramType); &#125; &#125; &#125; if (result.isEmpty()) &#123; throw new IllegalStateException(\"No exception types mapped to \" + method); &#125; return result;&#125;private void detectAnnotationExceptionMappings(Method method, List&lt;Class&lt;? extends Throwable&gt;&gt; result) &#123; ExceptionHandler ann = AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class); Assert.state(ann != null, \"No ExceptionHandler annotation\"); result.addAll(Arrays.asList(ann.value()));&#125; 到这里，我们用 @RestControllerAdvice 和 @ExceptionHandler 注解就会被 Spring 扫描到上下文，供我们使用 让我们回到你最熟悉的调用的入口 DispatcherServlet 类的 doDispatch 方法: 123456789101112131415161718192021222324252627protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; ... // 当请求发生异常，该方法会通过 catch 捕获异常 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); ... &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 调用该方法分析捕获的异常 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; ...&#125; 接下来，我们来看 processDispatchResult 方法，这里只要展示调用栈你就会眼前一亮了，又是为了返回统一格式数据: 总结上一篇文章的返回统一数据格式是基础，当异常情况发生时，只不过需要将异常信息提取出来。本文主要为了说明问题，剖析原理，好多地方设计方式是不可取，比如我们最好将异常封装在一个 Enum 类，通过 enum 对象抛出异常等，如果你用到这些，去完善你的设计方案吧 回复 「demo」，打开链接，查看文件夹 「unifiedreturn」下内容，获取完整代码 附加说明之前看到的一本书对异常的分类让我印象深刻，在此摘录一小段分享给大家: 结合出国旅行的例子说明异常分类: 机场地震，属于不可抗力，对应异常分类中的 Error，在制订出行计划时，根本不需要把这个部分的异常考虑进去 堵车属于 checked 异常，应对这种异常，我们可以提前出发，或者改签机票。而飞机延误异常,虽然也需要 check，但我们无能为力，只能持续关注航班动态 没有带护照，明显属于可提前预测的异常，只要出发前检查即可避免；去机场路上车子抛锚，这个异常是突发的，虽然难以预料，但是必须处理，属于需要捕捉的异常，可以通过更换交通工具；应对检票机器故障属于 可透出异常，交由航空公司处理,我们无须关心 灵魂追问 这两篇文章，你学到了哪些设计模式？ 你能熟练的使用反射吗？当看源码是会看到很多反射的应用 你了解 Spring CGLIB 吗？它的工作原理是什么？ 提高效率工具 JSON-ViewerJSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入json-viewer + TAB ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题 另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"https://dayarch.top/tags/Exception/"}]},{"title":"Springboot返回统一JSON数据格式是怎么实现的？","slug":"每天用SpringBoot，还不懂统一返回数据格式是怎么实现的？","date":"2019-08-08T13:22:23.000Z","updated":"2019-11-07T06:38:17.571Z","comments":true,"path":"/p/spring-boot-global-return.html","link":"","permalink":"https://dayarch.top/p/spring-boot-global-return.html","excerpt":"关于 Spring 的全局处理，我有两方面要说: 1. 统一数据返回格式 2. 统一异常处理 为了将两个问题说明清楚，将分两个章节分别说明，本章主要说第一点 有童鞋说，我们项目都做了这种处理，就是在每个 API 都单独工具类将返回值进行封装，但这种不够优雅；我想写最少的代码完成这件事，也许有童鞋说，加几个注解就解决问题了，说的没错，但这篇文章主要是为了说明为什么加了几个注解就解决问题了，目的是希望大家知其所以然。 为了更好的说明问题，本文先说明如何实现，然后再详细剖析实现原理(这很关键) 为什么要做统一数据返回格式 前后端分离是当今服务形式的主流，如何设计一个好的","text":"关于 Spring 的全局处理，我有两方面要说: 统一数据返回格式 统一异常处理为了将两个问题说明清楚，将分两个章节分别说明，本章主要说第一点 有童鞋说，我们项目都做了这种处理，就是在每个 API 都单独工具类将返回值进行封装，但这种不够优雅；我想写最少的代码完成这件事，也许有童鞋说，加几个注解就解决问题了，说的没错，但这篇文章主要是为了说明为什么加了几个注解就解决问题了，目的是希望大家知其所以然。 为了更好的说明问题，本文先说明如何实现，然后再详细剖析实现原理(这很关键) 为什么要做统一数据返回格式前后端分离是当今服务形式的主流，如何设计一个好的 RESTful API ，以及如何让前端小伙伴可以处理标准的 response JSON 数据结构都至关重要，为了让前端有更好的逻辑展示与页面交互处理，每一次 RESTful 请求都应该包含以下几个信息: 名称 描述 status 状态码，标识请求成功与否，如 [1:成功；-1:失败] errorCode 错误码，给出明确错误码，更好的应对业务异常；请求成功该值可为空 errorMsg 错误消息，与错误码相对应，更具体的描述异常信息 resultBody 返回结果，通常是 Bean 对象对应的 JSON 数据, 通常为了应对不同返回值类型，将其声明为泛型类型 实现通用返回值类定义根据上面的描述，用 Java Bean 来体现这个结构就是这样: 123456789101112131415161718@Datapublic final class CommonResult&lt;T&gt; &#123; private int status = 1; private String errorCode = \"\"; private String errorMsg = \"\"; private T resultBody; public CommonResult() &#123; &#125; public CommonResult(T resultBody) &#123; this.resultBody = resultBody; &#125;&#125; 配置没错，我们需要借助几个关键注解来完成一下相关配置: 123456789101112131415161718192021@EnableWebMvc@Configurationpublic class UnifiedReturnConfig &#123; @RestControllerAdvice(\"com.example.unifiedreturn.api\") static class CommonResultResponseAdvice implements ResponseBodyAdvice&lt;Object&gt;&#123; @Override public boolean supports(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass) &#123; return true; &#125; @Override public Object beforeBodyWrite(Object body, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) &#123; if (body instanceof CommonResult)&#123; return body; &#125; return new CommonResult&lt;Object&gt;(body); &#125; &#125;&#125; 到这里就结束了，我们就可以纵情的写任何 RESTful API 了，所有的返回值都会有统一的 JSON 结构 测试新建 UserController，添加相应的 RESTful API，测试用例写的比较简单，只为了说明返回值的处理 12345678910111213@RestController@RequestMapping(\"/users\")public class UserController &#123; @GetMapping(\"\") public List&lt;UserVo&gt; getUserList()&#123; List&lt;UserVo&gt; userVoList = Lists.newArrayListWithCapacity(2); userVoList.add(UserVo.builder().id(1L).name(\"日拱一兵\").age(18).build()); userVoList.add(UserVo.builder().id(2L).name(\"tan\").age(19).build()); return userVoList; &#125;&#125; 打开浏览器输入地址测试: http://localhost:8080/users/ ，我们可以看到返回了 List JSON 数据 继续添加 RESTful API，根据用户 ID 查询用户信息 1234@GetMapping(\"/&#123;id&#125;\")public UserVo getUserByName(@PathVariable Long id)&#123; return UserVo.builder().id(1L).name(\"日拱一兵\").age(18).build();&#125; 打开浏览器输入地址测试: http://localhost:8080/users/1 ，我们可以看到返回了单个 User JSON 数据 添加一个返回值类型为 ResponseEntity 的 API 1234@GetMapping(\"/testResponseEntity\")public ResponseEntity getUserByAge()&#123; return new ResponseEntity(UserVo.builder().id(1L).name(\"日拱一兵\").age(18).build(), HttpStatus.OK);&#125; 打开浏览器输入地址测试: http://localhost:8080/users/testResponseEntity ，我们可以看到同样返回了单个 User JSON 数据 解剖实现过程我会将关键部分一一说明清楚，断案还需小伙伴自己去案发现场(打开自己的 IDE 查看) 故事要从 @EnableWebMvc 这个注解说起，打开该注解看: 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; 通过 @Import 注解引入了 DelegatingWebMvcConfiguration.class，那来看这个类吧: 1234@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; ...&#125; 有 @Configuration 注解，你应该很熟悉了，该类的父类 WebMvcConfigurationSupport 中却隐藏着一段关键代码: 123456@Beanpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() &#123; RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter(); ... return adapter;&#125; RequestMappingHandlerAdapter 是每一次请求处理的关键，来看该类的定义: 1234public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; ...&#125; 该类实现了 InitializingBean 接口，我在 Spring Bean 生命周期之“我从哪里来”？ 这篇文章中明确说明了 Spring Bean 初始化的几个关键，其中 InitializingBean 接口的afterPropertiesSet 方法就是关键之一，在 RequestMappingHandlerAdapter 类中同样重写了该方法: 123456789101112131415161718@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBody advice beans initControllerAdviceCache(); if (this.argumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.initBinderArgumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125;&#125; 该方法内容都非常关键，但我们先来看 initControllerAdviceCache 方法，其他内容后续再单独说明: 123456789101112131415161718private void initControllerAdviceCache() &#123; ... if (logger.isInfoEnabled()) &#123; logger.info(\"Looking for @ControllerAdvice: \" + getApplicationContext()); &#125; List&lt;ControllerAdviceBean&gt; beans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext()); AnnotationAwareOrderComparator.sort(beans); List&lt;Object&gt; requestResponseBodyAdviceBeans = new ArrayList&lt;Object&gt;(); for (ControllerAdviceBean bean : beans) &#123; ... if (ResponseBodyAdvice.class.isAssignableFrom(bean.getBeanType())) &#123; requestResponseBodyAdviceBeans.add(bean); &#125; &#125;&#125; 通过 ControllerAdviceBean 静态方法扫描 ControllerAdvice 注解，可是我们在实现上使用的是 @RestControllerAdvice 注解，打开看该注解: 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@ControllerAdvice@ResponseBodypublic @interface RestControllerAdvice &#123; 该注解由 @ControllerAdvice 和 @ResponseBody 标记，就好比你熟悉的 @RestController 注解由 @Controller 和 @ResponseBody 标记是一样的 到这里你已经知道我们用 @RestControllerAdvice 标记的 Bean 是如何被加载到 Spring 上下文的，接下来就要知道是 Spring 是如何使用我们的 bean 以及对返回 body 做处理的 其实在 HttpMessageConverter是如何转换数据的？ 这篇文章中已经说明了一部分，希望小伙伴先看这篇文章，下面的部分就会秒懂了，我们在这里做进一步的说明 在 AbstractMessageConverterMethodProcessor 的 writeWithMessageConverters 方法中，有一段核心代码: 12345678910if (messageConverter instanceof GenericHttpMessageConverter) &#123; if (((GenericHttpMessageConverter) messageConverter).canWrite( declaredType, valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); ... return; &#125;&#125; 可以看到通过 getAdvice() 调用了 beforeBodyWrite 方法，我们已经接近真相了 123protected RequestResponseBodyAdviceChain getAdvice() &#123; return this.advice;&#125; RequestResponseBodyAdviceChain，看名字带有 Chain，很明显用到了「责任链设计模式」，这些内容在 不得不知的责任链设计模式 文章中明确说明过，只不过它传递责任链以循环的方式完成: 123456789101112131415161718192021222324class RequestResponseBodyAdviceChain implements RequestBodyAdvice, ResponseBodyAdvice&lt;Object&gt; &#123; @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType contentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType, ServerHttpRequest request, ServerHttpResponse response) &#123; return processBody(body, returnType, contentType, converterType, request, response); &#125; @SuppressWarnings(\"unchecked\") private &lt;T&gt; Object processBody(Object body, MethodParameter returnType, MediaType contentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType, ServerHttpRequest request, ServerHttpResponse response) &#123; for (ResponseBodyAdvice&lt;?&gt; advice : getMatchingAdvice(returnType, ResponseBodyAdvice.class)) &#123; if (advice.supports(returnType, converterType)) &#123; body = ((ResponseBodyAdvice&lt;T&gt;) advice).beforeBodyWrite((T) body, returnType, contentType, converterType, request, response); &#125; &#125; return body; &#125;&#125; 我们重写的 beforeBodyWrite 方法终究会被调用到，真相就是这样了!!! 其实还没完，你有没有想过，如果我们的 API 方法返回值是 org.springframework.http.ResponseEntity&lt;T&gt; 类型，我们可以指定 HTTP 返回状态码，但是这个返回值会直接放到我们的 beforeBodyWrite 方法的 body 参数中吗？如果这样做很明显是错误的，因为 ResponseEntity 包含很多我们非业务数据在里面，那 Spring 是怎么帮我们处理的呢？ 在我们方法取得返回值并且在调用 beforeBodyWrite 方法之前，还要选择 HandlerMethodReturnValueHandler 用于处理不同的 Handler 来处理返回值 在类 HandlerMethodReturnValueHandlerComposite 中的 handleReturnValue 方法中 12345678910@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName()); &#125; handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125; 通过调用 selectHandler 方法来选择合适的 handler，Spring 内置了很多个 Handler，我们来看类图: HttpEntityMethodProcessor 就是其中之一，它重写了 supportsParameter 方法，支持 HttpEntity 类型，即支持 ResponseEntity 类型: 12345@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return (HttpEntity.class == parameter.getParameterType() || RequestEntity.class == parameter.getParameterType());&#125; 所以当我们返回的类型为 ResponseEntity 时，就要通过 HttpEntityMethodProcessor 的 handleReturnValue 方法来处理我们的结果: 12345678910111213141516171819202122232425@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; ... if (responseEntity instanceof ResponseEntity) &#123; int returnStatus = ((ResponseEntity&lt;?&gt;) responseEntity).getStatusCodeValue(); outputMessage.getServletResponse().setStatus(returnStatus); if (returnStatus == 200) &#123; if (SAFE_METHODS.contains(inputMessage.getMethod()) &amp;&amp; isResourceNotModified(inputMessage, outputMessage)) &#123; // Ensure headers are flushed, no body should be written. outputMessage.flush(); // Skip call to converters, as they may update the body. return; &#125; &#125; &#125; // Try even with null body. ResponseBodyAdvice could get involved. writeWithMessageConverters(responseEntity.getBody(), returnType, inputMessage, outputMessage); // Ensure headers are flushed even if no body was written. outputMessage.flush();&#125; 该方法提取出 responseEntity.getBody()，并传递个 MessageConverter，然后再继续调用 beforeBodyWrite 方法，这才是真相!!! 这是 RESTful API 正常返回内容的情况，下一篇文章，让我们来侦查一下统一异常情况的处理以及实现原理 灵魂追问 返回值是非 ResponseEntity 类型时，用的是什么 handler？它支持的返回值类型是什么？看过你也许就知道为什么要用 @ResponseBody 注解了 你有追踪过 DispatchServlet 的整个请求过程吗？ 提高效率工具 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 | 回复「工具」 面试问题分析与解答 技术资料领取 | 回复「资料」 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"Shiro—小而美的安全框架","slug":"Shiro—小而美的安全框架","date":"2019-08-05T03:21:40.000Z","updated":"2019-11-07T06:36:52.166Z","comments":true,"path":"/p/shiro-in-practice.html","link":"","permalink":"https://dayarch.top/p/shiro-in-practice.html","excerpt":"写在前面 在一款应用的整个生命周期，我们都会谈及该应用的数据安全问题。用户的合法性与数据的可见性是数据安全中非常重要的一部分。但是，一方面，不同的应用对于数据的合法性和可见性要求的维度与粒度都有所区别；另一方面，以当前微服务、多服务的架构方式，如何共享Session，如何缓存认证和授权数据应对高并发访问都迫切需要我们解决。Shiro的出现让我们可以快速和简单的应对我们应用的数据安全问题 Shiro介绍 Shiro简介 这个官网解释不抽象，所以直接用官网解释：Apache Shiro™是一个强大且易用的 Java 安全框架，可以执行身份验证、授权、加密和会话管理等。基于 Shiro 的易于理解","text":"写在前面在一款应用的整个生命周期，我们都会谈及该应用的数据安全问题。用户的合法性与数据的可见性是数据安全中非常重要的一部分。但是，一方面，不同的应用对于数据的合法性和可见性要求的维度与粒度都有所区别；另一方面，以当前微服务、多服务的架构方式，如何共享Session，如何缓存认证和授权数据应对高并发访问都迫切需要我们解决。Shiro的出现让我们可以快速和简单的应对我们应用的数据安全问题 Shiro介绍Shiro简介这个官网解释不抽象，所以直接用官网解释：Apache Shiro™是一个强大且易用的 Java 安全框架，可以执行身份验证、授权、加密和会话管理等。基于 Shiro 的易于理解的API，您可以快速、轻松地使任何应用程序变得安全（从最小的移动应用到最大的网络和企业应用）。 谈及安全，多数 Java 开发人员都离不开 Spring 框架的支持，自然也就会先想到 Spring Security，那我们先来看二者的差别 Shiro Spring Security 简单、灵活 复杂、笨重 可脱离Spring 不可脱离Spring 粒度较粗 粒度较细 虽然 Spring Security 属于名震中外 Spring 家族的一部分，但是了解 Shiro 之后，你不会想 “嫁入豪门”，而是选择追求「诗和远方」冲动。 横看成岭侧成峰，远近高低各不同 (依旧是先了解概念就好) 远看 Shiro 看轮廓 Subject它是一个主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者 SecurityManager安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet前端控制器 Realm域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 近看 Shiro 看细节看图瞬间懵逼？别慌，会为你拆解来看，结合着图看下面的解释，这不是啥大问题，且看: Subject主体，可以看到主体可以是任何可以与应用交互的 “用户” SecurityManager相当于 SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理 Authenticator认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；需要自定义认证策略（Authentication Strategy），即什么情况下算用户认证通过了 Authrizer授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能 Realm可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm SessionManager如果写过 Servlet 就应该知道 Session 的概念，Session 需要有人去管理它的生命周期，这个组件就是 SessionManager；而Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB等环境；所以，Shiro 就抽象了一个自己的Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台Web服务器；接着又上了台EJB 服务器；这时又想把两台服务器的会话数据放到一个地方，我们就可以实现自己的分布式会话（如把数据放到Memcached 服务器） SessionDAODAO大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 Cryptography密码模块，Shiro提高了一些常见的加密组件用于如密码「加密/解密」的 注意上图的结构，我们会根据这张图来逐步拆分讲解，记住这张图也更有助于我们理解 Shiro 的工作原理，所以依旧是打开两个网页一起看就好喽 搭建概览多数小伙伴都在使用 Spring Boot， Shiro 也很应景的定义了 starter，做了更好的封装，对于我们来说使用起来也就更加方便，来看选型概览 序号 名称 版本 1 Springboot 2.0.4 2 JPA 2.0.4 3 Mysql 8.0.12 4 Redis 2.0.4 5 Lombok 1.16.22 6 Guava 26.0-jre 7 Shiro 1.4.0 使用 Spring Boot，大多都是通过添加 starter 依赖，会自动解决依赖包版本，所以自己尝试的时候用最新版本不会有什么问题，比如 Shiro 现在的版本是 1.5.0 了，整体问题不大，大家自行尝试就好 添加 Gradle 依赖管理 大体目录结构 application.yml 配置 基本配置 你就让我看这？这只是一个概览，先做到心中有数，我们来看具体配置，逐步完成搭建 其中 shiroFilter bean 部分指定了拦截路径和相应的过滤器，”/user/login”, ”/user”, ”/user/loginout” 可以匿名访问，其他路径都需要授权访问，shiro 提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限(先了解个大概即可)： 配置缩写 对应的过滤器 功能 anon AnonymousFilter 指定url可以匿名访问 authc FormAuthenticationFilter 指定url需要form表单登录，默认会从请求中获取username、password,rememberMe等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。 authcBasic BasicHttpAuthenticationFilter 指定url需要basic登录 Logout LogoutFilter 登出过滤器，配置指定url就可以实现退出功能，非常方便 noSessionCreation NoSessionCreationFilter 禁止创建会话 perms PermissionsAuthorizationFilter 需要指定权限才能访问 port PortFilter 需要指定端口才能访问 rest HttpMethodPermissionFilter 将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释 roles RolesAuthorizationFilter 需要指定角色才能访问 ssl SslFilter 需要https请求才能访问 user UserFilter 需要已登录或“记住我”的用户才能访问 数据库表设计数据库表设计请参考 entity package下的 bean，通过@Entity 注解与 JPA 的设置自动生成表结构 (你需要简单的了解一下 JPA 的功能)。 我们要说重点啦～～～ 身份认证身份认证是一个证明 “李雷是李雷，韩梅梅是韩梅梅” 的过程，回看上图，Realm 模块就是用来做这件事的，Shiro 提供了 IniRealm，JdbcReaml，LDAPReam等认证方式，但自定义的 Realm 通常是最适合我们业务需要的，认证通常是校验登录用户是否合法。 新建用户 User12345678910111213141516@Data@Entitypublic class User implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(unique =true) private String username; private String password; private String salt;&#125; 定义 Repository123456@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; public User findUserByUsername(String username);&#125; 编写UserController：1234567@GetMapping(\"/login\")public void login(String username, String password) &#123; UsernamePasswordToken token = new UsernamePasswordToken(username, password); token.setRememberMe(true); Subject currentUser = SecurityUtils.getSubject(); currentUser.login(token);&#125; 自定义 Realm自定义 Realm，主要是为了重写 doGetAuthenticationInfo(…)方法 123456789@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String username = token.getUsername(); User user = userRepository.findUserByUsername(username); SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(user, user.getPassword(), getName()); simpleAuthenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(user.getSalt())); return simpleAuthenticationInfo;&#125; 这些代码我需要做一个说明，你可能也满肚子疑惑: 这段代码怎么应用了 shiro？ controller 是怎么调用到 custom realm 的？ 重写的 doGetAuthenticationInfo(…) 方法目的是什么？ 认证流程说明用户访问/user/login 路径，生成 UsernamePasswordToken, 通过SecurityUtils.getSubject()获取Subject（currentUser），调用 login 方法进行验证，让我们跟踪一下代码，瞧一瞧就知道自定义的CustomRealm怎样起作用的，一起来看源码： 到这里我们要停一停了，请回看 Shiro 近景图，将源码追踪路径与其对比，是完全一致的 授权身份认证是验证你是谁的问题，而授权是你能干什么的问题， 产品经理：申购模块只能科室看程序员：好的产品经理：科长权限大一些，他也能看申购模块程序员：好的(黑脸)产品经理：科长不但能看，还能修改数据程序员：关公提大刀，拿命来… 作为程序员，我们的宗旨是：「能动手就不吵吵」; 硝烟怒火拔地起，耳边响起驼铃声（Shiro）：「放下屠刀，立地成佛」授权没有那么麻烦，大家好商量… 整个过程和身份认证基本是一毛一样，你对比看看 角色实体创建涉及到授权，自然要和角色相关，所以我们创建 Role 实体: 123456789101112@Data@Entitypublic class Role &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(unique =true) private String roleCode; private String roleName;&#125; 新建 Role Repository123456789@Repositorypublic interface RoleRepository extends JpaRepository&lt;Role, Long&gt; &#123; @Query(value = \"select roleId from UserRoleRel ur where ur.userId = ?1\") List&lt;Long&gt; findUserRole(Long userId); List&lt;Role&gt; findByIdIn(List&lt;Long&gt; ids);&#125; 定义权限实体 Permission123456789101112@Data@Entitypublic class Permission &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; @Column(unique =true) private String permCode; private String permName;&#125; 定义 Permission Repository12345678@Repositorypublic interface PermissionRepository extends JpaRepository&lt;Permission, Long&gt; &#123; @Query(value = \"select permId from RolePermRel pr where pr.roleId in ?1\") List&lt;Long&gt; findRolePerm(List&lt;Long&gt; roleIds); List&lt;Permission&gt; findByIdIn(List&lt;Long&gt; ids);&#125; 建立用户与角色关系其实可以通过 JPA 注解来制定关系的，这里为了说明问题，以单独外键形式说明 1234567891011121314@Data@Entitypublic class UserRoleRel &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; private Long userId; private Long roleId;&#125; 建立角色与权限关系12345678910111213@Data@Entitypublic class RolePermRel &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; private Long permId; private Long roleId;&#125; 编写 UserController12345@RequiresPermissions(\"user:list:view\")@GetMapping()public void getAllUsers()&#123; List&lt;User&gt; users = userRepository.findAll();&#125; @RequiresPermissions(&quot;user:list:view&quot;) 注解说明具有用户：列表：查看权限的才可以访问），官网明确给出权限定义格式，包括通配符等，我希望你自行去查看 自定义 CustomRealm (主要重写 doGetAuthorizationInfo) 方法: 与认证流程如出一辙，只不过多了用户，角色，权限的关系罢了 授权流程说明这里通过过滤器（见Shiro配置）和注解二者结合的方式来进行授权，和认证流程一样，最终会走到我们自定义的 CustomRealm 中，同样 Shiro 默认提供了许多注解用来处理不同的授权情况 注解 功能 @RequiresGuest 只有游客可以访问 @RequiresAuthentication 需要登录才能访问 @RequiresUser 已登录的用户或“记住我”的用户能访问 @RequiresRoles 已登录的用户需具有指定的角色才能访问 @RequiresPermissions 已登录的用户需具有指定的权限才能访问（如果不想和产品经理华山论剑，推荐用这个注解） 授权官网给出明确的授权策略与案例，请查看：http://shiro.apache.org/permissions.html 上面的例子我们通过一直在通过访问 Mysql 获取用户认证和授权信息，这中方式明显不符合生产环境的需求 Session会话管理做过 Web 开发的同学都知道 Session 的概念，最常用的是 Session 过期时间，数据在 Session 的 CRUD，同样看上图，我们需要关注 SessionManager 和 SessionDAO 模块，Shiro starter 已经提供了基本的 Session配置信息，我们按需在YAML中配置就好（官网https://shiro.apache.org/spring-boot.html 已经明确给出Session的配置信息） Key Default Value Description shiro.enabled true Enables Shiro’s Spring module shiro.web.enabled true Enables Shiro’s Spring web module shiro.annotations.enabled true Enables Spring support for Shiro’s annotations shiro.sessionManager.deleteInvalidSessions true Remove invalid session from session storage shiro.sessionManager.sessionIdCookieEnabled true Enable session ID to cookie, for session tracking shiro.sessionManager.sessionIdUrlRewritingEnabled true Enable session URL rewriting support shiro.userNativeSessionManager false If enabled Shiro will manage the HTTP sessions instead of the container shiro.sessionManager.cookie.name JSESSIONID Session cookie name shiro.sessionManager.cookie.maxAge -1 Session cookie max age shiro.sessionManager.cookie.domain null Session cookie domain shiro.sessionManager.cookie.path null Session cookie path shiro.sessionManager.cookie.secure false Session cookie secure flag shiro.rememberMeManager.cookie.name rememberMe RememberMe cookie name shiro.rememberMeManager.cookie.maxAge one year RememberMe cookie max age shiro.rememberMeManager.cookie.domain null RememberMe cookie domain shiro.rememberMeManager.cookie.path null RememberMe cookie path shiro.rememberMeManager.cookie.secure false RememberMe cookie secure flag shiro.loginUrl /login.jsp Login URL used when unauthenticated users are redirected to login page shiro.successUrl / Default landing page after a user logs in (if alternative cannot be found in the current session) shiro.unauthorizedUrl null Page to redirect user to if they are unauthorized (403 page) 分布式服务中，我们通常需要将Session信息放入Redis中来管理，来应对高并发的访问需求，这时只需重写SessionDAO即可完成自定义的Session管理 整合Redis12345678910111213141516@Configurationpublic class RedisConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public RedisTemplate&lt;String, Object&gt; stringObjectRedisTemplate() &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); return template; &#125;&#125; 重写SessionDao 查看源码，可以看到调用默认SessionManager的retriveSession方法，我们重写该方法，将Session放入HttpRequest中，进一步提高session访问效率 向ShiroConfig中添加配置 其实在概览模块已经给出代码展示，这里单独列出来做说明: 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 自定义RedisSessionDao用来管理Session在Redis中的CRUD * @return */@Bean(name = \"redisSessionDao\")public RedisSessionDao redisSessionDao()&#123; return new RedisSessionDao();&#125;/** * 自定义SessionManager,应用自定义SessionDao * @return */@Bean(name = \"customerSessionManager\")public CustomerWebSessionManager customerWebSessionManager()&#123; CustomerWebSessionManager customerWebSessionManager = new CustomerWebSessionManager(); customerWebSessionManager.setSessionDAO(redisSessionDao()); return customerWebSessionManager;&#125;/** * 定义Security manager * @param customRealm * @return */@Bean(name = \"securityManager\")public DefaultWebSecurityManager defaultWebSecurityManager(CustomRealm customRealm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager (); securityManager.setRealm(customRealm); securityManager.setSessionManager(customerWebSessionManager()); // 可不指定，Shiro会用默认Session manager securityManager.setCacheManager(redisCacheManagers()); //可不指定，Shiro会用默认CacheManager// securityManager.setSessionManager(defaultWebSessionManager()); return securityManager;&#125;/** * 定义session管理器 * @return */@Bean(name = \"sessionManager\")public DefaultWebSessionManager defaultWebSessionManager()&#123; DefaultWebSessionManager defaultWebSessionManager = new DefaultWebSessionManager(); defaultWebSessionManager.setSessionDAO(redisSessionDao()); return defaultWebSessionManager;&#125; 至此，将 session 信息由 redis 管理功能就这样完成了 缓存管理应对分布式服务，对于高并发访问数据库权限内容是非常低效的方式，同样我们可以利用Redis来解决这一问题，将授权数据缓存到Redis中 新建 RedisCache123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Slf4j@Componentpublic class RedisCache&lt;K, V&gt; implements Cache&lt;K, V&gt; &#123; public static final String SHIRO_PREFIX = \"shiro-cache:\"; @Resource private RedisTemplate&lt;String, Object&gt; stringObjectRedisTemplate; private String getKey(K key)&#123; if (key instanceof String)&#123; return (SHIRO_PREFIX + key); &#125; return key.toString(); &#125; @Override public V get(K k) throws CacheException &#123; log.info(\"read from redis...\"); V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k)); if (v != null)&#123; return v; &#125; return null; &#125; @Override public V put(K k, V v) throws CacheException &#123; stringObjectRedisTemplate.opsForValue().set(getKey(k), v); stringObjectRedisTemplate.expire(getKey(k), 100, TimeUnit.SECONDS); return v; &#125; @Override public V remove(K k) throws CacheException &#123; V v = (V) stringObjectRedisTemplate.opsForValue().get(getKey(k)); stringObjectRedisTemplate.delete((String) get(k)); if (v != null)&#123; return v; &#125; return null; &#125; @Override public void clear() throws CacheException &#123; //不要重写，如果只保存shiro数据无所谓 &#125; @Override public int size() &#123; return 0; &#125; @Override public Set&lt;K&gt; keys() &#123; return null; &#125; @Override public Collection&lt;V&gt; values() &#123; return null; &#125;&#125; 新建 RedisCacheManager12345678910public class RedisCacheManager implements CacheManager &#123; @Resource private RedisCache redisCache; @Override public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String s) throws CacheException &#123; return redisCache; &#125;&#125; 至此，我们不用每次访问 Mysql DB 来获取认证和授权信息，而是通过 Redis 来缓存这些信息，大大提升了效率，也满足分布式系统的设计需求 总结回复公众号 「demo」获取 demo 代码。这里只是梳理了Springboot整合Shiro的流程，以及应用Redis最大化利用Shiro，Shiro的使用细节还很多，官网说的也很明确，带着上面的架构图来理解Shiro会事半功倍，感觉这里面的代码挺多挺头大的？那是你没有自己动手去尝试，结合官网与 demo 相信你会对 Shiro 有更好的理解，另外你可以理解 Shiro 是 mini 版本的 Spring Security，我希望以小见大，当需要更细粒度的认证授权时，也会对理解 Spring Security 有很大帮助，点击文末「阅读原文」，效果更好 落霞与孤鹜齐飞 秋水共长天一色，产品经理和程序员一片祥和… 灵魂追问 都说 Redis 是单线程，但是很快，你知道为什么吗？ 你们项目中是怎样控制认证授权的呢？当授权有变化，对于程序员来说，这个修改是灾难吗？ 提高效率工具 MarkDown 表格生成器本文的好多表格是从官网粘贴的，如何将其直接转换成 MD table 呢？那么 https://www.tablesgenerator.com/markdown_tables 就可以帮到你了，无论是生成 MD table，还是粘贴内容生成 table 和内容都是极好的，当然了不止 MD table，自己发现吧，更多工具，公众号回复 「工具」获得 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 回复「工具」 面试问题分析与解答 技术资料领取 回复「资料」 后续会推出「多线程」与「ElasticSearch」等连载内容 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://dayarch.top/tags/Shiro/"}]},{"title":"@Conditional注解，Spring Boot 的灵活配置","slug":"Conditional注解，Spring-Boot-的灵活配置","date":"2019-07-31T08:30:07.000Z","updated":"2019-11-07T06:35:47.024Z","comments":true,"path":"/p/spring-boot-condition-annotation.html","link":"","permalink":"https://dayarch.top/p/spring-boot-condition-annotation.html","excerpt":"上一篇文章 你应该知道的 @ConfigurationProperties 注解的使用姿势，这一篇就够了 介绍了如何通过 @ConfigurationProperties 注解灵活读取配置属性，这篇文章将介绍如何灵活配置 Spring Bean 写在前面 当我们构建一个 Spring 应用的时候，有时我们想在满足指定条件的时候才将某个 bean 加载到应用上下文中， 在Spring 4.0 时代，我们可以通过 @Conditional 注解来实现这类操作 我们看到 @Conditional 注解接收的参数是 extends Condition 接口的泛型类，也就是说，我们要使用 @Con","text":"上一篇文章 你应该知道的 @ConfigurationProperties 注解的使用姿势，这一篇就够了 介绍了如何通过 @ConfigurationProperties 注解灵活读取配置属性，这篇文章将介绍如何灵活配置 Spring Bean 写在前面当我们构建一个 Spring 应用的时候，有时我们想在满足指定条件的时候才将某个 bean 加载到应用上下文中， 在Spring 4.0 时代，我们可以通过 @Conditional 注解来实现这类操作 我们看到 @Conditional 注解接收的参数是 extends Condition 接口的泛型类，也就是说，我们要使用 @Conditional 注解，只需要实现 Condition 接口并重写其方法即可: 看到接口的 matches 方法返回的是 boolean 类型，是不是和我们自定义 validation annotation 有些类似，都是用来判断是否满足指定条件。另外注意看，以上注解和接口都在 org.springframework.context.annotation package 中 终于到了 Spring Boot 时代，在这个全新的时代，Spring Boot 在 @Conditional 注解的基础上进行了细化，无需出示复杂的介绍信 (实现 Condition 接口)，只需要手持预定义好的 @ConditionalOnXxxx 注解印章的门票，如果验证通过，就会走进 Application Context 大厅 注解详解Spring Boot 对 @Conditional 注解为我们做了细化，这些注解都定义在 org.springframework.boot.autoconfigure.condition package 下 逐个打开这 13 个注解，我们发现这些注解上有相同的元注解: 从这些标记上我们可以了解如下内容: 都可以应用在 TYPE 上，也就是说，Spring 自动扫描的一切类 (@Configuration, @Component, @Service, @Repository, or @Controller) 都可以通过添加相应的 @ConditionalOnXxxx 来判断是否加载 都可以应用在 METHOD 上，所以有 @Bean 标记的方法也可以应用这些注解 都是用了 @Conditional 注解来标记，OnBeanCondition 等自定义 Condition 还是实现了 Condition 接口的，换汤不换药，没什么神秘的，只不过做了更具象的封装罢了，来看类依赖图: 其实看这些注解字面意思已经能理解这些注解的含义，但是我们还是要说明具体的使用以及一些注意事项，我按照个人使用频次由高到低讲解: @ConditionalOnProperty毫无疑问这个注解是榜首 这个条件解释是: application.properties 或 application.yml 文件中 mybean.enable 为 true 才会加载 MyCondition 这个 Bean，如果没有匹配上也会加载，因为 matchIfMissing = true，默认值是 false。 @ConditionalOnBean 和 ConditionalOnMissingBean有时候我们需要某个 Bean 已经存在应用上下文时才会加载，那么我们会用到 @ConditionalOnBean 注解: 与之相反，有时候我们需要某个 Bean 不存在于应用上下文时才会加载，那么我们会用到 @ConditionalOnMissingBean 注解 @ConditionalOnClass 和 @ConditionalOnMissingClass不要嫌我废话，和上面的一样，只不过判断某个类是否存在于 classpath 中，这就不做过多说明了 @ConditionalOnExpression如果我们有更复杂的多个配置属性一起判断，那么我们就可以用这个表达式了: 只有当两个属性都为 true 的时候才加载 MyModule，到这里要顺便揭晓上一篇文章 你应该知道的 @ConfigurationProperties 注解的使用姿势，这一篇就够了 灵魂追问 3，其中 :true 就是: 如果没有为该属性设置值，则为该属性设置默认值true, 其实这就是@Vaue 注解的规范，一切 SpEL 都可以应用在这里. 写到这，我常用的已经用完了，还要硬着头皮介绍其他几个内容 😄，开个玩笑，咱们继续: @ConditionalOnSingleCandidate这个注解和 @ConditionalOnBean 类似，为了更好的说明该注解的使用 (其实是 才疏学浅 ) ，我只能翻译一下类的注释了 只有指定类已存在于 BeanFactory 中，并且可以确定单个候选项才会匹配成功 BeanFactory 存在多个 bean 实例，但是有一个 primary 候选项被指定(通常在类上使用 @Primary 注解)，也会匹配成功。实质上，如果自动连接具有定义类型的 bean 匹配就会成功 目前，条件只是匹配已经被应用上下文处理的 bean 定义，本身来讲，强烈建议仅仅在 auto-configuration 类中使用这个条件，如果候选 bean 被另外一个 auto-configuration 创建，确保使用该条件的要在其后面运行 @ConditionalOnResource如果我们要加载的 bean 依赖指定资源是否存在于 classpath 中，那么我们就可以使用这个注解 看到这个 logback.xml 是不是很亲切，在我们引入第三方工具类如 Dozer 等都可以添加类似的开关 接下来的是真冷门，大家有个印象，如果有需要，至少能想到用这些注解实现灵活配置就好了 @ConditionalOnJndi只有指定的资源通过 JNDI 加载后才加载 bean @ConditionalOnJava只有运行指定版本的 Java 才会加载 Bean @ConditionalOnWebApplication 和 @ConditionalOnNotWebApplication只有运行在 web 应用里才会加载这个 bean 与之相反，在非 web 环境才加载 bean @ConditionalOnCloudPlatform这个注解冷的我呼吸都要停止了，只有运行在指定的云平台上才加载指定的 bean，CloudPlatform 是 org.springframework.boot.cloud 下一个 enum 类型的类，大家可以打开自行看看: 到此，Spring Boot 为我们提供的这 13 个注解就介绍完了，但是没有结束，下面的一些冷门知识，你需要知道: 组合条件组合条件 AND如果我们想多个条件一起应用，并且条件的关系是 and，我们只需要在类上使用多个@ConditionalOnXxxx 就可以了 (你这也叫冷门？) ，当然也可以继承 AllNestedConditions类封装我们多个条件 这样就有了组合 and 条件，只有内部所有条件都满足，才加载指定 bean 组合条件 OR如果我们希望组合的条件是 or 的关系，我们该怎么办呢？ 我们可以通过继承 AnyNestedCondition 来完成这一要求，示例代码和上面一样，大家自行打开 AnyNestedCondition 类，查看类说明即可 条件组合 NONE有 and 和 or 就肯定有 non(非)，我们可以通过继承 NoneNestedConditions 完成这一要求，大家自行查看即可 自定义注解通过组合方式实现了多条件逻辑应用，我们需要应用这些组合条件也就要自定义注解，其实文章开头已经讲过了，模仿内置的 13 个注解写就好了: 只需要通过@Conditional注解指定我们自定义的 condition 类就好了，然后应用到你想用的地方就好了 还是推荐大家看 RabbitMq 的 RabbitAutoConfiguration 类，这个类里面主流的注解都是用了 (只看这一个类就好了)，大家看框架理解学习这些注解是更好的方式: https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.java 总结到这里，你已经了解了如何灵活配置 bean，结合之前的文章，相信的定义会更加灵活，希望大家打开 IDE，自行查看这些注解，了解更多具体内容 灵魂追问 SpringBoot 添加了 web starter，有哪些方法将其更改为非 web 应用？ Java8 Stream 也有 findAny，findAll 这类的操作，这都是匹配，你有使用过吗？ 看下面这段代码，如果 classpath 中没有 MyBean class，编译会报错，那这个注解什么用呢？12345@Configuration @ConditionalOnClass(MyBean.class)public class MyConfiguration&#123; // omitted &#125; 提高效率工具 推荐阅读 红黑树，超强动静图详解，简单易懂 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 高效工具汇总 面试问题分析与解答 技术资料领取 后续会推出 「多线程」以及「ElasticSearch」等连载内容以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"注解","slug":"注解","permalink":"https://dayarch.top/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"红黑树，史上最强动静图详解","slug":"红黑树，史上最强动静图详解","date":"2019-07-29T08:42:05.000Z","updated":"2019-11-07T06:06:38.332Z","comments":true,"path":"/p/redblack-tree.html","link":"","permalink":"https://dayarch.top/p/redblack-tree.html","excerpt":"写在前面 红黑树，对很多童鞋来说，是既熟悉又陌生。学校中学过，只了解大概；工作中不怎么使用，但面试又是重点。每次需要查看红黑树内容时都很难以更生动形象的方式来理解其内容。没错，本文内容就是要解决这个问题，用简单的语言，搭配静图和动图(利用大脑图形记忆方式)，让你对红黑树有更深入的了解和更清晰的记忆，希望小伙伴们再次遇到红黑树的问题不至于头大，建议读该文章姿势: 打开两个页面，一个页面看图片和内容，一个页面看公式，像玩魔方一样，多玩几次就明白了 通过工具 (公众号回复「工具」—>那些可以提高效率的工具—>红黑树) 动态感受红黑树的转换过程 俺家司令买完东西后，我俩经常会发生这样的一段对话","text":"写在前面红黑树，对很多童鞋来说，是既熟悉又陌生。学校中学过，只了解大概；工作中不怎么使用，但面试又是重点。每次需要查看红黑树内容时都很难以更生动形象的方式来理解其内容。没错，本文内容就是要解决这个问题，用简单的语言，搭配静图和动图(利用大脑图形记忆方式)，让你对红黑树有更深入的了解和更清晰的记忆，希望小伙伴们再次遇到红黑树的问题不至于头大，建议读该文章姿势: 打开两个页面，一个页面看图片和内容，一个页面看公式，像玩魔方一样，多玩几次就明白了 通过工具 (公众号回复「工具」—&gt;那些可以提高效率的工具—&gt;红黑树) 动态感受红黑树的转换过程 俺家司令买完东西后，我俩经常会发生这样的一段对话:司令:你猜我买的这个多少钱？我: 1000司令: 高了我: 500司令: 低了:我: 750…… 直到最后猜中 这样说大家应该已经猜到了是「二分查找法」，通过这个例子我想要引出的是 树，来看图片 程序中的树其实是我们日常看到的树的倒影，或者发挥一下想象，倒影也可以是树根 二叉查找树二叉查找树，Binary Search Tree 「BST」，要想了解二叉查找树，我们首先看下二叉查找树有哪些特性呢？ 某节点的左子树节点值仅包含小于该节点值 某节点的右子树节点值仅包含大于该节点值 左右子树每个也必须是二叉查找树看个图就轻松理解上面三句话的意思了: 上图，结合二叉查找树的三条约束来看，非常好，没有什么问题。再来看一个图，依旧符合上面三条约束，感觉有问题吗？ 这是一个走路一米六，一米八的树 这是一个畸形的树，大风一挂很可能被折断的树从程序的角度来说这个树不够平衡，查找次数或时间复杂度 O(h)可能会随着一条腿长无限增长 理科生在高中学习生物时学过一个关键字「去除顶端优势」，通过去除植物顶端优势，侧芽会迅速生长，慢慢变得强壮和平衡， 红黑树其实就是去除二叉查找树顶端优势的解决方案，从而达到树的平衡 红黑树红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则: 每个节点都有红色或黑色 树的根始终是黑色的 (黑土地孕育黑树根，😄) 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点） 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点 瞬间懵逼？了解一下印象就行，开始玩魔方都是要照着魔方公式一点点玩的，多玩几次就熟悉了。红黑树也一样，红黑树有两大操作: recolor (重新标记黑色或红色) rotation (旋转，这是树达到平衡的关键)我们会先尝试 recolor，如果 recolor 不能达到红黑树的 4 点要求，然后我们尝试 rotation，其实红黑树的关键玩法就是弄清楚 recolor 和 rotation 的规则，接下来看看详细的算法公式吧 千万别着急记忆公式，有图示会逐步说明，就像魔方一样，多玩几次就懂了:假设我们插入的新节点为 X 将新插入的节点标记为红色 如果 X 是根结点(root)，则标记为黑色 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.1 如果 X 的 uncle (叔叔) 是红色 3.1.1 将 parent 和 uncle 标记为黑色 3.1.2 将 grand parent (祖父) 标记为红色 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3 话不多说，看下图 跟着上面的公式走: 将新插入的 X 节点标记为红色 发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」 发现 X 的 uncle (U) 同样为红色 将 P 和 U 标记为黑色 将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3 发现 G 是根结点，标记为黑色 结束 刚刚说了 X 的 uncle 是红色的情况，接下来要说是黑色的情况 如果 X 的 parent 不是黑色，同时 X 也不是 root: 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子) 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子) 3.2.3 右右 (和 3.2.1 镜像过来，恰好相反) 3.2.4 右左 (和 3.2.2 镜像过来，恰好相反)当出现 uncle 是黑色的时候我们第一步要考虑的是 旋转 ，这里先请小伙伴不要关注红黑树的第 4 条规则，主要是为了演示如何旋转的，来一点点看，不要看图就慌，有解释的😜:左左情况这种情况很简单，想象这是一根绳子，手提起 P 节点，然后变色即可 左右左旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的左孩子，然后再应用 左左情况 右右与左左情况一样，想象成一根绳子 右左右旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的右孩子，然后再应用 右右情况 你说的动图在哪里，你个大骗子，别着急，现在就为小伙伴们奉上动图演示，来说明公式的使用: 案例一 插入 10，20，30，15 到一个空树中 向空树中第一次插入数字 10，肯定是 root 节点 root 节点标记成黑色 向树中插入新节点 20，标记为红色 20 &gt; 10，并发现 10 没有叶子节点，将新节点 20 作为 10 的右孩子 向树中插入新节点 30，标记为红色 30 &gt; 10，查找 10 的右子树，找到 20 30 &gt; 20，继续查找 20 的右子树，发现 20 没有叶子节点，将值插在此处 30 和 20 节点都为红色，30 为右孩子，20 也为右孩子，触发了 右右情况 通过一次旋转，提起 20 节点 20 节点是根结点，标记为黑色 向树中插入新节点 15，标记为红色 通过比对大小和判断是否有叶子节点，最终插值为 10 节点的右孩子 15 和 10 节点都为红色，15 的 uncle 节点 30 也为红色 按照公式，将 15 的 parent 10 和 uncle 30 更改为黑色 让 15 节点 grand parent 20 的颜色与 15 节点的颜色一样，变为红色 20 为根结点，将其改为黑色 继续插入其他节点只不过反复应用上面的公式，上面应用到的红黑树工具，可以暂停动画效果，一帧一帧的看红黑树的转换过程，这样通过练习，查看公式，观察变化三管齐下，红黑树的入门理解应该完全不再是问题了 灵魂追问 jdk 1.8 HashMap 中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何 put 和 remove 的吗？ 这里讲的是红黑树的 insert，delete 又是什么规则呢？ 哪些场景可以应用红黑树？ 你了解各种树的时间复杂度吗？ 留个小作业，应用工具将 [10 70 32 34 13 56 32 56 21 3 62 4 ] 逐个插入到树中，理解红黑树 recolor 和 rotation 的转换规则 提高效率工具 推荐阅读 只会用 git pull ？有时候你可以尝试更优雅的处理方式 双亲委派模型：大厂高频面试题，轻松搞定 面试还不知道BeanFactory和ApplicationContext的区别？ 如何设计好的RESTful API 程序猿为什么要看源码？ 欢迎持续关注公众号：「日拱一兵」 前沿 Java 技术干货分享 [orange] 高效工具汇总 [green] 面试问题分析与解答 [pink] 技术资料领取 [red] 后续文章会为你讲解各种时间空间复杂度，以及多线程，ElasticSearch 等问题 以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注……","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"https://dayarch.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"二叉查找树","slug":"二叉查找树","permalink":"https://dayarch.top/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"}]},{"title":"如何设计好的Restful API","slug":"如何设计好的Restful-API","date":"2019-05-16T06:48:27.000Z","updated":"2019-11-07T06:37:47.212Z","comments":true,"path":"/p/restful-api-design.html","link":"","permalink":"https://dayarch.top/p/restful-api-design.html","excerpt":"现状 现阶段的开发模式多以前后端分离形式存在，前后端开发人员需要通过大量 API 来进行数据交互，如果在交互过程中前后端人员经常遭遇如下问题： * 前端人员不能快速理解接口字段含义及接口字段变化 * 后端人员想复用某些接口，但是不能快速从接口 URL 的定义中明确该接口的含义，需要进一步读代码确认 * URL中的英文单词使用五花八门，搜索某个接口不知道具体的关键字 * 请求方法动词如 POST GET 随意使用 * 完成当前业务接口对接，前端人员经常会询问下一步业务流程的接口定义在哪里，对接形式是什么样的 以上只是前后端人员通过接口交互的一小部分问题，这些问题就好比”牙痛”，不致","text":"现状现阶段的开发模式多以前后端分离形式存在，前后端开发人员需要通过大量 API 来进行数据交互，如果在交互过程中前后端人员经常遭遇如下问题： 前端人员不能快速理解接口字段含义及接口字段变化 后端人员想复用某些接口，但是不能快速从接口 URL 的定义中明确该接口的含义，需要进一步读代码确认 URL中的英文单词使用五花八门，搜索某个接口不知道具体的关键字 请求方法动词如 POST GET 随意使用 完成当前业务接口对接，前端人员经常会询问下一步业务流程的接口定义在哪里，对接形式是什么样的 以上只是前后端人员通过接口交互的一小部分问题，这些问题就好比”牙痛”，不致命，但是在整个软件开发的生命周期内，天天”牙痛”是很要命的, 需要解决上述的问题，需要前后端人员都能认识与了解接口设计规范的重要性。 什么是REST在 2000 年，Roy Fielding 提出 Representational State Transfer (REST) 的概念，中文翻译过来”表述性状态传递”，感兴趣的朋友可以去维基百科看看原始概念，乍一看是一个挺抽象的概念，但其实，这个概念就像交通灯规则一样简单，就看如何看待相关规范. 当我们谈及 RESTful 设计规范，多数人能了解设计的大原则，但是不了解小细节，而对这些细节的了解与否，是能否治好”牙痛病”的关键 REST术语介绍现实世界交通灯有红绿黄，REST相关的概念也是三个：资源，集合，URL 资源资源是某种东西的对象或表示，它具有一些与之相关的数据，并且可以有一组方法对其进行操作。 例如, 动物，学校和员工是资源; 删除，添加，更新是对这些资源执行的相关操作 集合集合是资源集合，例如，公司是公司资源的集合 URLURL（统一资源定位符）是可以通过其定位资源的路径，并且可以对其执行某些操作 了解到以上内容， 那REST 世界的”交通灯”规则是什么样的？我们来了解一下 如何设计和开发一个高可用的 REST APIs 网上一直有关于”最好的Restful API的设计”争论，何为最好，至今没有一个官方的指导。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。在 Restful API 设计标准之上，我们可以为我们的设计增加一些弹性（团队都认可的方式），每个项目的情况不同，最重要的是项目组成员达成一致的Restful API 设计规则，达到高可用即可 URL 设计学英语，名词（car/animal/teacher）都很好记忆，但是如何用动词和这些名词组合来准确的表达特定的含义却很困难，庆幸的是在 REST 的世界，动词寥寥无几，并且含义单一 ，RESTful 的核心思想也是通过这些动词 + 名词完成对资源的操作与访问，但我们经常看到这样的动词与名词的 URL 组合： /getAllUsers /createNewCompany /updateUserInfo /deleteUser?name=zhangsan 这些 URL 的设计会导致文章开头所说的很多问题，我们进一步来了解如何应用所谓的动词 + 名词 动词动词通常就是 5 种 HTTP 方法，对应我们常见的 CRUD 操作： POST：新建（Create） GET：读取（Read） PUT：更新（Update） PATCH：更新（Update），通常不分更新，也很少用到 DELETE：删除（Delete） 根据 HTTP 规范，动词一律大写，另外根据RESTful 幂等性（多次调用是否会对资源产生影响）原则，我们不能乱用动词，GET/PUT/DELETE 是幂等的，POST/PATCH 不是幂等的 有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。 这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。 12POST /users/12 HTTP/1.1X-HTTP-Method-Override: PUT 上面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST 名词名词就是表示一个资源或者服务，如 /users，/teachers，这里看到我用名词复数的形式描述某一资源，至于用单数还是复数每个人都有自己的见解，我在这里推荐使用复数，因为在现实世界中，资源多数是以集合的形式存在的 动词 + 名词 资源 POST（Create） GET（Read） PUT（Update） DELETE （Delete） /users 创建新用户 查询所有用户 批量更新用户 删除所有用户 /users/12 方法不被允许（405） 查询指定用户 更新指定用户 删除指定用户 1234567POST /usersGET /usersPUT /usersDELETE /usersGET /users/12PUT /users/12DELETE /users/12 上述动词 + 名词的组合是不是清晰多了，没有杂乱的动词在 URL 中，大家的理解含义相同 URL 层级现实中哪有这么简单的 CRUD，资源的相互关联与嵌套很常见，查找 id 是 12 的用户的所有帖子， 如何设计这个 URL，下面两种设计也会有争论： 12GET /users/12/postsGET /posts?userId=12 第一种出现两个名词主题（users/posts），会让人有几秒钟的猜想，这到底请求的是用户资源还是帖子资源，当存在更深浅套的时候也不容易扩展，所以我推荐第二种方式，主体名词 posts 资源明显，其他过滤条件也更容易扩展，比如 /posts?userName=zhangsan，我们可以复用同样的接口 版本我们看到过很多如下 URL 设计，用来区分 API 版本： 12POST /v2/usersGET /V1/users/12 我们都指向同样的资源 users，URL 中为什么要加版本号呢？ 针对这个问题，答案依旧没有统一标准，如果多个版本的API版本返回数据结果结构一样，那没必要区分版本，如果结构已经发生变化，而且要向下兼容，那版本号是很好的区分方式，而且通过 URL 加版本的方式可以更好的发现资源 过滤/分页/排序实际的业务场景中会经常对请求资源做条件筛选，分页显示，以及排序，我们不要为这些业务要求创建不同步的 API，我们应该尽量保持 URL 的信息简单，只需添加查询条件参数来实现上述功能，同时符合”望 URL 知意”的原则 过滤12GET /users/12/posts?state=publishedGET /users/12/posts?published=true 上述两种方式都可以实现资源的过滤 分页1GET /users?pageNo=1&amp;pageSize=20 以分页方式查询用户列表，显示第 2 页内容，每页显示 20 条信息 排序1GET /users?sort=score_desc 按照学生分数降序进行排序 上述所有的方式我们都可以做到”望 URL 知意”，这就是好的设计 返回结果RESTful API 的返回结果也是设计环节中重要的一环 响应数据格式API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。同时客户端也应作出相应的配合，客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json，多渠道调用可能会存在相同资源需要有不同的 producer 类型的情况存在 响应状态码很多后端开发人员可能受开发框架所限，或者返回数据封装形式不够好，经常会给前端人员不是很友好的 HTTP 状态码，比如 response 有 error，却给出 200 HTTP.OK 的状态码 (明明吃了三碗粉，却给两碗粉的钱) 123456789HTTP/1.1 200 OKContent-Type: application/json&#123; \"status\": \"-1\", \"result\": &#123; \"error\": \"分数应小于150\" &#125;&#125; 有人说，我已经标记返回内容 status 是 -1（表示failure）, 用 200 作为状态码也无妨吧？这是一个很错误的观念，RESTful 的设计理念之一是简单直观，试想一下，前端开发人员打开开发者工具，所有请求都是200的状态码，但是页面数据就是没有显示出来，难道前端开发人员还要每个接口调用点开看一看，是哪个 status 是 -1 导致的吗？ 很显然我们不希望这样的情况发生，正确的做法应该类似这样的： 123456789HTTP/1.1 400 Bad RequestContent-Type: application/json&#123; \"status\": \"-1\", \"result\": &#123; \"error\": \"分数应小于150\" &#125;&#125; 下面页列举出来常用的状态码以及表示的含义： 2xx 状态码 200表示成功，同时我们可以表示的更加精确 GET: 200 OK 请求成功 POST: 201 Created 创建成功 PUT: 200 OK 更新成功 DELETE: 204 No Content 找不到要删除的内容 使用状态码 202 有时候会比 使用状态啊吗 201 是更好的选择，状态码 202 的意思是：服务端已接收到了请求，但是还没有创建任何资源，但结果一切正常。 比如： 异步操作：服务器已接收到请求，但是还未处理，但是会在未来处理 资源已经存在，没有创建新的资源 （有些业务可能会返回错误信息”您创建的数据已存在”，所以这种情景没有明确的规定，符合自己的业务需求即可） 4xx 状态码 4xx 状态码表示客户端的错误，主要有以下几种： 400 Bad Request：服务器不理解客户端的请求，未做任何处理 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限 404 Not Found：所请求的资源不存在，或不可用 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式 这里要注意状态码 401 和 403 的区别 5xx 状态码 5xx 状态码表示服务端错误，通常只会用到两个： 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态 无状态过去开发人员通常会将活动的用户信息存储在服务端的 session 中， 这种形式很显然不适用于现在分布式微服务架构的模式，我们可以使用 JWT (JSON Web Token) 如 OAuth2 来实现，这样每次在 Httpheader 中添加 token 来做验证即可 API 文档Swagger是一种广泛使用的工具来用来记录与呈现 REST API，它提供了一种探索特定 API 使用的方法，因此允许开发人员理解底层的语义行为。 这是一种使用注释添加文档的声明性方法，它进一步生成描述 API 及其用法的 JSON，可以实时应对 API 的更新，具体请参考 Swagger 官网 , 同时使用 Spring Boot 的小伙伴也可以很轻松的集成 Swagger，只需引入Swagger Starter 12345&lt;dependency&gt; &lt;groupId&gt;com.spring4all&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; HATEOASHATEOAS (Hypermedia As Transfer Engine Of Application State), API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS , 举个例子，列表页数据通常会有查看操作，这样我们在返回列表页的数据的时候同样返回如何操作查看具体数据详情的 API 接口： 123456789101112&#123; \"status\": \"-1\", \"result\": [&#123; \"id\": 1, \"name\": \"zhangsan\", \"links\":[ &#123; \"href\": \"http://localhost:8080/user/&#123;id&#125;\" &#125; ] &#125;]&#125; 使用 Spring 框架的小伙伴可以快速的体验一下这种方式，Spring 官网项目 Spring HATEOAS , 会快速的将参数都做替换, 将查看 API URL 中的 id 直接替换成 1。 123456789101112&#123; \"status\": \"-1\", \"result\": [&#123; \"id\": 1, \"name\": \"zhangsan\", \"links\":[ &#123; \"href\": \"http://localhost:8080/user/1\" &#125; ] &#125;]&#125; 提升效率工具RestfulToolkit后端开发人员可以安装 IntellJ idea 插件 RestfulToolkit, Mac 环境使用快捷键 CMD + \\ 输入关键字快速定位到 API 位置 同时在右侧工具栏打开 API，会自动生成 demoData 请求参数，实现快速调用测试： JSON-ViewerJSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入json-viewer + TAB ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题 另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便 PostmanPostman 功能十分强大， 搜索 Postman 自定义环境变量，会打开新世界的大门 写在最后如何设计出最好的 RESTful API 永远不会有结论，设计出高可用，团队认可，简单清晰明了的 RESTful API 就是好的。 欢迎交流你们在团队中是如何设计 RESTful API 的，遇到了哪些问题，是如何解决和规范的","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"安全-协议-规范","slug":"Coding/安全-协议-规范","permalink":"https://dayarch.top/categories/Coding/%E5%AE%89%E5%85%A8-%E5%8D%8F%E8%AE%AE-%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://dayarch.top/tags/RESTful/"},{"name":"HTTP","slug":"HTTP","permalink":"https://dayarch.top/tags/HTTP/"}]},{"title":"Excel的公式使用","slug":"Excel的公式使用","date":"2019-05-10T02:15:39.000Z","updated":"2019-12-15T13:04:23.475Z","comments":true,"path":"/p/excel-formula.html","link":"","permalink":"https://dayarch.top/p/excel-formula.html","excerpt":"前言 最近在做基础数据的整理，数据存放在 Word 表格中，要将大量的数据整理好并导入到数据库中着实需要费些力气，于是需要笨方法和巧方法一起用 整理过程 首先应用笨方法，将 Word 中的数据表格拷贝到 Excel 中，貌似这是必须的，由于拷贝过来的表格有合并单元格的情况，所以我们要将 Excel 中的表格标准化 Excel通过公式拼接字符串换行 我们通常都会通过Excel公式=CONCATENATE(Text1,[Text2])来拼接字符串，当我们需要拼接的字符串中需要换行时我们可以使用CHAR(10)来完成拼接换行符，请看如下例子 =CONCATENATE(\"hello\",CHAR(","text":"前言最近在做基础数据的整理，数据存放在 Word 表格中，要将大量的数据整理好并导入到数据库中着实需要费些力气，于是需要笨方法和巧方法一起用 整理过程首先应用笨方法，将 Word 中的数据表格拷贝到 Excel 中，貌似这是必须的，由于拷贝过来的表格有合并单元格的情况，所以我们要将 Excel 中的表格标准化 Excel通过公式拼接字符串换行我们通常都会通过Excel公式=CONCATENATE(Text1,[Text2])来拼接字符串，当我们需要拼接的字符串中需要换行时我们可以使用CHAR(10)来完成拼接换行符，请看如下例子 =CONCATENATE(&quot;hello&quot;,CHAR(10),&quot;world&quot;)输出结果如下： hello worldNOTE: 使用拼接字符串公式的单元格请设置为常规，不要是自动换行. 取消合并单元格 将 Excel 全部选中，然后点击取消单元格 将空单元格进行字段的填充 我们看到拆分后的单元格好多都是空的，我们需要将空的单元格填充为它上面一行的数据 选中待处理的单元格 按F5 在弹出框的位置选择空值选项 键盘输入等于号”=”，然后敲击向上方向键 Ctrl + Enter 组合完成 修改 Excel 的默认语言 我用的Mac 英文版，打开 Excel 没有类似 LENB() 这样的函数，所以我需要将语言就改为中文 12345# 修改 Excel 语言defaults write com.microsoft.Excel AppleLanguages '(\"zh-tw\")'# 修改 Word 语言defaults write com.microsoft.Word AppleLanguages '(\"zh-tw\")' 数字与汉字的拆分 拷贝过来的数据，需要做K-V 的映射，将一段文字中的数字提取出来作为 key， 将文本中的汉字提取出来作为 Value，所以需要用到两组公式： LEFT(单元格, length) / RIGHT(单元格, length) LEFT: 从单元格内容开始位置截取指定长度内容； RIGHT: 从单元格内容末尾位置截取指定长度内容； LEN(单元格) / LENB(单元格) LEN是返回字符串的字符数; LENB是返回字符串的字节数; 数字、字母、英文、标点符号（半角状态）都是按1计算的，汉字、全角状态下的标点符号，每个字符按2计算 阿拉伯数字转罗马数字 只需要应用公式：= ROMAN(A16) 罗马数字转阿拉伯数字 同样应用公式：=MATCH(B16,INDEX(ROMAN(ROW(INDIRECT(“1:4000”))),0),0) 以上就是这次数据提取用到的一些公式 附录在此处附上 office 的各种语言字典码","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"https://dayarch.top/tags/Excel/"}]},{"title":"双亲委派模型","slug":"双亲委派模型","date":"2019-04-26T06:56:22.000Z","updated":"2019-11-07T06:37:53.347Z","comments":true,"path":"/p/java-parents-delegation-model.html","link":"","permalink":"https://dayarch.top/p/java-parents-delegation-model.html","excerpt":"双亲委派模型 在介绍这个Java技术点之前，先试着思考以下几个问题： 1. 为什么我们不能定义同名的 String 的 java 文件？ 2. 多线程的情况下，类的加载为什么不会出现重复加载的情况？ 3. 下面代码，虚拟机是怎样初始化注册 Mysql 连接驱动(Driver)的？ 1 Connection conn= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK\", \"root\",","text":"双亲委派模型在介绍这个Java技术点之前，先试着思考以下几个问题： 为什么我们不能定义同名的 String 的 java 文件？ 多线程的情况下，类的加载为什么不会出现重复加载的情况？ 下面代码，虚拟机是怎样初始化注册 Mysql 连接驱动(Driver)的？ 1Connection conn= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK&quot;, &quot;root&quot;, &quot;000000&quot;); 热部署的原理是什么？ 想理解以上几个问题的前提是了解类加载时机与过程, 这篇文章将会以非常详细的解读方式来回答以上几个问题 类加载时机与过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 加载在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头（当class文件以二进制形式打开，会看到这个文件头，cafebabe）、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值通常情况下是数据类型的零值，假设一个类变量的定义为： 12// 变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行public static int value=123; 有通常情况就有特殊情况，这里的特殊是指： 12// 当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0public static final int value=123; 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 初始化在介绍初始化时，要先介绍两个方法：&lt;clinit&gt; 和 &lt;init&gt; : 在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法, 另一个是实例的初始化方法 clinit&gt;：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行 &lt;init&gt;: 在实例创建出来的时候调用，包括调用new操作符；调用 Class 或 Java.lang.reflect.Constructor 对象的newInstance()方法；调用任何现有对象的clone()方法；通过 java.io.ObjectInputStream 类的getObject() 方法反序列化。 类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备极端，变量已经付过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主管计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程. &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 static{} 中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下： 1234567public class Test &#123; static &#123; i=0; System.out.println(i); //这句编译器会报错：Illegal forward reference (不合法的向前引用) &#125; static int i=1;&#125; 那么去掉报错的那句，改成下面： 1234567891011public class Test &#123; static &#123; i=0; // System.out.println(i); //这句编译器会报错：Illegal forward reference (不合法的向前引用) &#125; static int i=1; public static void main(String args[])&#123; System.out.println(i); &#125;&#125; 输出结果：1 为什么输出结果是1，在准备阶段我们知道 i=0，然后类初始化阶段按照顺序执行，首先执行 static 块中的 i=0,接着执行 static赋值操作i=1, 最后在 main 方法中获取 i 的值为1 &lt;clinit&gt;()方法与实例构造器&lt;init&gt;()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类&lt;init&gt;()方法执行之前，父类的&lt;clinit&gt;()方法方法已经执行完毕 由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。 &lt;clinit&gt;()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产&lt;clinit&gt;()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。 让我们来验证上面的加载规则 虚拟机会保证在子类&lt;init&gt;()方法执行之前，父类的&lt;clinit&gt;()方法方法已经执行完毕 123456789101112131415161718192021222324252627282930313233343536373839404142public class SSClass&#123; static &#123; System.out.println(\"SSClass\"); &#125;&#125;public class SuperClass extends SSClass&#123; static &#123; System.out.println(\"SuperClass init!\"); &#125; public static int value = 123; public SuperClass() &#123; System.out.println(\"init SuperClass\"); &#125;&#125;public class SubClass extends SuperClass&#123; static &#123; System.out.println(\"SubClass init\"); &#125; static int a; public SubClass() &#123; System.out.println(\"init SubClass\"); &#125;&#125;public class NotInitialization&#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 输出结果 123SSClassSuperClass init!123 通过数组定义来引用类，不会触发此类的初始化(我的理解是数组的父类是Object) 1234567public class NotInitialization&#123; public static void main(String[] args) &#123; SuperClass[] sca = new SuperClass[10]; &#125;&#125; 输出结果：无 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 123456789101112131415public class ConstClass&#123; static &#123; System.out.println(\"ConstClass init!\"); &#125; public static final String HELLOWORLD = \"hello world\";&#125;public class NotInitialization&#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLOWORLD); &#125;&#125; 输出结果： 1hello world 验证小结 虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）： 遇到 new, getstatic, putstatic, invokestatic 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用jdk1.7动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getstatic, REF_putstatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。 有了这个加载规则的印象，双亲委派模型就很好理解了，别着急，继续向下看, 你会发现你的理解层面提高了 双亲委派模型刚看到这个词汇的时候我是完全懵懂的状态，其实就是定义了 JVM 启动的时候类的加载规则, 大家要按规矩办事，好办事，来看下图： 所谓双亲委派是指每次收到类加载请求时，先将请求委派给父类加载器完成（所有加载请求最终会委派到顶层的Bootstrap ClassLoader加载器中），如果父类加载器无法完成这个加载（该加载器的搜索范围中没有找到对应的类），子类尝试自己加载， 如果都没加载到，则会抛出 ClassNotFoundException 异常， 看到这里其实就解释了文章开头提出的第一个问题，父加载器已经加载了JDK 中的 String.class 文件，所以我们不能定义同名的 String java 文件。 为什么会有这样的规矩设定？ 因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String 已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。 我们发现除了启动类加载器（BootStrap ClassLoader），每个类都有其”父类”加载器 ⚠️ 其实这里的父子关系是组合模式，不是继承关系来实现 从图中可以看到类 AppClassLoader 和 ExtClassLoader 都继承 URLClassLoader， 而 URLClassLoader 又继承 ClassLoader， 在 ClassLoader 中有一个属性 1234// The parent class loader for delegation// Note: VM hardcoded the offset of this field, thus all new fields// must be added *after* it.private final ClassLoader parent; 在通过构造函数实例化 AppClassLoader 和 ExtClassLoader 的时候都要传入一个 classloader 作为当前 classloader 的 parent 12345AppClassLoader(URL[] var1, ClassLoader var2) &#123; // 通过层层调用 super，最后指定到 ClassLoader.java 中的 parent 属性 super(var1, var2, Launcher.factory); this.ucp.initLookupCache(this);&#125; 顶层ClassLoader有几个函数很关键，先有个印象 指定保护域（protectionDomain），把ByteBuffer的内容转换成 Java 类，这个方法被声明为final的 1defineClass(String name, java.nio.ByteBuffer b,ProtectionDomain protectionDomain) 把字节数组 b中的内容转换成 Java 类，其开始偏移为off,这个方法被声明为final的 1defineClass(String name, byte[] b, int off, int len) 查找指定名称的类 1findClass(String name) 链接指定的类 1resolveClass(Class&lt;?&gt;) 类加载器责任范围上面我们提到每个加载器都有对应的加载搜索范围 Bootstrap ClassLoader:这个加载器不是一个Java类，而是由底层的c++实现，负责在虚拟机启动时加载Jdk核心类库（如：rt.jar、resources.jar、charsets.jar等）以及加载后两个类加载器。这个ClassLoader完全是JVM自己控制的，需要加载哪个类，怎么加载都是由JVM自己控制，别人也访问不到这个类 Extension ClassLoader:是一个普通的Java类，继承自ClassLoader类，负责加载{JAVA_HOME}/jre/lib/ext/目录下的所有jar包。 App ClassLoader：是Extension ClassLoader的子对象，负责加载应用程序classpath目录下的所有jar和class文件。 123456789101112131415/** * 测试类加载器加载目录 */public class TestClassLoaderPath &#123; public static void main(String[] args)throws Exception&#123; // BootStrap ClassLoader加载的文件 System.out.println(System.getProperty(\"sun.boot.class.path\")); // ExtClassLoader加载的文件 System.out.println(System.getProperty(\"java.ext.dirs\")); // AppClassLoader加载的文件 System.getProperty(\"java.class.path\") &#125;&#125; 大家自行运行这个文件，就可以看到每个类加载器加载的文件了 两种类的加载方式通常用这两种方式来动态加载一个 java 类，Class.forName() 与 ClassLoader.loadClass() 但是两个方法之间也是有一些细微的差别 Class.forName() 方式查看Class类的具体实现可知，实质上这个方法是调用原生的方法： 1private static native Class&lt;?&gt; forName0(String name, boolean initialize,ClassLoader loader); 形式上类似于Class.forName(name,true,currentLoader)。 综上所述，Class.forName 如果调用成功会： 保证一个Java类被有效得加载到内存中； 类默认会被初始化，即执行内部的静态块代码以及保证静态属性被初始化； 默认会使用当前的类加载器来加载对应的类。 ClassLoader.loadClass方式如果采用这种方式的类加载策略，由于双亲托管模型的存在，最终都会将类的加载任务交付给Bootstrap ClassLoader进行加载。跟踪源代码，最终会调用原生方法： 1private native Class&lt;?&gt; findBootstrapClass(String name); 与此同时，与上一种方式的最本质的不同是，类不会被初始化，只有显式调用才会进行初始化。综上所述，ClassLoader.loadClass 如果调用成功会： 类会被加载到内存中； 类不会被初始化，只有在之后被第一次调用时类才会被初始化； 之所以采用这种方式的类加载，是提供一种灵活度，可以根据自身的需求继承ClassLoader类实现一个自定义的类加载器实现类的加载。（很多开源Web项目中都有这种情况，比如tomcat，struct2，jboss。原因是根据Java Servlet规范的要求，既要Web应用自己的类的优先级要高于Web容器提供的类，但同时又要保证Java的核心类不被任意覆盖，此时重写一个类加载器就很必要了） 双亲委派模型源码分析Launcher分析类加载器源码要从 sun.misc.Launcher.class 文件看起, 关键代码已添加注释，同时可以在此类中看到 ExtClassLoader 和 AppClassLoader 的定义，也验证了我们上文提到的他们不是继承关系，而是通过指定 parent 属性来形成的组合模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public Launcher() &#123; Launcher.ExtClassLoader var1; try &#123; // 获取扩展类加载器 var1 = Launcher.ExtClassLoader.getExtClassLoader(); &#125; catch (IOException var10) &#123; throw new InternalError(\"Could not create extension class loader\", var10); &#125; try &#123; // 获取应用程序类加载器，同时指定 parent 是var1（扩展类加载器） this.loader = Launcher.AppClassLoader.getAppClassLoader(var1); &#125; catch (IOException var9) &#123; throw new InternalError(\"Could not create application class loader\", var9); &#125; // 设置AppClassLoader为线程上下文类加载器（很关键），破坏双亲委派模型都要用到这个机制 Thread.currentThread().setContextClassLoader(this.loader); String var2 = System.getProperty(\"java.security.manager\"); if (var2 != null) &#123; SecurityManager var3 = null; if (!\"\".equals(var2) &amp;&amp; !\"default\".equals(var2)) &#123; try &#123; // 调用loadClass函数，这里的loader是AppClassLoader var3 = (SecurityManager)this.loader.loadClass(var2).newInstance(); &#125; catch (IllegalAccessException var5) &#123; &#125; catch (InstantiationException var6) &#123; &#125; catch (ClassNotFoundException var7) &#123; &#125; catch (ClassCastException var8) &#123; &#125; &#125; else &#123; var3 = new SecurityManager(); &#125; if (var3 == null) &#123; throw new InternalError(\"Could not create SecurityManager: \" + var2); &#125; System.setSecurityManager(var3); &#125; &#125;...// 静态内部类ExtClassLoaderstatic class ExtClassLoader extends java.net.URLClassLoader&#123; ...&#125;// 静态内部类AppClassLoaderstatic class AppClassLoader extends java.net.URLClassLoader&#123; ...&#125; 进入上面第25行的 loadClass 方法中 123456789101112131415161718192021222324252627282930313233343536373839protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; // parent为空，交给BootStrapClassLoader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //URLClassLoader重写了ClassLoader的findClass方法，会调用defineClass方法形成一个Java类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 我们看到方法有同步块（synchronized）, 这也就解释了文章开头第2个问题，多线程情况不会出现重复加载的情况。同时会询问parent classloader是否有加载，如果没有，自己尝试加载。 URLClassLoader中的 findClass方法： 123456789101112131415161718192021222324252627282930protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException &#123; final Class&lt;?&gt; result; try &#123; result = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123; public Class&lt;?&gt; run() throws ClassNotFoundException &#123; String path = name.replace('.', '/').concat(\".class\"); Resource res = ucp.getResource(path, false); if (res != null) &#123; try &#123; // 定义Class return defineClass(name, res); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name, e); &#125; &#125; else &#123; return null; &#125; &#125; &#125;, acc); &#125; catch (java.security.PrivilegedActionException pae) &#123; throw (ClassNotFoundException) pae.getException(); &#125; if (result == null) &#123; throw new ClassNotFoundException(name); &#125; return result; &#125; 借用网友的一个加载时序图来解释整个过程更加清晰： 双亲委派模型的破坏Java本身有一套资源管理服务JNDI，是放置在rt.jar中，由启动类加载器加载的。以对数据库管理JDBC为例，java给数据库操作提供了一个Driver接口： 1234567891011121314151617package java.sql;public interface Driver &#123; Connection connect(String url, java.util.Properties info) throws SQLException; boolean acceptsURL(String url) throws SQLException; DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info) throws SQLException; int getMajorVersion(); int getMinorVersion(); boolean jdbcCompliant(); public Logger getParentLogger() throws SQLFeatureNotSupportedException;&#125; 然后提供了一个DriverManager来管理这些Driver的具体实现： 123456789101112131415public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(\"registerDriver: \" + driver); &#125; 这里省略了大部分代码，可以看到我们使用数据库驱动前必须先要在DriverManager中使用registerDriver()注册，然后我们才能正常使用。 不破坏双亲委派模型的情况（不使用JNDI服务）我们看下mysql的驱动是如何被加载的： 1234// 1.加载数据访问驱动，以Class.forName的方式加载，会初始化Class.forName(\"com.mysql.jdbc.Driver\");//2.连接到数据\"库\"上去Connection conn= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK\", \"root\", \"\"); 核心就是这句Class.forName()触发了mysql驱动的加载，我们看下mysql对Driver接口的实现： 12345678910111213141516171819202122public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; 可以看到，Class.forName()其实触发了静态代码块，然后向DriverManager中注册了一个mysql的Driver实现。这个时候，我们通过DriverManager去获取connection的时候只要遍历当前所有Driver实现，然后选择一个建立连接就可以了。 破坏双亲委派模型的情况在JDBC4.0以后，开始支持使用spi的方式来注册这个Driver，具体做法就是在mysql的jar包中的META-INF/services/java.sql.Driver 文件中指明当前使用的Driver是哪个，然后使用的时候就直接这样就可以了： 1Connection conn= DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb?characterEncoding=GBK\", \"root\", \"\"); 可以看到这里直接获取连接，省去了上面的Class.forName()注册过程。 现在，我们分析下看使用了这种spi服务的模式原本的过程是怎样的: 第一，从META-INF/services/java.sql.Driver文件中获取具体的实现类名“com.mysql.jdbc.Driver” 第二，加载这个类，这里肯定只能用class.forName(“com.mysql.jdbc.Driver”)来加载 好了，问题来了，Class.forName()加载用的是调用者的Classloader，这个调用者DriverManager是在rt.jar中的，ClassLoader是启动类加载器，而com.mysql.jdbc.Driver肯定不在/lib下，所以肯定是无法加载mysql中的这个类的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。 那么，这个问题如何解决呢？按照目前情况来分析，这个mysql的drvier只有应用类加载器能加载，那么我们只要在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。 文章前半段提到线程上下文类加载器可以通过 Thread.setContextClassLoaser() 方法设置，如果不特殊设置会从父类继承，一般默认使用的是应用程序类加载器 很明显，线程上下文类加载器让父级类加载器能通过调用子级类加载器来加载类，这打破了双亲委派模型的原则 现在我们看下DriverManager是如何使用线程上下文类加载器去加载第三方jar包中的Driver类的，先来看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class DriverManager &#123; static &#123; loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); &#125; private static void loadInitialDrivers() &#123; String drivers; try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(\"jdbc.drivers\"); &#125; &#125;); &#125; catch (Exception ex) &#123; drivers = null; &#125; // If the driver is packaged as a Service Provider, load it. // Get all the drivers through the classloader // exposed as a java.sql.Driver.class service. // ServiceLoader.load() replaces the sun.misc.Providers() AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; // ServiceLoader 是 implements Iterable&lt;S&gt;的一个类，并重写了 iterator 方法（很关键） ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); /* Load these drivers, so that they can be instantiated. * It may be the case that the driver class may not be there * i.e. there may be a packaged driver with the service class * as implementation of java.sql.Driver but the actual class * may be missing. In that case a java.util.ServiceConfigurationError * will be thrown at runtime by the VM trying to locate * and load the service. * * Adding a try catch block to catch those runtime errors * if driver not available in classpath but it's * packaged as service and that service is there in classpath. */ try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; &#125; catch(Throwable t) &#123; // Do nothing &#125; return null; &#125; &#125;); println(\"DriverManager.initialize: jdbc.drivers = \" + drivers); if (drivers == null || drivers.equals(\"\")) &#123; return; &#125; String[] driversList = drivers.split(\":\"); println(\"number of Drivers:\" + driversList.length); for (String aDriver : driversList) &#123; try &#123; println(\"DriverManager.Initialize: loading \" + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println(\"DriverManager.Initialize: load failed: \" + ex); &#125; &#125; &#125;&#125; 使用时，我们直接调用DriverManager.getConnection() 方法自然会触发静态代码块的执行，开始加载驱动然后我们看下ServiceLoader.load()的具体实现： 12345678public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; // 上文介绍类加载源码时，注释说明过设置AppClassLoader为上下文加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl);&#125;public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader)&#123; return new ServiceLoader&lt;&gt;(service, loader);&#125; 继续向下看构造函数实例化 ServiceLoader 做了哪些事情： 123456private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123; service = Objects.requireNonNull(svc, \"Service interface cannot be null\"); loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload();&#125; 查看 reload() 函数： 1234public void reload() &#123; providers.clear(); lookupIterator = new LazyIterator(service, loader);&#125; 继续查看LazyIterator构造器，该类同样实现了Iterator接口： 1234private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123; this.service = service; this.loader = loader;&#125; 实例化到这里我们也将上下文得到的类加载器实例化到这里，来回看ServiceLoader 重写的 iterator() 方法： 12345678910111213141516171819202122232425public Iterator&lt;S&gt; iterator() &#123; return new Iterator&lt;S&gt;() &#123; Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() &#123; if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); &#125; // DriverManager 类中 driversIterator 调用的next() 方法实际是这个方法 public S next() &#123; if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125;;&#125; 上面next() 方法调用了lookupIterator.next()，这个lookupIterator 就是刚刚实例化的 LazyIterator(); 来看next方法 12345678910public S next() &#123; if (acc == null) &#123; return nextService(); &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125;&#125; 继续查看nextService 方法： 1234567891011121314151617181920212223private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; c = Class.forName(cn, false, loader); &#125; catch (ClassNotFoundException x) &#123; fail(service, \"Provider \" + cn + \" not found\"); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, \"Provider \" + cn + \" not a subtype\"); &#125; try &#123; S p = service.cast(c.newInstance()); providers.put(cn, p); return p; &#125; catch (Throwable x) &#123; fail(service, \"Provider \" + cn + \" could not be instantiated\", x); &#125; throw new Error(); // This cannot happen&#125; 终于到这里了，在上面 nextService函数中第8行调用了c = Class.forName(cn, false, loader) 方法，我们成功的做到了通过线程上下文类加载器拿到了应用程序类加载器（或者自定义的然后塞到线程上下文中的），同时我们也查找到了厂商在子级的jar包中注册的驱动具体实现类名，这样我们就可以成功的在rt.jar包中的DriverManager中成功的加载了放在第三方应用程序包中的类了同时在第16行完成Driver的实例化，等同于new Driver(); 文章开头的问题在理解到这里也迎刃而解了 JAVA热部署实现首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。 另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。 热部署步骤： 销毁自定义classloader(被该加载器加载的class也会自动卸载)； 更新class 使用新的ClassLoader去加载class JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）： 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。 加载该类的ClassLoader已经被GC。 该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法 自定义类加载器要创建用户自己的类加载器，只需要继承java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，即指明如何获取类的字节码流。 如果要符合双亲委派规范，则重写findClass方法（用户自定义类加载逻辑）；要破坏的话，重写loadClass方法(双亲委派的具体逻辑实现)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package classloader;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;class TestClassLoad &#123; @Override public String toString() &#123; return \"类加载成功。\"; &#125;&#125;public class PathClassLoader extends ClassLoader &#123; private String classPath; public PathClassLoader(String classPath) &#123; this.classPath = classPath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getData(String className) &#123; String path = classPath + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try &#123; InputStream is = new FileInputStream(path); ByteArrayOutputStream stream = new ByteArrayOutputStream(); byte[] buffer = new byte[2048]; int num = 0; while ((num = is.read(buffer)) != -1) &#123; stream.write(buffer, 0, num); &#125; return stream.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String args[]) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; ClassLoader pcl = new PathClassLoader(\"D:\\\\ProgramFiles\\\\eclipseNew\\\\workspace\\\\cp-lib\\\\bin\"); Class c = pcl.loadClass(\"classloader.TestClassLoad\");//注意要包括包名 System.out.println(c.newInstance());//打印类加载成功. &#125;&#125; 感谢与参考非常感谢以下博文的作者，通过反复拜读来了解双亲委派模型的原理 https://blog.csdn.net/u014634338/article/details/81434327 https://www.cnblogs.com/aspirant/p/7200523.html https://www.cnblogs.com/gdpuzxs/p/7044963.html https://www.jianshu.com/p/09f73af48a98 https://www.cnblogs.com/yahokuma/p/3668138.html","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://dayarch.top/tags/ClassLoader/"},{"name":"热部署","slug":"热部署","permalink":"https://dayarch.top/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"}]},{"title":"PKIX证书导入","slug":"PKIX证书导入","date":"2019-04-12T03:55:47.000Z","updated":"2019-11-01T08:49:07.869Z","comments":true,"path":"/p/pkix-certificate-import.html","link":"","permalink":"https://dayarch.top/p/pkix-certificate-import.html","excerpt":"通过理解SSL握手过程解决客户端证书问题最近做项目，调用远程服务器突然出现如下错误： 1 PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 很明显，客户端找不到服务器端返回的public certificate，所以我们需要拿到服务器给客户端的证书，并且存放到Keystore中，这就涉及到SSL握手（handshake）获取信任的过程。 图解","text":"通过理解SSL握手过程解决客户端证书问题 最近做项目，调用远程服务器突然出现如下错误： 1PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 很明显，客户端找不到服务器端返回的public certificate，所以我们需要拿到服务器给客户端的证书，并且存放到Keystore中，这就涉及到SSL握手（handshake）获取信任的过程。 图解SSL（Secure Socket Layer）协议开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake） 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法 服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random） 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端 服务端使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret） 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程 以上就是握手的整个过程，其中握手阶段有三点需要注意 生成对话密钥一共需要三个随机数。 握手之后的对话使用”对话密钥”加密（对称加密），服务器的公钥和私钥只用于加密和解密”对话密钥”（非对称加密RSA），无其他作用。 服务器公钥放在服务器的数字证书之中。 SSL具体握手过程用-Djavax.net.debug=all来开启调试信息的输出，SSL的握手过程一目了然： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174182018-02-01 17:05:24 --INFO-- ***Helper : https://xxx.xxx.com:8443/***/ws/***ServiceIgnoring unsupported cipher suite: TLS_DHE_DSS_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_DHE_DSS_WITH_AES_256_CBC_SHA256Ignoring unsupported cipher suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_DHE_RSA_WITH_AES_256_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_RSA_WITH_AES_256_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384Ignoring unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256Ignoring unsupported cipher suite: TLS_RSA_WITH_AES_128_CBC_SHA256Allow unsafe renegotiation: falseAllow legacy hello messages: trueIs initial handshake: trueIs secure renegotiation: false%% Client cached [Session-5, TLS_RSA_WITH_AES_256_CBC_SHA]%% Try resuming [Session-5, TLS_RSA_WITH_AES_256_CBC_SHA] from port 12371##客户端跟服务器第一次打招呼##*** ClientHello, TLSv1RandomCookie: GMT: 1517410388 bytes = &#123; 95, 120, 132, 216, 69, 34, 205, 73, 133, 30, 240, 178, 37, 187, 228, 127, 73, 149, 1, 216, 19, 3, 35, 236, 29, 111, 125, 132 &#125;Session ID: &#123;248, 40, 73, 62, 46, 20, 43, 249, 49, 73, 148, 196, 222, 200, 202, 68, 221, 241, 33, 57, 128, 93, 149, 1, 7, 112, 248, 66, 173, 203, 187, 1&#125;##支持的加密算法##Cipher Suites: [TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, SSL_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA, SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA, SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA, SSL_RSA_WITH_RC4_128_SHA, TLS_ECDH_ECDSA_WITH_RC4_128_SHA, TLS_ECDH_RSA_WITH_RC4_128_SHA, SSL_RSA_WITH_RC4_128_MD5, TLS_EMPTY_RENEGOTIATION_INFO_SCSV]Compression Methods: &#123; 0 &#125;Extension elliptic_curves, curve names: &#123;secp256r1, sect163k1, sect163r2, secp192r1, secp224r1, sect233k1, sect233r1, sect283k1, sect283r1, secp384r1, sect409k1, sect409r1, secp521r1, sect571k1, sect571r1, secp160k1, secp160r1, secp160r2, sect163r1, secp192k1, sect193r1, sect193r2, secp224k1, sect239k1, secp256k1&#125;Extension ec_point_formats, formats: [uncompressed]Extension server_name, server_name: [host_name: idmtest.dcpc.com]***[write] MD5 and SHA1 hashes: len = 2200000: 01 00 00 D8 03 01 5A 72 D8 54 5F 78 84 D8 45 22 ......Zr.T_x..E\"0010: CD 49 85 1E F0 B2 25 BB E4 7F 49 95 01 D8 13 03 .I....%...I........DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Handshake, length = 220[Raw write]: length = 2250000: 16 03 01 00 DC 01 00 00 D8 03 01 5A 72 D8 54 5F ...........Zr.T_0010: 78 84 D8 45 22 CD 49 85 1E F0 B2 25 BB E4 7F 49 x..E\".I....%...I...[Raw read]: length = 50000: 16 03 01 06 22 ....\"[Raw read]: length = 15700000: 02 00 00 46 03 01 5A 72 63 4E F2 CF 4B 0F CE 58 ...F..ZrcN..K..X0010: 0E EF 36 D4 F3 3E C0 85 AD 6D 4B 8D DB CA FB 77 ..6..&gt;...mK....w0020: 80 B3 A1 D2 A7 90 20 D5 A6 FD 6E A7 FF 5A D4 DF ...... ...n..Z.....DefaultQuartzScheduler_Worker-3, READ: TLSv1 Handshake, length = 1570##服务器响应*** ServerHello, TLSv1RandomCookie: GMT: 1517445966 bytes = &#123; 242, 207, 75, 15, 206, 88, 14, 239, 54, 212, 243, 62, 192, 133, 173, 109, 75, 141, 219, 202, 251, 119, 128, 179, 161, 210, 167, 144 &#125;Session ID: &#123;213, 166, 253, 110, 167, 255, 90, 212, 223, 9, 221, 44, 82, 61, 249, 50, 79, 110, 177, 174, 106, 198, 101, 47, 213, 191, 119, 128, 106, 200, 188, 1&#125;##服务器选定的加密算法Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHACompression Method: 0***Warning: No renegotiation indication extension in ServerHello%% Initialized: [Session-8, TLS_RSA_WITH_AES_256_CBC_SHA]** TLS_RSA_WITH_AES_256_CBC_SHA[read] MD5 and SHA1 hashes: len = 740000: 02 00 00 46 03 01 5A 72 63 4E F2 CF 4B 0F CE 58 ...F..ZrcN..K..X0010: 0E EF 36 D4 F3 3E C0 85 AD 6D 4B 8D DB CA FB 77 ..6..&gt;...mK....w...##服务器返回给客户端的证书链,证明“我是我”*** Certificate chainchain [0] = [[ Version: V3 Subject: CN=*.****.com, ST=北京市, L=北京市, O=***公司, C=CN Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11 Key: Sun RSA public key, 2048 bits modulus: 256891288892062675553247103925... public exponent: 65537 Validity: [From: Wed May 17 16:15:30 CST 2017, To: Fri May 15 16:15:30 CST 2020] Issuer: CN=WoSign OV SSL CA, O=WoSign CA Limited, C=CN SerialNumber: [ 363fa17d 5c46082c dc707c24 6a8d81b2]Certificate Extensions: 9[1]: ObjectId: 1.3.6.1.5.5.7.1.1 Criticality=falseAuthorityInfoAccess [[ accessMethod: ocsp accessLocation: URIName: http://wosign-ovca.ocsp-certum.com, accessMethod: caIssuers accessLocation: URIName: http://repository.certum.pl/wosign-ovca.cer]][2]: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: A1 13 54 DC 56 73 2C 27 82 CA C8 84 EF EE BF 00 ..T.Vs,'........0010: FD 5F AB 56 ._.V]][3]: ObjectId: 2.5.29.19 Criticality=trueBasicConstraints:[ CA:false PathLen: undefined][4]: ObjectId: 2.5.29.31 Criticality=falseCRLDistributionPoints [ [DistributionPoint: [URIName: http://wosign.crl.certum.pl/wosign-ovca.crl]]][5]: ObjectId: 2.5.29.32 Criticality=falseCertificatePolicies [ [CertificatePolicyId: [2.23.140.1.2.2][] ] [CertificatePolicyId: [1.2.616.1.113527.2.5.1.12.2][PolicyQualifierInfo: [ qualifierID: 1.3.6.1.5.5.7.2.2 qualifier:0000: 30 81 E4 30 1F 16 18 41 73 73 65 63 6F 20 44 61 0..0...Asseco Da0010: 74 61 20 53 79 73 74 65 6D 73 20 53 2E 41 2E 30 ta Systems S.A.0...]] ]][6]: ObjectId: 2.5.29.37 Criticality=falseExtendedKeyUsages [ serverAuth clientAuth][7]: ObjectId: 2.5.29.15 Criticality=trueKeyUsage [ DigitalSignature Key_Encipherment][8]: ObjectId: 2.5.29.17 Criticality=falseSubjectAlternativeName [ DNSName: *.dcpc.com DNSName: dcpc.com][9]: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: B3 A6 53 AD 96 D8 B7 51 09 D5 E1 07 E5 B2 BC E6 ..S....Q........0010: B5 F2 82 2B ...+]]] Algorithm: [SHA256withRSA] Signature:0000: 9A 38 A4 8F B2 A8 CE 9A B6 98 2F 8F 18 AA 45 79 .8......../...Ey0010: DE D6 31 22 99 6E D7 14 45 5E C1 1F 06 EC 7F C9 ..1\".n..E^.........]***==客户端从本地找到的信赖证书(如果找不到会直接报certificate_unknow)==Found trusted certificate:[[ Version: V3 Subject: CN=*.****.com, ST=北京市, L=北京市, O=****公司, C=CN Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11 Key: Sun RSA public key, 2048 bits modulus: 2568912888920626755532471039254124.... public exponent: 65537 Validity: [From: Wed May 17 16:15:30 CST 2017, To: Fri May 15 16:15:30 CST 2020] Issuer: CN=WoSign OV SSL CA, O=WoSign CA Limited, C=CN SerialNumber: [ 363fa17d 5c46082c dc707c24 6a8d81b2]Certificate Extensions: 9[1]: ObjectId: 1.3.6.1.5.5.7.1.1 Criticality=falseAuthorityInfoAccess [ [ accessMethod: ocsp accessLocation: URIName: http://wosign-ovca.ocsp-certum.com, accessMethod: caIssuers accessLocation: URIName: http://repository.certum.pl/wosign-ovca.cer]][2]: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: A1 13 54 DC 56 73 2C 27 82 CA C8 84 EF EE BF 00 ..T.Vs,'........0010: FD 5F AB 56 ._.V]][3]: ObjectId: 2.5.29.19 Criticality=trueBasicConstraints:[ CA:false PathLen: undefined][4]: ObjectId: 2.5.29.31 Criticality=falseCRLDistributionPoints [ [DistributionPoint: [URIName: http://wosign.crl.certum.pl/wosign-ovca.crl]]][5]: ObjectId: 2.5.29.32 Criticality=falseCertificatePolicies [ [CertificatePolicyId: [2.23.140.1.2.2][] ] [CertificatePolicyId: [1.2.616.1.113527.2.5.1.12.2][PolicyQualifierInfo: [ qualifierID: 1.3.6.1.5.5.7.2.2 qualifier:0000: 30 81 E4 30 1F 16 18 41 73 73 65 63 6F 20 44 61 0..0...Asseco Da0010: 74 61 20 53 79 73 74 65 6D 73 20 53 2E 41 2E 30 ta Systems S.A.0...]] ]][6]: ObjectId: 2.5.29.37 Criticality=falseExtendedKeyUsages [ serverAuth clientAuth][7]: ObjectId: 2.5.29.15 Criticality=trueKeyUsage [ DigitalSignature Key_Encipherment][8]: ObjectId: 2.5.29.17 Criticality=falseSubjectAlternativeName [ DNSName: *.dcpc.com DNSName: dcpc.com][9]: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: B3 A6 53 AD 96 D8 B7 51 09 D5 E1 07 E5 B2 BC E6 ..S....Q........0010: B5 F2 82 2B ...+]]] Algorithm: [SHA256withRSA] Signature:0000: 9A 38 A4 8F B2 A8 CE 9A B6 98 2F 8F 18 AA 45 79 .8......../...Ey0010: DE D6 31 22 99 6E D7 14 45 5E C1 1F 06 EC 7F C9 ..1\".n..E^.........][read] MD5 and SHA1 hashes: len = 14920000: 0B 00 05 D0 00 05 CD 00 05 CA 30 82 05 C6 30 82 ..........0...0.0010: 04 AE A0 03 02 01 02 02 10 36 3F A1 7D 5C 46 08 .........6?..\\F....*** ServerHelloDone[read] MD5 and SHA1 hashes: len = 40000: 0E 00 00 00 ....*** ClientKeyExchange, RSA PreMasterSecret, TLSv1[write] MD5 and SHA1 hashes: len = 2620000: 10 00 01 02 01 00 85 BD 72 17 92 EA 05 0F 0A BD ........r.......0010: 90 92 72 51 08 0F 6E 29 C4 A2 F0 D2 BA 78 0B A0 ..rQ..n).....x.....DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Handshake, length = 262[Raw write]: length = 2670000: 16 03 01 01 06 10 00 01 02 01 00 85 BD 72 17 92 .............r..0010: EA 05 0F 0A BD 90 92 72 51 08 0F 6E 29 C4 A2 F0 .......rQ..n)......SESSION KEYGEN:PreMaster Secret:0000: 03 01 80 92 4B 03 FA 1D 39 CE F4 82 3D 4A 96 A7 ....K...9...=J.....CONNECTION KEYGEN:Client Nonce:0000: 5A 72 D8 54 5F 78 84 D8 45 22 CD 49 85 1E F0 B2 Zr.T_x..E\".I.......Server Nonce:0000: 5A 72 63 4E F2 CF 4B 0F CE 58 0E EF 36 D4 F3 3E ZrcN..K..X..6..&gt;...Master Secret:0000: 93 05 C4 97 B7 FB 23 5F 11 15 8A 8E 2C C1 C7 72 ......#_....,..r...Client MAC write Secret:0000: 22 84 BA CD 61 27 D9 62 5F 84 FA 7A DF 05 DE 0A \"...a'.b_..z.......Server MAC write Secret:0000: D2 AC 73 AC CE F2 D2 00 31 E6 4F 8A DE E3 97 8D ..s.....1.O.....0010: 73 52 BA D2 sR..Client write key:0000: CA FB B2 02 E7 3F 79 93 55 61 CB AB FF EF 1E 76 .....?y.Ua.....v0010: 10 4C DD DE 83 55 99 6F 28 8E 19 5D 18 25 33 A2 .L...U.o(..].%3.Server write key:0000: 1A 25 31 69 D2 3B 45 D7 70 09 5F 9A FF D5 B3 71 .%1i.;E.p._....q0010: 73 9D D6 52 F0 10 21 8B 8E 13 97 BE B1 02 75 46 s..R..!.......uFClient write IV:0000: 68 49 14 C3 A2 97 75 A0 F3 AC 89 DA 31 84 C3 EF hI....u.....1...Server write IV:0000: 2C 03 9D 28 6F C2 7D BD 37 B1 AA E5 30 6E 09 EA ,..(o...7...0n..DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Change Cipher Spec, length = 1[Raw write]: length = 60000: 14 03 01 00 01 01 ......*** Finishedverify_data: &#123; 56, 169, 160, 43, 198, 100, 229, 140, 160, 251, 76, 146 &#125;***[write] MD5 and SHA1 hashes: len = 160000: 14 00 00 0C 38 A9 A0 2B C6 64 E5 8C A0 FB 4C 92 ....8..+.d....L.Padded plaintext before ENCRYPTION: len = 480000: 14 00 00 0C 38 A9 A0 2B C6 64 E5 8C A0 FB 4C 92 ....8..+.d....L.0010: F5 B1 BB DE F4 25 ED A2 3A 18 9D C8 8E EE 2B A6 .....%..:.....+.0020: 4A 1E 3A C7 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B J.:.............DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Handshake, length = 48[Raw write]: length = 530000: 16 03 01 00 30 4E 92 1F 3A 1F 91 C8 1B 9F 6B 3A ....0N..:.....k:0010: CC 2C 67 2C 9D CA 58 DA 4F 91 21 01 8E D8 5A 37 .,g,..X.O.!...Z70020: 67 B8 BD A9 E4 F3 79 E9 9C E6 E1 52 BB 8D 39 0E g.....y....R..9.0030: 45 5F F5 7E 7A E_..z[Raw read]: length = 50000: 14 03 01 00 01 .....[Raw read]: length = 10000: 01 .DefaultQuartzScheduler_Worker-3, READ: TLSv1 Change Cipher Spec, length = 1[Raw read]: length = 50000: 16 03 01 00 30 ....0[Raw read]: length = 480000: A9 B4 AB 6C 68 BA 47 DB CF 6E EF 8A F2 6F BD 73 ...lh.G..n...o.s0010: E4 44 55 C8 93 1B 4B C6 D9 A3 DB 4D 03 3B E0 8D .DU...K....M.;..0020: 67 ED E8 35 CA 63 D8 F8 C8 11 40 1B 54 DD 6F F2 g..5.c....@.T.o.DefaultQuartzScheduler_Worker-3, READ: TLSv1 Handshake, length = 48Padded plaintext after DECRYPTION: len = 480000: 14 00 00 0C 58 5A F4 F0 FA C9 BE 1D 27 6A A5 3A ....XZ......'j.:0010: DC 90 D1 52 C8 53 16 DD CB 04 E9 F0 F7 46 E2 9F ...R.S.......F..0020: 9E A6 EF 63 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B 0B ...c............*** Finishedverify_data: &#123; 88, 90, 244, 240, 250, 201, 190, 29, 39, 106, 165, 58 &#125;***%% Cached client session: [Session-8, TLS_RSA_WITH_AES_256_CBC_SHA][read] MD5 and SHA1 hashes: len = 160000: 14 00 00 0C 58 5A F4 F0 FA C9 BE 1D 27 6A A5 3A ....XZ......'j.:DefaultQuartzScheduler_Worker-3, setSoTimeout(9000000) calledPadded plaintext before ENCRYPTION: len = 960##发送数据0000: 50 4F 53 54 20 2F 69 64 6D 2F 77 73 2F 55 6E 69 POST /idm/ws/Uni0010: 74 53 65 72 76 69 63 65 20 48 54 54 50 2F 31 2E tService HTTP/1.0020: 30 0D 0A 43 6F 6E 74 65 6E 74 2D 54 79 70 65 3A 0..Content-Type:0030: 20 74 65 78 74 2F 78 6D 6C 3B 20 63 68 61 72 73 text/xml; chars0040: 65 74 3D 75 74 66 2D 38 0D 0A 41 63 63 65 70 74 et=utf-8..Accept0050: 3A 20 61 70 70 6C 69 63 61 74 69 6F 6E 2F 73 6F : application/so0060: 61 70 2B 78 6D 6C 2C 20 61 70 70 6C 69 63 61 74 ap+xml, applicat0070: 69 6F 6E 2F 64 69 6D 65 2C 20 6D 75 6C 74 69 70 ion/dime, multip0080: 61 72 74 2F 72 65 6C 61 74 65 64 2C 20 74 65 78 art/related, tex0090: 74 2F 2A 0D 0A 55 73 65 72 2D 41 67 65 6E 74 3A t/*..User-Agent:00A0: 20 41 78 69 73 2F 31 2E 34 0D 0A 48 6F 73 74 3A Axis/1.4..Host:00B0: 20 69 64 6D 74 65 73 74 2E 64 63 70 63 2E 63 6F ***.***.co00C0: 6D 3A 38 34 34 33 0D 0A 43 61 63 68 65 2D 43 6F m:8443..Cache-Co...DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Application Data, length = 960[Raw write]: length = 9650000: 17 03 01 03 C0 76 73 C9 5C 37 18 B3 8D 85 B6 4A .....vs.\\7.....J0010: A5 FF 06 E0 81 74 E2 46 22 C7 32 12 51 A6 C4 10 .....t.F\".2.Q...0020: 7E 1D 14 C6 1E 1B 44 95 57 6E AC 83 AA 8D A7 92 ......D.Wn......0030: 4C 34 01 5D E9 A1 1E 8C BB 03 55 D9 7A 09 0F 1E L4.]......U.z...0040: 5D C4 71 46 CA 29 72 0D C1 CC F8 CE 6E F9 51 3A ].qF.)r.....n.Q:...[Raw read]: length = 50000: 17 03 01 01 60 ....`[Raw read]: length = 3520000: CD C2 06 A2 9F EA 9F 00 C7 27 5E F0 B3 C4 3D 78 .........'^...=x0010: 2E 9B F4 52 08 FF D7 05 2E A8 1B 42 3F 9A 3D 73 ...R.......B?.=s...DefaultQuartzScheduler_Worker-3, READ: TLSv1 Application Data, length = 352##接收数据Padded plaintext after DECRYPTION: len = 3520000: 48 54 54 50 2F 31 2E 31 20 32 30 30 20 0D 0A 43 HTTP/1.1 200 ..C0010: 6F 6E 74 65 6E 74 2D 54 79 70 65 3A 20 74 65 78 ontent-Type: tex0020: 74 2F 78 6D 6C 3B 63 68 61 72 73 65 74 3D 55 54 t/xml;charset=UT0030: 46 2D 38 0D 0A 44 61 74 65 3A 20 54 68 75 2C 20 F-8..Date: Thu,0040: 30 31 20 46 65 62 20 32 30 31 38 20 30 39 3A 30 01 Feb 2018 09:00050: 35 3A 32 35 20 47 4D 54 0D 0A 43 6F 6E 6E 65 63 5:25 GMT..Connec0060: 74 69 6F 6E 3A 20 63 6C 6F 73 65 0D 0A 0D 0A 3C tion: close....&lt;0070: 73 6F 61 70 3A 45 6E 76 65 6C 6F 70 65 20 78 6D soap:Envelope xm0080: 6C 6E 73 3A 73 6F 61 70 3D 22 68 74 74 70 3A 2F lns:soap=\"http:/0090: 2F 73 63 68 65 6D 61 73 2E 78 6D 6C 73 6F 61 70 /schemas.xmlsoap00A0: 2E 6F 72 67 2F 73 6F 61 70 2F 65 6E 76 65 6C 6F .org/soap/envelo...[Raw read]: length = 50000: 15 03 01 00 20 ....[Raw read]: length = 320000: 10 E4 3E EF D9 D6 A2 0F F3 11 85 6F 8F 68 48 C8 ..&gt;........o.hH.0010: 26 73 2E C8 FA 9D 00 03 AB 3B 79 46 DE ED CC 40 &amp;s.......;yF...@DefaultQuartzScheduler_Worker-3, READ: TLSv1 Alert, length = 32Padded plaintext after DECRYPTION: len = 320000: 01 00 C2 40 0A 51 E1 F1 28 06 65 73 E4 84 81 01 ...@.Q..(.es....0010: 8F A9 A1 FD A9 6E 09 09 09 09 09 09 09 09 09 09 .....n..........DefaultQuartzScheduler_Worker-3, RECV TLSv1 ALERT: warning, close_notifyDefaultQuartzScheduler_Worker-3, called closeInternal(false)DefaultQuartzScheduler_Worker-3, SEND TLSv1 ALERT: warning, description = close_notifyPadded plaintext before ENCRYPTION: len = 320000: 01 00 4F BB 75 8C 9C 8A 12 64 D7 62 F6 AF 81 90 ..O.u....d.b....0010: 92 0E 91 25 6F 9B 09 09 09 09 09 09 09 09 09 09 ...%o...........DefaultQuartzScheduler_Worker-3, WRITE: TLSv1 Alert, length = 32[Raw write]: length = 370000: 15 03 01 00 20 C1 60 66 8A 2A 1D A5 6C 82 C3 59 .... .`f.*..l..Y0010: A8 D5 E9 28 70 1D 93 F1 DD 34 00 14 1F 56 12 46 ...(p....4...V.F0020: 33 0C 4C 3F 51 3.L?QDefaultQuartzScheduler_Worker-3, called closeSocket(selfInitiated)DefaultQuartzScheduler_Worker-3, called close()DefaultQuartzScheduler_Worker-3, called closeInternal(true)DefaultQuartzScheduler_Worker-3, called close()DefaultQuartzScheduler_Worker-3, called closeInternal(true) 证书识别Java程序对受信证书的查找顺序是： javax.net.ssl.trustStore 就是System.setProperty(“javax.net.ssl.trustStore”,”D:\\cacert.keystore”);或者通过JVM参数指定：-Djavax.net.ssl.trustStore=D:\\cacert.keystore。 JAVA_HOME\\jre\\lib\\security\\jssecacerts 【推荐】 默认没有jssecacerts，一般把cacerts复制成jssecacerts，然后再使用keytool来修改它。jsse的全称是Java Secure Socket Extension。 JAVA_HOME\\jre\\lib\\security\\cacerts 通常情况下不就建议通过-Djavax.net.ssl.trustStore=D:\\cacert.keystore来直接修改keystore文件的位置，因为这样会造成系统中其他模块可能找不到自己对应的证书了。推荐使用jssecacerts。我们需要什么证书直接往这个位置导就行了。程序不需要做调整。 Springboot 程序实现我们希望在Springboot应用每次启动后都向服务器请求证书，并将证书更新到Keystore中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203@ConditionalOnProperty(value = &quot;cert.installation&quot;, havingValue = &quot;true&quot;)@ConfigurationProperties(&quot;cert&quot;)@Configurationpublic class InstallCert implements CommandLineRunner &#123; private static Logger logger = LoggerFactory.getLogger(InstallCert.class); /** * 生成的证书需要存放的security路径，即： %JAVA_HOME%\\jre\\lib\\security */ private String path; /** * 需要SSL认证的域名 */ private List&lt;String&gt; domains = new ArrayList&lt;&gt;(); private String password = &quot;changeit&quot;; public String getPath() &#123; return path; &#125; public void setPath(String path) &#123; this.path = path; &#125; public List&lt;String&gt; getDomains() &#123; return domains; &#125; public void setDomains(List&lt;String&gt; domains) &#123; this.domains = domains; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public void run(String... strings) throws Exception &#123; logger.info(&quot;ready to install valid certs&quot;); if (!Collections.isEmpty(domains))&#123; logger.info(&quot;domains is &#123;&#125;&quot;, domains.toString()); String[] arrayStr = new String[domains.size()]; installValidCerts(domains.toArray(arrayStr)); &#125; &#125; private void installValidCerts(String[] args) throws Exception &#123; logger.info(&quot;Usage: java InstallCert &lt;host&gt;[:port] [passphrase]&quot;); char[] passphrase = password.toCharArray(); String certPath = path; if (Strings.isNullOrEmpty(path))&#123; char separator = File.separatorChar; certPath = System.getProperty(&quot;java.home&quot;) + separator + &quot;lib&quot; + separator + &quot;security&quot;; &#125; File dir = new File(certPath);// File file = new File(&quot;jssecacerts&quot;);// if (file.isFile() == false) &#123;// char SEP = File.separatorChar;// File dir = new File(System.getProperty(&quot;java.home&quot;) + SEP + &quot;lib&quot; + SEP + &quot;security&quot;);// file = new File(dir, &quot;jssecacerts&quot;);// if (file.isFile() == false) &#123;// file = new File(dir, &quot;cacerts&quot;);// &#125; KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); InputStream in = null; logger.info(&quot;jre security dir path: &#123;&#125;&quot;, dir.getCanonicalPath()); File file = new File(dir, &quot;jssecacerts&quot;); if (!file.exists() &amp;&amp; !file.isFile())&#123; file.createNewFile(); File file1 = new File(dir, &quot;cacerts&quot;); if (!file1.isFile())&#123; logger.info(&quot;no certs will be registered, casue no cacerts file was found&quot;); return; &#125; in = new FileInputStream(file1); ks.load(in, passphrase); logger.info(&quot;file jssecacerts is created successfully&quot;); &#125;else &#123; in = new FileInputStream(file); ks.load(in, passphrase); logger.info(&quot;file jssecacerts is existing, will not create again&quot;); &#125; IOUtils.closeQuietly(in); logger.info(&quot;Loading KeyStore &quot; + file + &quot;...&quot;); SSLContext context = SSLContext.getInstance(&quot;TLS&quot;); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(ks); X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0]; SavingTrustManager tm = new SavingTrustManager(defaultTrustManager); context.init(null, new TrustManager[] &#123; tm &#125;, null); SSLSocketFactory factory = context.getSocketFactory(); OutputStream out = new FileOutputStream(file); for (String domain: args)&#123; logger.info(&quot;domain is &#123;&#125;&quot;, domain); String[] c = args[0].split(&quot;:&quot;); String host = c[0]; int port = (c.length == 1) ? 443 : Integer.parseInt(c[1]); logger.info(&quot;Opening connection to &quot; + host + &quot;:&quot; + port + &quot;...&quot;); SSLSocket socket = (SSLSocket) factory.createSocket(host, port); socket.setSoTimeout(10000); try &#123; logger.info(&quot;Starting SSL handshake...&quot;); socket.startHandshake(); socket.close(); logger.info(&quot;No errors, certificate is already trusted&quot;); &#125; catch (SSLException e) &#123; e.printStackTrace(System.out); &#125; X509Certificate[] chain = tm.chain; if (chain == null) &#123; logger.info(&quot;Could not obtain server certificate chain, continue next one&quot;); continue; &#125; logger.info(&quot;Server sent &quot; + chain.length + &quot; certificate(s):&quot;); MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA1&quot;); MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); for (int i = 0; i &lt; chain.length; i++) &#123; X509Certificate cert = chain[i]; logger.info(&quot; &quot; + (i + 1) + &quot; Subject &quot; + cert.getSubjectDN()); logger.info(&quot; Issuer &quot; + cert.getIssuerDN()); sha1.update(cert.getEncoded()); logger.info(&quot; sha1 &quot; + toHexString(sha1.digest())); md5.update(cert.getEncoded()); logger.info(&quot; md5 &quot; + toHexString(md5.digest())); &#125; int k=0; X509Certificate cert = chain[k]; String alias = host + &quot;-&quot; + (k + 1); ks.setCertificateEntry(alias, cert); ks.store(out, passphrase); logger.info(cert.toString()); logger.info(&quot;Added &#123;&#125; certificate to keystore &apos;jssecacerts&apos; using alias &#123;&#125;&quot;, domain, alias); &#125; IOUtils.closeQuietly(out); &#125; private static final char[] HEXDIGITS = &quot;0123456789abcdef&quot;.toCharArray(); private static String toHexString(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(bytes.length * 3); for (int b : bytes) &#123; b &amp;= 0xff; sb.append(HEXDIGITS[b &gt;&gt; 4]); sb.append(HEXDIGITS[b &amp; 15]); sb.append(&apos; &apos;); &#125; return sb.toString(); &#125; private static class SavingTrustManager implements X509TrustManager &#123; private final X509TrustManager tm; private X509Certificate[] chain; SavingTrustManager(X509TrustManager tm) &#123; this.tm = tm; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; throw new UnsupportedOperationException(); &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; throw new UnsupportedOperationException(); &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; this.chain = chain; tm.checkServerTrusted(chain, authType); &#125; &#125;&#125; 接下来我们只需要在YAML（applicaton.yml）中配置要申请握手的服务器就好 12345cert: installation: true domains: - bidxxxxxxx.xxxxxxxxxxxxxx.com - suppxxxxxx.xxxxx.com 至此，就不会出现证书找不到的问题了 参考 https://www.cnblogs.com/huqiaoblog/p/8398009.html http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html https://blog.csdn.net/catoop/article/details/80819638","categories":[],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://dayarch.top/tags/SSL/"}]},{"title":"Arthas调整log日志等级","slug":"Arthas调整log日志等级","date":"2019-04-09T05:39:37.000Z","updated":"2019-11-07T05:14:40.445Z","comments":true,"path":"/p/arthas-log-level.html","link":"","permalink":"https://dayarch.top/p/arthas-log-level.html","excerpt":"阿里的开源Java诊断工具Arthas可以在线调整log等级 1. 查找当前类的classloader hashcode 1 sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 2. 用OGNL获取logger 1 ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger' 3. 单独设置UserController的logger level 1 ognl -c 1be6f5c3 '@c","text":"阿里的开源Java诊断工具Arthas可以在线调整log等级 查找当前类的classloader hashcode 1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 用OGNL获取logger 1ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger' 单独设置UserController的logger level 1ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)' 全局设置logger level 1ognl -c 1be6f5c3 '@org.slf4j.LoggerFactory@getLogger(\"root\").setLevel(@ch.qos.logback.classic.Level@DEBUG)'","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Arthas","slug":"Coding/Arthas","permalink":"https://dayarch.top/categories/Coding/Arthas/"}],"tags":[{"name":"Arthas","slug":"Arthas","permalink":"https://dayarch.top/tags/Arthas/"}]},{"title":"Springboot去掉@RequestBody中字符串类型值的前后空格","slug":"Springboot去掉-RequestBody中字符串类型值的前后空格","date":"2018-07-12T08:06:17.000Z","updated":"2019-11-01T08:56:36.962Z","comments":true,"path":"/p/spring-boot-request-body-space.html","link":"","permalink":"https://dayarch.top/p/spring-boot-request-body-space.html","excerpt":"改造MappingJackson2HttpMessageConverter前言 项目组提出要求，Springboot项目中，@ResquestBody标记的bean传入的字符串类型的值要去掉前后空格 实现 因为项目默认使用 MappingJackson2HttpMessageConverter 作为 Json转换器， 于是乎重写一些方法做文章，具体实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42","text":"改造MappingJackson2HttpMessageConverter 前言项目组提出要求，Springboot项目中，@ResquestBody标记的bean传入的字符串类型的值要去掉前后空格 实现因为项目默认使用 MappingJackson2HttpMessageConverter 作为 Json转换器， 于是乎重写一些方法做文章，具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@EnableWebMvc@Configurationpublic class WebConfig implements WebMvcConfigurer&#123; //... 省略重写的其他方法 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super.configureMessageConverters(converters); //对应无法直接返回String类型 converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); return super.getObjectMapper(); &#125; /** * 重写read方法，然后做去掉前后空格处理，重新转换成object * @param type * @param contextClass * @param inputMessage * @return * @throws IOException * @throws HttpMessageNotReadableException */ @Override public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; Object object = super.read(type, contextClass, inputMessage); String json = JSONObject.toJSONString(object); Map&lt;String,Object&gt; map = (Map&lt;String, Object&gt;) JSONObject.parse(json); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet(); Map&lt;String, Object&gt; removeSpaceMap = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; entry : entrySet)&#123; if (entry.getValue() instanceof String)&#123; removeSpaceMap.put(entry.getKey(), ((String) entry.getValue()).trim()); &#125;else &#123; removeSpaceMap.put(entry.getKey(),entry.getValue()); &#125; &#125; Gson gson = new Gson(); String removeSpaceJson = JSON.toJSONString(removeSpaceMap); return gson.fromJson(removeSpaceJson, type); &#125; &#125;); &#125;&#125; 但是上面的代码经过各种测试发现一个问题，Gson在处理Integer，Long非浮点型的数值类型时候，自动转换为Double来处理，这导致后续代码做一些数据转换的时候会出现问题，因为Gson内部在处理数据类型都当成Number类型，可以读一下源码，这样需要做如下的改动： 1234567891011121314151617181920212223242526272829303132/** * * @param type * @param contextClass * @param inputMessage * @return * @throws IOException * @throws HttpMessageNotReadableException */@Overridepublic Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; Object object = super.read(type, contextClass, inputMessage); String json = JSONObject.toJSONString(object); Map&lt;String,Object&gt; map = (Map&lt;String, Object&gt;) JSONObject.parse(json); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet(); Map&lt;String, Object&gt; removeSpaceMap = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; entry : entrySet)&#123; if (entry.getValue() instanceof String)&#123; removeSpaceMap.put(entry.getKey(), ((String) entry.getValue()).trim()); &#125;else &#123; removeSpaceMap.put(entry.getKey(),entry.getValue()); &#125; &#125; String removeSpaceJson = JSON.toJSONString(removeSpaceMap); return JSONObject.parseObject(removeSpaceJson, type); //注释掉Gson，转换默认将Integer，Long等转换成Double，内部处理看作Number /*Gson gson = new Gson(); return gson.fromJson(removeSpaceJson, type);*/&#125; 以为这样就结束了吗？哈哈，没有… 😒 以上我们传入的都是正常的JsonObject，比如这种格式的数据 1234567891011121314151617181920212223242526&#123; \"commonName\":\"test2\", \"ver\":1, \"certificateRootType\":\"Z200\", \"expiredDate\":\"2118-01-01\", \"certificateName\":\"税务登记证 。\", \"commonCode\":\"suibian\", \"updateTime\":\"2018-07-12 13:09:14\", \"perpetual\":2, \"certificateNo\":\"11111111\", \"certificateTypeName\":\"税务登记证\", \"imgInfoVOList\":[ &#123; \"url\":\"https://www.a.b.c/a.jpg\" &#125;, &#123; \"url\":\"https://www.a.b.c/b.jpg\" &#125; ], \"producerType\":1, \"createTime\":\"2018-07-12 13:09:14\", \"supplier\":1043, \"id\":5016, \"startDate\":\"2018-01-01\", \"certificateType\":\"Z202\"&#125; 但是要有这种格式的数据 1234567891011121314[ &#123; \"roleId\":212, \"name\":\"上帝视角\" &#125;, &#123; \"roleId\":212, \"name\":\"上帝视角\" &#125;, &#123; \"roleId\":212, \"name\":\"上帝视角\" &#125;] 如果是下面这种格式的，我们解析的时候就会报转换错误，所以针对下面JsonArray类型的数据，我们需要做特殊处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * * @param type * @param contextClass * @param inputMessage * @return * @throws IOException * @throws HttpMessageNotReadableException */@SuppressWarnings(\"unchecked\")@Overridepublic Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; Object object = super.read(type, contextClass, inputMessage); String json = JSONObject.toJSONString(object); String jsonResult = null; if (json.startsWith(\"[\"))&#123; JSONArray jsonArray = JSONArray.parseArray(json); if (jsonArray != null &amp;&amp; !jsonArray.isEmpty())&#123; List&lt;Map&lt;String, Object&gt;&gt; result = Lists.newArrayList(); for (int i=0; i&lt;jsonArray.size(); i++)&#123; Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) jsonArray.get(i); Map&lt;String, Object&gt; removeSpaceMap = removeSpace(map); result.add(removeSpaceMap); &#125; jsonResult = JSON.toJSONString(result); &#125; &#125;else &#123; Map&lt;String,Object&gt; map = (Map&lt;String, Object&gt;) JSONObject.parse(json); Map&lt;String, Object&gt; removeSpaceMap = removeSpace(map); jsonResult = JSON.toJSONString(removeSpaceMap); &#125; //注释掉Gson，转换默认将Integer，Long等转换成Double，内部处理看作Number /*Gson gson = new Gson(); return gson.fromJson(removeSpaceJson, type);*/ return JSONObject.parseObject(jsonResult, type);&#125;private Map&lt;String, Object&gt; removeSpace(Map&lt;String, Object&gt; map)&#123; Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet(); Map&lt;String, Object&gt; removeSpaceMap = Maps.newHashMap(); for (Map.Entry&lt;String, Object&gt; entry : entrySet)&#123; if (entry.getValue() instanceof String)&#123; removeSpaceMap.put(entry.getKey(), ((String) entry.getValue()).trim()); &#125;else &#123; removeSpaceMap.put(entry.getKey(),entry.getValue()); &#125; &#125; return removeSpaceMap;&#125; 这样就应对大多数问题了 接下来需要具体了解一下，构建过程，如上图，在HttpInputMessage 通过 converter 转换成Object对象之前做处理，这样在Controller接收的时候就可以拿到处理后的对象了","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://dayarch.top/tags/Json/"},{"name":"Springboot","slug":"Springboot","permalink":"https://dayarch.top/tags/Springboot/"}]},{"title":"Java实现文件下载并压缩成zip文件","slug":"Java实现文件下载并压缩成zip文件","date":"2018-07-04T05:48:44.000Z","updated":"2019-11-07T05:42:07.256Z","comments":true,"path":"/p/java-download-file-zip.html","link":"","permalink":"https://dayarch.top/p/java-download-file-zip.html","excerpt":"IO流，网络编程的基础背景 最近在做Springboot分布式微服务项目，用到了文件上传和下载，文件上传是既有的功能，将文件或图片上传到S3服务器上，将生成的文件URL地址和截取的文件名存储到DB中，正常我们只需要给前端URL，通过浏览器就可以实现文件的下载了，但是我们在将文件上传到S3服务器之前是将文件名称进行转码的，如：文件test.docx上传到S3服务器之后的URL地址是： http://www.S3.xxx.com/files/abRsdf.docx, 这样我们下载下来的文件文件名就是 abRsdf.docx, 显然这是不符合我们要求的，下载的文件名应该是test.docx, 并且需","text":"IO流，网络编程的基础 背景最近在做Springboot分布式微服务项目，用到了文件上传和下载，文件上传是既有的功能，将文件或图片上传到S3服务器上，将生成的文件URL地址和截取的文件名存储到DB中，正常我们只需要给前端URL，通过浏览器就可以实现文件的下载了，但是我们在将文件上传到S3服务器之前是将文件名称进行转码的，如：文件test.docx上传到S3服务器之后的URL地址是： http://www.S3.xxx.com/files/abRsdf.docx, 这样我们下载下来的文件文件名就是 abRsdf.docx, 显然这是不符合我们要求的，下载的文件名应该是test.docx, 并且需要多个文件压缩成zip文件打包下载. 所以需要在response中做一些文章，修改文件名，以及做多文件的压缩。 实现因为DB中存储了文件的URL和文件名称，大概数据形式如下： 序号 url name 1 http://www.S3.xxx.com/files/abRsdf.docx test.docx 2 http://www.S3.xxx.com/files/lsdTew.docx test1.docx 封装DB数据将DB中的url和name数据封装到类型为DownloadVO.java中，DownloadVO.java的代码很简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319import com.google.common.base.Strings;import com.viewhigh.epro.mall.vo.base.DownloadVO;import io.jsonwebtoken.lang.Collections;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.UUID;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class DownloadUtil &#123; private final static Logger LOG = LoggerFactory.getLogger(DownloadUtil.class); /** * 下载单个文件 * @param downloadVO * @param request * @param response * @throws IOException */ public static void toDownloadFile(DownloadVO downloadVO, HttpServletRequest request, HttpServletResponse response)throws IOException &#123; String savePath = request.getServletContext().getRealPath(new StringBuffer(File.separator).append(\"attachment\").append(File.separator).toString()); LOG.info(\"The Path where file will storage is &#123;&#125;\", savePath); downloadFile(getFile(downloadVO, savePath), request, response, true); &#125; /** * 在服务器生成文件 * @param downloadVO * @param savePath * @return * @throws IOException */ public static File getFile(DownloadVO downloadVO, String savePath) throws IOException&#123; InputStream inputStream = null; FileOutputStream fileOutputStream = null; try &#123; URL url = new URL(downloadVO.getUrl()); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); // 创建连接实例 conn.setConnectTimeout(3*1000); //设置超时间为3秒 conn.setRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)\"); //防止屏蔽程序抓取而返回403错误 conn.setRequestProperty(\"Charset\", \"UTF-8\"); inputStream = conn.getInputStream(); //获取连接输入流 byte[] getData = readInputStream(inputStream); //获取字节数组 File saveDir = new File(savePath); // 创建文件存放路径 if (!saveDir.exists())&#123; saveDir.mkdir(); &#125; File file = new File(savePath, downloadVO.getName()); // 在新建路径下创建对应附件名称的文件 fileOutputStream = new FileOutputStream(file); fileOutputStream.write(getData); return file; &#125; catch (MalformedURLException e) &#123; throw e; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; // 关闭流 if(fileOutputStream!=null)&#123; fileOutputStream.close(); &#125; if(inputStream!=null)&#123; inputStream.close(); &#125; &#125; &#125; /** * 下载多个文件，并压缩成zip * @param downloadVOS 待下载的文件信息 * @param request Servlet请求 * @param response Servlet相应 * @param zipName 待生成的zip文件名成 * @throws IOException * @throws ServletException */ public static void toDownloadFiles(List&lt;DownloadVO&gt; downloadVOS, HttpServletRequest request, HttpServletResponse response, String zipName)throws IOException, ServletException &#123; if (!Collections.isEmpty(downloadVOS))&#123; LOG.info(\"The total of Attachment is &#123;&#125;\" , downloadVOS.size()); String savePath = request.getServletContext().getRealPath(new StringBuffer(File.separator).append(\"attachment\").append(File.separator).toString()); LOG.info(\"The Path where file will storage is &#123;&#125;\", savePath); List&lt;File&gt; files = new ArrayList&lt;File&gt;(downloadVOS.size()); /** * 处理同名文件，如果存在，则以 a.txt, a(1).txt, a(2).txt */ Map&lt;String, Integer&gt; map = Maps.newHashMap(); for (DownloadVO downloadVO : downloadVOS)&#123; String fileName = downloadVO.getName(); if (map.containsKey(fileName))&#123; map.put(fileName, map.get(fileName) + 1); &#125;else &#123; map.put(fileName, 0); &#125; if (map.get(fileName) != 0)&#123; int position = fileName.lastIndexOf(\".\"); downloadVO.setName(new StringBuffer(fileName.substring(0, position)).append(\"(\").append(map.get(fileName)).append(\")\").append(fileName.substring(position, fileName.length())).toString()); &#125; File file = getFile(downloadVO, savePath); files.add(file); &#125; // 生成zip文件 File fileZip = generateZipFile(files, savePath, zipName); // 下载zip文件 downloadFile(fileZip, request, response, true); // 删除源文件 deleteSourceFile(files); &#125; &#125; private static void deleteSourceFile(List&lt;File&gt; files) &#123; if (!Collections.isEmpty(files))&#123; files.forEach(File::delete); &#125; &#125; /** * 从输入流中获取字节数组，根据 available 获取一次性读取的字节数量 * @param inputStream * @return * @throws IOException */ public static byte[] readInputStream(InputStream inputStream) throws IOException &#123; int count = 0; while (count == 0) &#123; count = inputStream.available(); &#125; byte[] buffer = new byte[count]; int len = 0; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while((len = inputStream.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; LOG.info(\"current file length is &#123;&#125;\", len); bos.close(); return bos.toByteArray(); &#125; /** * 生成zip文件 * @param files * @param savePath * @param zipName * @return */ public static File generateZipFile(List&lt;File&gt; files, String savePath, String zipName) throws IOException, ServletException &#123; String zipFileName = zipName; if (Strings.isNullOrEmpty(zipFileName))&#123; zipFileName = UUID.randomUUID().toString(); &#125; zipFileName = zipFileName + \".zip\"; File fileZip = new File(savePath, zipFileName ); FileOutputStream fileOutputStream = null; // 文件输出流 ZipOutputStream zipOutputStream = null; // 压缩流 try &#123; fileOutputStream = new FileOutputStream(fileZip); zipOutputStream = new ZipOutputStream(fileOutputStream); zipFile(files, zipOutputStream); &#125; catch (FileNotFoundException e) &#123; throw e; &#125;finally &#123; if (zipOutputStream != null)&#123; zipOutputStream.close(); &#125; if (fileOutputStream != null)&#123; fileOutputStream.close(); &#125; &#125; return fileZip; &#125; /** * 压缩文件 * @param files * @param outputStream * @throws IOException * @throws ServletException */ public static void zipFile(List&lt;File&gt; files, ZipOutputStream outputStream) throws IOException, ServletException &#123; try &#123; int size = files.size(); // 压缩列表中的文件 for (int i = 0; i &lt; size; i++) &#123; File file = (File) files.get(i); zipFile(file, outputStream); &#125; &#125; catch (IOException e) &#123; throw e; &#125; &#125; public static void zipFile(File inputFile, ZipOutputStream outputstream) throws IOException, ServletException &#123; FileInputStream inStream = null; BufferedInputStream bInStream = null; try &#123; if (inputFile.exists()) &#123; if (inputFile.isFile()) &#123; inStream = new FileInputStream(inputFile); bInStream = new BufferedInputStream(inStream); ZipEntry entry = new ZipEntry(inputFile.getName()); outputstream.putNextEntry(entry); final int MAX_BYTE = 10 * 1024 * 1024; // 最大的流为10M long streamTotal = 0; // 接受流的容量 int streamNum = 0; // 流需要分开的数量 int leaveByte = 0; // 文件剩下的字符数 byte[] inOutbyte; // byte数组接受文件的数据 streamTotal = bInStream.available(); // 通过available方法取得流的最大字符数 streamNum = (int) Math.floor(streamTotal / MAX_BYTE); // 取得流文件需要分开的数量 leaveByte = (int) streamTotal % MAX_BYTE; // 分开文件之后,剩余的数量 if (streamNum &gt; 0) &#123; for (int j = 0; j &lt; streamNum; ++j) &#123; inOutbyte = new byte[MAX_BYTE]; // 读入流,保存在byte数组 bInStream.read(inOutbyte, 0, MAX_BYTE); outputstream.write(inOutbyte, 0, MAX_BYTE); // 写出流 &#125; &#125; // 写出剩下的流数据 inOutbyte = new byte[leaveByte]; bInStream.read(inOutbyte, 0, leaveByte); outputstream.write(inOutbyte); outputstream.closeEntry(); // Closes the current ZIP entry // and positions the stream for // writing the next entry &#125; &#125; else &#123; throw new ServletException(\"文件不存在！\"); &#125; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; if (bInStream != null)&#123; bInStream.close(); // 关闭 &#125; if (inStream != null)&#123; inStream.close(); &#125; &#125; &#125; /** * 下载zip文件 * @param file * @param response * @param isDelete */ public static void downloadFile(File file,HttpServletRequest request , HttpServletResponse response,boolean isDelete) throws IOException &#123; BufferedInputStream bufferedInputStream = null; OutputStream outputStream = null; try &#123; bufferedInputStream = new BufferedInputStream(new FileInputStream(file.getPath())); byte[] buffer = new byte[bufferedInputStream.available()]; bufferedInputStream.read(buffer); response.reset(); // 清空response outputStream = new BufferedOutputStream(response.getOutputStream()); response.setContentType(\"application/octet-stream\"); LOG.info(\"fileName:\" + file.getName()); String userAgent = request.getHeader(\"User-Agent\"); String formFileName = file.getName(); // 针对IE或者以IE为内核的浏览器： if (userAgent.contains(\"MSIE\") || userAgent.contains(\"Trident\") || userAgent.contains(\"Edge\")) &#123; formFileName = java.net.URLEncoder.encode(formFileName, \"UTF-8\"); &#125; else &#123; // 非IE浏览器的处理： formFileName = new String(formFileName.getBytes(\"UTF-8\"), \"ISO-8859-1\"); &#125; response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + formFileName); outputStream.write(buffer); outputStream.flush(); //是否将生成的服务器端文件删除 if(isDelete)&#123; file.delete(); &#125; &#125; catch (IOException ex) &#123; throw ex; &#125;finally &#123; if (bufferedInputStream != null)&#123; bufferedInputStream.close(); &#125; if (outputStream != null)&#123; outputStream.close(); &#125; &#125; &#125;&#125; servlet路径问题上面的代码将文件下载到了servlet的realPath中，顺便总结一下各种路径的差别 请求路径的URL http://localhost:8080/electest/system/elecMenuAction_menuHome.do 12345678System.out.println(\"contentType------\"+request.getContentType());System.out.println(\"requestcontextPath------\"+request.getContextPath());System.out.println(\"servletPath----\"+request.getServletPath());System.out.println(\"requestRealPath\"+request.getRealPath(\"\"));System.out.println(\"realPath------\"+request.getServletContext().getRealPath(\"\"));System.out.println(\"requestURI------\"+request.getRequestURI());System.out.println(\"requestURL-------\"+request.getRequestURL());System.out.println(\"contextPath-------\"+request.getServletContext().getContextPath()); 打印结果 12345678contentType------application/x-www-form-urlencodedrequestcontextPath------/electestservletPath----/system/elecMenuAction_menuHome.dorequestRealPathD:\\tomcate\\apache-tomcat-7.0.63-windows-x64\\apache-tomcat-7.0.63\\webapps\\electestrealPath------D:\\tomcate\\apache-tomcat-7.0.63-windows-x64\\apache-tomcat-7.0.63\\webapps\\electestrequestURI------/electest/system/elecMenuAction_menuHome.dorequestURL-------http://localhost:8080/electest/system/elecMenuAction_menuHome.docontextPath---------/electest 方法和代码的注释写的已经很详细了，具体的实现就不再详述了","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://dayarch.top/tags/IO/"}]},{"title":"Springboot Json格式数据不返回null值属性","slug":"Springboot-Json格式数据不返回null值属性","date":"2018-07-02T05:41:37.000Z","updated":"2019-11-07T06:21:40.625Z","comments":true,"path":"/p/spring-boot-json-return-non-null.html","link":"","permalink":"https://dayarch.top/p/spring-boot-json-return-non-null.html","excerpt":"Spring ResponseBody without null field通常Restful返回的Json格式数据，里面包含很多为空值null的字段，我们没必要将这些字段返回给前端，应该给出更多的有效字段，所以我们需要在Converter Message的时候将这些null值字段给过滤掉 方法一 添加 @JsonInclude(JsonInclude.Include.NON_NULL) 注解 该方法很简单，但是我们有太多的返回类型，一一添加也是很大的工作量，所以我们需要在转换的源头进行控制 方法二 实现 WebMvcConfigurer 接口，添加 @EnableWebMvc 和 @Co","text":"Spring ResponseBody without null field 通常Restful返回的Json格式数据，里面包含很多为空值null的字段，我们没必要将这些字段返回给前端，应该给出更多的有效字段，所以我们需要在Converter Message的时候将这些null值字段给过滤掉 方法一添加 @JsonInclude(JsonInclude.Include.NON_NULL) 注解该方法很简单，但是我们有太多的返回类型，一一添加也是很大的工作量，所以我们需要在转换的源头进行控制 方法二实现 WebMvcConfigurer 接口，添加 @EnableWebMvc 和 @Configuration 注解，然后重写 MappingJackson2HttpMessageConverter 中 getObjectMapper() 方法 123456789101112131415161718@EnableWebMvc@Configurationpublic class WebConfig implements WebMvcConfigurer&#123; //... 省略重写的其他方法 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super.configureMessageConverters(converters); //对应无法直接返回String类型 converters.add(0, new MappingJackson2HttpMessageConverter()&#123; @Override public ObjectMapper getObjectMapper() &#123; super.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL); return super.getObjectMapper(); &#125; &#125;); &#125;&#125; 这样所有的null值都会被过滤掉，注意这里使用的是 JsonInclude.Include.NON_NULL， Json中的某个集合如果为空还是会返回空数组，我们希望把这样的数据也过滤掉，只需要将JsonInclude.Include.NON_NULL 修改为 JsonInclude.Include.NON_EMPTY 这样就好了，返回给前端清晰有效的数据.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"},{"name":"Json","slug":"Json","permalink":"https://dayarch.top/tags/Json/"}]},{"title":"使用 Docker 部署 Spring Boot","slug":"使用-Docker-部署-Spring-Boot","date":"2018-04-09T07:43:42.000Z","updated":"2019-11-01T08:58:35.964Z","comments":true,"path":"/p/docker-deploy-spring-boot.html","link":"","permalink":"https://dayarch.top/p/docker-deploy-spring-boot.html","excerpt":"前言 最近陆续在通过SpringBoot搭建项目，往里面逐渐添加功能，项目地址SpringBootLearning, 当总结Docker部署SpringBoot的时候，我遇到了一些问题，加以总结 问题汇总 文章主要参考Spring Boot 2.0(四)：使用 Docker 部署 Spring Boot, 因为我是已有的SpringBoot项目，不是简单的SpringBoot项目，所以使用Docker部署SpringBoot的时候遇到了一些问题，现总结如下： 1. mvn package 打包命令不能生成jar包到target目录下 因为Docker会用到jar包，所以在用Doc","text":"前言最近陆续在通过SpringBoot搭建项目，往里面逐渐添加功能，项目地址SpringBootLearning, 当总结Docker部署SpringBoot的时候，我遇到了一些问题，加以总结 问题汇总文章主要参考Spring Boot 2.0(四)：使用 Docker 部署 Spring Boot, 因为我是已有的SpringBoot项目，不是简单的SpringBoot项目，所以使用Docker部署SpringBoot的时候遇到了一些问题，现总结如下： mvn package 打包命令不能生成jar包到target目录下因为Docker会用到jar包，所以在用Docker部署之前，先用Maven来进行打包，保证正确，但是使用命令并不能生成jar包，发现打包中打了我的测试用例类，测试用例有持续执行操作，当然其他持续操作也有可能出现这个问题，所以我在pom.xml中加入了plugin来过滤掉Test case.123456789101112&lt;properties&gt;&lt;!--mvn 打包时省略test用例--&gt;&lt;skipTests&gt;true&lt;/skipTests&gt;&lt;/properties&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;$&#123;skipTests&#125;&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 通过Maven的docker插件来部署，遇到了两个问题： [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: connect -&gt; [Help 1] [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target -&gt; [Help 1] 通过查找资料在pom.xml中maven的docker插件中添加了如下内容： 12&lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt;&lt;dockerCertPath&gt;D:/Users/fraser.yu/.docker/machine/machines/default&lt;/dockerCertPath&gt;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://dayarch.top/tags/Spring-Boot/"}]},{"title":"Docker学习(四)——容器","slug":"Docker学习-四-——容器","date":"2017-11-07T02:45:33.000Z","updated":"2019-11-07T05:21:11.715Z","comments":true,"path":"/p/docker-container.html","link":"","permalink":"https://dayarch.top/p/docker-container.html","excerpt":"容器是镜像的一个运行实例，所不同的是，它有额外的可写文件层上一篇文章Docker学习(三)——镜像介绍了Docker的镜像， 包括 获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像，接下来逐步拆分讲解Docker的核心内容之一——容器. Docker的容器十分轻量级，用户可以随时创建或删除容器 创建容器 单纯创建容器 语法: docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 1. 为本地Ubuntu镜像创建容器 1 $ docker create -it ubuntu","text":"容器是镜像的一个运行实例，所不同的是，它有额外的可写文件层 上一篇文章Docker学习(三)——镜像介绍了Docker的镜像，包括 获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像，接下来逐步拆分讲解Docker的核心内容之一——容器. Docker的容器十分轻量级，用户可以随时创建或删除容器 创建容器单纯创建容器语法: docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 为本地Ubuntu镜像创建容器 1$ docker create -it ubuntu:latest 查看本地启动的容器（注意观察容器的状态是Created,换句话说这个容器是终止状态，没有运行） 1$ docker ps -a 容器信息解释 CONTAINER ID： 容器ID IMAGE: 容器所运行镜像的名称 COMMAND: 运行容器时的命令 CREATED: 容器的创建时间 STATUS: 容器当前状态 详细信息请使用下面命令自行了解 1$ docker create --help 启动容器方法一语法: docker start [OPTIONS] CONTAINER [CONTAINER…] 查看刚刚创建的容器ID，通过start命令来启动 1$ docker start 93f 重新查看容器信息（注意当前容器状态是Exited，即容器运行终止） 1$ docker ps -a 详细信息请使用下面命令自行了解 1$ docker start --help 启动容器方法二创建容器和启动容器有一种更方便的命令来完成上面create 和 start 的操作.语法: docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 为本地Ubuntu镜像在此创建容器并启动1$ docker run -it ubuntu:latest 详细信息请使用下面命令自行了解（和create是一样的）1$ docker run --help 退出容器输入exit或者Ctrl+D来退出容器，对于所创建的bash容器，当使用exit命令退出之后，该容器就出于终止状态了，这是因为对于Docker容器来说，当运行的应用（此处以bash为例）退出后，容器也就没有继续运行的必要了. 守护态运行更多的时候，需要让Docker容器在后台以守护态（Daemonized）形式运行，用户可以通过添加-d option来实现. 运行容器，每隔一秒打印出hello world1$ docker run -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 获取容器的输出信息1$ docker logs ce90 详细信息请使用下面命令自行了解1$ docker logs --help 终止容器语法: docker stop [OPTIONS] CONTAINER [CONTAINER…]执行上述命令后，终止容器分为两个步骤，先向容器发送一个SIGTERM信号，10秒钟后会再次发送一个SIGKILL信号终止容器 终止上文中启动的容器1$ docker stop ce90 查看终止的容器1$ docker ps -a -q 启动容器1$ docker start ce90 重启容器（将运行中的容器终止，并重新启动）1$ docker restart ce90 详细信息请使用下面命令自行了解1$ docker stop --help 进入容器上文中提到使用-d参数可以使Docker成守护态运行，但是用户无法看到容器的内部信息，而很多时候我们需要进入到容器内进行操作，Docker也提供了集中方法来实现这个功能 docker attach语法: docker attach [OPTIONS] CONTAINER, 运行该命令时，该容器必须是运行状态（UP）,如果没有运行，使用start命令，attach命令可以不用指定命令参数，默认执行上次run的命令参数/bin/bash, 但是当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示，当某个窗口因为某一个命令阻塞时，其他窗口就无法执行其他操作了，所以不建议使用. 进入刚刚以守护态启动的容器1$ docker attach 9d89 详细信息请使用下面命令自行了解1$ docker attach --help docker exec语法: docker exec [OPTIONS] CONTAINER COMMAND [ARG…], 该命令至少需要一个命令参数 进入刚刚一守护态启动的容器1$ docker exec -it 9d89 /bin/bash 详细信息请使用下面命令自行了解1$ docker exec --help 删除容器语法: docker rm [OPTIONS] CONTAINER [CONTAINER…] 删除处于 终止状态 的容器，同时可以输入多个容器ID批量删除容器 删除处于终止状态的容器1$ docker rm 9d89 详细信息请使用下面命令自行了解1$ docker rm --help 导入和导出容器导出容器导出容器是指导出一个已经创建的容器到一个文件，不管该容器是否是处于运行状态语法: docker export [OPTIONS] CONTAINER 导出9d89容器到ubuntu_export.tar文件1$ docker export 9d89 &gt; ubuntu_export.tar 详细信息请使用下面命令自行了解1$ docker export --help 导入容器导出的文件又可以使用docker import 命令导入，成为镜像 导入上文中的ubuntu_export.tar文件成为镜像1$ cat ubuntu_export.tar | docker import - test/ubuntu:v1.0 详细信息请使用下面命令自行了解1$ docker import --help 我们在上一节中讲过载入镜像 docker load 命令导入镜像文件到本地镜像库，这节通过 docker import 命令来导入一个容器快照到本地镜像库，但是容器快照文件将丢弃所有历史数据和元数据（仅仅保存容器当前的快照状态）， 而镜像文件形式保存完整记录，体积要大，此外，容器快照导入标签可以重新指定标签元数据等，向上文中的test/ubuntu:v1.0","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"Docker学习(三)——镜像","slug":"Docker学习-三-——镜像","date":"2017-11-06T06:50:32.000Z","updated":"2019-11-07T05:19:56.130Z","comments":true,"path":"/p/docker-image.html","link":"","permalink":"https://dayarch.top/p/docker-image.html","excerpt":"镜像是Docker运行容器的前提上一篇文章Docker学习(二)——Docker架构讲述了Docker的基本架构，接下来逐步拆分讲解Docker的核心内容之一——镜像. Docker 运行容器前需要本地存有对应的镜像，如果镜像不存在，Docker会尝试先从默认（Docker Hub公共注册服务器中的仓库）镜像仓库下载，用户也可以配置使用自己的仓库. 本章内容主要有：获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像. 看着内容很多，其实熟悉Git的朋友，分分钟就可以理解上面的这些内容， 操作方式都是相通的, 话不多说，看命令说话. 获取镜像 语法: docker","text":"镜像是Docker运行容器的前提 上一篇文章Docker学习(二)——Docker架构讲述了Docker的基本架构，接下来逐步拆分讲解Docker的核心内容之一——镜像. Docker 运行容器前需要本地存有对应的镜像，如果镜像不存在，Docker会尝试先从默认（Docker Hub公共注册服务器中的仓库）镜像仓库下载，用户也可以配置使用自己的仓库. 本章内容主要有：获取镜像，查看镜像信息，搜寻镜像，删除镜像，创建镜像，存储和载入镜像，上传镜像. 看着内容很多，其实熟悉Git的朋友，分分钟就可以理解上面的这些内容， 操作方式都是相通的, 话不多说，看命令说话. 获取镜像语法: docker pull NAME[:TAG] 从Docker Hub的Ubuntu仓库下载最新版本Ubuntu镜像(如果不指定tag，默认tag是latest,即下载最新版本)1$ docker pull ubuntu 从Docker Hub的Ubuntu仓库下载指定版本Ubuntu镜像1$ docker pull ubuntu:16.04 我们前面讲过，默认是从Docker Hub的Registry中下载，所以以上的命令相当于12$ docker pull registry.hub.docker.com/ubuntu:latest$ docker pull registry.hub.docker.com/ubuntu:16.04 从其他注册服务器下载Docker镜像（如DockerPool社区，需要指定完整的注册服务器地址）1$ docker pull dl.dockerpool.com:5000/ubuntu 详细信息请使用下面命令自行了解1$ docker pull --help 查看镜像信息语法：docker images通过该命令可以查看本地所有的镜像，说明一下执行该命令之后每列的含义 REPOSITORY: 来自于哪个仓库，同样是如果没有指定注册服务器的地址，那默认就是Docker Hub的仓库 TAG：镜像的标签信息，比如latest、16.04 IMAGE ID：镜像的唯一ID标识 CREATED:（镜像拉取到本地或者在本地创建镜像的时间） VIRTUAL SIZE:镜像的大小 repository是不同的仓库，tag是标记同一个仓库的不同的镜像 Tag打标记有时候镜像需要一个自己需要的tag标识，这会我们需要用到docker 的tag命令来方便我们管理镜像语法：docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] 给镜像打上自己的标签1$ docker tag dl.dockerpool.com:5000/ubuntu:latest ubuntu:20171106_ubuntu 详细信息请使用下面命令自行了解1$ docker tag --help 执行完以上命令再次查看[docker images]本地所有镜像，发现我们打了标记的镜像和被打标记的镜像的镜像ID竟然一样.这说明新打上标签的镜像只是指向了同一个镜像文件，只是别名不同，标签在这里就起到了引用或快捷方式的作用. 查看镜像的详细信息语法：docker inspect [OPTIONS] NAME|ID [NAME|ID]执行[docker inspect]命令会得到一个Json格式的信息，如果我们需要关注某一个部分，可以使用[-f]参数来使用，镜像ID使用前几个字符就可以，不用输入全部 查看刚刚打了标记的Ubuntu镜像的详细信息(镜像ID因人而异)1$ docker inspect 5506de2b643b 查看镜像指定的详细信息1$ docker inspect -f &#123;&#123;\".Architecture\"&#125;&#125; 5506 详细信息请使用下面命令自行了解1$ docker inspect --help 搜寻镜像语法：docker search [OPTIONS] TERM 搜寻mysql镜像1$ docker search mysql 说明一下执行该命令之后每列的含义 NAME: 镜像名称 DESCRIPTION：竞相描述 STARTS：镜像星级（代表受欢迎程度） OFFICIAL:是否为官方创建和维护的 AUTOMATED:是否自动创建（自动创建的资源允许用户验证镜像内容以及来源） 删除镜像语法：docker rmi [OPTIONS] IMAGE [IMAGE…], IMAGE可以是镜像标签或者镜像ID，rmi其实就是remove image的缩写. 删除镜像这里的规矩稍稍多一点但是遵循以下几个原则，不用背诵以下，会在后面的实践中逐步来验证 当本地一个镜像有多个标签时，删除某一个标签不影响其他镜像 当本地一个镜像只有一个标签时，删除该标签会彻底删除该镜像 当通过镜像ID删除镜像的时候，会逐个删除指向该镜像的标签，最终删除镜像. 当有该镜像创建的容器存在时，镜像不会被删除，docker会更换该镜像ID，并且镜像没有名字. 当有该镜像创建的容器存在时,可以使用[-f] 参数来强制删除镜像（不建议这样做） 当有该镜像创建的容器存在时,应遵循先删除容器，然后再删除镜像 删除mysql镜像1$ docker rmi mysql:latest 创建镜像创建镜像有三种方式： 基于已有镜像的容器创建 基于本地模板导入 基于Dockerfile创建（最常用，此处先了解整个过程，后续章节经常使用的时候自然就会了） 基于已有镜像的容器创建新镜像语法：docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 启动镜像（通过容器运行Ubuntu16.04, 并且进入bash环境），运行后通过[docker ps -a]来查看容器信息，当下主要关注容器ID1$ docker run -it ubuntu:1604 /bin/bash 创建test文件并且退出容器12touch testexit 通过运行的容器创建新的镜像,执行成功后会返回新创建的镜像ID信息1$ docker commit -m \"added a new file\" -a \"fraser\" a925cb test:latest 详细信息请使用下面命令自行了解[“-m”:提交信息,”-a”:作者信息,”-p”:提交时暂停容器运行]1$ docker commit --help 基于本地模板导入可以直接从一个操作系统模板文件导入一个镜像，推荐OpenVZ提供的模板来创建(个人觉得这个应用的不是很多，了解即可) 通过模板文件导入1$ sudo cat ubuntu-16.04-x86_64.tar.gz | docker import - ubuntu:1604 基于Dockerfile创建Dockerfile需要讲解的内容很多，包括里面各个指令的应用，我们会单独拿出一个章节来讲解Dockerfile. 存出和载入镜像存出镜像语法：docker save [OPTIONS] IMAGE [IMAGE…] , 存出镜像到本地文件 存出本地的ubuntu:1604镜像为ubuntu_1604.tar1$ docker save -o ubuntu_1604.tar ubuntu:1604 详细信息请使用下面命令自行了解1$ docker save --help 载入镜像语法：docker load [OPTIONS] , 从存出的本地文件中再导入到本地镜像库 从ubuntu_1604.tar文件导入镜像到到本地镜像列表123$ docker load --input ubuntu_1604.tar或$ docker load &lt; ubuntu_1604.tar 上传镜像语法：docker push [OPTIONS] NAME[:TAG]用户在DockerHub上完成注册之后，即可上传自制的镜像，但是需要打上带有user的标签（注册的用户名） 将本地hello-world镜像加上标签1$ docker tag hello-world:latest fraseryu/helloworld:latest 查看本地镜像列表可以看到打上标签的镜像1$ docker images 登录完成DockerHub授权认证，输入刚刚在DockerHub上注册的用户名和密码1$ docker login push本地订制的镜像到DockerHub1$ docker push fraseryu/helloworld:latest 登录DockerHub看到我们的镜像已经push成功","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"Docker学习(二)——Docker架构","slug":"Docker学习-二-——Docker架构","date":"2017-11-03T05:53:16.000Z","updated":"2019-11-07T05:20:30.846Z","comments":true,"path":"/p/docker-architect.html","link":"","permalink":"https://dayarch.top/p/docker-architect.html","excerpt":"像面向对象编程一样理解Docker镜像与容器上一篇文章Docker学习(一)——Docker安装讲述了在Ubuntu下安装，安装完了要了解一下Docker架构与一些名词解释，这样对Docker后续的操作会有更好的理解. Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器, 也就是说我们通过Docker客户端来完成对镜像以及容器的一系列操作 对于上面的图片出现的一系列名词可以这样理解： 名词术语解释Docker 镜像(Images)Docker 镜像是用于创建 Docker 容器的模板Docker 容器(Container)容器是独立运行的一","text":"像面向对象编程一样理解Docker镜像与容器 上一篇文章Docker学习(一)——Docker安装讲述了在Ubuntu下安装，安装完了要了解一下Docker架构与一些名词解释，这样对Docker后续的操作会有更好的理解. Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器, 也就是说我们通过Docker客户端来完成对镜像以及容器的一系列操作 对于上面的图片出现的一系列名词可以这样理解： 名词术语 解释 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板 Docker 容器(Container) 容器是独立运行的一个或一组应用 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器 Docker 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库，Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用 关于Registry我要多说一句，应该把它理解成管理仓库的仓库，这个仓库中有Ubuntu仓库，Apache仓库，Nginx仓库等， 每个小仓库还都管理不同version的镜像，如Ubuntu1604,Ubuntu1404等. 文章开头提到像面向对象编程一样理解Docker镜像与容器，看如下表格，一个类可以创建多个对象（除了单例模式），也就是说一个镜像可以有多个容器来运行. Docker 面向对象 镜像 类 容器 对象 充分理解一下这篇架构图以及名词解释，就要进入接下来的Docker之旅了. 参考 Docker架构 几张图帮你理解 docker 基本原理及快速入门","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"Docker学习(一)——Docker安装","slug":"Docker学习-一-——Docker安装","date":"2017-11-01T06:04:46.000Z","updated":"2019-11-07T05:18:34.850Z","comments":true,"path":"/p/docker-install.html","link":"","permalink":"https://dayarch.top/p/docker-install.html","excerpt":"Docker, incredible virtual machine什么是Docker 按照惯例，介绍一些历史，说明一下来龙去脉，至少知道它是怎么来的，又为什么会来，能干什么 1. Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护 2. Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHE","text":"Docker, incredible virtual machine 什么是Docker按照惯例，介绍一些历史，说明一下来龙去脉，至少知道它是怎么来的，又为什么会来，能干什么 Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护 Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 Docker与传统虚拟机的对比通过两张图，来理解一下Docker与传统虚拟机的对比，通过下面两张图能看出来Docker节省了哪些资源即可,其他的好处在后面的学习过程中陆续介绍 Docker目前分为两个版本 Docker Enterprise Edition (Docker EE) 专为企业开发和IT团队设计，用于在大规模生产中构建，运送和运行关键业务应用程序Docker EE集成，认证和支持，为企业提供业界最安全的容器平台，使所有应用程序现代化 Docker Community Edition (Docker CE) 是开发人员和小团队的理想选择，希望开始使用Docker并尝试基于容器的应用程序Docker CE可在许多平台上使用，从桌面到云到服务器 环境Docker系列学习主要通过 VirtualBox 在 Ubuntu16.04 中完成安装以及后续进阶课程的学习, Docker版本为DockerCE 安装安装Ubuntu16.04VirtualBox 安装Ubuntu1604请参考在virtualbox下安装ubuntu server 16.04 安装docker按照Docker官网Get Docker CE for Ubuntu描述安装DockerCE 检查安装条件Docker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 Ubuntu 版本是否支持 Docker。通过 uname -r 命令查看你当前的内核版本 1$ uname -r 卸载旧的版本老的Docker版本我们叫做docker或docker-engine, 如果之前安装过，这里需要先卸载, Docker CE package现在叫做docker-ce 1$ sudo apt-get remove docker docker-engine docker.io 搭建Docker仓库首次在宿主机上安装DockerCE，需要搭建Docker repository,搭建完成后，可以通过repository安装或更新Docker. 更新apt package1$ sudo apt-get update 允许apt用https方式访问Docker仓库（命令太长可以用 \\ 符号换行）12345$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 添加Docker的官方GPG密钥1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 验证fingerprint 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88, 用后八位字符即可 1$ sudo apt-key fingerprint 0EBFCD88 设置稳定版Repository1234$ sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 安装Docker CE 更新apt索引1$ sudo apt-get update 安装最新版本的Docker CE1$ sudo apt-get install docker-ce 生产环境指定Docker版本生产环境为了稳定性会选择指定版本，而不是Dokcer的最新版本，查看可用版本：123$ apt-cache madison docker-cedocker-ce | 17.09.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages 安装指定Docker CE 版本1$ sudo apt-get install docker-ce=&lt;VERSION&gt; 确认Docker CE 是否安装成功 仔细阅读docker run hello-world的输出内容，对于理解docker的工作原理有帮助 12$ sudo docker run hello-world$ sudo docker version 启动Docker1$ systemctl start docker 重新启动Docker1$ systemctl restart docker Docker命令去掉sudo默认情况下，我们每次敲docker命令都需要sudo权限，下面的方法可以省去sudo方便很多. 创建docker组1$ sudo groupadd docker 添加当前用户到docker组1$ sudo usermod -aG docker $USER 登出，重新登录shell 验证docker命令是否可以运行（注意没有sudo）1$ docker run hello-world","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://dayarch.top/categories/Coding/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dayarch.top/tags/Docker/"}]},{"title":"指数基金交易会产生哪些费用","slug":"指数基金交易会产生哪些费用","date":"2017-06-09T01:58:14.000Z","updated":"2019-11-01T09:02:37.016Z","comments":true,"path":"/p/investment-index-fee.html","link":"","permalink":"https://dayarch.top/p/investment-index-fee.html","excerpt":"引言 在购买指数基金时，我们会看到让人眼花缭乱的各种费用，既然理财了，就要知道： 1. 我们为了购买这些基金都发生了那些费用？ 2. 怎样购买方式能节省这些费用？ 了解这些对于我们财富增长将会起到重要作用， 以下文章是借鉴前辈”银行螺丝钉” 的文章加以总结. 钱都花到哪里去了 申购费、赎回费、交易佣金、印花税、服务费、托管费、管理费……, 在了解这么对费用之前，我们需要知道指数基金按照购买方式可以分为： 1. 场内基金 场内基金指的是上市（股市）交易的基金，只能用证券帐户购买，主要是封闭式基金和上市型开放式基金（LOF基金） 2. 场外基金","text":"引言在购买指数基金时，我们会看到让人眼花缭乱的各种费用，既然理财了，就要知道： 我们为了购买这些基金都发生了那些费用？ 怎样购买方式能节省这些费用？ 了解这些对于我们财富增长将会起到重要作用， 以下文章是借鉴前辈”银行螺丝钉” 的文章加以总结. 钱都花到哪里去了申购费、赎回费、交易佣金、印花税、服务费、托管费、管理费……, 在了解这么对费用之前，我们需要知道指数基金按照购买方式可以分为： 场内基金 场内基金指的是上市（股市）交易的基金，只能用证券帐户购买，主要是封闭式基金和上市型开放式基金（LOF基金） 场外基金 场外基金不上市交易，是只能在指定的网点（银行、基金公司、证券公司等）申购的基金，如一般的开放式基金 场内基金，例如ETF基金，它既可以申购赎回，又可以买卖。申购赎回需要几十万起，买卖则是100股起，所以我们一般是通过买卖获取ETF基金。场外基金一般只有申购赎回，大部分是1000元起，我们一般通过申赎获取场外基金，先做一个表格来说明这些费用都发生在哪些基金上 基金\\费用 申购费 赎回费 交易佣金 印花税 服务费 托管费 管理费 场内基金 无 无 有 有 无 有 有 场外基金 有 有 无 无 有/无 有 有 费用详解 申购费和赎回费 场内基金也可以申购，我在上面表格中没有写, 因为例如ETF基金申购一般是几十万起，我们一般不通过申购这一途径获取ETF基金，而是通过场内买卖ETF来获取。买卖跟股票一样，100股起买； 场外基金，一般都是申购获得。交易日下午3点前申购，按照当天收盘的基金净值申购；3点后，按照下一交易日收盘基金净值申购。 以我开始投资场外基金的平台南方基金来看下图： 如果频繁操作购买，1-1.5%的申购与赎回费用还是非常高的，购买1万元就要100到150元的成本，购买指数基金我们一般都会持有至少三年以上，现在好多基金平台都推出申购零手续费，如果持有超过两年也免掉赎回费用. 交易佣金(买卖佣金) 交易佣金针对场内基金来的。上面说过，场内基金可以通过买卖来获得，跟股票一样。需要去券商开股票账户，目前基本所有券商开户都是免费的。交易费率跟股票是一样的，部分券商可以商议。不确定的话可以联系自己的券商客户经理确定，没有任何做广告的嫌疑，我现在用华泰证券，费率还是很合适的. 印花税 印花税也是针对场内的品种来说的，股票买卖交易是需要交印花税的。印花税是股票交易非常重要的一个税种，甚至可以起到调节股市牛熊的作用。印花税是在买卖股票交割的时候券商就代为扣收了，买卖完股票后第二天查下交割单就可以知道扣了多少印花税。目前股票交易的印花税是交易额的千分之一，单边收取，即买股票不收，卖股票收。对场内基金来说，目前不需要交印花税 销售服务费 我们经常能看到一些基金公司宣传某只指数基金申赎费用全免。这里免申赎费用的基金指的是C类基金。是针对场外基金来说的。一般的场外指数基金，是收取申购赎回费，不管买卖频率如何。这样对于一些频繁操作场外基金的投资者，交易成本是非常高的。C类基金比较特殊。它不收取申购费用，一般持有一个月以上赎回也不收取赎回费用。但会固定收取一定比例的销售服务费，一般是0.4-0.6%。这样就把交易成本固定下来了, 依旧以南方基金举例 不过我投资指数基金一般是在低估值的时候分批买，高估值的时候分批卖，一般需要持有一年或多年以上。这种情况下挑选申购费一折的平台申购场外基金，交易成本可以控制在千一左右，持有两年以上也没有了赎回费；C类基金则需要固定交千四到千六，如果不是频繁申赎，不是特别好的选择 托管费管理费 上面说的费用都是在基金交易相关的费用。实际上基金在运营的时候还会产生管理费和托管费。这两项费用会直接从基金净值中扣。管理费就是基金公司的一个非常重要的利润来源。主动型基金一般会收取基金规模的1.5%作为管理费。例如管理10个亿的资产的股票基金，一年会收取1500万的管理费。指数基金作为被动型基金，管理费率一般低一些。国内指数基金的平均管理费率在0.83%左右。部分规模较大、运行时间较长的基金，管理费率会降到0.5%。这些可以在基金的公告中查看。托管费是交给基金的托管方的。基金的庞大资产，并不是直接存放在基金公司，一般会在第三方托管方，例如某家大型银行。像我们熟知的50ETF（510050），它的托管方就是工商银行。国内指数基金的托管费率平均在0.17%左右，低的可以做到0.15% 总结按照上面的表格以及费用详细做出如下总结： 总体来说，投资指数基金，无论场内还是场外，管理费和托管费都要交的，会从基金净值中扣（我们无能为力） 场内基金会收取交易佣金和印花税。目前场内基金印花税下调到了0，交易佣金不同券商不一样 场外基金如果不是C类基金，会收取申购费，赎回费持有超两年可免；C类基金适合频繁申赎的朋友，会收取约0.4-0.6%的销售服务费。定投的话选普通的场外基金就好，不用选C类（因为我们会持有这个基金至少3年以上） 我们经常看到某一只股票上标注一个“融”字，那这个字的含义是什么呢？ 这个词距离资金量还不是很大的投资者来说其实是一个比较遥远的，因为能做到融资融券不同的券商对投资者还有有很高的规格限制的，不过这个“融”字的内在含义还是非常有意思的. 融——融资融券融资融券是券商开拓的业务，都是发生在券商和投资者之间，和上市公司本生没关系。 融：就是扩大，开拓的意思 融资：其实就是借钱 融券：就是借股票 借钱我们好理解，但是为什么要借股票呢？我们知道中国股票市场只能做多，就是你买了股票只能等待上涨获利，如果股票下跌就没法获利了，而融券就提供了一种做空的工具。 举例说明 融资：投资者看好一只股票在未来会有上升趋势，苦于手中没有银两来购买股票，于是乎打算向券商借钱来购买该股票，等到指定期限将钱还给券商同时还要支付一些利息（钱不能是白借的啊） 张三看好股票A在未来会有上升趋势，手中却没有银两，张三已经具备了融资的资格（不同的券商标准不一样，请咨询具体的券商经理），于是乎向券商借了1万元钱以每股10元的价格购买了1000股，券商协定的还款日期到了，此时股票A的股价已经涨到了20元，这会我还是还券商1万元钱+利息，也就是说在这次融资的过程中（除去利息）赚了20000-10000=10000（元） 融券：与融资相反，投资者觉得某股A具有明显的下跌空间，但是手中并没有该股，于是乎打算向券商借来股票卖出去 张三觉得某股A具有明显的下跌空间，但是手中并没有该股，于是向券商借了100手于10元卖出，得10万元，等到该股下跌到9元后买回100手该股还给券商，买回只用了9万，获利1万元。这就是一种典型的融券 融券还有一种方式叫做对冲，试举例说明：投资者当天于10元买入某股100手，当天就涨到于11元，投资者想于该点卖出，但是苦于中国股市是T+1制度，当天买进的股票当天不能卖出。这时你可以融券该股100手于11元卖出，而把手中的100手还给券商，就相当于做了个T+0. 注意 实际操作中还有很多限制，比如“标的”就是一种，你不能对任何股票都进行融券，而只能对券商指定的股票群进行融券，这个股票群就叫“标的”。 另一个限制就是券商手中有可能没有你想融券的“标的”，因为券商也不傻，你想卖的股票，多半券商也不想留在手中。。。所以在考虑融券之前要查询一下券商手中是否还有该股票。 另外，借，就要有利息，不管融资还是融券都按照相关市值的银行利息结算（大致如此），但是很多券商都规定：当天借当天还没利息，所以有利于做T+0","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"投资理财学习","slug":"Life/投资理财学习","permalink":"https://dayarch.top/categories/Life/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"费用","slug":"费用","permalink":"https://dayarch.top/tags/%E8%B4%B9%E7%94%A8/"},{"name":"指数基金","slug":"指数基金","permalink":"https://dayarch.top/tags/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"}]},{"title":"Java多态调用顺序","slug":"Java多态调用顺序","date":"2017-05-05T12:21:20.000Z","updated":"2019-11-07T06:36:20.433Z","comments":true,"path":"/p/java-polymorphism-order.html","link":"","permalink":"https://dayarch.top/p/java-polymorphism-order.html","excerpt":"Java多态调用该案例 大家先看自行测试如下程序的输出结果是什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class A { public String show(D obj) { return (\"A and D\"); } public String show(A obj) {","text":"Java多态调用该案例大家先看自行测试如下程序的输出结果是什么？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class A &#123; public String show(D obj) &#123; return (\"A and D\"); &#125; public String show(A obj) &#123; return (\"A and A\"); &#125; &#125; public class B extends A&#123; public String show(B obj)&#123; return (\"B and B\"); &#125; public String show(A obj)&#123; return (\"B and A\"); &#125; &#125; public class C extends B&#123; &#125; public class D extends B&#123; &#125; public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1--\" + a1.show(b)); System.out.println(\"2--\" + a1.show(c)); System.out.println(\"3--\" + a1.show(d)); System.out.println(\"4--\" + a2.show(b)); System.out.println(\"5--\" + a2.show(c)); System.out.println(\"6--\" + a2.show(d)); System.out.println(\"7--\" + b.show(b)); System.out.println(\"8--\" + b.show(c)); System.out.println(\"9--\" + b.show(d)); &#125; &#125; 仔细思考哦…………….来看答案，有没有意外发生？ 1--A and A 2--A and A 3--A and D 4--B and A 5--B and A 6--A and D 7--B and B 8--B and B 9--A and D 接下来主要针对第四个输出结果做出解释，其他的输出结果按照此规矩自然就能得出，请记住： 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O) 所以，这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。 感谢感谢作者原文","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"多态","slug":"多态","permalink":"https://dayarch.top/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"OAuth2.0 详解","slug":"Oauth2-0-详解","date":"2017-05-05T08:13:12.000Z","updated":"2019-11-01T09:00:21.204Z","comments":true,"path":"/p/oauth2-detail.html","link":"","permalink":"https://dayarch.top/p/oauth2-detail.html","excerpt":"OAuth2.0 详解 以下内容为转载博主的内容 1. 为什么需要 Oauth2.0 协议？ 2. 开放平台 3. Access Token 与 Refresh Token 4. Implicit 授权方式 5. Authorization Code 授权 6. Resource Owner Password Credentials 授权和 Client Credentials 授权","text":"OAuth2.0 详解以下内容为转载博主的内容 为什么需要 Oauth2.0 协议？ 开放平台 Access Token 与 Refresh Token Implicit 授权方式 Authorization Code 授权 Resource Owner Password Credentials 授权和 Client Credentials 授权","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"安全-协议-规范","slug":"Coding/安全-协议-规范","permalink":"https://dayarch.top/categories/Coding/%E5%AE%89%E5%85%A8-%E5%8D%8F%E8%AE%AE-%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"https://dayarch.top/tags/OAuth2-0/"}]},{"title":"Hybris tomcat Jrebel热部署配置","slug":"Hybris-tomcat-Jrebel热部署配置","date":"2017-03-30T07:31:33.000Z","updated":"2019-11-07T05:28:27.664Z","comments":true,"path":"/p/hybris-jrebel.html","link":"","permalink":"https://dayarch.top/p/hybris-jrebel.html","excerpt":"背景 Jrebel是非常强大的实现项目热部署的软件，当然也比较消耗电脑的性能，当如Hybris的这种启动需要一段时间的项目，对于后端开发人员来说，改动一些东西就要重启服务真的是一种折磨，浪费时间，接下来说明一下Jrebel在Hybris项目中的配置 配置Jrebel Jrebel可以通过IntelliJ IDEA来下载安装集成好的插件，也可以单独下载Jrebel的包 （请支持正版） 方法一：通过IntelliJ IDEA 插件 如下图下载安装InteliJ IDEA 插件 安装好之后我们就可以在IntelliJ IDEA的安装目录中看到该插件，接下来在Hybris的local.prop","text":"背景Jrebel是非常强大的实现项目热部署的软件，当然也比较消耗电脑的性能，当如Hybris的这种启动需要一段时间的项目，对于后端开发人员来说，改动一些东西就要重启服务真的是一种折磨，浪费时间，接下来说明一下Jrebel在Hybris项目中的配置 配置JrebelJrebel可以通过IntelliJ IDEA来下载安装集成好的插件，也可以单独下载Jrebel的包 （请支持正版） 方法一：通过IntelliJ IDEA 插件如下图下载安装InteliJ IDEA 插件 安装好之后我们就可以在IntelliJ IDEA的安装目录中看到该插件，接下来在Hybris的local.properties文件中来配置tomcat #JRebel tomcat.javaoptions=-agentpath:&quot;D:/Users/fraser/.IntelliJIdea2016.2/config/plugins/jr-ide-idea/lib/jrebel6/lib/jrebel64.dll&quot; -DforceANSI=true tomcat.debugjavaoptions=-agentpath:&quot;D:/Users/fraser/.IntelliJIdea2016.2/config/plugins/jr-ide-idea/lib/jrebel6/lib/jrebel64.dll&quot; -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n -DforceANSI=true方法二：通过安装包下载Jrebel安装包来，将安装包解压到某一个目录下，然后同样配置local.properties 文件如下： #JREBEL tomcat.javaoptions=-Xverify:none -javaagent:&quot;E:/MyProjectSpace/jrebel_5.6.0/jrebe/jrebel.jar=de.hybris.tomcat.HybrisWebappClassLoader60&quot; tomcat.debugjavaoptions=-Xverify:none -javaagent:&quot;E:/MyProjectSpace/jrebel_5.6.0/jrebe/jrebel.jar=de.hybris.tomcat.HybrisWebappClassLoader60&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8060,suspend=y #可不配 tomcat.generaloptions=-Xmx2G -Xms2G -XX:PermSize=500M -XX:MaxPermSize=300M -Xss256K -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+CMSPermGenSweepingEnabled -XX:+CMSClassUnloadingEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+CMSScavengeBeforeRemark -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:&quot;${HYBRIS_LOG_DIR}/tomcat/java_gc.log&quot; -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dorg.tanukisoftware.wrapper.WrapperManager.mbean=true -Djava.endorsed.dirs=..b/endorsed -Dcatalina.base=%CATALINA_BASE% -Dcatalina.home=%CATALINA_HOME% -Dfile.encoding=UTF-8 -Dlog4j.configuration=log4j_init_tomcat.properties -Djava.util.logging.config.file=jdk_logging.properties -Djava.io.tmpdir=&quot;${HYBRIS_TEMP_DIR}&quot; -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000测试启动Hybris服务器如看到如下信息就说明Jrebel配置成功： 这样我们执行ant build 命令等待build成功，就可以实现热部署，如果遇到如下问题： 找到D:\\projects\\hybrisHn\\hybris\\bin\\ext-backoffice\\backoffice\\buildcallbacks.xml 文件，按照如下注释掉 即可 &lt;macrodef name=&quot;backoffice_after_build&quot;&gt; &lt;sequential&gt; &lt;!--&lt;backoffice_remove_web_fragments/&gt;--&gt; &lt;backoffice_create_web_fragments/&gt; &lt;/sequential&gt; &lt;/macrodef&gt;重新尝试ant build 命令应该就可以build成功，快尝试一下吧","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Hybris","slug":"Hybris","permalink":"https://dayarch.top/tags/Hybris/"},{"name":"Jrebel","slug":"Jrebel","permalink":"https://dayarch.top/tags/Jrebel/"}]},{"title":"Linux 根据关键字查看集群服务器的log","slug":"Linux-根据关键字查看集群服务器的log","date":"2017-03-29T07:22:34.000Z","updated":"2019-11-01T08:46:43.214Z","comments":true,"path":"/p/linux-search-keyword-script.html","link":"","permalink":"https://dayarch.top/p/linux-search-keyword-script.html","excerpt":"背景 现在项目多数会采用集群部署的形式，进行负载均衡，来分担客户端大量请求的压力，当客户端请求发生异常，异常log只能在某一个服务器节点上产生，当服务器节点比较少时候，我们可以根据log的关键字来单个查找，但是当服务器节点多的时候我们还这么查找真的有些浪费时间而且不准确. 解决方案 在某一台release 服务器上执行下面脚本即可完成多个节点的log信息的查询 check_log_in_console.sh脚本内容如下 #!/bin/bash if [ $# -lt 1 ]; then echo \"please provide the content you want to find","text":"背景现在项目多数会采用集群部署的形式，进行负载均衡，来分担客户端大量请求的压力，当客户端请求发生异常，异常log只能在某一个服务器节点上产生，当服务器节点比较少时候，我们可以根据log的关键字来单个查找，但是当服务器节点多的时候我们还这么查找真的有些浪费时间而且不准确. 解决方案在某一台release 服务器上执行下面脚本即可完成多个节点的log信息的查询check_log_in_console.sh脚本内容如下 #!/bin/bash if [ $# -lt 1 ]; then echo &quot;please provide the content you want to find&quot; echo &quot;usage: $0 [content] [date in yyyymmdd format]&quot; exit 0 fi if [ &quot;$2&quot; == &quot;&quot; ]; then d=`date +%Y%m%d` else d=$2 fi s=prd-hybris-pad for((i=1;i&lt;=4;i++)) do server=$s$i.bb.com echo &quot;============check logs on $server====================&quot; ssh app@$server &quot;grep &apos;$1&apos; /data/workspace/hybris/hybris/log/tomcat/console-$d.log&quot; sleep 1 done echo &quot;done&quot; #exit 0这样我们只需要在该文件目录中执行 ./check_log_in_console.sh &quot;你要搜索的关键字&quot; [回车]就会去以上节点中四个服务器中去查找你要搜索的关键字，打印出类似如下的log信息： ============check logs on prd-hybris-pad1.bb.com========== ============check logs on prd-hybris-pad2.bb.com========== ============check logs on prd-hybris-pad3.bb.com========== ============check logs on prd-hybris-pad4.bb.com==========","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Linux","slug":"Coding/Linux","permalink":"https://dayarch.top/categories/Coding/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dayarch.top/tags/Linux/"}]},{"title":"Spring MVC 之 @ResponseStatus","slug":"Spring-MVC-之-ResponseStatus","date":"2017-03-28T09:09:03.000Z","updated":"2019-11-03T03:08:01.835Z","comments":true,"path":"/p/springmvc-response-status.html","link":"","permalink":"https://dayarch.top/p/springmvc-response-status.html","excerpt":"@ResponseStatus Restful webservice请求会用到@ResponseStatus 注解，该注解可用于类级别上，也可以应用在方法级别上，代表请求响应的状态，通常就是返回HttpStatus的状态码，具体可查询每个状态码代，这里简单罗列一些： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 CONTINUE(100, \"Continue\"), SWITCHING_PROTOCOLS(101, \"Switching Protocols\"), PROCESSING(102, \"Processing\"), CHECKPOINT(103","text":"@ResponseStatusRestful webservice请求会用到@ResponseStatus 注解，该注解可用于类级别上，也可以应用在方法级别上，代表请求响应的状态，通常就是返回HttpStatus的状态码，具体可查询每个状态码代，这里简单罗列一些： 1234567891011121314151617CONTINUE(100, \"Continue\"),SWITCHING_PROTOCOLS(101, \"Switching Protocols\"),PROCESSING(102, \"Processing\"),CHECKPOINT(103, \"Checkpoint\"),OK(200, \"OK\"),CREATED(201, \"Created\"),ACCEPTED(202, \"Accepted\"),NON_AUTHORITATIVE_INFORMATION(203, \"Non-Authoritative Information\"),NO_CONTENT(204, \"No Content\"),RESET_CONTENT(205, \"Reset Content\"),PARTIAL_CONTENT(206, \"Partial Content\"),MULTI_STATUS(207, \"Multi-Status\"),ALREADY_REPORTED(208, \"Already Reported\"),IM_USED(226, \"IM Used\"),MULTIPLE_CHOICES(300, \"Multiple Choices\"),MOVED_PERMANENTLY(301, \"Moved Permanently\"),FOUND(302, \"Found\"), 应用在类级别创建一个异常类，用该注解标注 package com.zj.exception; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ResponseStatus; @ResponseStatus(value=HttpStatus.FORBIDDEN,reason=&quot;用户不匹配&quot;) public class UserNotMatchException extends RuntimeException{ }写一个目标方法来抛出异常 @RequestMapping(&quot;/testResponseStatus&quot;) public String testResponseStatus(int i){ if(i==0) throw new UserNotMatchException(); return &quot;hello&quot;; } 这样当我们请求该方法，如果出现异常，会将用户不匹配的信息返回给浏览器，让异常信息更加明确，而不是一堆异常信息代码 应用在方法级别@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=&quot;用户名不匹配&quot;) @RequestMapping(&quot;/testResponseStatus&quot;) public String testResponseStatus(int i){ if(i==0) throw new UserNotMatchException(); return &quot;hello&quot;; }ResponseStatus修饰目标方法，无论它执行方法过程中有没有异常产生，用户都会得到异常的界面。而目标方法正常执行 这个情况要看项目的使用情况，通常会制定一个标准的异常信息显示，可以灵活使用.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://dayarch.top/tags/Spring/"}]},{"title":"Spring MVC 之 @initbinder","slug":"Spring-MVC-之-initbinder","date":"2017-03-28T08:24:26.000Z","updated":"2019-11-03T03:07:54.831Z","comments":true,"path":"/p/springmvc-init-binder.html","link":"","permalink":"https://dayarch.top/p/springmvc-init-binder.html","excerpt":"背景 在Web项目中，太多需要提交表单或者在请求URL中添加参数信息的操作，无论是前者还是后者，SpringMVC都将每个元素当做String来处理， 如果前台传入格式化为字符串的日期或这数值类型的时候就会报错（在SpringMVC中，bean中定义了Date，double等类型，如果没有做任何处理的话，日期以及double都无法绑定），我们手动来强制转型很是麻烦，SpringMVC 提供的@initbinder 就是解决这个问题 @initbinder 在我的项目中是在BaseController中增加方法initBinder，并使用注解@InitBinder标注，那么spring mvc","text":"背景在Web项目中，太多需要提交表单或者在请求URL中添加参数信息的操作，无论是前者还是后者，SpringMVC都将每个元素当做String来处理， 如果前台传入格式化为字符串的日期或这数值类型的时候就会报错（在SpringMVC中，bean中定义了Date，double等类型，如果没有做任何处理的话，日期以及double都无法绑定），我们手动来强制转型很是麻烦，SpringMVC 提供的@initbinder 就是解决这个问题 @initbinder在我的项目中是在BaseController中增加方法initBinder，并使用注解@InitBinder标注，那么spring mvc在绑定表单之前，都会先注册这些编辑器, Spring自己提供了大量的实现类，诸如CustomDateEditor ，CustomBooleanEditor，CustomNumberEditor等许多，基本上够用, 当然我们也可以自己来写这些编辑器. 自定义编辑器import org.springframework.beans.propertyeditors.PropertiesEditor; public class DoubleEditor extends PropertiesEditor { @Override public void setAsText(String text) throws IllegalArgumentException { if (text == null || text.equals(&quot;&quot;)) { text = &quot;0&quot;; } setValue(Double.parseDouble(text)); } @Override public String getAsText() { return getValue().toString(); } } 类似Long、Float等都可以这样写，然后将这些自定义的编辑器或Spring自带的编辑器放到BaseController中带有@initbinder的方法中注册就好. @InitBinder protected void initBinder(WebDataBinder binder) { binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;), true)); binder.registerCustomEditor(int.class, new CustomNumberEditor(int.class, true)); binder.registerCustomEditor(int.class, new IntegerEditor()); binder.registerCustomEditor(long.class, new CustomNumberEditor(long.class, true)); binder.registerCustomEditor(long.class, new LongEditor()); binder.registerCustomEditor(double.class, new DoubleEditor()); binder.registerCustomEditor(float.class, new FloatEditor()); } 当然我们也可以将自定义的编辑器直接继承 PropertyEditorSupport， 因为： public class org.springframework.beans.propertyeditors.PropertiesEditor extends java.beans.PropertyEditorSupport { 参考非常感谢一下两位作者贡献整理的文章： spring mvc使用@InitBinder 标签对表单数据绑定 @InitBind来解决字符串转日期类型","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://dayarch.top/tags/SpringMVC/"}]},{"title":"Java中的ArrayList的容量","slug":"Java中的ArrayList的容量","date":"2017-03-16T03:33:44.000Z","updated":"2019-11-07T05:31:10.268Z","comments":true,"path":"/p/java-arraylist-capacity.html","link":"","permalink":"https://dayarch.top/p/java-arraylist-capacity.html","excerpt":"1. List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。 2. ArrayList继承于List接口，除继承过来的方法外，还提供一些方法来操作内部用来存储列表的数组的大小。 3. 每个ArrayList实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。 4. ArrayList是经常会被用到的，一般情况下，使用的时候会","text":"List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。 ArrayList继承于List接口，除继承过来的方法外，还提供一些方法来操作内部用来存储列表的数组的大小。 每个ArrayList实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。 ArrayList是经常会被用到的，一般情况下，使用的时候会像这样进行声明： List arrayList = new ArrayList();如果像上面这样使用默认的构造方法，初始容量被设置为10。当ArrayList中的元素超过10个以后，会重新分配内存空间，使数组的大小增长到16。可以通过调试看到动态增长的数量变化：10-&gt;16-&gt;25-&gt;38-&gt;58-&gt;88-&gt;… 也可以使用下面的方式进行声明： List arrayList = new ArrayList(4);将ArrayList的默认容量设置为4。当ArrayList中的元素超过4个以后，会重新分配内存空间，使数组的大小增长到7。可以通过调试看到动态增长的数量变化：4-&gt;7-&gt;11-&gt;17-&gt;26-&gt;… 那么容量变化的规则是什么呢？请看下面的公式： ((旧容量 * 3) / 2) + 1注：这点与C#语言是不同的，C#当中的算法很简单，是翻倍。 一旦容量发生变化，就要带来额外的内存开销，和时间上的开销。所以，在已经知道容量大小的情况下，推荐使用下面方式进行声明：List arrayList = new ArrayList(CAPACITY_SIZE); 即指定默认容量大小的方式。 感谢原文作者：原文","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Java","slug":"Coding/Java","permalink":"https://dayarch.top/categories/Coding/Java/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"https://dayarch.top/tags/ArrayList/"}]},{"title":"Jenkins自动化部署Hybris","slug":"Jenkins自动化部署Hybris","date":"2017-03-08T07:03:17.000Z","updated":"2019-11-01T08:46:23.478Z","comments":true,"path":"/p/jenkins-hybris-deploy.html","link":"","permalink":"https://dayarch.top/p/jenkins-hybris-deploy.html","excerpt":"前言 项目开发时间不算紧张，知道项目应用Jenkins 持续集成实现自动化部署，这个部署是如何实现的，向架构师取经研究之后做此记录. 部署架构拓扑图 以下是项目部署架构简易拓扑图，不包括Solr服务器的部署, Prod Env采用Cluster Deployment的方式. 运维人员搭建Jenkins服务器之后，每位被授权的开发人员都可以访问Jenkins 工作主页， 当push代码之后，统一在指定时间点build (Jenkins没有采用有push代码自动build的方式 ). 1. 开发人员Push 代码 2. Build QA1, 功能测试通过之后进行下一步 3. Bu","text":"前言项目开发时间不算紧张，知道项目应用Jenkins 持续集成实现自动化部署，这个部署是如何实现的，向架构师取经研究之后做此记录. 部署架构拓扑图以下是项目部署架构简易拓扑图，不包括Solr服务器的部署, Prod Env采用Cluster Deployment的方式. 运维人员搭建Jenkins服务器之后，每位被授权的开发人员都可以访问Jenkins 工作主页， 当push代码之后，统一在指定时间点build (Jenkins没有采用有push代码自动build的方式 ). 开发人员Push 代码 Build QA1, 功能测试通过之后进行下一步 Build QA2, 功能测试通过之后进行下一步 等待发布版本时间节点 Build Stage环境，功能测试通过之后进行下一步 （拓扑图中没有显示Stage环境） Build Prod 环境， 功能测试通过之后成功发布. 开发人员只需要点击Jenkins控制台的Build，即可完成自动化部署，这正是Jenkins 带来的便利，接下来就解释一下Jenkins 整个工作过程. Jenkins 持续集成过程详解生产环境是采用集群部署，和QA环境是有所区别的，下面针对生产环境和QA环境分别作解释 Common 环境解释Jenkins 的Home Directory 是 /var/lib/jenkinsQA环境部署 以QA1 环境为例，item名称为 qa_honor_hybris, workspace的路径是Jenkins 的workspace路径与item名称的拼接，这样当前item的$workspace的路径为 /var/lib/jenkins/workspace/qa_honor_hybris 点击build之后，Jenkins会按照该item配置好的Git Repository 来拉取最新代码到workspace中 执行自定义Shell 脚本(Jenkins 控制台写好的脚本) # 1. 移除掉工作区旧代码 rm -rf /data/qa_honor_hybris/hybris/bin/custom # 2. copy 拉取下来的最新代码到工作区中 cp -r $WORKSPACE/bin/custom /data/qa_honor_hybris/hybris/bin # 3. copy local.properties 和 localextensions.xml 到 工作区config目录下 cp $WORKSPACE/config/local.properties /data/qa_honor_hybris/hybris/config cp $WORKSPACE/config/localextensions.xml /data/qa_honor_hybris/hybris/config # 5. 进入工作区platform 目录 cd /data/qa_honor_hybris/hybris/bin/platform # 6. 设置基本环境变量，当然可以Jenkins 设置好 export JAVA_HOME=/usr/local/jdk1.8 export JRE_HOME=/usr/local/jdk1.8/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$PATH # 7. 指定ant 目录并且build，执行该步骤是为了检测项目是否能build成功 . ./setantenv.sh ant clean all # 8. 切换到工作区build 目录下 cd /data/qa_honor_hybris/build ./build_and_deploy.sh ./build_and_deploy.sh 脚本内容 #!/bin/bash # 1. 进入工作区目录 cd /var/lib/jenkins/workspace/qa1-honor-hybris echo &quot;build for honor hybris qa1&quot; # 删除workspace 历史内容 echo &quot;create honor source code tar ball&quot; rm -rf honor rm -rf honor.tar.gz # 创建文件夹，等待打包 mkdir honor # copy workspace 最新代码拷贝到 刚刚新建的honor 文件夹中 cp -r /var/lib/jenkins/workspace/qa1-honor-hybris/bin honor cp -r /var/lib/jenkins/workspace/qa1-honor-hybris/config/qa honor # 将honor 文件夹压缩打包 tar -zcvf honor.tar.gz honor # 将打包的honor.tar.gz 远程copy到 QA1 服务器的workspace 中 echo &quot;======copy tar ball to qa1 server(10.11.12.233)=====&quot; scp honor.tar.gz app@10.11.12.233:/data/build_workspace # 进入到QA1 环境并且进入workspace, 停掉QA1 的服务 echo &quot;===build hybris and start hybris on qa1 server===&quot; ssh app@10.11.12.233 &apos;cd /data/build_workspace;. ./stop.sh&apos; # 执行QA1相应路径下的脚本. ssh app@10.11.12.233 &apos;cd /data/build_workspace;. ./build_and_start.sh&apos; echo &quot;build_and_deploy done&quot; exit 0 ./build_and_start.sh 脚本内容 #!/bin/bash # 1. 删除掉honor 文件夹（确保文件夹删除，下面其实已经删除了一次） rm -rf honor # 2. 赋予可读可写可执行的权限 chmod 755 honor.tar.gz # 3. 解压刚刚传输过来的压缩包，并赋予可读可写可执行的权限 tar -zxvf honor.tar.gz chmod -R 755 honor # 4. 删除掉旧的Hybris代码 echo &quot;remove old honor hybris source code...&quot; rm -rf /data/build_workspace/honor-hybris/hybris/bin/custom rm -rf /data/build_workspace/honor-hybris/hybris/config/local.properties rm -rf /data/build_workspace/honor-hybris/hybris/config/localextensions.xml # 5. copy刚刚解压出来的honor文件夹的内容到工作区 echo &quot;copy new honor source code...&quot; cd /data/build_workspace cp -r honor/* honor-hybris/hybris cp honor/qa/local_qa1.properties honor-hybris/hybris/config/local.properties cp honor/qa/localextensions.xml honor-hybris/hybris/config/localextensions.xml # 6. 删除解压出来的文件夹 rm -rf honor # 7. 设置环境变量 echo &quot;begin to start qa1...&quot; export JAVA_HOME=&quot;/usr/local/jdk1.8.0_101&quot; export PATH=$JAVA_HOME/bin:$PATH cd /data/build_workspace/honor-hybris/hybris/bin/platform . ./setantenv.sh ant clean all # 8. 直接以debug模式启动（方便远程调试，但是Jenkins build进度条始终是红色，不影响使用，还没找到这个解决办法） . ./hybrisserver.sh debug exit 0 以上是QA环境还不涉及到多node的情况，接下来会介绍Prod 的情况，大体流程和QA环境相似，只不过是多了处理node的情况. Prod 环境部署 Jenkins 在build之后会将最新的代码pull到release服务器， 然后在release服务器上执&gt; 行脚本，将代码发布到各个服务器上, 在release服务器的/data 目录下有两个目录 /data/install: 将环境所需的软件、Licence等存放在此，这些只是第一次发布的时候会用到 /data/build: 这是真正build的所需要的目录 点击build之后，Jenkins会按照该item配置好的Git Repository 来拉取最新代码到workspace中 执行自定义Shell 脚本(Jenkins 控制台写好的脚本, 和QA环境类似，注意目录的改变) rm -rf /data/prod_honor_hybris/hybris/bin/custom cp -r $WORKSPACE/bin/custom /data/prod_honor_hybris/hybris/bin cp $WORKSPACE/config/local.properties /data/prod_honor_hybris/hybris/config cp $WORKSPACE/config/localextensions.xml /data/prod_honor_hybris/hybris/config cd /data/prod_honor_hybris/hybris/bin/platform export JAVA_HOME=/usr/local/jdk1.8 export JRE_HOME=/usr/local/jdk1.8/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$PATH . ./setantenv.sh ant clean all cd /data/prod_honor_hybris/build ./build_and_deploy.sh ./build_and_deploy.sh 脚本内容 #!/bin/bash cd /var/lib/jenkins/workspace/prod-honor-hybris echo &quot;build for honor hybris product&quot; echo &quot;create honor source code tar ball&quot; rm -rf honor rm -rf honor.tar.gz mkdir honor cp -r /var/lib/jenkins/workspace/prod-honor-hybris/bin honor cp -r /var/lib/jenkins/workspace/prod-honor-hybris/config/prod honor tar -zcvf honor.tar.gz honor # 1. 生产上要备份原有的压缩包，以防万一进行恢复版本 echo &quot;======backup original tar in release server(10.11.12.232)=====&quot; ssh app@10.11.12.232 &quot;cp /data/build/product/honor.tar.gz /data/build/product/honor.tar.gz_backup&quot; echo &quot;======copy tar ball to release server(10.11.12.232)=====&quot; scp honor.tar.gz app@10.11.12.232:/data/build/product echo &quot;build_and_deploy done&quot; exit 0 发布内容前端服务器，进入到Prod Release 服务器相应目录执行脚本app_release.sh 主要动态循环IP地址，将文件传送到不同的服务器，执行相应服务器的脚本. #!/bin/bash if [ $# -lt 2 ]; then echo &quot;please provide server start index and end index&quot; echo &quot;usage: $0 [start] [end]&quot; # exit 0 fi s=prd-hybris-pad baseIp=11.12.126. let ipStartNum=$1+54 echo &quot;release artifact to hybris server from $s$1 to $s$2&quot; for((i=$1;i&lt;=$2;i++)) do server=$s$i.xxx.com ipAddr=$baseIp$ipStartNum echo &quot;============deploy on $server====================&quot; echo &quot;copy Hybris production Deployment ZIP to $server&quot; scp /data/build/product/honor.tar.gz app@$server:/data/workspace echo &quot;build hybris on $server and start hybris&quot; ssh app@$server &quot;cd /data/workspace;./stop.sh; nohup ./build_and_start.sh $ipAddr &gt;./build.log 2&gt;&amp;1 &amp; &quot; let ipStartNum=$ipStartNum+1 sleep 1 done echo &quot;done&quot; #exit 0 Prod 服务器目录结构 进入到Prod 服务器之一 查看./stop.sh 脚本内容 #!/bin/bash cd /data/workspace/hybris/hybris/bin/platform . ./setantenv.sh &amp;&amp; ./hybrisserver.sh stop 查看./build_and_start.sh内容（内容有些复杂） #!/bin/bash rm -rf honor chmod 755 honor.tar.gz tar -zxvf honor.tar.gz chmod -R 755 honor echo &quot;remove old honor hybris source code...&quot; rm -rf /data/workspace/hybris/hybris/bin/custom rm -rf /data/workspace/hybris/hybris/config/local.properties rm -rf /data/workspace/hybris/hybris/config/localextensions.xml echo &quot;copy new honor source code...&quot; cp -r honor/* hybris/hybris cp honor/prod/local.properties hybris/hybris/config/local.properties cp honor/prod/localextensions.xml hybris/hybris/config/localextensions.xml cp template.tomcat.context.tpl hybris/hybris/config/tomcat/tomcat_context.tpl sed -c -i &apos;s/.*name=&quot;backoffice&quot;.*/&lt;!-- &lt;extension name=&quot;backoffice&quot; \\/&gt; --&gt;/g&apos; hybris/hybris/config/localextensions.xml sed -c -i &apos;s/.*requires-channel=&quot;https&quot;.*/&lt;intercept-url pattern=&quot;\\/\\*\\*&quot; requires-channel=&quot;https&quot;\\/&gt;/g&apos; hybris/hybris/bin/custom/honor/honorcommercewebservices/web/webroot/WEB-INF/config/v2/security-v2-spring.xml sed -c -i &apos;s/.*name=&quot;mcc&quot;.*/&lt;!-- &lt;extension name=&quot;mcc&quot; \\/&gt; --&gt;/g&apos; hybris/hybris/config/localextensions.xml #echo cluster.id=$1 &gt;&gt; hybris/hybris/config/local.properties echo -e &quot;\\ncluster.broadcast.method.jgroups.tcp.bind_addr=$1&quot; &gt;&gt; hybris/hybris/config/local.properties echo -e &quot;\\ntask.processing.enabled=fase&quot; &gt;&gt; hybris/hybris/config/local.properties echo -e &quot;\\nhac.webroot=/hac&quot; &gt;&gt; hybris/hybris/config/local.properties rm -rf honor echo &quot;begin to start server...&quot; export JAVA_HOME=&quot;/usr/local/jdk1.8.0_101&quot; export PATH=$JAVA_HOME/bin:$PATH cd /data/workspace/hybris/hybris/bin/platform . ./setantenv.sh ant clean all . ./hybrisserver.sh start exit 0 template.tomcat.context.tpl 文件内容 #if ( $contextPath != &apos;/hmc&apos; &amp;&amp; $contextPath != &apos;/hac&apos; &amp;&amp; $contextPath != &apos;/backoffice&apos; &amp;&amp; $contextPath != &apos;/advancedexport&apos; &amp;&amp; $contextPath != &apos;/admincockpit&apos; &amp;&amp; $contextPath != &apos;/mcc&apos; &amp;&amp; $contextPath != &apos;/reportcockpit&apos; &amp;&amp; $contextPath != &apos;/importcockpit&apos; &amp;&amp; $contextPath != &apos;/cscockpit&apos; &amp;&amp; $contextPath != &apos;/cmscockpit&apos; &amp;&amp; $contextPath != &apos;/cmscockpitRegular&apos; &amp;&amp; $contextPath != &apos;/productcockpit&apos; &amp;&amp; $contextPath != &apos;/chinacheckoutaddon&apos; &amp;&amp; $contextPath != &apos;/instore&apos; &amp;&amp; $contextPath != &apos;/virtualjdbc&apos; &amp;&amp; $contextPath != &apos;/erpintegration&apos; &amp;&amp; $contextPath != &apos;/acceleratorservices&apos; &amp;&amp; $contextPath != &apos;/commercesearchsampledata&apos; &amp;&amp; $contextPath != &apos;/solrfacetsearch&apos; ) #if($contextDescription &amp;&amp; $contextDescription != &apos;&apos;) &lt;!-- $contextDescription --&gt; #end &lt;Context path=&quot;$contextPath&quot; docBase=&quot;$contextDocBase&quot; $!contextAdditionalAttributes&gt; &lt;Manager pathname=&quot;&quot; /&gt; #if($contextLoader &amp;&amp; $contextLoader != &apos;&apos;) $contextLoader #end #if($contextAdditionalElements &amp;&amp; $contextAdditionalElements != &apos;&apos;) $contextAdditionalElements #end &lt;/Context&gt; #end 发布内容后端服务器，进入到Prod Release 服务器相应目录执行脚本backend_release.sh #!/bin/bash if [ $# -lt 2 ]; then echo &quot;please provide server start index and end index&quot; echo &quot;usage: $0 [start] [end]&quot; # exit 0 fi s=prd-hybris baseIp=10.0.126. let ipStartNum=$1+52 echo &quot;release artifact to hybris server from $s$1 to $s$2&quot; for((i=$1;i&lt;=$2;i++)) do server=$s$i.xxxx.com ipAddr=$baseIp$ipStartNum echo &quot;============deploy on $server====================&quot; echo &quot;copy Hybris production Deployment ZIP to $server&quot; scp /data/build/product/honor.tar.gz app@$server:/data/workspace echo &quot;build hybris on $server and start hybris&quot; ssh app@$server &quot;cd /data/workspace;./stop.sh; nohup ./build_and_start.sh $ipAddr &gt;./build.log 2&gt;&amp;1 &amp; &quot; let ipStartNum=$ipStartNum+1 sleep 1 done echo &quot;done&quot; #exit 0 security-v2-spring.xml 文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- [y] hybris Platform Copyright (c) 2000-2016 SAP SE or an SAP affiliate company. All rights reserved. This software is the confidential and proprietary information of SAP (&quot;Confidential Information&quot;). You shall not disclose such Confidential Information and shall use it only in accordance with the terms of the license agreement you entered into with SAP. --&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:security=&quot;http://www.springframework.org/schema/security&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;http pattern=&quot;/v2/**&quot; entry-point-ref=&quot;oauthAuthenticationEntryPointV2&quot; access-decision-manager-ref=&quot;webSecurityAccessDecisionManager&quot; xmlns=&quot;http://www.springframework.org/schema/security&quot; create-session=&quot;stateless&quot;&gt; &lt;anonymous username=&quot;anonymous&quot; granted-authority=&quot;ROLE_ANONYMOUS&quot;/&gt; &lt;!--&lt;session-management session-authentication-strategy-ref=&quot;fixation&quot;/&gt;--&gt; &lt;intercept-url pattern=&quot;/**&quot; requires-channel=&quot;https&quot;/&gt; &lt;port-mappings&gt; &lt;port-mapping http=&quot;#{configurationService.configuration.getProperty(&apos;tomcat.http.port&apos;)}&quot; https=&quot;#{configurationService.configuration.getProperty(&apos;tomcat.ssl.port&apos;)}&quot;/&gt; &lt;port-mapping http=&quot;#{configurationService.configuration.getProperty(&apos;embeddedserver.http.port&apos;)}&quot; https=&quot;#{configurationService.configuration.getProperty(&apos;embeddedserver.ssl.port&apos;)}&quot; /&gt; &lt;/port-mappings&gt; &lt;custom-filter ref=&quot;resourceServerFilter&quot; before=&quot;PRE_AUTH_FILTER&quot;/&gt; &lt;access-denied-handler ref=&quot;oauthAccessDeniedHandlerV2&quot;/&gt; &lt;headers &gt; &lt;content-type-options /&gt; &lt;hsts include-subdomains=&quot;true&quot; max-age-seconds=&quot;16070400&quot; /&gt; &lt;xss-protection /&gt; &lt;security:frame-options disabled=&quot;true&quot;/&gt; &lt;/headers&gt; &lt;security:csrf disabled=&quot;true&quot;/&gt; &lt;/http&gt; &lt;bean id=&quot;oauthAuthenticationEntryPointV2&quot; parent=&quot;oauthAuthenticationEntryPoint&quot;&gt; &lt;property name=&quot;exceptionRenderer&quot; ref=&quot;oAuth2ExceptionRendererV2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;oauthAccessDeniedHandlerV2&quot; parent=&quot;oauthAccessDeniedHandler&quot;&gt; &lt;property name=&quot;exceptionRenderer&quot; ref=&quot;oAuth2ExceptionRendererV2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;oAuth2ExceptionRendererV2&quot; parent=&quot;oAuth2ExceptionRenderer&quot;&gt; &lt;property name=&quot;messageConverters&quot; ref=&quot;messageConvertersV2&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 大家看到了好处，也看到了Jenkins 不同服务器的部署基本类似，就是苦力活了， 接下来会将docker的部署陆续添加进来.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://dayarch.top/tags/Jenkins/"}]},{"title":"Spring AOP","slug":"Spring-AOP配置","date":"2017-02-23T12:14:54.000Z","updated":"2019-11-01T08:52:53.872Z","comments":true,"path":"/p/spring-aop.html","link":"","permalink":"https://dayarch.top/p/spring-aop.html","excerpt":"前言 Spring AOP 的道理懂得，但是很少在项目中使用，刚巧这个项目中有用到，将AOP的理解以及使用中遇到的问题加以总结记录 使用场景 设想一下，项目已接近尾声，经理说为了项目验收，更好的监控程序调用日志，需要在每个方法调用前或调用后加上日志，天啊，这是多大的工作量，项目中至少有几百个方法，我们要做这种无脑的工作了吗？ 如果不懂得Spring AOP面向切面编程的道理，那这个体力活看来是费力不讨好的事情，接下来让我们慢慢剖析Spring AOP 的道理. Java 动态代理 Java23中设计模式之一代理模式，Spring AOP充分利用了Java 动态代理功能来实现（对动态代理有所","text":"前言Spring AOP 的道理懂得，但是很少在项目中使用，刚巧这个项目中有用到，将AOP的理解以及使用中遇到的问题加以总结记录 使用场景设想一下，项目已接近尾声，经理说为了项目验收，更好的监控程序调用日志，需要在每个方法调用前或调用后加上日志，天啊，这是多大的工作量，项目中至少有几百个方法，我们要做这种无脑的工作了吗？ 如果不懂得Spring AOP面向切面编程的道理，那这个体力活看来是费力不讨好的事情，接下来让我们慢慢剖析Spring AOP 的道理. Java 动态代理Java23中设计模式之一代理模式，Spring AOP充分利用了Java 动态代理功能来实现（对动态代理有所理解的可以跳过该段内容），即便没有Spring AOP 我们也能够通过Java 动态代理解决上述问题. 在Java 动态代理中有两个重要的接口或类： InvocationHandler （Interface） Proxy （Class） 这一个接口和类是实现我们动态代理所必须用到的，其实这种设计模式可以联想到我们现实生活中的代购或代理商: 这是什么，怎么好像和我们说的项目中需要不沾边际，项目快要结束了，满项目鞋子和衣服方法已经写好，突然项目经理说要给鞋子和衣服加上包装（日志），刚好代理商可以轻松做到这个，每次客户调用鞋子和衣服方法时，只需要调用代理商暴露出来的鞋子和方法即可, 还没懂？ 没关系，程序猿看代码还是最实际的. InvocationHandler看一下官方定义： InvocationHandler is the interface implemented by the invocation handler of a proxy instance. Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler. —— InvocationHandler 是一个接口，它被一个代理类实例的handler所实现，每一个代理类实例都有其对应的handler, 当一个代理实例的方法被调用，方法的调用就交给了它对应的handler来处理 InvocationHandler 接口只定义了一个方法： Object invoke(Object proxy, Method method, Object[] args) throws Throwable; proxy : 代理类对象 method : 我们调用真实对象的某个方法 args : 我们调用真是对象的某个方法接受的参数 Proxy看一下官方定义： Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. —— Proxy提供一个静态方法用来创建动态代理类实例，并且是所有代理类的父类 Proxy 类中最常用的方法是： /** *Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler */ public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) { try { Class e = getProxyClass(loader, interfaces); return e.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{h}); } catch (RuntimeException var4) { throw var4; } catch (Exception var5) { throw new CodeGenerationException(var5); } } loader : 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载 interfaces : 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 h : 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 代码示例定义Subject 接口：public interface Subject { public void shoes(); public void clothes(String str); }定义接口真实实现类public class RealSubject implements Subject { @Override public void shoes() { System.out.println(&quot;This is shoes method without packaging&quot;); } @Override public void clothes(String str) { System.out.println(&quot;hello: &quot; + str); } }定义动态代理类，并实现InvocationHandler 接口public class DynamicProxy implements InvocationHandler { //这个就是我们要代理的真实对象 private Object subject; //构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) { this.subject = subject; } @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable { //在代理真实对象前我们可以添加一些自己的操作，比如给鞋子和衣服做包装 System.out.println(&quot;before packaging&quot;); System.out.println(&quot;Method:&quot; + method); //当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); //在代理真实对象后我们也可以添加一些自己的操作，加完包装之后的一些售后服务 System.out.println(&quot;after packaging&quot;); return null; } }看看客户端类的定义public class Client { public static void main(String[] args) { //我们要代理的真实对象 Subject realSubject = new RealSubject(); //我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject .getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.shoes(); subject.clothes(&quot;clothes, it&apos;s without packaging&quot;); } }控制台的输出结果$Proxy0 before packaging Method:public abstract void com.xiaoluo.dynamicproxy.Subject.shoes() This is shoes method without packaging after packaging before packaging Method:public abstract void com.xiaoluo.dynamicproxy.Subject.clothes(java.lang.String) hello: clothes, it&apos;s without packaging after packagingProxy.newProxyInstance 生成代理对象时所需要的invocationHandler 参数更像是代理商和供应商之间的物流，当代理商需要供应商的鞋子时候，需要告诉这个物流去取鞋子. 一个代理商当然也代理多个品牌，这就是为什么参数中interfaces 是数组形式，至此关于Java 动态代理就告一段落了，我们来看看Spring AOP , 道理都是相通的. Spring AOP术语解释 术语名称 对应解释 官方术语描述 Aspect 它是一个包含一系列API的模块，同时提供横切的需求，比如日志记录. A module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement. Join point 应用程序真正会发生通知行为的一个点 This represents a point in your application where you can plug-in AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework. Advice 可以理解为通知，在目标程序执行前通知还是执行后通知 This is the actual action to be taken either before or after the method execution. This is actual piece of code that is invoked during program execution by Spring AOP framework. Pointcut Join Point的集合，程序中所有想切入的点的集合 This is a set of one or more joinpoints where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples. Advice 通知 术语名称 对应解释 官方术语描述 before 在调用目标方法之前通知 Run advice before the a method execution after 在调用目标方法之后通知，不管目标方法是否执行成功 Run advice after the a method execution regardless of its outcome. after-returning 当目标方法成功执行没有任何异常之后 Run advice after the a method execution only if method completes successfully after-throwing after 或 after-returning 运行之后捕获异常 Run advice after the a method execution only if method exits by throwing an exception. around 运行目标方法前后环绕 Run advice before and after the advised method is invoked try{ //前置通知 //环绕通知 //调用目标对象方法 //环绕通知 //后置通知 }catch(){ //异常通知 }finally{ //终止通知 }Spring XML配置&lt;context:annotation-config/&gt; &lt;aop:config proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;&gt; &lt;aop:aspect ref=&quot;capitalModification&quot;&gt; &lt;aop:pointcut id=&quot;handleOrder&quot; expression=&quot;execution(* com.honor.facades.app.order.HonorOrderFacade.handleCapital(..)) || execution(* com.honor.facades.serviceOrder.HonorServiceOrderFacade.handleCapital(..)) || execution(* com.honor.facades.aftersales.HonorReturnFormFacades.handleCapital(..))&quot;/&gt; &lt;aop:after method=&quot;capitalAndRecordModification&quot; pointcut-ref=&quot;handleOrder&quot;/&gt; &lt;aop:after-throwing throwing=&quot;ex&quot; method=&quot;capitalAndRecordModificationExceptionHandle&quot; pointcut-ref=&quot;handleOrder&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=&quot;capitalModification&quot; class=&quot;com.honor.core.customerCapital.impl.DefaultCapitalModificationStrategy&quot;&gt; &lt;property name=&quot;customerCapitalService&quot; ref=&quot;customerCapitalService&quot;/&gt; &lt;property name=&quot;honorSuperOrderService&quot; ref=&quot;honorSuperOrderService&quot;/&gt; &lt;property name=&quot;honorBillService&quot; ref=&quot;honorBillService&quot;/&gt; &lt;/bean&gt;多个pointcut 可以用 || 或 or 来实现. 项目使用中遇到的问题关于AOP无法切入同类调用方法的问题Controller 层方法A调用了Facade层方法B，可是B内调用了方法C, 我们想使用AOP织入方法C, 当程序运行后， 始终找不到代理方法，意味着织入C没有成功, public class MyController{ public void methodA(){ myFacade.methodB(); } } public class MyController{ public void methodB(){ myFacade.methodC(); } public void methodC(){ System.out.println(&quot;bingo&quot;); } } public class Aspect { @AfterReturning(execution(* Facade.methodB(..))) public void after() { Logger.info(after call and do something); } } 我们发现在 AopContext.class 中： public static Object currentProxy() throws IllegalStateException { Object proxy = currentProxy.get(); if(proxy == null) { throw new IllegalStateException(&quot;Cannot find current proxy: Set \\&apos;exposeProxy\\&apos; property on Advised to \\&apos;true\\&apos; to make it available.&quot;); } else { return proxy; } }解决办法： 设置proxy-target-class=”true”expose-proxy=”true” &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;expose-proxy=&quot;true&quot;/&gt; 手动指定代理调用方法 ((Facade) AopContext.currentProxy()).methodB(); 参考链接非常感谢以下几位博主，在你们认真的博客上学到了许多. http://blog.csdn.net/lirui0822/article/details/8555691 http://www.cnblogs.com/xiaoluo501395377/p/3383130.html 同时修改AOP函数返回值及获取函数参数请参考以下文章： http://blog.csdn.net/cleverutd/article/details/8607491 https://my.oschina.net/itblog/blog/211693","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring","slug":"Coding/Spring","permalink":"https://dayarch.top/categories/Coding/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://dayarch.top/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://dayarch.top/tags/AOP/"}]},{"title":"Jenkins学习之邮箱配置","slug":"Jenkins学习之邮箱配置","date":"2017-01-05T07:05:18.000Z","updated":"2019-11-01T08:46:03.072Z","comments":true,"path":"/p/jenkins-config-mail.html","link":"","permalink":"https://dayarch.top/p/jenkins-config-mail.html","excerpt":"使用场景 开发人员build project 之后，build结果无论是成功还是失败，都要及时的通知组内其他成员了解最新情况，邮件通知这时候就派上用场，恰巧 Jenkins 提供了这么一个功能，不过该功能还是过于单一，如不能编写email template 来格式化邮件内容，但Extended E-mail Notification（Jenkins 邮件插件）实现了更高级的功能，接下来逐步看一下 Jenkins 邮件功能的配置 配置邮件服务器 以管理员身份登录，在 Jenkins 首页click Manage Jenkins, 然后 click Configure System, 下拉到页面","text":"使用场景开发人员build project 之后，build结果无论是成功还是失败，都要及时的通知组内其他成员了解最新情况，邮件通知这时候就派上用场，恰巧 Jenkins 提供了这么一个功能，不过该功能还是过于单一，如不能编写email template 来格式化邮件内容，但Extended E-mail Notification（Jenkins 邮件插件）实现了更高级的功能，接下来逐步看一下 Jenkins 邮件功能的配置 配置邮件服务器以管理员身份登录，在 Jenkins 首页click Manage Jenkins, 然后 click Configure System, 下拉到页面的最底部 E-mail Notification 处： 此处我用了网易yeah.net的邮箱，User Name(邮箱账号)，Password(邮箱密码)，在Test e-mail recipient(接收邮件)，不过配置了这些仅仅是配置邮件服务器地址、账号和密码，但是jenkins不知道采用哪个邮箱去发送，所以我们需要在该处配置发送的邮箱，并且要和管理员的邮箱一致 到此点击一下Test configuration button 看一下测试结果，如果测试不成功要检查一下管理员邮箱是否有开通 SMTP服务，登录你设置的邮箱开通SMTP 设置完之后测试结果为成功 当我们在project 中配置build之后的行为时，可以添加邮件通知，这样在接收人列表中的人都可以接受到build的结果： build 一下项目，看一下有没有收到邮件通知吧. 安装Email插件Jenkins 首页 —— Manage Jenkins —— Manage Plugins，安装该插件 重新启动Jenkins, 可以在刚刚配置邮件的上方看到已安装好的email 插件 这样编辑Default Content 字段来编写email template, 支持 HTML 标签. 这样在项目构建后行为中选择Editable Email Notificatioin 来发布build的结果 NOTE: 大家看不懂的字段多多点开字段右侧的问号，里面的说明还是非常清晰的. 邮件插件的其他小功能也请自行研究.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://dayarch.top/tags/Jenkins/"}]},{"title":"巧用PostMan","slug":"巧用PostMan","date":"2016-10-27T09:06:12.000Z","updated":"2019-11-01T09:01:07.922Z","comments":true,"path":"/p/postman-advanced-usage.html","link":"","permalink":"https://dayarch.top/p/postman-advanced-usage.html","excerpt":"现在越发的认识到巧用工具提高工作效率的重要性，接下来看一下PostMan带来的便利 业务情景 在实际工作中，当App或其他渠道来调用Java后台接口的时候，我们通常会用到PostMan这个工具来模拟调用，当需要token来作为验证的时候，当每次请求的token发生变化的时候我们同时要改变其他请求URL中的token内容，这样很麻烦，降低工作效率，PostMan的环境变量解决了这个问题 配置环境变量 and and and and and and 至此设置环境变量结束，其他功能会陆续补充.","text":"现在越发的认识到巧用工具提高工作效率的重要性，接下来看一下PostMan带来的便利 业务情景在实际工作中，当App或其他渠道来调用Java后台接口的时候，我们通常会用到PostMan这个工具来模拟调用，当需要token来作为验证的时候，当每次请求的token发生变化的时候我们同时要改变其他请求URL中的token内容，这样很麻烦，降低工作效率，PostMan的环境变量解决了这个问题 配置环境变量andandandandandand 至此设置环境变量结束，其他功能会陆续补充.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"PostMan","slug":"PostMan","permalink":"https://dayarch.top/tags/PostMan/"}]},{"title":"Git Ignoring Files","slug":"Git-Ignoring-Files","date":"2016-10-15T01:32:43.000Z","updated":"2019-11-07T05:24:49.443Z","comments":true,"path":"/p/git-ignore.html","link":"","permalink":"https://dayarch.top/p/git-ignore.html","excerpt":"前言 以下内容根据Git Help以及Git Docs 整理翻译 Ignoring files(忽略文件) 有时候会有一些我们不想Git 提交一些文件到GitHub/GitLab，下面有几种方式让我们告诉Git来忽略哪些文件. Create a local .gitignore（创建局部/本地的.gitignore文件） 如果在local repository（仓库）中创建一个名为.gitignore的文件，在你commit（提交）动作之前，Git 将会读取*.gitignore文件去判断哪些文件或者目录需要忽略掉. 同时这个文件应该push到remote repository, 这样cl","text":"前言以下内容根据Git Help以及Git Docs 整理翻译 Ignoring files(忽略文件)有时候会有一些我们不想Git 提交一些文件到GitHub/GitLab，下面有几种方式让我们告诉Git来忽略哪些文件. Create a local .gitignore（创建局部/本地的.gitignore文件） 如果在local repository（仓库）中创建一个名为.gitignore的文件，在你commit（提交）动作之前，Git 将会读取*.gitignore文件去判断哪些文件或者目录需要忽略掉. 同时这个文件应该push到remote repository, 这样clone该repository的用户都会共享ignore的规则. 当然GitHub上维护了一个官方的、针对许多流行的操作系统、环境、语言的.gitignore 文件样例 在终端，定位到Git repository所在位置，输入以下命令来创建.gitignore文件（当然在windows环境可以直接在仓库位置鼠标右键创建名为.gitignore的文件即可） touch .gitignore注意：如果某个文件已经被提交，此时你想让git 忽略它，这是你把这个文件添加到.gitignore文件中，git也不会忽略它，此时我们必须先untrack这个文件，这样Git才会忽略这个文件 git rm --cached FILENAMECreate a global .gitignore（创建全局.gitignore文件） 通常我们会有多个repository，如果多个仓库需要的规则类似，我们还需要为每一个repository都新建一个.gitignore 文件吗？显然我们此刻需要一个全局的方式来管控所有的repository. 有两种方式来创建该全局文件： 当安装了Git之后，在git 主目录(Windows环境C:\\Users\\Fraser)下会有一个.gitconfig文件，里面指定了如下内容： [user] [core] excludesfile = D:\\\\Users\\\\fraser\\\\Documents\\\\gitignore_global.txt [user] [user] name = XXXXX email = XXXXX@qq.com也就是说我们把规则定义在gitignore_global.txt文件中就好. 或者指定其他文件， 这个文件是windows自动生成的 通过命令指定.gitignore_global的文件 git config --global core.excludesfile ~/.gitignore_global通常.gitignore_global文件也是放在主目录下. Explicit repository excludes(明确仓库忽略的文件) 如果你不想创建一个.gitignore文件并且share给其他人，你可以创建一个不需要提交到repository的规则，比如我使用IntelliJ IDEA编辑器，编辑器会生成一些相应文件，但是同事使用Eclipse，也就是说IntelliJ IDEA编辑器生成的文件规则并不适用Eclipse，所以我们需要用另外方法来处理这种情况. 用编辑器打开.git/info/exclude，将规则加载这里即可,这个git是不会提交的. Ignore 规则说明gitignore - Specifies intentionally untracked files to ignore 描述上面我们说到了我们可以采用多种方式来让git ignore文件，同时配置了这些文件，优先级是什么呢？ Level1命令行执行的命令(很少用) Level2仓库中的.gitignore 文件 Level3$GIT_DIR/info/exclude Level4全局的配置：core.excludesFile PATTERN FORMAT规则说明 空行，没有任何实际ignore意义，只是作为可读性的分隔符 “#”号开头代表该行是注释，如果在前面加上“\\”，则转义成以“#”开头 “!” 是重新让git check in 某文件的意思，但是该文件的父目录被exclude，re-include 该文件Git是做不到的. 同样可以加上”&quot;来转义，!important!.txt和!important!.txt 以“/”结束，如foo/ 会匹配foo以及foo下面的子文件夹，但是不会匹配foo/下面的任何文件. * 是通配符，如*.c，会匹配所有.c为后缀的文件 ** 的含义非常多： A leading “**” followed by a slash means match in all directories. For example, “/foo” matches file or directory “foo” anywhere, the same as pattern “foo”. “/foo/bar” matches file or directory “bar” anywhere that is directly under directory “foo”. A trailing “/**” matches everything inside. For example, “abc/**” matches all files inside directory “abc”, relative to the location of the .gitignore file, with infinite depth. A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, “a/**/b” matches “a/b”, “a/x/b”, “a/x/y/b” and so on.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dayarch.top/tags/Git/"}]},{"title":"Windows下删除过长文件路径或过长文件名的文件","slug":"Windows下删除过长文件路径或过长文件名的文件","date":"2016-09-05T07:28:25.000Z","updated":"2019-11-01T08:58:12.351Z","comments":true,"path":"/p/delete-long-name-file-in-windows.html","link":"","permalink":"https://dayarch.top/p/delete-long-name-file-in-windows.html","excerpt":"在Windows下，删除文件时报错”文件路径太长或者文件名太长”，无论是Shift+Del、进入子目录一点点删除都不可以以及使用Windows内置命令都不可以，但是我电脑中装有node，于是安装【rimraf】——是专门用于删除模块的插件 官方描述：A deep deletion module for node (like rm -rf) npm install -g rimraf 使用方法： 1. 进入project目录 cd project/ 2. 删除hybris目录及目录下所有文件 rimraf hybris","text":"在Windows下，删除文件时报错”文件路径太长或者文件名太长”，无论是Shift+Del、进入子目录一点点删除都不可以以及使用Windows内置命令都不可以，但是我电脑中装有node，于是安装【rimraf】——是专门用于删除模块的插件 官方描述：A deep deletion module for node (like rm -rf) npm install -g rimraf使用方法： 进入project目录 cd project/ 删除hybris目录及目录下所有文件 rimraf hybris 可以看到，hybris目录及其所有子目录及文件全部删除干净，非常爽。 感谢原作者的分享","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://dayarch.top/tags/Windows/"},{"name":"Node","slug":"Node","permalink":"https://dayarch.top/tags/Node/"}]},{"title":"Git配置多个账号（GitLab和GitHub）","slug":"Git配置多个账号（GitLab和GitHub）","date":"2016-08-09T02:29:32.000Z","updated":"2019-11-07T05:27:32.582Z","comments":true,"path":"/p/git-multiple-account.html","link":"","permalink":"https://dayarch.top/p/git-multiple-account.html","excerpt":"背景 现在好多公司用GitLab作为项目管理工具，自己也会有开源项目在GitHub上，按照以往的配置全局的用户貌似在这种情形下就没有作用了（公司的项目需要用公司邮箱，自己的项目需要用自己的邮箱），此时就要做Git多账户的管理与设置。 Git支持的协议 Git主要支持四中协议： file:// , git://, http(s)://, ssh://, 这里主要说明一下http(s)和ssh协议的区别。 https 和 SSH 的区别 1. 前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key (这里就是添加公钥","text":"背景现在好多公司用GitLab作为项目管理工具，自己也会有开源项目在GitHub上，按照以往的配置全局的用户貌似在这种情形下就没有作用了（公司的项目需要用公司邮箱，自己的项目需要用自己的邮箱），此时就要做Git多账户的管理与设置。 Git支持的协议Git主要支持四中协议： file:// , git://, http(s)://, ssh://, 这里主要说明一下http(s)和ssh协议的区别。 https 和 SSH 的区别 前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key (这里就是添加公钥，取得管理员的信任)，否则无法克隆。 https url 在push的时候是需要验证用户名和密码的，而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。 Git设置多账户检查本机是否已有SSH Key$ cd ~/.ssh $ ls如果存在会有两个秘钥文件id_rsa(私钥)和id_rsa.pub(公钥)，如果没有则需要下一步的创建。 创建SSH Key输入如下命令： $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;参数解析： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： Generating public/private rsa key pair. # Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]当然，你也可以不输入文件名，直接车，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），这样别人用你的机器没有密码是不可能随便push代码的，一种安全性的体现，当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了。 Enter passphrase (empty for no passphrase): # Enter same passphrase again:在此案例中，就需要输入两个email来创建个相应的SSH Key: $ ssh-keygen -t rsa -C &quot;personal@example.com&quot; (个人邮箱) $ ssh-keygen -t rsa -C &quot;company@example.com&quot; (公司邮箱)此时在.ssh 目录下应该会有下面四个文件： id_rsa id_rsa.pub id_rsa_company id_rsa_company.pub将公钥id_rsa.pub和id_rsa_company.pub 分别添加到GitHub和GitLab上，怎样添加请自行查询，至此，我们已经有两个用户（可以更多），怎样指定要连接GitHub还是GitLab呢？这样就需要解决多用户的权限问题。 多用户权限问题GitHub/GitLab使用SSH与客户端连接。如果是单用户（A），生成密钥对后，将公钥保存至 GitHub/GitLab，每次连接时SSH客户端发送本地私钥（默认~/.ssh/id_rsa）到服务端验证。单用户情况下，连接的服务器上保存的公钥和发送的私钥自然是配对的。但是如果是 多用户 （A,B），我们在连接到第二个帐号时，B保存的是自己的公钥，但是SSH客户端依然发送默认私钥，即A的私钥，那么这个验证自然无法通过, 所以需要让SSH客户端发现B的私钥。 查看系统SSH Key $ ssh-add -l如果提示： $ Could not open a connection to your authentication agent.可以输入如下命令然后重新输入：ssh-add -l $ ssh-agent bash ssh-agent bash命令解释：ssh-agent是专为既令人愉快又安全的处理RSA和DSA密钥而设计的特殊程序，不同于ssh，ssh-agent是个长时间持续运行的守护进程（daemon），设计它的唯一目的就是对解密的专用密钥进行高速缓存。ssh包含的内建支持允许它同ssh-agent通信，允许ssh不必每次新连接时都提示您要密码才能获取解密的专用密钥。对于ssh-agent，您只要使用ssh-add把专用密钥添加到ssh-agent的高速缓存中。这是个一次性过程；用过ssh-add之后，ssh将从ssh-agent获取您的专用密钥，而不会提示要密码短语来烦您了。如果出现如下提示信息说明没有SSH Key在代理中 $ The agent has no identities.下面可以手动加入SSH Key 到代理中： $ ssh-add ~/.ssh/id_rsa_company可以使用如下命令remove SSH Key $ ssh-add -D 配置config 路由文件config文件即绑定私钥和远程服务器的关系，以我的config文件为例： # 该文件用于配置私钥对应的服务器 # 默认自己GitHub的配置 Host github HostName github.com User FraserYu PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa # 公司所用GitLab的配置 Host gitlab HostName gitlab.com #(可以是域名/IP地址) User Fraser PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_company 测试输入如下命令进行GitLab和GitHub的测试(注意命令中用了Host的别名)： $ ssh -T git@github $ ssh -T git@gitlab $ git clone git@github:username/project.git 用户名邮箱配置Git全局配置和单个仓库的用户名邮箱配置，学习git的时候, 大家刚开始使用之前都配置了一个全局的用户名和邮箱 $ git config --global user.name &quot;github&apos;s Name&quot; $ git config --global user.email &quot;github@xx.com&quot; $ git config --list如果你公司的项目是放在自建的gitlab上面, 如果你不进行配置用户名和邮箱的话, 则会使用全局的, 这个时候是错误的, 正确的做法是针对公司的项目, 在项目根目录下进行单独配置 $ git config user.name &quot;gitlab&apos;s Name&quot; $ git config user.email &quot;gitlab@xx.com&quot; $ git config --listgit config –list查看当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置 除了默认的id_rsa是被git默认读取，我们每次打开终端都需要执行 ssh-add ～/.ssh/id_rsa_company， 这样十分麻烦，以MacOs为🌰，我们可以将其添加到 KeyChain Access， 执行命令 ssh-add -K [path/to/your/ssh-key]， 如：ssh-add -K ～/.ssh/id_rsa_company 即可","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dayarch.top/tags/Git/"}]},{"title":"Chrome保存网页为脱机文件","slug":"Chrome保存网页为脱机文件","date":"2016-08-08T11:23:15.000Z","updated":"2019-11-01T08:36:23.784Z","comments":true,"path":"/p/chrome-save-offline-file.html","link":"","permalink":"https://dayarch.top/p/chrome-save-offline-file.html","excerpt":"Chrome 浏览器保存网页为脱机文件 我们经常需要将一些网页保存为脱机文件，这样即便没有网络我们也可以正常的浏览，IE浏览器将网页另存为在选择文件类型的地方会有选择*.mht, 可是Chrome 却没有这个选项，接下来教大家如何通过Chrome来保存网页为mht文件 1. 打开浏览器输入 chrome://flags/ 2. 通过关键字搜索save 或 另存为如下图： 3. 点击Enable或使用，重新启动浏览器 4. 鼠标右键另存为选择类型和保存路径如下图： 5. 等待下载完成即","text":"Chrome 浏览器保存网页为脱机文件我们经常需要将一些网页保存为脱机文件，这样即便没有网络我们也可以正常的浏览，IE浏览器将网页另存为在选择文件类型的地方会有选择*.mht, 可是Chrome 却没有这个选项，接下来教大家如何通过Chrome来保存网页为mht文件 打开浏览器输入 chrome://flags/ 通过关键字搜索save 或 另存为如下图： 点击Enable或使用，重新启动浏览器 鼠标右键另存为选择类型和保存路径如下图： 等待下载完成即可","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://dayarch.top/tags/Chrome/"}]},{"title":"git 使用流程","slug":"git-使用流程","date":"2016-06-24T01:44:01.000Z","updated":"2019-11-07T06:36:00.509Z","comments":true,"path":"/p/git-workflow.html","link":"","permalink":"https://dayarch.top/p/git-workflow.html","excerpt":"Git分支管理策略 首先share一下Ruan老师的博客内容：Git分支管理策略 ，读过之后，理解Master、Develop、临时分支（feature、release、fixbug）的基本意思，这里写的就更加透彻了：A successful Git branching model， 项目中如果按照这种严格规范来执行版本的管理，应该是会取得成功的结果. 仔细阅读这个workflow深刻的体会： Git 使用实战情景说明 为什么不罗列出来Git的命令列表，因为罗列在这貌似也很难深刻理解命令的含义，也不知道怎样去使用，所以做一些情景案例来说明git命令 跟踪GitHub上开源项目 当在Git","text":"Git分支管理策略首先share一下Ruan老师的博客内容：Git分支管理策略 ，读过之后，理解Master、Develop、临时分支（feature、release、fixbug）的基本意思，这里写的就更加透彻了：A successful Git branching model， 项目中如果按照这种严格规范来执行版本的管理，应该是会取得成功的结果. 仔细阅读这个workflow深刻的体会： Git 使用实战情景说明为什么不罗列出来Git的命令列表，因为罗列在这貌似也很难深刻理解命令的含义，也不知道怎样去使用，所以做一些情景案例来说明git命令 跟踪GitHub上开源项目当在Github中遨游一阵，发现了喜欢的项目想在本地研究，同时还想跟踪了解源项目的最新动态，我们需要如下的一些步骤： Fork (分叉)在跟踪的开源项目上点击Fork，会发现分叉到你的Repo中，此时我们应用如下命令将项目clone到local Repo, https或ssh两种都可以 $ git clone git@github.com:YOUR-USERNAME/REPO-NAME $ git clone https://github.com/YOUR-USERNAME/REPO-NAME此时可以通过如下命令来查看remote的版本，即你自己的remote Repo的信息 $ git remote -v得到如下结果： https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 添加 fork 源仓库的地址我们的目的不但是要在本地修改自己想要的代码，还要了解最新的源的动态，所以我们需要用如下命令： $ git remote add originProject https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git同样应用 git remote -v命令会的到如下结果： origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) originProject https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git(fetch) originProject https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git (push)此处的originProject 可以是你取得任意的名字, 就是给远程主机取个名字 $ git remote add &lt;主机名&gt; &lt;网址&gt; Fetch源当你要跟踪源动态，就要fetch一份到本地Repo $ git fetch originProject通过如下命令查看分支： $ git branch 合并源到本地首先切换到本地master分支 $ git checkout master之后merge源到本地master $ git merge originProject/master这个地方可能会有冲突，需要解决冲突完成merge，最后将merge好的代码push到自己remote git push origin master 本地上传代码到GitHub通常会在本地写点程序，然后放到github来管理，此时我们怎样把本地的代码上传到github呢 git初始化新建一个文件夹，初始化 $ git init你的项目code应该在这个文件夹中 添加项目文件到本地Repo我们需要将本地的code添加到本地的Repo中，add . 代表添加全部文件 $ git add . 提交文件到本地Repo添加文件之后，我们需要commit文件到本地Repo，并且标记注释 $ git commit -m &quot;注释语句&quot; 在github上新建Repo在github上新建Repo，并且copy Repo的https或ssh URL $ git remote add origin https://github.com/YOUR_USERNAME/YOUR_FORK.git Pull远程代码在push之前我们需要pull remote 代码 $ git pull origin master Push本地代码到remote我们已经提交代码到本地Repo，此时我们需要push到remote $ git push -u origin master 更改远程URL在实际场景中我们会遇到Git服务器迁移了，这样我们.git仓库存储的remote repository的地址信息就是错误的，所以需要更改这个URL. 请参考Git Help之Changing a remote’s URL 如果你觉得你合并后的状态是一团乱麻，想把当前的修改都放弃，你可以用下面的命令回到合并之前的状态： $ git reset --hard HEAD或者你已经把合并后的代码提交，但还是想把它们撒销： $ git reset --hard ORIG_HEAD但是刚才这条命令在某些情况会很危险，如果你把一个已经被另一个分支合并的分支给删了，那么 以后在合并相关的分支时会出错。 Git远程操作命令详解有了基本的了解，我们还是在这里引用一下Ruan老师的博客内容，慢慢理解与体会 Git远程操作详解 和 Git常用命令清单, 同时还要把廖雪峰老师的Git教程简介：Git远程操作详解放在这里，都是最好的学习资料，后续我还会继续补充. 有疑问可以留言，加入git实用情景中.","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dayarch.top/tags/Git/"}]},{"title":"WeChatFeedback","slug":"WeChatFeedback","date":"2016-05-23T07:55:56.000Z","updated":"2019-11-01T08:57:45.837Z","comments":true,"path":"/p/english-common-model.html","link":"","permalink":"https://dayarch.top/p/english-common-model.html","excerpt":"郑重声明： 未经同意，不得转载 微信作业反馈2016 万能句型 万能句型第一发[got to get] 先附上两张图片来做一个总览，接下来逐个举例说明： 万能句型前面搭配： 序号搭配省略’ve或’s1I’ve可以2We’ve可以3You’ve可以4They’ve可以5He’s不可以6She’s不可以万能句型举例： 序号句子翻译连读音标1I got to get going我得走了2I got to get used to it我得适应某物3I got to get used to this bed我得适应这张床4I got to get Used to the new comp","text":"郑重声明： 未经同意，不得转载 微信作业反馈2016万能句型万能句型第一发[got to get]先附上两张图片来做一个总览，接下来逐个举例说明： 万能句型前面搭配： 序号 搭配 省略’ve或’s 1 I’ve 可以 2 We’ve 可以 3 You’ve 可以 4 They’ve 可以 5 He’s 不可以 6 She’s 不可以 万能句型举例： 序号 句子 翻译 连读音标 1 I got to get going 我得走了 2 I got to get used to it 我得适应某物 3 I got to get used to this bed 我得适应这张床 4 I got to get Used to the new computer 我得适应这个新电脑 5 I got to get used to waking up early 我得适应早起 6 I got to get Used to eating less 我得适应少吃点 7 I got to get Used to drinking tea 我得适应喝茶 序号 句子 翻译 连读音标 1 I got to get a life 我得得到一个生活（想象：天天宅在家里，突然醒悟对自己说这句话） 2 I got to get a nicer house 我得得到/有/买一个更好的房子 3 I got to get a girl friend 我得有个女朋友 4 I got to get an invite 我得得到/收到一个邀请 5 I got to get an extra plate 我得要一个额外的盘子 6 I got to get an apartment 我得有/买/得到个公寓 7 I got to get a coffee 我得来杯咖啡 序号 句子 翻译 连读音标 1 I got to get serious 我得变得严肃点 2 I got to get stronger 我得变得更强壮 3 I got to get taller 我得更高一点 4 I got to get healthier 我得更健康一些 5 I got to get better at sth 我得更擅长某事 6 I got to get better at doing sth 我得更擅长做某事 7 I got to get faster at sth 我得更快速于某事 8 I got to get faster at doing sth 我得更快速于做某事 [Sb] got to get more [sth] 得得到更多 序号 句子 翻译 连读音标 1 I got to get more than that 我得得到更多，比手里拥有的更多 2 I got to get more clothes 我得有/得到更多衣服 3 I got to get more money 我得得到/拥有更多钱 [Sb] got to get started [doing sth] 开始做某事，多指需要一段时间过程的事情，不是一瞬间就能搞定的 序号 句子 翻译 连读音标 1 I got to get started writing my report 我得开始写我的报告 2 I got to get started working on my project 我得开始做我的项目 3 I got to get started planning my wedding 我得开始筹划婚礼 4 I got to get started moving these boxes 我得开始搬这些盒子了 5 I got to get started cooking dinner 我得开始做饭了 [Sb] got to get [adv]副词/[prep]介词 序号 句子 翻译 连读音标 1 I got to get up 我得起床了 2 You got to get up early tomorrow 你明早得早起 3 I got to get started planning my wedding 我得开始筹划婚礼 4 I got to get started moving these boxes 我得开始搬这些盒子了 5 I got to get started cooking dinner 我得开始做饭了 [Sb] got to get back…某人得回去、回家 序号 句子 翻译 连读音标 1 I got to get back 我得回家 （有时候说回家不一定非要有home） 2 You got to get back to work[sth] 你得回去工作了 3 She’s got to get back on that horse 她得再坚持一次（俚语，之前从马上掉下来一次，再次回到马上） 4 He’s got to get back soon. 他得马上回来 5 I got to get back in the game 我得回到老行当（爱好，工作，喜好) 算是重操旧业 [Sb] got to get there…某人得到达某处 序号 句子 翻译 连读音标 1 I got to get there at 4 我得4点到那 2 You got to get there on time 你得回去工作了 3 She’s got to get there in time 她得及时到那 4 He’s got to get there before it’s too late 他赶紧到那儿，不然就晚了 [Sb] got to get out… 某人得出去/跑走/避免、摆脱 序号 句子 翻译 连读音标 1 I got to get out of here 我得离开这 2 She’s got to get out of work 她得摆脱工作（一起看电影，她工作很忙，要是想去需要先摆脱工作） 3 He’s got to get out of this relationship 他得摆脱这段关系的纠缠 4 You got to get out of bed 你得离开床（滚下床） [Sb] got to get [to smw] / [to the smw] /[smw] 某人得去某个地方 序号 句子 翻译 连读音标 1 I got to get to school 我得去学校 2 You got to get to work 你得去上班 3 He’s got to get home. 他得回家 4 We got to get to the hospital 我们得去医院 5 You got to get to the part where [SVO]主谓宾 你得去把（电视，剧集等）看到哪个段落，哪一集 [Sb] got to get [Sb][sth] 某人得给某个人送某个东西 序号 句子 翻译 连读音标 1 I got to get to you a gift 我得给你送个礼物 2 You got to get him a girlfriend 你得给他找个女朋友 3 We got to get them a car 我们得给他弄辆车 4 We got to get to the hospital 我们得去医院 5 They got to get me a job 他们得给我找个工作 [Sb] got to get [Sb][smw] 某人得送某个人去某个地方 序号 句子 翻译 连读音标 1 I got to get you to school 我得送你去学校 2 You got to get me home 你得送我回家 3 We got to get them a car 我们得给他弄辆车 4 I got to get you out of here. 我得让你离开这儿 5 I got to get this off the wall. 我得把这东西从墙上弄下来作 6 She’s got to get all this stuff into the luggage 她得把所有东西塞进行李箱 MarMar 29th 序号 句子 翻译 连读音标 1 I don’t know what to do 这个看起来也很好 2 Give it to him 把这个给他吧 3 I made an important decision today 我今天做了个很重要的决定 4 I have to leave early last night 差不多是时候了 Mar 30th 序号 句子 翻译 连读音标 1 This one looks good too 这个看起来也很好 2 I tried to talk to him 我试着想跟他聊(但他不听) 3 It’s hard to tell 这不好说 4 It’s about time 差不多是时候了 5 I can’t tell, can you 我看不出来，你可以吗 6 I’ve decided to move forward with it 我决定继续前进 Mar 31st 序号 句子 翻译 连读音标 1 What do you mean 你想表达什么，你什么意思 2 We could do that 当有人提议我们一起做一件事时，好啊，我们可以做.. 事 3 Don’t let your guard down 别放松警惕 4 It might take a while 这可能需要一段时间 5 It won’t take too long 不会花费太长时间的 6 Don’t tell me the answer 不要告诉我答案 7 I’ve decided to move forward with it 我决定继续前进 AprApr 4th 序号 句子 翻译 连读音标 1 Yep, pretty much 对，差不多 2 Keep pushing, come on 用力推，使劲 3 I always keep people at distance 我一直都跟别人保持距离 4 They have deep pocket 他们有的是钱 5 I got a backup plan 我已经留了后手 6 You guys got to keep pace 你们得跟我节奏 Apr 5th 序号 句子 翻译 连读音标 1 Stop being stupid 别傻了 2 I couldn’t help but notice 我无法不注意到 3 We’ll stop by on weekends 我们周末回过来的 4 You’re very upbeat today 你今天这是出奇的活跃啊 5 Can you stop being so loud 你不能小点声吗 6 Can you help me 能帮我一下吗 Apr 6th 序号 句子 翻译 连读音标 1 We need to take a step back 咱们需要退一步 2 I have to stop by my place first 我得先回家一趟 3 I need to go pick up my friend 我要去接我的朋友 4 I have to make up for past mistakes 我必须弥补我过去的错误 5 Can you grab me a coke 能给我带个可乐吗 6 Don’t rub my fact in it 别在伤口上撒盐 Apr 7th 序号 句子 翻译 连读音标 1 He didn’t show up for work 他没来上班 2 She dressed up for her interview 她为面试打扮的 3 You need to stand up for yourself 你要维护你自己 4 I got a backup plan 我已经留了后手 5 Can you stop moping 别再这么消沉了好吗 6 I bought my son a popup book 我给我儿子买了本立体故事书 Apr 11st 序号 句子 翻译 连读音标 1 I’d take christmas alone any day 我宁愿自己过圣诞节 2 I take classes on line 我在网上上课 3 Why don’t you ask questions 你怎么不问问题 4 I’ll take care of it 我觉得你很可爱 5 You look gorgeous 你看起来好迷人 6 You look great too 你看起来也很棒 Apr 12nd 序号 句子 翻译 连读音标 1 He gets a big kick out of it 他从这件事中收货很多乐趣 2 He wears thick glasses 他带着厚厚的眼镜 3 You look good 你气色不错啊 4 I think you look cute 我觉得你很可爱 5 Is this a trick question 你问的这个问题是个陷阱吗 6 I bought a new bookcase from IKEA 我从宜家买了个新书柜 Apr 13rd 序号 句子 翻译 连读音标 1 They make good pizza here 他们这的Pizza很不错 2 I’ve got an electric guitar 我得到了一把电吉他 3 He’s a very romantic guy 他是个很浪漫的人 4 Who’s milk carton is this 这盒奶是谁的 5 It’s all a big coverup 这全是演示 6 That’s a big cat 那只猫真肥 Apr 14th 序号 句子 翻译 连读音标 1 Either the dog goes or I go 让狗离开，要么我走 2 He sent me a gag gift for christmas 他送了我一个搞怪的圣诞礼物 3 What do you say, big guy 你怎么看哥们 4 Can we at least hug goodbye 我们能至少拥抱一下来告别吗 5 He took credit for my work 他把我的功劳占为己有 6 These are big cups 这些杯子好大 Apr 18th 序号 句子 翻译 连读音标 1 She’s so great 她真好 2 This is so unfair 这个太不公平了 3 This is sick 真变态 4 I leave for work at seven in the morning 我早上七点去上班 5 I live for dance 我是为了跳舞而生 6 Breath through the pain 咬咬牙 Apr 19th 序号 句子 翻译 连读音标 1 I lost Monica’s shoes 我把莫妮卡的鞋子丢了 2 yes, she is 她确实是 3 Let show them who’s boss 让他们看看谁才是老板 4 What does she do? 她是做什么的 5 Why is she here 她为什么在这 6 How long has she been in the bathroom 她在洗手间多长时间了 Apr 20th 序号 句子 翻译 连读音标 1 These are nice shoes 这鞋子不错 2 I think he’s shy 我想他是害羞 3 I really like this shirt 我特别喜欢这件衣服 4 This is because she doesn’t like you 这是因为她不喜欢你 5 How is she doing 她现在状态怎么样啊 6 What she like 她人怎么样啊 Apr 21st 序号 句子 翻译 连读音标 1 Go and have fun 去好好地玩 2 Houseflies live for a day 果蝇只活一天 3 What kind of food are they serving 他们提供哪些种类的食物 4 It’s cruel twist of fate 这是个残酷的命运反转 5 I have to leave for work 我得走了去上班了 6 I have faith in you 我对你有信心 Apr 25th 序号 句子 翻译 连读音标 1 Of course she likes me 他当然喜欢我啊 2 She hasn’t, has she 她没有，对吧 3 How is that possible 怎么可能这样 4 Give it back 把它还给我 5 It’s hard to say goodbye 说再见真不容易 6 Give me my credit card 把我的信用卡给我 Apr 26th 序号 句子 翻译 连读音标 1 How could that even be possible 这是怎么可能的啊 2 What are you up to 干啥啊你 3 It’s just another one of his pipe dream 这是他的另一个白日梦 4 Let’s get back to the topic at hand 咱们言归正传 5 Henry’s rock bottom lately 亨利最近想入了人生的谷底 6 Let’s look the big picture 咱们从大局着想 Apr 27th 序号 句子 翻译 连读音标 1 This is my big break 这是我的重大突破 2 This is a public place 这是公共区域 3 It’s no big deal 没什么大不了的 4 It broke down this morning 它今天早晨坏掉了 5 How bad could it be 能坏到哪去呢 6 so, how’d go 怎么样了 Apr 28th 序号 句子 翻译 连读音标 1 I think I should go 我觉得我该走了 2 I think you need to read the subtitle 我想你需要看字幕 3 We can’t stop, we got to keep going 我们不能停，我们得继续 4 oh yeah, big time 是的，相当的 5 You got to give it back 你得换回去 6 good bye 再见 MayMay 2nd 序号 句子 翻译 连读音标 1 Don’t I know you? 我好像在哪见过你 2 I did, didn’t I? 我做了，对吧？ 3 Don’t even try it 想也别想 4 I wouldn’t even care 我一点都不会在乎的 5 Listen to me 你听我说 6 Let’s move on to something else 咱们讨论下个吧 May 3rd 序号 句子 翻译 连读音标 1 Shouldn’t I do something about this 我不应该做些什么吗 2 I don’t mean to be rude 我不是故意冒犯你 3 There’s no reason to do that 没有必要这样 4 I haven’t spoken to him in years 我好几年都没和他说话了 5 Let’s move on to something else 咱们聊下一个话题吧 6 Do you believe in Santa Claus 你相信圣诞老公公吗 May 4th 序号 句子 翻译 连读音标 1 There are plenty of intelligent inventors 有很多聪明的发明家 2 I’m on a international flight to Canada 我正在坐一个国际航班去Canada 3 There are twenty presenters scheduled for today 今天安排了20个演讲者 4 There are identical twins 同卵双胞胎 5 He works in the entertainment industry 他在娱乐圈工作 6 Why won’t he listen to me 他为什么不听我的话 May 5th 序号 句子 翻译 连读音标 1 Why does he do that 他为什么那么做 2 Why doesn’t he come to me 他为什么不来找我 3 Did he mention us 他提到我们了吗 4 There he is 他在那 5 I thought he was nice 我觉得他挺好的啊 6 I think about him all the time 我一直在想他 May 10th 序号 句子 翻译 连读音标 1 I’ll take him to the store 我会带他去商店 2 I’m looking for him 我在找他 3 Let him do what he wants 让他做他想做的 4 Can you tell him for me 你能替我告诉她吗 5 I’ll give him back his book 我会把他的书还给他 6 It’s his, not mine 是他的，不是我的 May 11th 序号 句子 翻译 连读音标 1 They found a gun in his hand 他们在他收找到一把枪 2 This is his office 这是他的办公室 3 When is his birthday 什么时候是他的生日 4 Don’t push her 别逼她/别推她 5 I walked her out to the bus stop 我把她送到了车站 6 I wanna make her breakfast 我想给她做早餐 May 12th 序号 句子 翻译 连读音标 1 He really told her off 他臭骂了她一顿 2 I went to the mall with her 我跟她一起去了商场 3 You’ve got to call her 你得给她打个电话 4 Is it her birthday today 今天是她的生日吗 5 I think his idea’s good 我觉得他的主意挺好 6 Is this his wallet 这是他的钱包吗 May 16th 序号 句子 翻译 连读音标 1 Get in the car 上车 2 It’s not in there 不在那里 3 This is my first night in BJ 这是我在北京的第一夜 4 He’s out in the hallway 他在外面的走廊 5 It hit me right in the eye 正好打到我的眼睛 6 What’s that in the car 车里那个是什么 May 17th 序号 句子 翻译 连读音标 1 This is a important day for me 这对我是一个重要的日子 2 Martin said the milk is rotten 马丁说牛奶已经过期了 3 Would you like some sweetener for your coffee 你想加一些甜味剂给你的咖啡吗 4 Can you draw the curtains 你能拉上那个窗帘吗 5 I wanna help lighten the load 我想帮忙分担一些重量 6 I’ve written a letter to him 我已经给他写信了 May 18th 序号 句子 翻译 连读音标 1 I need to buy a hair straightener 我需要买一个直发加班 2 I just got a new kitten 我刚刚买了一只小猫 3 Have you seen my mittens 你看到我的连指手套了吗 4 Have you eaten yet 你吃饭了吗 5 I lost a button 我丢了一个扣子 6 Are you certain that he left 你确定他已经走了吗 May 19th 序号 句子 翻译 连读音标 1 The dentist is going to whiten my teeth 牙医将会给我的牙齿美白 2 It’s disheartening news 这是个令人沮丧的消息 3 Please enlighten me 请指引我 4 I wanna shorten my bangs 我想剪短我的刘海 5 The wall is crooked, it needs to be straightened 这堵墙歪了，需要重新调整 6 The horror movie we saw was frightening 我们看过的那个恐怖片很可怕 May 23rd 序号 句子 翻译 连读音标 1 What about you 那你呢 2 Can I get you something to drink 你想要喝点什么吗 3 That’s what you said 你就是这么说的啊 4 There’s something that you should know 有些事情你应该知道 5 Look at you, you’re mess 看看你，你一团糟 6 I thought you left already 我以为你已经走了 May 24th 序号 句子 翻译 连读音标 1 I got you flowers 我给你买了花 2 Don’t you wanna know? 你不想知道吗 3 Is that what you’re saying 你说的是这个意思吗 4 What did you do 你做了什么 5 Would you give it a rest 你能不能别折腾了 6 How could you do that to me 你怎么能这样对我 May 25th 序号 句子 翻译 连读音标 1 Hey, I’m glad you’re here 嘿，幸亏你来了 2 Should you be doing that 你应该这么做吗 3 I told you yesterday that I’m busy today 我昨天就跟你说了我今天很忙 4 He said you wanted to go home 他说了你想回家 5 I’m sorry I stood you up last night 不好意思昨天晚上放了你鸽子 6 Why would you do that 你为什么那么做 May 26th 序号 句子 翻译 连读音标 1 Did you sleep okay 你睡得好吗 2 How did you do that 你是怎么做的 3 I don’t need your pity 我不需要你的可怜 4 I brought you some books 我给你带了书 5 Why can’t you go 你为什么不能去 6 Don’t let your guard down 你别放松警惕 May 30th 序号 句子 翻译 连读音标 1 What are you talking about? 你在说什么啊 2 What’s going on 最近怎么样 3 What are you doing here 你在这里做什么 4 I’m tell you, this guys mean business 我跟你讲，他们是玩真的 5 Yeah, that’s right, keep walking 没错，继续走 6 I’m having the time of my life 我正在享受一生中最快乐的时光 May 31st 序号 句子 翻译 连读音标 1 What are you saying? 你什么意思啊 2 Quit being such a wuss 别做胆小鬼了 3 What are you looking at 你看什么呢 4 What are you trying to do 你想做什么 5 When are we starting 我们什么时候开始 6 I’m getting you home 我送你回家 JunJun 1st 序号 句子 翻译 连读音标 1 Hey, I’m talking to you 嘿，我正和你讲话呢 2 He’s going into the house 他正要走进那个房子 3 I’ve been waiting all day 我等了一整天 4 Stop shouting at me 别冲我嚷嚷 5 They’re fighting again 他们又吵起来了 6 When are we meeting 我们什么时候见面 Jun 2nd 序号 句子 翻译 连读音标 1 He keeps hitting on her 他一直在搭讪她 2 I’m putting out the cigarette 我正在把烟灭了 3 What’s he eating 他在吃什么 4 This is exciting 这个好刺激 5 I was putting on my jacket 我当时在穿夹克 6 He keeps putting it off 他一直在拖延 Jun 6th 序号 句子 翻译 连读音标 1 They aren’t coming, are they？ 他们不回来了，对吧？ 2 She couldn’t have done that 他不会做那样的事的 3 She would have asked for permission 他本来可以先征求许可的 4 I would have done it differently 如果是我我不会这么做 5 It’d been done before 早就有人做过了 6 You shouldn’t have said anything 你本来什么都不应该讲的 Jun 7th 序号 句子 翻译 连读音标 1 Where have you been ? 你到哪去了？ 2 Why are you so annoying? 你为什么这么生气？ 3 Doesn’t he know 他不知道吗？ 4 When have you ever cared about me? 你什么时候在乎过我？ 5 She would told me if she could 如果可以的话她一定会告诉我的 6 He wasn’t even here when it happened 事情发生的时候他不在这里 Jun 8th 序号 句子 翻译 连读音标 1 You need not have done that 你不需要做那件事 2 They haven’t had a chance 他们一直没有机会 3 It will do for now 暂时这样就可以了 4 It couldn’t have been him 不可能是他 5 Where’s our food 我们的吃的在哪 6 He wouldn’t have done that to you [如果是他]他不会对你这么做的 Jun 9th 序号 句子 翻译 连读音标 1 It had better be good 最好是好事 2 Where has she been？ 她到哪去了 3 It would be nice if you could cut me some slack 你要是对我要求松一点就好了 4 It couldn’t have been her 不可能是她 5 There is a good restaurant on the corner 街角有一家好吃的饭店 6 When have I ever led you wrong? 我什么时候带你走过弯路 Jun 13th 序号 句子 翻译 连读音标 1 Who did you talk to? 你和谁说过了 2 What did you do? 你做了什么 3 When did you go? 你是什么时候去的 4 Where did you put it? 你放哪儿去了 5 Why did you do that ? 你为什么这么做了 6 How did you do that? 你是怎么做到的 Jun 14th 序号 句子 翻译 连读音标 1 Who do you talk to? 你平时和谁说啊 2 What do you do? 你是做什么的 3 When do you go? 你什么时候要去 4 Where do you put it? 你平时放哪 5 Why do you do that ? 你为什么这么做 6 How do you do that? 这是怎么做到的 Jun 15th 序号 句子 翻译 连读音标 1 You got to get ahead 你得想办法出人头地 2 I wanted to talk about the future 我想聊聊未来 3 I don’t know if that’s good idea 我不知道那是不是一个好主意 4 You should come to the party 你应该参加那个聚会 5 Let me give it a shot 让我试一试 6 You want to give me a crack at it 让我试试好吗","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"English","slug":"Life/English","permalink":"https://dayarch.top/categories/Life/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://dayarch.top/tags/English/"}]},{"title":"SpringMVC之RequestMapping注解","slug":"SpringMVC之RequestMapping注解","date":"2016-01-26T02:49:59.000Z","updated":"2019-11-07T06:13:31.735Z","comments":true,"path":"/p/springmvc-requestmapping-annotation.html","link":"","permalink":"https://dayarch.top/p/springmvc-requestmapping-annotation.html","excerpt":"SpringMVC之RequestMapping注解 什么是RequestMapping注解 在SpringMVC的API中我们发现对@interface RequestMapping 有如下的定义： *Annotation for mapping web requests onto specific handler classes and/or handler methods. Provides a consistent style between Servlet and Portlet environments, with the semantics adapting to the","text":"SpringMVC之RequestMapping注解 什么是RequestMapping注解在SpringMVC的API中我们发现对@interface RequestMapping 有如下的定义： *Annotation for mapping web requests onto specific handler classes and/or handler methods. Provides a consistent style between Servlet and Portlet environments, with the semantics adapting to the concrete environment. * 翻译过来的意思就是通过在在类和方法上的限制来匹配request RequestMapping的几大属性在Spring4.2.4的API中发现RequestMapping有八大属性来mappingURL请求 value *In a Servlet environment this is an alias for path(). For example @RequestMapping(“/foo”) is equivalent to @RequestMapping(path=”/foo”). *在Servlet中value就是表示path，表示请求的路径的mapping, 支持通配符形式 method The HTTP request methods to map to, narrowing the primary mapping: *GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE. ***Http请求中有以上几种方式，我们可以通过加入method来限制mapping范围 params Same format for any environment: a sequence of “myParam=myValue” style expressions, with a request only mapped if each such parameter is found to have the given value. Expressions can be negated by using the “!=” operator, as in “myParam!=myValue”. “myParam” style expressions are also supported, with such parameters having to be present in the request (allowed to have any value). Finally, “!myParam” style expressions indicate that the specified parameter is not supposed to be present in the request. *请求参数中必须有key*等于某个value或者key必须不等于某个value，多个条件是与**的关系。 headers Same format for any environment: a sequence of “My-Header=myValue” style expressions, with a request only mapped if each such header is found to have the given value. Expressions can be negated by using the “!=” operator, as in “My-Header!=myValue”. “My-Header” style expressions are also supported, with such headers having to be present in the request (allowed to have any value). Finally, “!My-Header” style expressions indicate that the specified header is not supposed to be present in the request. Also supports media type wildcards (), for headers such as Accept and Content-Type. For instance,will match requests with a Content-Type of “text/html”, “text/plain”, etc. *和params属性类似，支持通配符匹配。 @RequestMapping(value = &quot;/something&quot;, headers = &quot;content-type=text/*&quot;) name Assign a name to this mapping. Supported at the type level as well as at the method level! When used on both levels, a combined name is derived by concatenation with “#” as separator.给mapping命名，支持在类和方法上使用该属性，联合起来的name用#来分隔 consumes *The consumable media types of the mapped request, narrowing the primary mapping. The format is a single media type or a sequence of media types, with a request only mapped if the Content-Type matches one of these media types. Examples: consumes = &quot;text/plain&quot; consumes = {&quot;text/plain&quot;, &quot;application/*&quot;} *Expressions can be negated by using the “!” operator, as in “!text/plain”, which matches all requests with a Content-Type other than “text/plain”. *consumes数组里面可以是一个或多个值，只要匹配到他们其中一个即可。 produces he producible media types of the mapped request, narrowing the primary mapping. The format is a single media type or a sequence of media types, with a request only mapped if the Accept matches one of these media types. Examples: produces = &quot;text/plain&quot; produces = {&quot;text/plain&quot;, &quot;application/*&quot;} produces = &quot;application/json; charset=UTF-8&quot; *It affects the actual content type written, for example to produce a JSON response with UTF-8 encoding, “application/json; charset=UTF-8” should be used. Expressions can be negated by using the “!” operator, as in “!text/plain”, which matches all requests with a Accept other than “text/plain”. *指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 path In a Servlet environment only: the path mapping URIs (e.g. “/myPath.do”). Ant-style path patterns are also supported (e.g. “/myPath/.do”). At the method level, relative paths (e.g. “edit.do”) are supported within the primary mapping expressed at the type level. Path mapping URIs may contain placeholders (e.g. “/${connect}”) * 以上所有属性都是来限制mapping要求的，但是常用的是params、method、consumes. 验证属性 valuevalue支持通配符的表现形式, ?表示匹配文件名中的一个字符, * 表示匹配任意一个或多个字符, ** 表示匹配多层路径的一个或多个字符, @PathVariable算是URL参数的占位符。 @RequestMapping(value=&quot;/?/testValue1/{id}&quot;) public String testValue1(@PathVariable(&quot;id&quot;) String id){ System.out.println(&quot;value测试&quot; + id); return SUCCESS; } URL: http://localhost:8080/springMVC1/demo/a/testValue1/28Result: value测试28 现在我们遇到一种情况，如果我们的id是1.2.0007.9 这种类型的字符，如果在还向上面那样来传参数只会的到1.0这样的结果，于是我们需要用到正则表达式： @RequestMapping(value=&quot;/?/testValue1/{id：.*}&quot;) public String testValue1(@PathVariable(&quot;id&quot;) String id){ System.out.println(&quot;value测试&quot; + id); return SUCCESS; } 写成{id:.*} 或 {id:.+} 都可以。 methodjsp部分代码如下： &lt;dl&gt; &lt;dt&gt;Test method&lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;demo/testMethod_GET&quot;&gt;Method_GET&lt;/a&gt; &lt;/dd&gt; &lt;dd&gt; &lt;form action=&quot;demo/testMethod_POST&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Method_POST&quot;/&gt; &lt;/form&gt; &lt;/dd&gt; &lt;dd&gt; &lt;form action=&quot;demo/testMethod_DELETE&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Method_DELETE&quot;/&gt; &lt;/form&gt; &lt;/dd&gt; &lt;dd&gt; &lt;form action=&quot;demo/testMethod_PUT&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Method_PUT&quot;/&gt; &lt;/form&gt; &lt;/dd&gt; &lt;/dl&gt;GET和POST方法很好理解，可是在DELETE方法和PUT方法中我们却加入了一个hidden类型的input，值分别为DELETE和PUT，为什么要加这个隐藏域，我们先来看一下Spring中org.springframework.web.filter.HiddenHttpMethodFilter类的一段源码： public static final String DEFAULT_METHOD_PARAM = &quot;_method&quot;; private String methodParam = DEFAULT_METHOD_PARAM; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)throws ServletException, IOException { String paramValue = request.getParameter(this.methodParam); if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; StringUtils.hasLength(paramValue)) { String method = paramValue.toUpperCase(Locale.ENGLISH); HttpServletRequest wrapper = new HttpMethodRequestWrapper(request, method); filterChain.doFilter(wrapper, response); } else { filterChain.doFilter(request, response); } }这段代码的主要意思就是如果_method中存在值，并且是post方法，那我们的servlet对这个方法进行处理，为了完成这个功能我们需要进一步在web.xml中配置这个org.springframework.web.filter.HiddenHttpMethodFilter，如下： &lt;!-- org.springframework.web.filter.HiddenHttpMethodFilter 可以将post请求转为PUT和DELETE请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;现在我们来看JAVA后台controller中的代码，如下： @RequestMapping(value=&quot;/testMethod_GET&quot;, method=RequestMethod.GET) public String testMethod_GET(){ System.out.println(&quot;This is GET method&quot;); return SUCCESS; } @RequestMapping(value=&quot;/testMethod_POST&quot;,method=RequestMethod.POST) public String testMethod_POST(){ System.out.println(&quot;This is POST method&quot;); return SUCCESS; } @RequestMapping(value=&quot;/testMethod_DELETE&quot;, method=RequestMethod.DELETE) public String testMethod_DELETE(){ System.out.println(&quot;This is DELETE method&quot;); return SUCCESS; } @RequestMapping(value=&quot;/testMethod_PUT&quot;, method=RequestMethod.PUT) public String testMethod_PUT(){ System.out.println(&quot;This is PUT method&quot;); return SUCCESS; } paramsjsp部分代码如下： &lt;dl&gt; &lt;dt&gt;Test params&lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;demo/testParams?username&amp;age=10&quot;&gt;testParams&lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;Java的Controller代码如下： @RequestMapping(value=&quot;/testParams&quot;, params={&quot;username&quot;,&quot;age!=0&quot;}) public String testParams(){ System.out.println(&quot;testParams&quot;); return SUCCESS; }params={“username”,”age!=0”}代表请求参数中必须有username和age这两个参数，同时age不能等于0. headersheaders属性同params类似，都是可以以数组的形式来进行约束。需要什么样的请求参数可以通过开发者工具来查看请求中都有什么样的参数。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Spring-Boot","slug":"Coding/Spring-Boot","permalink":"https://dayarch.top/categories/Coding/Spring-Boot/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://dayarch.top/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"annotation","slug":"annotation","permalink":"https://dayarch.top/tags/annotation/"}]},{"title":"Maven Project","slug":"Maven-Project","date":"2016-01-21T09:28:06.000Z","updated":"2019-11-01T09:05:15.895Z","comments":true,"path":"/p/maven-project-structure.html","link":"","permalink":"https://dayarch.top/p/maven-project-structure.html","excerpt":"创建Maven Web Project 什么是Maven 在Apache Maven 官网上的说明是：Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information. 翻译过来的基本意思就是：Maven是基于项","text":"创建Maven Web Project 什么是Maven在Apache Maven 官网上的说明是：Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information. 翻译过来的基本意思就是：Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工 具。 使用Maven管理项目的好处 对第三方依赖库进行统一的版本管理。 只要用了Maven就不用再为每个项目复制spring.jar和hibernate.jar了，Maven会在你需要的时候，自动把这些第三方依赖库找到，你需要编译，Maven就把这些jar包放到classpath里，你需要打包，Maven2就帮你把需要的jar包都复制到WEB- INF/lib/目录下。 统一项目的目录结构 可以保证所有项目的目录结构都是一样的，目录结构统一的好处就是，你要找源代码就去src/main/java/下，你要找需要放到classpath下的资源，就去src/main/resources/下，你要找单元测试对应的代码和资源，就去src/test/下。每个目录下放什么东西，程序编译，发布的时候，每个目录起什么作用都很清楚明了，不会出现打开项目找不到要找的文件的情况。 统一软件构建阶段 Maven2把软件开发的过程划分成了几个经典阶段，比如你先要生成一些java代码，再把这些代码复制到特定位置，然后编译代码，复制需要放到 classpath下的资源，再进行单元测试，单元测试都通过了才能进行打包，发布。 支持多种插件 在http://maven.apache.com/和http://mojo.codehaus.org/上可以找到大量的Maven2插件，通过这些插件可以完成多种多样的扩展功能。 以上只是概念性的东西，陆续会用实例证明以上好处 下载及安装Maven 访问Maven 下载： 以Windows 环境为例，将下载的apache-maven-3.3.9-bin.zip 解压到某一磁盘目录下，apache-maven-3.3.9 作为MAVEN_HOME 目录， 新建本地Maven仓库（Repository），编辑apache-maven-3.3.9\\conf\\setting.xml 文件，在本地建立仓库（任意一次盘文件夹下即可） 环境变量可配置也可不配置，如果用到命令行必须要配置环境变量。 新建系统变量MAVEN_HOME, 并指定目录：E:\\Java_Web\\apache-maven-3.3.9-bin\\apache-maven-3.3.9 编辑系统变量Path，增加%MAVEN_HOME%\\bin; 命令行下（cmd）检测Maven 版本： mvn -v Eclipse下配置Maven 现在新版本的Eclipse已经集成了Maven插件，在Windows-Preferences-Maven节点下的Installations添加Maven, 最后勾选上添加的Maven。 在Windows-Preferences-Maven节点下的User Setting设置setting.xml 文件 ### 新建Maven Web Project 鼠标邮件New Maven Project 选择Artifact ID 填写required text pom.xml 上鼠标邮件run as Maven install, 会发现关于这个项目的war包在Maven仓库中已经生成 常用MVN命令 mvn help:system 自动在本用户下创建 ~/.m2/repository mvn clean compile 清理编译 mvn clean test 清理测试 mvn clean package 清理打包 mvn clean install 清理将打包好的jar存入 本地仓库 注意是本地仓库 mvn archetype:generate 使用Archetype生成项目骨架 mvn clean deploy 根据pom中的配置信息将项目发布到远程仓库中 Maven项目目录结构说明 src/main/java :正式内容包路径 src/mian/resources :正式的配置文件路径 src/test/java :测试包路径 src/test/resources :测试的配置文件路径 src/main/webapp : war 资源目录 更多更多关于IntelliJ IDEA 下创建Maven项","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"DevOps","slug":"Coding/DevOps","permalink":"https://dayarch.top/categories/Coding/DevOps/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://dayarch.top/tags/Maven/"}]},{"title":"English","slug":"English","date":"2016-01-15T09:43:37.000Z","updated":"2019-11-01T08:39:34.656Z","comments":true,"path":"/p/spoken-english.html","link":"","permalink":"https://dayarch.top/p/spoken-english.html","excerpt":"连读 1. You’re gonna wanna get more experiences before you apply before 可以读成 /b fɔr/， you和apply之间加w的音 2. I just wanted to have a look at her resume before you hired her wanted to 读成 /wa nI tə/， nt+vowel,省t wanted=/wɑntɪd/=/wɑnɪd/, at her 读成/æ dər/ hired her 同理不发","text":"连读 You’re gonna wanna get more experiences before you apply before 可以读成 /b fɔr/， you和apply之间加w的音 I just wanted to have a look at her resume before you hired her wanted to 读成 /wa nI tə/， nt+vowel,省t wanted=/wɑntɪd/=/wɑnɪd/, at her 读成/æ dər/ hired her 同理不发h的音 *Give up or make decision because you can’t have it both ways * give up or 读成/gɪ vʌ pər/ , because 读成/kɔz/, 同时注意 can’t和can的读音区别 Didn’t it seem kinda cold last night Didn’t it /dɪ dɪn nɪ/ And your daddy didn’t understand？ / ə njər dæ di dɪ ‘ə nʌn dər sdænd?/ How does he expect me to buy stuff / hɑu dʌ ziks bekt mi də bɑi sdʌf?/ You’re probably gonna wanna train the new intern because he is hopeless** probable可以省略中间的b的音 /‘prɑbəli/ new intern之间加w的音， because he is /kɔ zɪs/ Look I’m really tired, so can we go home? look I’m /lʊ kai m/ Who else wants to see a movie? who else 中间有w的音 see a 中间有j的音 Oh,we do, but not just yet. /Ouwi dµ, bʌ’ nɑ’ dʒʌ sje’/ But it won’t work out /bʌ’ɪ’ woun’ wər kɑu’/ This might be a bad idea be a 中间有j的音 idea中间也有j的音 But I’m gonna do it anyway What if I had taken that job at Merrill Lynch? /wʌ dɪ fɑi hæ’ tei kɪn ðæ’ dʒɑ bæ’ meər rəl lintʃ? / Well, why didn’tyou take the job? /Wel wɑi dɪ ‘ən tʃµ teik ðə dʒɑb/ Do you not wanna be seen with me? /də jμ nɑ’ wɑ nəbi sin wɪθ mi?/ ** we’renot gonna hide it anymore.** /wər nɑ’ gʌ nə hɑi dɪ dæ ni mɔr / Here, let me give it a shot 让我试一试 give it a shot /ɡɪ vɪ də ʃɑ/ When are we gonna hang out? 我们什么时候出去玩一玩 when are we /we nar wi/ This isn’t what I wanted wanted /wɑnɪd/ Matt can’t be that fat, can he? 重音： can’t、 that， can he /cæni/ It’d’ve been nice to go out today It’d’ve = It would have /I’ dI dIv/ when am I going to get promoted when am I /we nə maɪ/ Is it a school night and she has a lot of homework to do? /ɪ zɪ də sguəl nɑi’ ən ᵗʃi hæ zə lɑ də houmwərk tə dµ/ When’s her birthday? /wen tsər bərθ dei/ Would you give it a rest 你省省吧，休息一下吧， （不要喋喋不休了，能停停吗） He is gonna wish he was never born wish he /wɪʃi/ 此处省略h could you… hold out that ring and ask me to marry you? /kʊ dʒµ… houl dɑu’ ðæ’ riŋ ŋən… æs mi də mæ rijµ?/ that 咬舌停顿，略读 How much is it? /hɑu mʌ tʃɪ zɪ’ ?/ 重音在is上 I thought that it mattered what I said or where I said it /ɑi θɔ’ ðæ dɪ’ mædərd wʌdɑi sed, ɔr weərrɑise dɪ’/ He knows what it’s about /hi nou zwʌ dɪtsə bɑu’/ You wanted it to be a surprise. / jµ wanɪ dɪ’ tə bi jə sә’praiz / I never had a bike of my own /ɑine vər hæ də bɑi kə mɑi ʲoun / Not really, I got to drag him around, too! / nɑ’rɪlli, ɑi gɑ’ tə dræg hɪ mə rɑun’ tµ! / (注意是gɑ’ tə， 表示“我也有拖着他跑的”， 不是“我得拖着他跑”) I’m sorry we can’t store your childhood things anymore. /ɑim sɔr ri wi kæn’ tsdɔr jər tʃɑild hʊ’ θiŋ ze nimɔr./ ** I used to love to play restaurant.** /ɑi jµs tə lʌv tə plei res dər rɔn’/ She’s not as pretty as she was when she was 29 /ʃis nɑ dəz prɪ di ʲæ ʃi wʌz wen ᵗʃi wʌz twe ni nɑin/ Ms. Greene would like to establish some ground rules before she comes out /mɪs grin wʊ’ lɑik tµ ʷɪs dæblɪʃ sʌm grɑun’ ruəlz bə fɔr ʃi kʌm zɑu’/ No, I love it.Thank you /nouʷɑi lʌvɪ’ θæŋkjµ/ Now that you’re a couple, we don’t get two presents from you guys? /nɑuðæ’ jər rə kʌpəl, wi doun’ge’ tµprezɪnᵗs frʌ mjµ gɑiz?/ you have got to try this cheesecake /jµhæv gɑ’ tə trɑi ðɪs tʃiz keik / Somebody sent it to us /sʌmbɑ di se nɪ’ tµ ʷʌs/ I’ll be right with you /ɑlbi rɑi’ wɪ θjµ / I was not staring at her /ɑiwʌz nɑ’ tsdeər riŋ ŋæ’ hər/ In college, Ross used to wear leg warmers! / ɪn kɑ lɪdʒ, rɔs jµs tə weər le gwɑər mərz/ Monica couldn’t tell time ’til she was 13 /mɑ nɪ kə kʊ ‘ən tel tɑi mʌn tɪl ʃi wʌz θər tin/ We used to be very close / wi jµs tə bi ve ri klous/ It’s not a big deal! /ɪts nɑ də bɪ’ diəl/ What did you say when you made up your vows? / wʌ dɪ dʒµ sei we njµ mei dʌ’ jər vɑuz?/ I am supposed to be writing my vows and all I have is this! /ɑim sʌ pous tə bi rɑi diŋ mɑi vɑuz ə nɑl lɑihæv ɪz ðɪs./ Those boots are amazing /ðouz bµ tsɑər rə mei ziŋ/ 金牌音标 /v/ 同“飞”的口型，喉咙震动 never ever over very give have love everything every even move believe leave everybody haven live five everyone whatever drive leaving moving alive movie giving forever lovely given evening cover seven leaving loved voice above evil save government forgive private /ð/ 舌头放在上下齿之间或者舌头顶在牙齿上，喉咙震动 the than those that other this these there then they mother father another together brother though either rather others /ʒ/ /ʃ/ 英文单词以sion sure sual rsion为结尾的包含ʒ音，同she的口型，嘟起嘴唇，喉咙震动, 注意不同于汉语的“湿” conclusion confusion decision division occasion provision television visionexposure measure pleasure disclosure, enclosure, leisure, treasure*usual visual casual *aversion conversion dispersion immersion perversion versionaction cooperation inflation situation appreication /ai/ /au/ /n/ 发/n/ 舌头要贴上颚 /ai/ 阿姨 behind bind blind wind find mind /au/ 啊屋 /aun/ 联想“云”字bound hound count mount pound found down brown town downtown /‘ən/ /ə/ 嘴巴全部放松喉咙震动， 很懒很放松的“饿” certain certainly fountain(喷泉，泉水) mountain curtain（窗帘） shorten written bitten gotten sweeten（减轻，使变甜） forgottten kitten(小猫) mitten(手套)/tən/ 通常drop t /‘əl/ /ə/ 嘴巴全部放松喉咙震动， 很懒很放松的“饿” /l/ 舌尖向上卷碰到牙齿, 嘴唇不动， 拉长“楼”的音 *people able pull bicycle table uncle principle deal heal meal rural actural formal legal * /r/ 舌头向后上转是正常的r（在末尾） 动作回去就是r的另一个发音（在开头）， 通常r 既在末尾又要在开头都发音， 如teacher is /titʃɚr rIs/ r在开头： rain ring read ride role roomr在末尾: wider easier higher dear poker /t/ /d/ 清辅音和浊辅音就是喉咙有没有震动,用气弹那么一下talked take top installed leged learnt student /ʊ/ 类似于“饿”的读音， 但是没有“饿”这个音喉咙那么用力 good look book took hood cook could would should put /i/ /ɪ/ 将“叶”字分解. *it, fit hit bit itch(痒) lip sit * 美语口语2016.3.2 Future WorldJ: ** Did u hear the Apple Pay is coming to China? It means we can *pay with our Iphone, isn’t that nifty* pay with: 用… 支付; nifty: /‘nɪfti/ X: That’s pretty slick, who would’ve thought that one day we could make payments with a mobile phone? Technology seems to make our lives better and better, what do u think the future has in store for us over the next 50 years slick 等同 nifty，表示高科技的小物件比较酷who would’ve thought that one day… 谁能想到有一天…sth has/have in store for 等同于 sth will happen in the future J: I think *things** will continue to get smaller, Maybe one day our cellphone will be the size of a grain of rice* things 日常的东西cellphone 在美国手机经常用这个词the size of a grain of rice 米粒儿一样的大小 X: * That’d be pretty cool! Maybe it will be implanted in our bodies, we’ll see a greater integration between man and machine* That’d be pretty cool 一种猜测，虚拟语气implant 植入integration 集成 IC卡（Integrated Circuit Card） J: I think VR(virtual reality) is the next big thing, I bet stem cell research will make great strides as well, maybe we can grow a new in the lab(laboratory) organ instead of transplanting some else’s the next big thing 成为主流，something that is not popular now, but will be popular and mainstream in the futuremake great strides 取得更大进步stem cell 干细胞 X: I’d rather work than become a *couch potato*** couch potato 沙发土豆 指懒人 2016.3.7 Online LearningX: I thought you were supposed to have class now? what are you doing at your home? were supposed to 本应该干什么却没干 J: I’m having class, can’t you see? have class 上课 X: What do you mean? you’re at home on your computer what do you mean? 什么意思？ 期待对方给予答案on your computer 面对电脑. I’m on my computer 我正在用电脑. on the internet 上网. I’m on the bus 我在公交车上 J: Come on, *get with the times,** a lot of people are taking classes online now, it’s perfect for workaholics(工作狂) like me, not only that, you can go online and learn just about anything, right now, i’m studying economics. The best thing is I can choose the time I want to study, the time isn’t set in stone* get with the times 跟上时代的潮流take class = have class 上课 (where are you taking class? i’m taking class online)not only that 不仅如此just about anything 几乎所有的事情/东西， just在这里指几乎economy 经济 economics 经济学 economist 经济学家set in stone 设置在石头上，表示“固定,永久不变的”， isn’t set in stone 不固定 X: I had no idea that you could learn online have no idea 是完全不知道， i don’t know 有时候还表示一些不确定在里面 J: You should jump on the bandwagon and study online too jump on the bandwagon 跟上潮流. keep up with trend, trend本身就是一个大的趋势，所以千万不要写big trend， 从汉语的解释big就是累赘 X: I’d love to, Maybe next semester I can pick some online classes, Right now my *thesis** is driving me bonkers* thesis /‘θisɪs/ 比较正式的论文drive me bonkers/nuts/crazy 让我抓狂 J: What do you so stressed about? I thought you had the whole semester to get it done stress about 抓狂（什么东西压着你） X: Yeah, I did, but I procrastinated until the very last minute, Now i’m paying the price procrastinate /pro’kræstɪnet/ 耽搁、延迟pay the price 付出代价 J: Just take it easy, Rome is not built in a day, you know? Rome is not built in a day 罗马不是一天建成的 J: * Good thing you are here, my computer crashed, now i can’t boot it, I have to finish my homework by the end of the day, can you help me out， I’m really pressed for time with this homework* good thing 幸亏， 类似于thanks god.crashed 可以表示电脑死机boot 启动 boot an electronic device (启动电子设备)by the end of the day 截止到今天help me out 帮我渡过难关/困难pressed for time 时间紧迫 X: * You scratch my back, I will scratch your back, it’s only fair* you scratch my back, i’ll scratch your back 你挠挠我都后背，我挠挠你的后背，指互帮互助 J: Alright, you win， It works, you really are *a Jack of all trades*** a Jack of all trades 某人各种工作都干得很好，一个什么都会做的人 表示什么都会 X: So you are gonna *renege on our deal? *that’s cold renege on our deal/go back on your words/go back on your promise 反悔that’s cold 一种心理描述， “太不靠谱了” 心灰意冷 2016.3.10 Visiting a friend in the hospitalJ: What a pleasant surprise I’m so happy to see you 表示非常高兴 X: How ya doin’, Sis? I thought I’d pay you a visit, I bet you are pretty lonely here in the hospital all by yourself How are you doing? 在口语中可以说 How ya doin’, 表示问候“怎么样了”pay a visit to sb = pay sb a visit (拜访某人) J: That’s so sweet of you, my mom just left a few minutes ago, I’m surprised you didn’t bump into her as you were coming up so sweet of you = so kind of you (你真好)bump into sb (偶然遇到某人， 强调偶然性) X: Oh rats, That would’ve been great to catch up with her, I haven’t seen her in ages, anyways, how’d your operation go? oh rats 真可惜，很可惜catch up with sb (Talk with someone who you haven’t seen in a long time 和很久没见的人唠嗑聊天)I haven’t see her in ages (我好久没见到她了， long time no see)How’d (did) your operation/holiday/birthday go? (… 过得怎么样)？ J: It was success, The doctor said I will be back to normal in no time, Although, i’m feeling a little woozy(头晕) from the anesthesia(麻药) I will be back to normal in no time = I’ll get back on my feet soon = I’ll fully recover soonanesthesia /,ænəs’θiʒə/ 麻药 X: That’s a relief, I would’ve come earlier had I known That’s a relief (那我就放心了) J: Two days ago, I was helpig my mom do the dishes when I slipped and fell on my knee,Thankfully, we didn’t have to call ambulance, my mom rushed me to the ER(emergency room) do the dishes 洗碗thankfully 非常幸运地rush sb to smw = send sb smw quickly (飞速的把某人送到某地) X: Good thing your mom was there to help you out. I brought you some stuff to munch on, beef jerky, your favorite munch on = to snack on = to eatbeef jerky 牛肉干 pork jerky 猪肉干 J: This will make me feel even better, I should stay in the hospital a little longer, I don’t mind being pampered by you pamper /‘pæmpɚ/ to take really good care of someone 精心照料 X: Is there anything I can do for you (常用口语， 我能为你做些什么事情吗)J: You can go pick up some medicine for me at drug store, take this prescription and get me three bottles of painkillers and three bottles of penicillin, The drug store is on the first floor to the left of entrance, on your way back, help me ask the nurse on duty, if I’ll be able to come home tomorrow drug store = pharmacy （药房）prescription 处方， painkiller 止痛药， penicillin 青霉素The drug store is on the first floor to the left of entrance （注意描绘方位）on your way back 在你回来的路上on duty 值班 2016.3.14 Negotiating with LandlordsL: After seeing the apartment, are you satisfied with everything? be satisfied with 对… 满意look for a house/place 找房子 X: I think so, I just have a few questions if you don’t mind if you don’t mind 如果你不介意，一种非常客气的说法，可以放在句子开头也可以放在句子末尾 L: Okay, shoot shoot 非常口语化的表达“请直说，但说无妨，问吧” X: I’m on the fence about choosing the big room or the small room, they are both very nice I’m on the fence about sth/doing sth 表示“不大确定，还在犹豫”to sit on the fence “墙头草“的意思 he is to sit on the fence L: If I were you, I’d pick the bigger room, it’s closer to the bathroom and the view is facing the city, it’s really the best of both worlds the view is facing the city 窗子冲着市区景色it’s really the best of both worlds 两全其美 X: You’re right, I’m a sucker for beautiful scenery, Okay, i’m sold, the big room it is, what’s the next step? I’m a sucker for sth 我对… 没有抵抗力i’m sold 我要了/我买了the big room it is 就是这个大房间了， .. it is 表示就是.. 了 Pizza it is 就是披萨了 L: If you are sure you’d like to live here, we require that all of tenants sign a one year lease agreement, then I need your John Hancock here lease agreement 租约， 通常连用John Hancock 签名 = autograph (所有签名的单词都可以通用在任何场合) X: There you go, are we finished?L: That’s it, here is your key, you’re free to move in anytime, if you have any question, please give us a call and we’ll glad to assit you move in 搬进来，入住 L: Hello, Mr. Gao, how is the new apartment?X: Well.. it’s great, but there is a slight problem slight problem 小问题，一种委婉的说法 L： What’s the matter?X: There’s a huge pest(害虫、虫子、有害之物) problem in the kitchen, I’m worried that it might come into my room *L: *What kind of pests are we talking about?X: Roaches roach (蟑螂) 全程cockroach L: I’m very sorry to hear that, have you tried cleaning the kitchen thoroughly(彻底地，完全地)X: That’s why I came here, isn’t there something that you can do?L: I’m afraid notX: But you are my landlord, I thought your slogan was “above and beyond the call of duty” slogan 口号above and beyond the call of duty 竭尽全力做某事，全心全意做某事 L: You mustn’t have read the fine print in the contract. it says here on line 217 that we are not responsible for any bug infestations fine print 小字体 large print 大字体infestation /ɪnfɛs’teʃən/ 感染，侵扰 X: I see， in that case, I’ll have to hire a prefessional to get rid of the bugs in that case 那么，在这种情况下get rid of 清除.. 2016.3.16 House of CardsJ: Hi,Xiaogao, why do you have those bags under your eyes, have you not been sleeping well lately? bags under one’s eyes = to have dark shadows under one’s eyes, usually from a lack of sleep (由于睡眠不足导致的黑眼圈) X: You can say that you can say that (你可以这么说） 等同于yes，表示肯定 J: Care to elaborate? care to elaborate = can you please explain? 能解释一下吗？ 详细说说？ X: I’ve been binging on House of Cards lately, season 4 came out last week, and my eyes have been glued to the screen ever since binge on sth/doing sth = to over indulge in sth 过渡做某事， 这里指疯狂追剧纸牌屋binge drinking (酗酒，豪饮)come out 上映， 多用于影片one’s eyes have been glued to the screen = to be infatuated with a movie or show to the point where you don’t want to do anything 眼睛贴在屏幕上了，意指沉迷于电影或电视节目而无心做其他事 J: Season 4 is already out? I just remember just a few years ago when the first season came out back in early 2013. It seems like just yesterday It seems like just yesterday （used to refer to something that isstill fresh in one’s memory） 恍如昨日的感觉 X: Yeah, I’m hooked on it, I think it is so cool that Netflix was able to make such a successful online-only web television series, They really broke new grounds Be hooked on sth = to be addicted to sth 沉迷于某事，上瘾hook uponline-only web television 只在网络上播放的网剧break new grounds （to accomplish something that hasn’t been accomplished before） 完成从未被完成过的事，常指开创新局面 J: Did you know the first season received nine prime time Emmy Award nominations, The whole world seems like to love this political drama receive .. award 获得.. 奖项political drama （A drama series that has a political background） 有政治背景的剧集 X: I think Kevin Spacey and Robin Wright’s acting is outstanding! The first three seasons kept me on the edge of my seat during each episode. I love Neve Campbell’s performance in season 4! She’s one of my favorite actresses of all time. outstanding 这里指演技出神入化，很棒[Something] keeps you on the edge of your seat = [something] is very suspenseful 非常具有悬念的某事 这里指很刺激of all time 一直以来 J: So, how is season 4? I heard there are some similarities(相似之处) between season 4 and the American election campaign. Is that true?X: That’s right! There certainly are parallels（相似之处） between season 4’s script and the 2016 primary campaign. Are you sure you want me to go into specifics? It might spoil（剧透） it for you? Go into specifics = talk about something in detail (详细说，仔细解释) J: On second thought, I think you’d better wait until I watch itmyself. on second thought 经过再一次考虑 X: Well, all I can say is get ready for more suspense and nail-biting drama! It’s so fun to watch Frank Underwood climb up the ladder of power! all that I can say is = what I can say is （具体查看语法定语从句）nail-biting (咬指甲，指非常刺激的剧情)climb up the ladder = to ascend in rank, power, or status （字面爬上梯子，意指达到某种权力) 2016.3.23 Artificial IntelligenceJ： I didn’t know you played Go(围棋)X: I don’t, but I really wanna learn it, Did you hear about the amazing archievement of Google’s AI robot AplhaGo? hear about 听说archievement 成就，非常大的词汇，表示很了不起的成果 J: I heard about it, why are you so excited? *X: *Because it’s the first AI program that could beat a professional player at the most complex board game mankind（人类） has ever created. board game 棋盘游戏 J: I thought computers have been able to beat humans at chess for a long time, what’s the big deal? for a long time = in ageswhat’s the big deal? 有什么大不了的，多大的事 X: You’re right, but there is a huge difference between chess and Go, computers could easily beat humans because it’s way less complicated. computers don’t need to be smart to win at chess, they just need to be fast, a computer can use technique called brute forceto(BF) win at chess, this is not possible with Go, AlphaGo use reall AI called deep learning in order to solve problem. there is a huge difference between A and B (A 和 B有很大的不同)way less complicated (此处的way相当于very /much)deep learning (深度学习)win at sth （赢得什么/取胜） J: I think I understand now, but why does this matter for mankind? why does this matter for mankind? (但此事为何对人类事关重要？) X: such as complex weather conditions,disease control, and global warming issuesJ: I heard the AI robot only won 4 out of 5 matches. Does that mean that AI has room for improvement? 4 out of 5 五分之四 四分之三：three fourths= three quarters 五分之三：three fifths 分数的表达法：分子用基数词,分母要用序数词,分子大于1时,分母的序数词后加s.对于四分之一,常用quarter来表示.sth has room for improvement （sth 还有进步空间） X: That’s right. The robot isn’t perfect, but it certainly impressed the entire world. Some of AlphaGo’s moves were described as “beautiful” by Go fans. sth impressed sb （.. 给某人留下深刻印象）AlphaGo’s moves 此处的move表示棋路 J: This is getting scary. Are robots going to take over the world? take over (控制/接管) X： Although Google’s AI victory marked a major milestone for artificial intelligence, the world is still a long way away from mimicing true human intelligence. mark a major milestone (标识一个重要的里程碑)mimic /‘mɪmɪk/ vt. 模仿，摹拟A long way away from… = 与…差得很远 2016.3.28 HoroscopeJ: We’ve already talked about the first six zodiac signs, I think it’s time we talk about the last six . Pop quiz first six 前六个 last six 后六个pop quiz 考考你 X: These people love justice(公正) and fairness（公平）， they also work well with other people work well with sb 非常融洽的和某人合作、 配合默契 J: Libras are known to be cooperative(有合作精神的), they don’t like violence（暴力） or injustice（不公正） of any kind.X: Scorpios seem quiet and cool on the outside, but they are actually really emotional(内心感情丰富) and passionate(富有激情) on the inside on the outside 外表 on the inside 内心 J: I heard they make really great leaders, they don’t like being lied to, so make sure you’re always honest to a Scorpio make great leaders 非常会做领导 注意make的用法 X: Sagittarius are deep thinkers deep thinkers 思想家/思想者 J: They are really extroverted and optimistic, it’s hard for a Sagittarius to feel down， we’ve finally reached the last three zodiac signs(星座) extroverted/introverted (外向的/内向的)optimistic/pessimistic （乐观的/悲观的）feel down (不开心，情绪低落)reach 到达， 到达了最后三个，就代表剩下三个 X: These people is known for their professionalism and traditional values , they are really serious people professionalism and traditional values （专业精神和传统价值观）serious people (严肃认真的人， 高冷) J: Let’s move on, it should not surprise you that the symbol of Aquarius the water bearer, they can also be boisterous and energetic. They love to lend a helping hand to those in need. it should not surprise you (毫无疑问，不会让你感到惊讶)boisterous /ˈbɔɪ.stɚ.əs/ 喧闹的, 精力旺盛的lend a helping hand to sb 帮助某人 X: The Pisces is a very gentle and affectionate(深情的，有爱心的) person. They are there for you when you need to spill your guts. Why would I want to be like you? spill your guts 说心里话why would I wannt to be like you? 为什么我要像你一样？ 十二星座 Aries /ˈer.iːz/ 白羊座 Taurus /ˈtɔːr.əs/ 金牛座 Gemini /ˈdʒem.ə.naɪ/ 双子座 cancer /ˈkæn.sɚ/ 巨蟹座 Leo /ˈliː.oʊ/ 狮子座 Virgo /ˈvɝː.ɡoʊ/ 处女座 Libra /ˈliː.brə/ 天秤座 Scorpio /ˈskɔːr.pi.oʊ/ 天蝎座 Sagittarius /ˌsædʒ.əˈter.i.əs/ 射手座 Capricorn /ˈkæp.rə.kɔːrn/ 摩羯座 Aquarius /əˈkwer.i.əs/ 水瓶座 Pisces /ˈpaɪ.siːz/ 双鱼座 2016.3.30 Airport EnglishXiaogao is at the airport checking in(办理登机), Jingjing plays the part of the airline employeeJ: Hello sir, where are you flying today? (您此行飞往何处？)X: I’m headed to Detroit. be headed to smw 前往某地， 不能指从外地回家Head to = to go to 去（往）某地 J： Can I please see your passport? do you have any goods to declare? declare 申报， 指过海关的申报 X： Here’s my passport, no goods to declare this time.J: Okay, will you be checking in any bags? check in (既可以指办理登机，也可以指托运行李，此处是后者) X: Yes, Just this oneJ: Please place it on the scale, oh *your bag is overweight（超重）, I’m afraid you’ll have to pay a small fee*** place it on the scale(秤: a device to measure weights) 把它放在秤上pay a small fee (此处要用fee， tip指吃完饭给的小费)I’m afraid that （恐怕…） I’m afraid of (害怕…) 注意二者的区别 X: That’s fine, here you go(给你)J: Here’s your boarding pass, you’ll begin boarding at 10:05 at gate D12 boarding pass (登机牌) X: Thanks ma’am ma’am /mɑːm/ 对女士饿一种礼貌的称呼，不在乎结婚与否 Xiao Gao is going through the security check. Jing Jing plays the part of the customs agent go through 通过security check 安检 J: Please take your laptop out of your bag and place it in a bin(指安检的小盒子)X: No problem, should I take my shoes off too?J: Yes, sir, you can put your shoes in another bin, please step through the metal detector. step through （走过） 注意和go through的区别metal detector （金属探测器） X: I’m gonna have to pat your down, do you have any metal items in your pockets? pat one’s down (很形象的说明“搜查身体”， 原意是拍拍你的身体) to search someone’s clothes for items they shouldn’t have J: No, I think it might be the belt buckle, it’s made of metal. belt buckle (皮带扣) X: You are free to go, don’t forget to grab your things grab sth （拿上某物）grab a bite to eat/ grab sth to eat Xiao Gao is onthe airplane getting ready to take off. Jing Jing plays the part of the stewardess(指空姐) Flight attendants/stewardess 空乘人员 J: Here is a hot towel(毛巾) for you.Would you care for a pair of head phones? care for sth (需要…)head phones (耳机) X: I will take a pair(指一对耳机)， BTW， could I have a cup of water, please?J: Coming right up, and here’s some peanuts(花生) and pretzels（椒盐脆饼） for you to snack on. coming right up (马上送过来)snack on = munch on (食用, 当零食吃) X: Thanks! Those are my favorite! favorite 此处是形容词作名词，直接单数形式 The captain makes an announcement（机长开始广播）Good morning ladies and gentlemen. This is your captain speaking. We have been cleared for takeoff(名词：起飞). We’ll be leaving in just a few minutes. Please sit down and fasten your seatbelts. We expect to arrive in Detroit in 12 hours. Thank you for flying with Happy Airlines. Flight attendants, prepare for takeoff! 扩展翻译 哪里是落地签办理处？Where can I find the visa on arrival office? 我在28号安检口等待安检I’m waiting at gate 28 for a security check 可以免费托运多重的行李？What’s the heaviest amount of luggage that we can check for free? 转机时是否需要取行李?行李可以直达目的地吗？Do I have to grab my luggage during connecting flights? Can we send my luggage directly to my destination? 紧急出口在哪儿？Where’s the emergency exit? 2016.4.6 CampingJ: What are you gonna do for the weekend? what are you gonna do/what are you plans/what you have in mind for the weekend? 周末打算做什么 X: I haven’t decided yet, it’s still up in the air as to whether I’ll go camping with my friends or go bike riding through the countryside(郊外). I haven’t decided yet. （注意加上yet更加完整，表示“我还没有决定”）sth is still up in the air （某事还没决定，此处是事没确定）sb is on the fence about sth （某人还在犹豫某事， 此处是人在犹豫）as to （至于…. ） J: Both of those things sound really tiring. why don’t you stay in town and hang out with your friends? tiring: sth is tiring that makes you tired.注意hang out 和 play的区别, play跟多的是指小朋友之间的玩耍，hang out 指逛街之类的 X: I’m an outdoorsman, I love nature, and besides, lately the weather has taken a turn for the better. outdoorsman （户外运动控）take a turn （转个弯，变化） 多数用于天气/身体 take a turn for the better/worse J: I guess different things make us happy, I use my weekend to catch some shuteye catch some shuteye (补觉) X: I think you’d really like camping,how about we both go camping this weekend?J: I don’t know, is it expensive?X: Not at all, but I’d appreciate some help with gas money. it’s a long drive out to the campsite(度假营地) not at all (一点也不，注意连读)I’d appreicate some help … 非常委婉客气的说法It’s a long drive out to the campsite/hospital/my mom house (去..的路程很远) J: I’ll spring for gas, can I help with anything else? spring (作动词讲意思：拿出..东西) pay for = spring for the ticket/dinner X: I’ll let you set up a tent, you’ll love it set up a tent = pitch a tent （搭帐篷） J: It sounds like I’m getting the raw end of the deal, I heard that can be a lot of work get the raw end of the deal (raw 生的， is not fair， 意思是吃了亏，拿到了不好的一端) X: Don’t worry, I’ll help you through it. so are we on for the weekend? I’ll help you throught it = I’ll help you out (我会帮你搞定它)are we on .. (我们说定了..嘛？) are we on for tonight/the weekend? （说好今晚/周末？） J: we’re on 说定了 J: You should have looked at the weather report before we left.I can’t believe it’s raining right now, this is the pits I can’t believe it’s raining/April 4This is the pits (pit: the hole in the ground, 表示不理想的情况， 太糟糕了) X: Don’t worry, we still have a good time, hurry up and pitch the tent before we get any wetter. hurry up and pitch the tent before we get any wetter (快来，在我们淋湿之前把帐篷打起来，注意此处比较级的运用，更加地道) J: There a lot of poles(杆子), I don’t know what to do first.X: There is nothing to it, watch me, there, all done there is nothing to it (没难度，很简单) J: I guess that wasn’t so bad, so what are we supposed to do now? it’s too cold and wet to be outside right now.X: How about we make dinner in tent? I brought a portable stove and some ramen portable （唯一表示“便携式”的单词）ramen 拉面 J: Now you’re talking, cooking is right up my alley, ok, Xiaogao, just sit back and relax, i’m gonna cook up a mean bowl of noodles. you’re talking (太好了，很同意这么做，表示赞成)sth is right up one’s alley = sb is good at stha mean bowl/dish of sth (一碗特别好吃的…) X: Hey, you should come camping more often! You seem like a pro! pro 此处表示专家， 注意和professor的区别， 此处不能用professor， pro表示很专业more ofen 表示“经常” J: What can I say? I guess I’m just good at everything I do! what can I say (我能说什么呢？ 很炫耀的一种说法)I’m good at everything I do = I’m a Jack of all trades (我什么事都能做好， 我是个全才) 2016.4.11 30-day ChallengeX: My friends and I are gonna go see Zootopia and then go grab a bite to eat, you in? grab a bite to eat 吃点东西A: you in? B: yes, I’m in / no, I’ll pass J: I’ll passX: What? I thought you were dying to see that movie be dying to do sth = Yearning to do something (非常/渴望想做某事) J: I do really wanna see that movie, but I’ve got other plans, Lately I’ve been helping people at the old folks’ home old folks’ home = nursing home (敬老院，前者多用于口语中) X: Why would you do that instead of going to the movies? That doesn’t make sense make sense (有意义)That doesn’t make sense (根本没道理，讲不通) J: I made a commitment to myself that I will do something good every day for 30days, I recently attented a TED seminar（专题讨论会） by Matt, He talked about the benefits of doing something for 30 days straight. make a commitement (做承诺)注意此处Straight的用处 X: Oh yeah, tell me about it. tell me about it = care to elaborate J: He said it’s a greate way to improve yourself-confidence. It’s also a great way to force yourself to do something that you’ve always wannted to do, but never got around to actually doing improve yourself-confidence (注意：提升自信心要用improve)push sb to do sth = force sb to do sthget around to doing sth (抽时间做某事) 在肯定句中： finally get around to doing sth 在否定句中： never get around to doing sth X: Oh, that sounds like something I should do…J: I think you’d love it. You can pick something that you’re willing to do for 30 days, for example, writing a 50,000-word short story. Every day you just have to write 1667 words, but the tough part is that you can’t go to sleep until you’ve finished what you promised yourself you’d do. the tough part (最艰难的部分) X: I think I’ll give this a shot.Okay, have fun helping the old people. I’m off to the movies! give it/this a shot （试一试）have fun doing sth (有兴趣做某事)I’m off (我走了，可用于结束一天的工作指“下班”) J: * You look a lot thinner than the last time we met.* package some pounds （变胖） X: I took your advice and decided to go on a diet for 30 days. So far, I’ve stuck to my diet really well. go on a diet (节食、减肥)stick to doing sth/sth （坚持做某事） J: That’s great! So, tell me about it? What exactly are you doing? what exactly are you doing? (你到底做了什么) X: * I promised myself that I would eat healthy for at least 30 days. I also promised myself to get lots of exercise by walking and going to the gym.*J: How are you making sure that you eat heathy?X: * I weigh all of my food on a digital scale before I eat it. Then I calculate the amount of calories. Right now, I only eat about 1900 calories a day. It’s really helped me slim down.* digital scale (电子秤) 关联2016.3.30 Airport English 中 place it on the scaleslim down (瘦身，瘦下来) J: I can see that! You look like a completely different person! (你简直像换了一个人，注意completely的使用)X: By the way, are you still sticking to your commitment?J: My 30-day commitment ended two weeks ago, but I felt so good about myself that I decided to keep it as a healthy habit. I still try to do one good thing every day. I love it! 2016.4.18 Getting Money BackX: Can I talk to you for a minute? I’d like to pick your brains about something. pick someone’s brains (询问/征求某人意见) Can I get your advice? J: I’m all ears, what’s up? I’m all ears (浑身上下都是耳朵，指在认真听，洗耳恭听) X: I lent my friend 500RMB two weeks ago, and he still hasn’t paid me back, I’m at a loss of what to do borrow sth from sb (从某人借某物)lend sth to sb (借给某人某物)pay me back (还钱给我)I’m at a loss [of]… 我困惑.. 不知道怎么办 I don’t know what to do. J: You could give him the benefit of the doubt, maybe he forget about the money give sb the benefit of the doubt (暂且相信某人 站在对方的立场上想，给某人一次证明自己的机会) X: * That’s a lot of money to forget about. I’m really starting to get angry now.*J: I suggest you sit down with him and have a heart-to-heart talk. whatever you do, don’t lash out and accuse him of stealing your money, he really might have forgotten. heart-to-heart talk (坦诚的，开诚布公的谈话)lash out (用言语攻击、狠批) don’t lash out (不要说伤人的话，不要情绪太冲动失控)accuse sb of doing sth (谴责/斥责/指控某人做某事， 不见得有证据的指控/斥责) X: I think I’d better keep him at arm’s length from now on keep sb at arm’s length (和某人保持距离) J: Don’t jump to conclusions so fast, talk to him about it first, and then draw your conclusion. jump to conclusions (妄下结论)draw one’s conclusion (下结论) X: Okay, I’ll keep you posted keep you posted (告知某人某事，我会保持更新消息， 有消息就告诉你, 可以用在邮件书写中) J: Were you able to get your money back? get money back (还钱) X: Yeah, but it was no walk in the park. a walk in the park (轻而易举)a pain in the neck (脖子上有疼痛，指不顺利，有麻烦)twists and turns (故事上的“曲折”) The story is twists and turns J: What do you mean?X: I asked him if he could give me my money back, and he told me that it had completely slipped his mind. slip one’s mind (忘得一干二净) J: So did he give the money back to you thenX: He only gave me 300. He said he will give me the other 200 next week once he gets paid. But then I remembered that he was going on vacation next week, so I called him on his bluff call sb bluff （揭穿某人） J: Did he come clean? come clean (变得清晰 指说真话 老实交代) X: Yes, he apologized and gave me the other 200 the next day. He said he has been really tight for cash lately. tight for cash (手头紧) J: It sounds like youburied the hatchet with him? bury the hatchet (埋掉战争、斧头, 指“和解；冰释前嫌”) X: Yeah, I decided to let bygones be bygones. Now we’re back to being good friends,just like before. let bygones be bygones (过去的事就让过去吧， 既往不咎) J: * I’m glad you listened to me and were able to remain friends with him.* remain friends (维持朋友关系) X: what would I do without you? 2016.4.20 Taxi EnglishJJ is visiting NewYork for the first time. XG plays the part of the taxi driver.JJ: Thanks so much for stopping, do you know how to get to Times Square(时代广场) from here? how to get to smw from here? 从这怎样去smw XG： Hop in, so, is this your first time to The Big Apple? hop in （上车）/ hop out (下车) hop本意是“跳”NYC(NewYork city 别称叫The Big Apple) JJ： Yeah, it sure is, I never thought NewYork was this big, It reminds me of ShangHai,China It sure is (当然了，确实是这样)this （此处表示强调， 增强描述语气）remind sb of sth （让某人想起某事） XG: You’re from China, eh? wow, that’s a long way from NewYork. when did you land? it’s a long way from swm (距离某地很远)when did you land (什么时候到的) = when did you arrive JJ: Last night, I’m still a little jet lagged I’m still a little jet lagged (我现在仍然有点时差疲劳) tired from the time difference between two placesi’m lagging (通常是指“我网络延迟”) XG： Well, welcome to Manhattan(曼哈顿) ， where else are you gonna see while you’re here?JJ: *I’m planning on visiting Central Park(中央公园) and of course , the Empire State Building(帝国大厦), maybe you can tell me some good places to visit? * I’m planning on doing sth (正打算某事) XG： It’d be my pleasure, I think you should add the Statue of Liberty(自由女神) to your list, it’s a must-see must-see(必看的[地方]) must-do(必做的[事情]) JJ： tha’s a greate idea.XG: If you’re into animals, you should check out the Bronx ZOO(布朗克斯动物园), The 9/11 memorial is also a place you can’t miss, and since you’re laddy, I bet you like shopping, right? be into sth (特别喜欢某物/事)check out (去看看， 在酒店结账退房也可以用check out)A place you can’t miss (非要去看不可的地方)The 9/11 memorial is also a place you can’t miss (注意句子结构用法) JJ： That’s rightXG： Well， you’ll love downtown Manhattan(曼哈顿闹市区)， there’s enough shopping malls there to keep you busy for days. but make sure you save some money for Coney island(康尼岛), there’s a lot of things to do, If you have enough energy, You should check out NewYork’s night life, You won’t be disappointed.JJ: Thanks so much, those are some great tips!(小攻略)XG： Here we are, Times Square! That’ll be $32.50（thirty two dollars and fifty cents）JJ: Here’s $35, keep the change. By the way, can you tell me how to get to the music store? keep the change = You can keep the tip(留着小费吧) XG： Sure, walk two blocks east. You’ll see it on your right.Good luck walk two blocks east (向东走两条街， 注意之路方向词的用法) 扩展： 纽约市共分为五区〈Borough〉：布朗〈The Bronx〉、布鲁克林〈Brooklyn〉、曼哈顿〈Manhattan〉、皇后〈Queens〉、及李奇文(又称为列治文)〈Richmond (Staten Island)〉。 put your arm out (伸出手，想象叫出租车的样子) 2016.4.25 Vacation EnglishXiao Gao is checking into a hotel(办理入住酒店). Jing Jing plays the part of the front desk employeeJJ: How may I help you?XG: I have a reservation under the name Gao A: I have a reservation. B: under which name (用哪个名字预定的) JJ： Wait a moment while I’ll look you up, XG, is that right? look [sth] up (查询) XG： Yes, that’s rightJJ: It looks like you have booked a queen size bed? queen size bed （大床房） King size bed (超级大床房) XG： BTW, could you tell me some fun things to do around here? it’s my first time to Miami.JJ: You asked the right person, I used to work as a tour guide before getting this job at the hotel, I think you should check out Miami beach, it’s a great place to get a tan, At Miami beach, you can go on a speed boat tour, afterwards（然后）, you should take a boat to the Bahamas(巴哈马)， it’s a paradise, you’ll love the restaurants and bars there you asked the right person (你问对人了)get a tan (晒的美黑) (tan 既可以是名词， 也可以是动词 I’m tanning now)get a sunburnt(晒红， 就是指晒伤了)sea sick (晕船)go on a speed boat(快艇)/sth tour (来一个…游)it’s a paradise (就是一个天堂啊) XG： thanks, I’m gonna get my swim suit on and hit the beach swim suit (泳衣)you look good in the suit. the suit looks nice on you (注意介词in和on的使用)hit the beach (奔向海滩，注意动词hit的使用，指去哪) XG is at a restaurant at the Bahamas. Jing Jing plays the part of the restaurant employeeJJ： Sir, table for one? table for one/two (一位/两位吗)A: how many? (几位？) B: table for six (六个人) XG Yes, PleaseJJ: Smoking or non? (您想坐吸烟区还是非吸烟区)XG： Non, pleaseJJ: right this way, *Can I get started off with a something to drink?*** right this way (这边请)Can I get started off(start off 就相当于start) with a something to drink? XG: How about a martini(马丁尼)JJ: Coming right up, do u still need a minute to look at the menu? coming right up (马上就来) XG： What are your specials today? (今天的特价菜是什么？)JJ： Today our specials are steak（牛排） and potatoes（土豆） and roasted salmon（烤三文鱼）. Do any of those sound good?XG： I’ll go with the steak please. I’ll have / go with + 菜名 （我要点什么.. ） JJ： Okay, I’ll be right back with your order. （您的单很快就来）JJ: How are we doing? Can I get you another martini? how are we doing (怎么样，外国像国内需要叫服务员，他们会四处走来照顾顾客需求) XG： No, thank you, I’m feeling a bit tipsy already. I’ll take the check, though. I’m feeling a bit tipsy already(我感觉有点微醺了) / I’m feeling a little tipsy/woozy (I think I’ve caught a buzz). I gotta foot the bill.I’ll take the check ， though(我要买单了, though就算是一种语气词“了”) JJ： You got it. Here you are. I’ll be back to pick that up in a few minutes.(我过一会回来拿） you got it (没问题) 扩展： 四大洋： the Pacific [pə’sɪfɪk] Ocean (太平洋),the Atlantic [ət’læntɪk] (Ocean)(大西洋),the Indian Ocean(印度洋),the Arctic [‘ɑrktɪk] Ocean (北冰洋) Hurricane crashed the Florida last week (飓风上周袭击了弗罗里达州) 2016.5.4 House Warming PartyJJ: XG, how’s the guest list coming along? how’s [sth] coming along? (sth进展的怎么样，还没有结束) XG： It’s pretty good, I’ve already thought of 30 people who we should invite.JJ: I think you should limit your guest list, after all we’re on a tight budget. hosting so many people could be really expensive. on a tight budget (预算有限) 注意和tight for cash的理解区别hosting (邀请) XG： You’re right, what about invitations? maybe we should use social media instead of paper invitations in order to cut down on costs what about（直接提出选择、想法） 和 how about（有了一个，提出另外一个）cut down on costs (减少开支) JJ： Good idea, make sure you request an RVSP so that we can play for foods and drinks better. RVSP (Répondez s’il vous plait(French for “please respond”) 敬请回复,收到请回复) XG： Speaking of food, I think we should have finger foods that people can munch on while they mingle. speaking of [sth] (说道sth)saying [sth] （比如sth）finger foods (foods that are convenient to eat with your hands 能用手拿着吃的方便食物)mingle (Mingle = to socialize 陌生人之间的社交) JJ: I was thinking we should hire a catering service to provide our food . that way we can focus on decorating our new home, we want it to look nice when the guests arrive. catering service (a service that provides food for an event or party 为特定活动提供餐饮服务) XG： Great party huh？JJ： Yeah， it sure is, the music is great, and the food is even better. it sure is (确实，给与肯定) XG： Who do you know here? (你都认识这里的谁，注意表达)JJ： I’m JJ’s friend, we went to school together. we went to school together (可以表示我们过去时同学) XG： Oh cool. Xiao Gao and I are on the same basketball team. Nice to meet you. I’m Bob, by the way. 注意口语对话中 by the way 的使用， 顺便介绍一下自己 JJ： I’m Jennifer. Nice to meet you too. Did you get to go on a tour of the place yet? It’s such a nice home. I’m so happy for them go on a tour of the place (在这个房子里四处转转了吗？) 联想 go on a speed boat tour (来一个快艇游) 注意灵活使用 XG： Yeah, I’m surprised at how much space they have. Anyways, would you like to go grab some refreshments（零食，点心）? I see you’re almost done with your drink. The turkey is splendid（非常好）. sb is done with sth (某人的sth快做完了/sth快没了) I’m done with my work. JJ： I’m a vegan（ 严格素食主义者）, so I don’t eat meat. But I’ll join you for some more spirits. spirits (we just use the word “spirits” to refer to liquor(酒) in general, so we only use it in plural(复数) form (spirits). We can’t say “I’d like a spirit”, instead we should say specifically what kind you want, such as “I’d like a shot of vodka” or “I’d like a glass of whiskey”) XG: Do you think I could get your phone number? You seem like a really cool person. We’re always looking for more members on our basketball team. It’s open to both guys and girls. Think you’d be interested? 在国外要异性电话就是对对方有好感， 委婉一些可以提出一些借口如（You seem like a really cool person） 2016.5.9 Obsessive Compulsive Disorder （OCD）JJ： Quit biting your nails, it’s a bad habit.XG: It’s a bad habit, I’ve done it since I was a kid.JJ: Sounds like you got OCD, do you do it a lot?XG: Yeah, pretty often, do you ever tweak out about things like that? tweak out about sth = freak out about sth = worry about sth JJ: Sometimes, when I’m about to put my earbuds(塞入式耳机) in to listen to music, I always have to make sure that the R and L are in the correct ear. be about to do sth(马上要做某事) I’m about to leave. (我马上要离开) XG： Do you know what else drive me nuts? After I set the alarm at night to wake me up in the morning, I gotta check again like 5 minutes later to make sure I acturally set it. drive sb nuts/crazy/bonkers/up the wall 让某人抓狂 JJ： Year, sometimes I have to make sure over and over that I locked the door at night before I sleep. over and over (反复，一遍又一遍） XG： I can’t stand it when someone doesn’t completely clean the blackboard in school, I feel really weird in class and keep looking at. I can’t stand it (我不能忍受) JJ： I remember when I was going to school and our test grades would be out for us to look at, I would never go and see my score.XG: Sounds like we’re both a little OCD. Hey, what does OCD stand for anyway?JJ: You tell me! Why don’t you go home and do some research about it?XG: Geez, is being bossy one of your OCD habits too? (天哪，难道发号施令也是你的强迫症症状之一吗？)JJ: So, what did you find out about OCD?XG: it stands for Obsessive Compulsive Disorder, Basicly it’s when you have a lot of anxiety and you do a lot of repetitive behaviors to make the anxiety go away. (大致就是说你有很多的焦虑，并且必须通过重复某种行为才让这种焦虑消失。) JJ: What kinds of behaviors are you talking about? Did you find out about anything newXG: Yeah I did. Do you know what hoarders(囤积控) are? herder (牧人) JJ: * I think so. Aren’t they the people who have to round up a bunch(群) of sheep?* round up sth (收集 聚集 归拢 ) XG： * No, those are called herders（牧人）, I’m talking about hoarders! H-O-A-R-D-E-R-S. Hoarders! Hoarding is when you keep a lot of things and don’t throw them away, even if they are worthless or meaningless.*JJ： I don’t know, Xiao Gao… Your room is pretty messy（杂乱的）. Do you think you might …. messy (指家，办公室，头发杂乱的，小朋友吃饭弄得哪里都是也可以用 ) XG： Hey! My room is messy but it’s not that bad!JJ： Anyways, do a lot of people suffer from this disorder?XG： It’s fairly（相当） common. Actually, it’s the fourth-most diagnosed mental（心理的） disorder. One in fifty people have been diagnosed with it in the United States.JJ： Uh oh! We’re doomed! We probably have it too! You’re so dead (你死定了) We’re doomed（我们死定了） XG： Don’t worry! I think we’re okay. I also learned that just because you might have some obsessive behaviors, doesn’t mean that you have OCD.JJ： Is it treatable?XG： Yes. The good news is that this mental disorder is treatable with therapy(治疗，疗法) and medication! 2016.5.11 At The CrossroadsJJ: Hey,XG why do you look so stressed out? do you have a lot of homework or something? stressed out (抓狂)or something 放在问句的结尾类似汉语的“..吧/吗” XG： Well， it’s just it, school’s going fine this year… but I’m not sure about next year. well, it’s just it (就是这么回事)I’m not sure about sth (不确定sth) JJ： I don’t get it, you said school’s going fine now, why do you have an issue at school year? I don’t get it (我没明白) = I don’t understandYou got it (多数是回答对话指“没问题”) XG: The way things are looking now, I don’t think I’ll be able to fork up enough money for tuition next year. the way things are looking now (照目前来看)fork up money = pay a large amount of money. JJ: That’s not good, so what are you gonna do?XG: I was planning on working at a factory this summer and saving up some money and maybe take out a student loan, that way, I should be able to go to school next year. take out a [student] loan (申请助学贷款)that way (那样的话)save up (储蓄， 存储) JJ： Problem solved, right? what are you worrying about? worry about sth = tweak out about sth = freak out about sth XG: I got a job offer to work as an English teacher, I wouldn’t be able to go to school on such a low salary, but I think it would be really fun, so now I’m having second thoughts, Maybe I should take the teaching English position instead. have second thoughts (犹豫，再加思索)on second thought (经过再次思考)instead 放在句尾使用 JJ： You have to think this through carefully, On one hand the English teaching job is fun, that’s right, but on the other hand you wouldn’t be able to fulfill your long term goal of getting a bachelor’s degree, I don’t think it’s in your best interests to take the English teaching job think sth through [carefully] (充分的考虑某事)on one hand … on the other hand … （一方面… 另一方面…）fulfill your long term goal (完成/实现长远目标， fulfill 可以指完成目标、需求、愿望)in one’s best interests (对某人最好的利益， 是某人最好的选择) XG： *But I think that teaching job will help me in the future to land a better job, don’t you think it will look good on my resume, if I had some teaching experience. * land a job (获得工作)注意experience是经验的时候不可数 JJ： It might help, but I think having a bachelor’s degree on your resume will look even better. you really have to weight the pros and cons 在简历上用 on resumeweight the pros and cons (权衡利弊) XG： *But working in the factory will be so boring, I’d much rather do something that would make me happy, it’s always been one of my dreams * I would rather do sth(我宁愿做sth) JJ: Well, that’s part of growing up and being responsible. This experience will make you a better and more responsible person in the future. Trust me, a bachelor’s degree is worth much more than a temporary English teaching job. Plus, you don’t even know for sure if you’ll like teaching English. Anyways, you could always make learning English your hobby at night when you come home from work. Next semester at school, maybe you could take an English elective class. If you’re certain you really like teaching English, then next semester maybe you could tutor a child on the weekend and at the same time make some extra money? that’s part of growing up （这就是成长的一部分）A is worth much more than B (A比B更有价值/意义)elective class (选修课) mandatory class(必修课)tutor a child (指导孩子，做家教) XG： Okay, you’ve convinced me. I’m gonna do what’s best for myself and work hard to earn enough money to pay for school! Thanks so much, Jing Jing. you’ve convinced me (你说服了我) 2016.5.16 Left and Right HandednessJJ: Have you ever wondered how hard it must be for people who are left-handed(左撇子) to use a computer, the computer mouse is made for right-handed(右撇子) people. Have you ever wondered … （你有没有想过…）mouse (鼠标)， wireless mouse (hamster仓鼠， 因为没有尾巴.) XG: Year, it must be hard, my sister is lefty and she seems to do alright. lefty (左撇子， 比left-handed 更加口语化) JJ： So do people choose to be left-handed or is it something that they’re born with? something that they’re born with (他们与生俱来的，他们生来就有的) XG： The actual reasons why some people are left-handed are still a little vague（谜）, but scientists think that it has to do with people’s genetics（遗传学，基因学） and the environment they grew up in. Studies also show that about 15% of the population is left-handed. vague (谜)the environment they grew up in (注意in不能丢掉， 成长在环境中)studies/study/research show[s] 研究表明 JJ： So besides holding a pen with their left hand, are there any other differences between left-handers and right-handers?XG： Actually, yes.JJ： I heard left-handed people are kinda clumsy（笨拙的）, is that true?XG： No, it’s not. There are a lot of social stigmas（社会偏见） about left-handed people that are completely false.In reality, left-handed people tend to be more athletic（运动的）. Also, left-handed people seem to have better problem-solving skills. social stigmas (社会偏见，指根深蒂固的偏见) —— To be a nonreader carries a social stigma.bias about/against sth (对某事有偏见) bias toward/against sb (对某人.. 的偏见)outright wrong (完全没有根据的错误) JJ: Wow, I kinda wish I were left-handed nowXG: Did you know that a lot of famous people were left-handed? Like Barak Obama and Prince William of England.JJ: That’s really interesting. I’m gonna go home and see what I can learn about right-handed people now. Take care! A: see ya B: take care / A: take care B: see ya （对话中双方） XG： See ya.JJ： So, did you find out anything about right-handed people? find out sth （调查/查询到sth） XG： Well, there’s one major plus to being a right-handed person: most items in life are geared towards right-handed people. Everything from water bubblers to door handles.Other than that, there’s really no intellectual advantage to being right-handed. plus (在此处指“好处，优点”)gear toward sb (专门为sb制造的)water bubblers (饮水机) water fountain (户外饮水泉)other than that (除此之外) JJ： * So, do right-handed people use the right side of their brain and left-handed people use the left?*XG： No, it’s actually the opposite. Right-handed people are left-brain oriented and vice versa. money oriented (金钱导向的)vice versa (反之亦然) XG： Are there any people that can use both left and right hands equally well?JJ： Yes, these people are called ambidextrous（ 双手都使用得非常灵巧的）. It’s incredibly rare, but you can actually teach yourself to become ambidextrous.XG： Really? So you mean I could teach myself how to use my left hand to do things?JJ： Yes, but don’t expect it to be a cinch. You might have grey whiskers by the time you master it. a cinch = walk in a park = a piece of cakehave grey whiskers (白发苍苍，指变老的时候) XG: Cool,well,I’m gonna go practice some left-handed food eating. You coming? you coming? (你来吗) 2016.5.23 Personality TraitsXG: Ouch! I just got bit again by another skeeter(蚊子)! I think summer is just around the corner. Summer is just around the corner (夏天就要来了) JJ： Yeah, you must have sweet blood.XG： Well, all I know is that my blood type is “A”, I’m not sure if it’s sweet or not.JJ： Oh, you know your blood type eh? Did you know that there’s been a lot of research done about blood type in relation to personality?XG： No, I didn’t,can you enlighten me? enlighten me (给我讲讲，让我明白受教) JJ： As you know,there are four possible blood types that a human being can have: A, B, AB, and O. Since you’re A, let me tell you a few things about your personality.XG： Okay, give it your best shot. Let me give it a shot (让我试一试)give it your best shot (你来试试吧) JJ： Most type As are sensitive to the needs of others and are good listeners.XG： Yeah, well,doesn’t this describe everyone?JJ： * Hold on! I’m not done yet! You’re also detail-oriented, creative and inventive. On the outside, you seem really calm, but on the inside, you are filled with anxiety and worry.* on the outside (在外表看来) on the inside (在内心看来) XG： You’re lying! I think you are describing me on purpose. … on purpose (… 是故意的) JJ： I’m not kidding! The research really shows this. Also, type As are usually shy and sensitive, and a lot of them are perfectionists（完美主义者）.XG： That’s me to a T! .. to a T (表示准确极了，完全精准的描述) JJ： Romantically,type As work best with other type As and ABs. Romantically (感情上说) XG： What do type As end up doing for jobs?JJ: Common type A career choices include accountants, librarians, economists, computer programmers and writers.XG: I was once a computer programmer! Does it say anything about us being really stressed out(压力大)?I’m usually pretty tense（紧张） during the day.JJ： Yes it does,actually. Most type As often bottle up anxiety in order to get along with others. Many of them are tense, impatient, and unable to sleep well. bottle up emotions [anxiety] (把焦虑藏起来，想象瓶子装起来一个东西并且把瓶塞塞上，在感情藏在心里，不告诉别人，也不释放出来) XG： Ahh! It’s like you’re reading my mind! What blood type are you? Tell me now!! read my mind (读心) JJ： That’s for you to determine. Go home and research all the different blood types, then let’s see if you can guess it correctly!XG: Okay, Jingjing, I’ve done my research. I think I know which blood type you are.JJ: Oh yeah? Which one?XG: You’re a type B!JJ: You’re right.But how did you come to that conclusion? come to that conclusion. (怎么得出这个结论，有一个循序渐进的过程在里面) XG: Well, it said type Bs are easygoing(随和的), creative, original and flexible.JJ： Can you say something more concrete（具体的）?XG： Well, it says that type Bs are globally-oriented people. Also, it says that you learn best through listening. On top of that（并且）, it says you are goal-oriented and ambitious. on top of that (并且) JJ： It’s true, I am good at listening, that’s why I like working on the radio.XG： * It also said you aren’t a very picky person, and you don’t worry about little things too much.* a picky person (一个挑剔的人，计较的人) JJ: Yup, for example, I don’t say anything to you when you come to work dressed like a slob (没有条理，邋遢的人).XG: Hey! That wasn’t very nice.JJ: How about romance-wise? romance-wise (感情方面，感情角度)time-wise (时间方面，时间角度) XG： Type Bs do best with other type Bs and ABs. do best with others = work together well. JJ: Anything else?XG: Basically, you are thoughtful like type As and ambitious like Os. It’s a very interesting blood type. But do you know what the smoking gun was that made me convinced you were blood type B? smoking gun (让你破案的线索，确凿证据， 想象冒烟的枪，破案的线索) JJ： No, what was it?XG： Common career choices for type B, such as cooks, military leaders（军官）, talk show hosts and journalists!JJ： That’s me,indeed! Good job, Greg! So we talked about blood type As and blood type Bs, but do you remember me telling you there was also a blood type AB? do you remember sb doing sth XG: Yeah, Ido, I found them to be the most interesting of all!JJ: Me too. Not surprisingly, they have both A and B traits(特性).Sometimes they’re shy and outgoing（外向的，extroverted）, hesitant and confident.XG: Type ABs often stand out like a sore thumb among other types. They are trustworthy and like to help others. stand out like a sore thumb （杰出，突出，鹤立鸡群）trustworthy (可靠的) JJ： They also think logically and are determined to do things correctly. think logicaly/emotionally/rationally (逻辑、感性、理性) XG： Type ABs can find a soul mate with any other blood type. soul mate （灵魂伴侣） JJ： Did you know that both John F. Kennedy and Marilyn Monroe are type ABs?XG： Yeah, what a coincidence! What’s even more interesting is that only about 2%～5% of the population are blood type AB. what a coincidence (太巧了) JJ： They’re really charming（迷人的，可爱的） and popular. They don’t sweat the small stuff. sweat the small stuff (不拘小节，不纠结于小事情, 不为小事烦心) XG： So what do type ABs usually do for work?JJ： Well, some common type AB careers are bartenders（调酒师）, lawyers, teachers and sales people（销售）.XG： There’s never a dull moment in a type ABs life. If you can find one for a friend, consider yourself lucky! Well, we’ve talked about A, B, and AB. We haven’t even said a thing about type O yet. There’s never a dull moment in sth (在sth上一点也不单调) There’s never a dull moment in GFGconsider yourself lucky (你实在太幸运了) JJ： Type Os are really unique. They’re responsible, decisive（有决心的）, organized（有条理的）, and practical（务实的）.XG： That’s right. Type Os are shot callers. They often end up being bankers,politicians, gamblers（赌徒）, investment brokers（投资经纪人）, and pro athletes shot caller (法令开枪的人，指“决策人”) JJ： They tend to be loners（独行侠） or leaders and are self-reliant（自立的） and daring（勇敢的）.XG： They cope with stress better than any other blood types and don’t get sick that much. cope with sth (处理sth) （可以再也不用handle了， 欧耶） JJ： They also have a strong build （健康的体魄）and like to stay active.XG： Being hard-headed（头脑清晰冷静的） and determined to succeed helps them to reach their goals. be determined to do sth (决心要做某事)reach one’s goal (实现目标) JJ： They’re also really creative and are often the center of attention. the center of attention (关注的焦点) Children offen wanna be the center of attention. XG: That’s right, they are the social butterflies that you meet in life from time to time. social butterfly (善于交际的，没有贬义)from time to time (不时，有时） JJ： What I found most interesting is that they seem to use their five senses better than the other blood types.XG： Well, now we know a lot more about different blood types. I’m still surprised at how accurately it described me. be surprised at sth (吃惊… ) 2016.6.1 Awesome Brand New Book Is OutJW: Hey, Anya. How’s it hanging? What are you doing how’s it hanging? = what’s going on? = how you’re doing ? （最近怎么样） AY: I’m listening to Going for Gold. Normally I’d be studying the book, but I’ve already gone through the whole thing normally (一般来说)Go through the whole thing = to finish something entirely, front to back (完成某事) JW: Oh, I love Going for Gold. I can’t imagine life without it. I can’t imagine life without it (标准句型，注意使用，“不敢想象生活没有它会怎样”) AY： Me too. I bought Jing Jing and Xiao Gao’s first book last year. Also, I listen to their show using an app on my phone. I like to look at the script（文本） on WeChatJW： :I get home from work pretty late at night, but Jing Jing always hosts an evening show online for those of us who like to self-study（自学）. I’ve gotten so much out of it. I’ve learned so many native phrases(用语，短语)! I’ve gotten so much out of it (我觉得收获很大) AY: This is the best program I’ve ever listened to. It totally changed the way I study English. I wasn’t learning native stuff in the past, in fact it was mostly Chinglish（中式英语）. By following Going for Gold, not only have I learned how to express myself, but I’ve learned correct pronunciation and have gained confidence in speaking. gain confidence (获得自信) improve confidence (提升自信) JW： The first book was awesome because it came with an MP3 CD. The second book is even better because you can download the dialogues for free. I’m definitely buying the second book so I can keep learning. sth1 came with sth2 (sth1随身附带sth2) AY： :I’ve already passed the show on to several of my friends, classmates, and even family members. I really liked watching Xiao Gao’s videos that he used to post on Weibo. I hope he posts more in the future. It was a great way to learn! pass sth on to sb = to share [something] with other people (多指口头分享)post (发布东西) JW： I heard there was a way to get an autographed copy of the new book. Is that true? autographed copy of the new book (新书的签名版) AY： Yeah, we just have to follow Jing Jing’s Weibo account and forward comments about the book, then we’ll be eligible for a raffle（抽奖）. They’ll announce the winners on the weekend. be eligible for sth/doing sth (有资格做某事) JW： I heard this book is a limited edition. I’d better hurry up and buy it! limited edition (限量版)I’d better hurry up and buy it! (我得赶紧入手) AY： Yeah, what are you waiting for? Next Monday will be the first class of the new book. I’m gonna participate more in the WeChat challenges each week, because the more I practice, the better I get. This is another reason why I love this radio show so much!JW： Hey, we forgot the most important part: Going for Gold is free! We can learn so many things without paying anything. That is so awesome! so much feedback (注意用much) 2016.6.6 Bad HabitsJJ: Pee yew! What’s that awful smell? Pee yew (咿呀, 口语化的表达， 通常和 what’s that awful smell 什么味道这么难闻) XG: Don’t look at me! I took a shower today! take a shower (洗澡，指淋浴) shower 也可以当动词使用， I showered today (我今天洗澡了) JJ： No, I mean… something smells like smoke. *XG： *Oh, I recently picked up a bad habit. I started smoking a few weeks ago pick up a bad habit （养成一个坏习惯） JJ： Really? Why did you start doing that? Why did you start doing that (你是怎样开始的？ ) XG： I bummed a cigarette from my friend one day. After that, I got hooked. bum (to ask someone for something without intending to pay for it), (有一天我从我朋友那儿顺了一根烟)get hooked [on sth] ([对某事]上瘾) JJ： Well, I think you should kick the habit! kick the habit (改掉那个习惯) XG： I want to, but it’s really hard!JJ： You know what they say: Bad habits are like comfortable beds, easy to get into, hard to get out of. you know what they say [that]…(俗话说…) XG: You can say that again. So, do you have any suggestions on how to quit? you can say that again (你说的太对了，用以表示“肯定”)suggestions on … (…的建议) JJ： I heard the patch（戒烟贴片） works really well. Why don’t you give it a try and see if it helps?XG： Okay, I’ll give it a shot. Talk to you later!JJ： Hey, Xiaogao.Were you able to quit smoking yet?XG： * Yes, thank God! It was really hard, but I finally did it.* It was really hard, but I finally did it (可以常用，表示经过一番努力取得成功，很有成就感的感脚) JJ： I’m sure it was, after all, old habits die hard. So did you use the patch? old habits die hard (旧习难改) XG： No, the patch was a rip off, so I didn’t buy it. sth is a rip off (…太贵了) JJ： So how did you do it?XG： I went cold turkey. It’s the cheapest and most effective method there is. go/went code turkey (采用简单粗暴的方法, 立刻完全停止做某事，不借助任何药物的帮助，也不给自己留时间慢慢来) JJ： Wow, good for you! How do you feel now? Did you have any withdrawals? withdrawal (副作用，瘾。因为没有获得足够自己已经上瘾的物质，例如咖啡因、尼古丁、酒精等，而造成的难受的感觉)phisical suffering XG： For the first three days I had a headache,after that it was smooth sailing. smooth sailing (一帆风顺) JJ： Well, I’m glad you’ve given yourself a new lease of life. In the future, don’t bum anymore cigarettes! a new lease of life=新面貌，在经历一段艰辛后迎来的崭新生活don’t bum anymore cigarettes (以后可别再沾烟了) XG: I learned my lesson, I won’t make that mistake again! I learned my lesson.=吸取了教训。指某人犯过一次错误后，不会再犯类似的错误。I won’t make that mistake again = 我不会再犯那样的错 2016.6.13 Getting Along with Co-workersXG: Ohhh, Jingjing! I have been having the worst time at work lately! My co-workers are driving me up the wall. drive sb nuts/crazy/up the wall/bonkers/ lose sb’s nerve JJ: Well, you came to the right person. You know I’m always here to listen when you want to vent your feelings. So what’s up? Who is bothering you and why? you came to the right person (你问对人了)vent one’s feelings (吐槽，发泄情绪) XG： Well, my cube mate, Jerry, smacks gum all day. It’s so distracting（分心的） and discourteous（无礼的）! cubicle的口语化简称 cube (指办公室的工位)smack gum (嚼口香糖出声音)slurp smack （都指出声音的咀嚼东西） JJ： Have you ever thought about asking him to not chew so loudly? Or how about asking your boss if you can change cubicles? have you ever thought about sth XG: I’ve thought about that, but we’re working on the same project together, I don’t want to make him upset. Anyways, I can live with this problem, but there’s some other things at work that are making me lose my nerve too. work on sthmake sb upset （让某人心烦）live with sth (忍受sth)lose my nerve （忍无可忍，让我抓狂） JJ： Yeah? Like what? like what（什么事？）, like who（比如谁？）, like when（什么时候） XG： My other co-worker, Bob, takes all the credit for the work I do. I designed a website last week for our company, Bob only edited two pictures, but he told everyone that he did the whole thing! It’s so unfair! take all the credit for sth （抢功占为己有） JJ： Yeah, I feel you. That’s happened to me a couple times too. I suggest you tell Bob that he isn’t being a team player. You have a right to tell him how much it upset you, but be careful not to lose your temper and start screaming at him. He probably doesn’t realize what he did. I feel you (我理解你 I understand you)you have a/every/the right to do sthlose one’s temper (失态，发脾气)scream/yell at sb （大吼大叫某人） XG： You’re probably right. Wow, you sure know a lot about this kind of situation.Can you give me some more advice? can you give me some more advice? = can I pick your brains? JJ: I tell you what, it’s almost lunch time. Let’s go sit down at a restaurant and I’ll tell you some rules of thumb for dealing with difficult people at work. a rule of thumb=经验法则，为适宜的行为提供指导deal with sb （和某人相处，打交道） Jingjing and Xiaogao sit down at a restaurant and begin their conversationJJ: Alright, Xiaogao, rule number one: when you’re at work, make sure you always carry your own weight.That means you should always do what’s asked of you and try not to let other co-workers pick up the slack. carry your own weight (做好分内的事，不能要求别人为你做)pick up the slack (替别人做他们应该做但没有做的) XG: Okay, that I can do. But what about when my co-workers are in a grumpy mood? Sometimes I want to lash out at them. grumpy（mood）=脾气暴躁，生气或不友善lash out at sb （向某人发火）， yell at sb, lay into sb(痛斥某人)I am so gonna do (我特别想做) JJ: That brings me to rule number two: no matter how other people act at work, you should always maintain a professional attitude. That means you should talk to people with respect at all times. If something bothers you, you can talk to your boss or the HR department. maintain a professional attritude (保持专业的态度) XG： I have another co-worker who sits close to me, her name is Amanda. She’s always on the phone with her boyfriend talking up a storm. It’s really distracting, just like Jerry chewing his gum(没有复数形式，本身就是复数). What should I do about that? She’s a girl, is it okay to confront her about it? She’s always on the phone with her boyfriend talking up a storm,It’s really distracting (她总是和她的男朋友煲电话粥。这真的很让人分心)talk up a storm (滔滔不绝的讲)confront sb (直面某人) JJ： Of course it’s okay. Just remember to stay professional and ask nicely. She probably doesn’t realize that she’s being a chatterbox. If you ask her nicely I’m sure she’ll keep her voice down. She probably doesn’t realize that she’s being a chatterbox (她可能没有意识到自己一直在喋喋不休)keep her voice down XG: Thanks for all your advice. I have to get back to work now, wish me luck.JJ: One last thing, Xiaogao. Just remember that the most important thing at work is getting along with your co-workers. If you have a bad relationship with them, then you will start to hate your job, or maybe your coworkers will despise(鄙视) you. A happy workplace is a healthy workplace! XG： Got it. Okay, I gotta run. Talk to you later!JJ： Hey, Xiaogao! You didn’t pay the bill! Waaaaiiit! Oh… forget it! pay the bill (买单)forget it （算了吧） 2016.6.20 A Fork in a RoadXG: Hey, Jing Jing,why do you look so vexed? vexed = annoyed (心烦意乱的) JJ: I’ve come to a fork in the road, I don’t know what to do. Can you give me some advice? Come to a fork in the road = be in a position where you must make a tough decision (人生做重要决定的关口)give sb some advice/pointers/tips （给某人建议） XG： Sure, I’ll trymy best. What’s up?JJ： Well, I’ve been working as an RN at an ICU unit for the past four years, but I feel like I’ve hit a plateau. It’s the same thing over and over, the night shift is really taking a toll on me. But three years ago, a teacher got me thinking, and I started to look into nursing overseas. I began to study professional English with the hopes of one day working as a nurse abroad. RN (Registered Nurse) 注册护士ICU (Intensive Care Unit) 重症监护室hit a plateau = to be unable to make any more progress (到达瓶颈处)overcome / break out/ surmount the plateau 克服瓶颈night shift/day shift (夜班/白班)take a toll on sb = If something takes its/a toll, it causes suffering, deaths, or damageget one thinking (启发，给了某人一个灵感)look into (钻研，研究) XG： It sounds like a no-brainer.What’s holding you back? no-brainer = requiring no thought; an easy decision (不需要费脑子的决定)hold sb back = make [one] hesitate （让人犹豫不决） JJ： I took a test in Singapore from the SNB and passed with flying colors. Just as I was about to make my next move, my parents and boyfriend complained that I shouldn’t go abroad to be a nurse. They’re worried that I won’t be able to adapt to the way of life and work environment over there. And once I go to work abroad, I’ll lose my job here in China. My parents don’t have really high expectations of me, they’ve never demanded that I find a super high paying job. As long as I am near their side they’ll be happy. pass with flying colors (高分通过)have high expectations of/on sb (对某人有很高的期待) XG： Well I think that might be the problem right there. Look at what you’re saying: it will make your parents happy if you stay at the same hospital. Did they ever consider what would make you happy? If you’ve studied English so hard and are able to pass the Singapore test, why should they be worried about you not being able to adapt to life abroad? I think that might be the problem right there (我觉得这可能就是问题的所在)be adapt to env/sth (适应…) JJ: What they don’t know is, Singapore was just my first step. My ultimate goal is to go to America to work as an RN. I’m confused about that too. Should I first use Singapore as a stepping stone and work there for a bit, or should I go directly to the United States to work? ultimate goal (终极目标，最终目标)stepping stone (垫脚石，敲门砖) XG： That’s a tough call. Considering you’re only 27 years old, you’re still young and can do many things. If you wait any longer, you might miss your chance. I think going to Singapore first would be a good idea because you can prepare for what it feels like to work abroad. You might also learn important skills there that will help you when you go to the United States to work. I’m 32 years old. I’m preparing to start my second Master’s degree. I had to make this decision on my own.Taking a risk and coming to China was the best decision I ‘ve ever made in my life. tough call = a hard decisionmake a call = make a decisionyou never too old to learn sth newtake a risk (冒险) JJ： Okay, I’m starting to feel better now. But what if I can’t find a job anywhere?XG: Unless people stop becoming sick, you’ll be able to find a job as a nurse anywhere on Earth. Good luck to you! 2016.6.22 Saying GoodbyeXG: Well, Jingjing, I’m afraid I’m going to have to cut my stay short here in Beijing. cut my stay short (提前离开) We had to cut short our holiday because Richard was ill. JJ: What? You mean you’re gonna split(离开)? Why? I thought you liked it here?XG： Don’t worry, I’ll be back. I’m just going home to straighten out my visa. strainghten sth out / out sth = to solve a problem or to deal successfully with a confusing situation (解决问题) Once we get these problems straightened out, we should be all right.straighten sb out = to improve someone’s behaviour I thought that once he got a girlfriend that would straighten him out. JJ: Oh, okay, phew! Well, when are you coming back? phew (那还好，哎呀，你吓死我了，语气词，指松了一口气) XG: Probably in a month or so. But I have to leave soon. My visa expires in a couple of days so it’s a race against the clock to get back home as soon as possible. Probably in a month or so (一个月左右，注意 or so)race against the clock=分秒必争，指着急 JJ: Oh, I see. Well, when you come back hopefully you’ll have all the time in the world. It’s no fun being pressed for time. Hey, do you have anyone that will send you to the airport? have all time in the world (有大量的时间; 指不必担心或有压力)It’s no fun being pressed for time(这么紧迫实在太痛苦了)pressed for time (时间紧迫) XG: No, I was gonna take a cab there. Unless… take a cab (坐出租车) JJ： Of course I’ll take you! You know you don’t have to ask that! 注意You know you don’t have to ask that! 语气 XG： Really? You’re the greatest!JJ： I know I am! What time does your flight leave? I know I am (比较骄傲的说：我也这么认为的)What time does your flight[交通工具] leave? （你的航班几点起飞） XG： Nine in the morning, do you think you can handle that? handle (搞定，此处以为来得及吗) JJ： I’ll be at your place at 6:00 on the dot. See you then! on the dot/sharp(准时准点，只能用在整点, 如7:00 on the dot，不能说7:15 on the dot XG： I must say, Jingjing. I have to take my hat off for you, you said you’d be at my place at 6:00 sharp and you were. I really appreciate it! I got to say/ I got to tell you (老实说)take my hat for sb (脱帽致敬)I really appreciate it JJ: No problem, you know I always keep my word. Well, right now it’s only 7:00. You still have some time to kill before your plane leaves. keep my word (说话算话)you have my word (保密 不泄密) renege on our deal/go back on your words/go back on your promise 反悔have some time to kill=有空闲时间来消磨 XG: Okay, let’s go get a cup of coffee. It’s my treat. (Xiaogao saysto the coffee shop worker) Two cups of coffee please. It’s my treat (我请客) JJ: Wow! This coffee is so strong! It just about knocked my socks off! I don’t usually drink coffee this early in the morning. knock one’s socks off=（通常指口味或气味）非常浓烈。例如，一杯二锅头会“knock XG: Yeah, this is some good stuff. You know, Jingjing, I’m really gonna miss you.JJ: Now is not the time to get all emotional. Here, I brought you a going away gift. 现在还不是催泪的时候。看，我给你带了一个告别礼物 XG: A gift? Why did you do that?JJ: It’s common for Chinese to give a gift when someone is coming or going. You didn’t know?XG: * No, I didn’t. That’s so nice of you. Can I open it?*JJ: Be my guest. be my guest = of course 请便 XG: Cool! A new watch! I needed a new one!JJ: * I’m glad you like it.*(The loud speaker at the airport says Now boarding flight1423 to Detroit.) That’s my flight. I gotta bounce(颠了，离开). Thanks for everything,Jingjing. I’ll see you when I get back. 2016.6.27 Meeting Someone at The AirportM: Hey! Long time no see! Thanks so much for picking me up! pick up sb/skill/knowledge/friend JJ: No problem! Your plane was a little late coming in. You must be beat! You must be beat (你一定累了吧) I’m beat 反义 I’m wired M: I’m fine, I chugged a bunch of coffee on the plane, so now I’m wired. chug （a drink）=灌（饮料） drink a lot of sth very quicklywired=相其兴奋的 JJ: So? How was your trip? Tell me all about it.M: I had a great time. It was really nice to see my family. I just wish that I could have stayed a little longer.JJ: Well, you know what they say:all good things must come to an end. You should just be happy that you even got to go on vacation at all. I’ve been working here the past month, lucky you! you know what they say, all good things must come to an end (一切美好的事物都会有尽头，天下无不散的筵席)go on vacation M: That’s true! Oh, I almost forgot, I got a present for you while I was in America. Here you go, hope you like it! here you go 就是给你.. there you go 有点类似归还东西 JJ: Thanks… but what is it?M: It’s a voodoo doll（巫毒娃娃）.JJ： A what doll?M: A voodoo doll. I bought it in New Orleans（新奥尔良） where voodoo is heavily practiced（盛行）. This doll will bring you luck and protection. I hope it works!JJ： Cool, I love it! I hope you didn’t spend too much money on it?M: Nah, in New Orleans they’re a dime a dozen. a dime a dozen=常见而便宜的东西 JJ: Okay, that’s good. Let’s hit the road now. We should get back home before the sun goes down. hit the road (上路)sun goes down (太阳落山) M: Well, we finally made it.Thanks again for the ride, Jingjing. give me a ride (载我一程) JJ： Don’t mention it.M: By the way, can I give you some gas money?JJ: Don’t worry about it. Just take me to the airport next month when I go to see my parents and we’ll be even. we’ll be even (我们就扯平了) M: Okay, cool. Hey, why don’t you come in and drink a glass of lemonade(柠檬水) with me before you go home? It’s the least I could do for you.JJ： That sounds like it will hit the spot! It seems like this heat wave will never end! Hey, while we’re at it how about we watch a DVD too? hit the spot (正中要害，正合我意)heat wave (热浪，不能用hot， hot weather, heat wave) M: I’d love to, but I have to wake up at the crack of dawn tomorrow to go to work. crack of dawn (破晓) JJ： Really? Geez（天啊）, I never knew you were such an early bird. early bird/night owl M: Yup… Don’t you wake up early to go to work too?JJ: Not as early as you. I’m more of a night owl. I like staying up late and working on my computer. I’m more of a night owl (我其实是个夜猫子) M: Oh… Well, let’s go inside and get that ice cold glass of lemonade that’s waiting for us! dog days of summer (had nothing to do，闲着，像夏天狗热了躺在地上什么也不干) 2016.7.4 Don’t text and driveM: Ah! Jingjing! I’m in a grind! I’m in a grind/bind (我好痛苦，不方便，尴尬， 指精神情感的，不是身体上的) JJ: What’s the matter? You look like you’ve seen a ghost! （你看起来像见了鬼一样）M: Yeah, I just got in a wreck. My parents are gonna bite my head off. get in a wreck (出了车祸，基本上就是报销了，成本大于2000美元)fender bender (车祸，成本小于2000美元，可以修理)bite sb head off (yell at sb, 大喊大叫，指非常生气) JJ： Really? Are you okay? How about your car?M: I’m fine, but my car is totaled! They gave that car to me last year when I graduated college, it cost thirty grand! I don’t know what to do! totaled (“完蛋了”， 不能直接说totaled，需要结合上下文， I wrecked my car totally)grand (1000美元) JJ： Just stay calm! Accidents happen. I’m sure it wasn’t your fault. stay calm (保持冷静) M: Actually it was. I really goofed up, Jingjing. I was texting and driving. I wasn’t paying attention to the road. goofed up/messed up/screw up (出大错，搞砸了)text (可以动词使用， I’ll text you， 我会给你发信息) JJ： Mark! What’s gotten into you? That doesn’t seem like something you’d do! what’s gotten into you (你是怎么想的？ 脑袋进水了吗) M: I know. I don’t know what I was thinking. Jingjing, what am I supposed to do?! what am I supposed to do (what should I do? 但是前者更常用，表达更好一点) JJ： Look, you need to be blunt with your parents and tell them what happened. I’m sure they’ll forgive you! After all, they’re your parents. be blunt with sb (坦率的说，不顾及对方感受，有点简单粗暴，只是如实说出来) M: Okay, I’m gonna go home now and spill the beans. spill the beans (如是说，更强调实话实说，注意和be blunt with sb 的区别) JJ： So? How did it go with your parents? Are they ticked off? ticked off (生气，之前忍了几次了 这次彻底爆发了， 忍无可忍) M: No. They were more worried than anything. They were just happy I wasn’t hurt. The good news is that the insurance will cover the cost of the car. cover the cost of the car (保险公司将会赔付我汽车的损失) JJ: Wow, it sounds like they are letting you off pretty easy. What’s the catch? let sb off pretty easy(放你一马，很容易的放过你)what’s the catch (有什么条件) M: The catch is that they are making me pay the deductable(抵扣款), and they told me I’m not allowed to send text for a month.JJ： No text messages? I think I would go bananas! I love sending texts. I bet you can’t wait for this month to go by, huh? go bananas (疯掉了，但是没有伤害的，no harm) M: That’s right, next month I’ll be like a dog with two tails. Although, I swear I’ll never send another text while driving again. I’ll be like a dog with two tails (恢复自由了，指非常高兴) JJ： Look on the bright side, at least you’ll save a lot of money this month by not having to send texts. Texting can be expensive. look on the bright/down/dark side (往好处/坏处想) M: That’s true! I never thought about that. With all this left over money(省下来的钱), I think I might go buy some books that I’ve been wanting to read.JJ： See, Mark. This whole ordeal（磨难） has turned out to be a blessing in disguise. turn out to be a blessing in disguise (因祸得福) M: Hey, how come you always seem to cheer me up? Do you have magical powers or something? cheer sb up (鼓励某人，激励某人) JJ： No, I’m just awesome!（我就是天才，比较骄傲的口吻） That’s all… 英语语法定语从句定语从句相关基本概念 定语从句的定义：用作定语的从句叫定语从句 定语从句结构：先行词 + 引导词 + 定语从句 先行词：被定语从句所修饰的名词或代词 定语从句的位置：紧跟先行词（名词或代词）之后 引导词：引导定语从句的词（包括关系代词和关系副词） 关系代词：that/who/whom/which/as 关系副词：when/where/why 引导词的功能 连接先行词和定语从句。（相当于桥梁） *I like the book which I bought. * 在定语从句中充当一定的成分（关系代词充当主语或宾语，关系副词充当状语）。 *This is the man who studied with me. *（关系代词做主语） This is the man with whom I studied. * (关系代词做宾语, 将介词提前) 定语从句类型定语从句有限制性和非限制性两种。限制性定语从句是先行词不可缺少的部分，去掉它主句意思往往不明确；非限制性定语从句是先行词的附加说明，去掉了也不会影响主句的意思，它与主句之间通常用逗号分开，以下是简单例子说明： This is the house which I bought last month （限制性定语从句） The house, which I bought last month, is very nice (非限定性定语从句) (一) 限制性定语从句（主句和定语从句之间无逗号隔开） The man who you’re talking to is my friend. The man to whom you’re talking is my friend. I need a pencil with which I can write a letter I need a piece of paper on which I can write a letter The man (*who/whom/that** 都可以) I talked about at the meeting is from Peking University. * The man about whom I talked at the meeting）is from Peking University. The palace (which/that 都可以) I often pay a visit to was built in the 17th century. The palace to which I often pay a visit was built in the 17th century 总结： 介词可以放到关系代词之前也可以放在句子末尾，放在关系代词之前是很地道的书写方式，介词只能加宾语，于是只有 介词+which 和 介词+whom两种形式， who在定语从句中既可以做主语也可以做宾语，作宾语可以与whom互换，但是如果有介词，必须要用whom， 另外paper单独指论文，一页纸要用a piece of paper, 北京大学要用Peking University，BJ University指北京的大学。 (二) 非限制性定语从句 （主句和定于从句之间有逗号分隔）当当先行词是专有名词或物主代词和指示代词所修饰时，其后的定语从句通常是非限制性的 Charles Smith, who was my former teacther, retired last year My house, which I bought last month, has got a lovely garden The novel, which I have reading three times, is very touching 非限制性定语从句还能将整个主句作为先行词,对其进行修饰,这时从句谓语动词要用第三人称单数 He seems not to have grasped what I meant, which greatly upsets me 他似乎没抓住我的意思，这使我心烦 由介词+关系代词（whom/which）引导 I live in a house far away from city, in front of which is a big tree. 其中far away from city 做后置定语 There is an apple tree standing there at the gate, on which are many apples 由“代词/名词+of+whom/which”或“of which/ whom +名词/代词”(先行词指人用whom,指物用which)引导。One, some, any, none,all, both, several, many, most, neither, either等词、数词、分数或百分比与of whom或of which连用。 He has five children, two of whom are abroad. (He has five children, and two of them are abroad. 外国人不喜欢重复，所以将连词去掉并且把them换成which， 因为这里which就是指代them) We have three books, none of which is/are interesting. (We have three books, but none of them is/are interesting 道理同上) whose引导非限定性定语从句 The house, whose window faces South, is mine 注意： 关系代词that和关系副词why不能引导非限制性定语从句 引导词（关系代词）that/which/who用法详解（一） 当先行词是物时，关系代词(that/which)只用that的情况 当先行词被序数词或形容词最高级修饰时，只能用that, 当然that也可以省略This is the best film that has been shown this year.This is the first book that I borrow from the libraryHe is the first student that/who came to school today (student 是人，所以可以用who) 当先行词为两个或两个以上分别指人和物的名词时，只能用thatHe talked about the teachers and the school that he had visited. 当先行词本身是all的，只能用thatAll that(what) I want to say to you is “Thank you” (all that=what)Go over all that (what) we learned 先行词为something, anything, nothing, everything, thing时, 只能用thatI’ll tell you anything that I know. 当先行词前有all, much, little, many, (a) few, every, some, any, no, only, the very, one of, the only, the last, the next等修饰语时This is one of the books in which I’m very interested （有介词就要用which）This is the only book that I read.He is the only one of the boys that likes playing the piano. 当先行词在以who或which开头的特殊疑问句中时，用that引导以避免混淆．Who is the man that is talking with the lady?Which of you that know the answer can come to the front? 当先行词是在定语从句中作表语时，用thatHe likes the girl that sheused to be. （二）当先行词是物时，关系代词(that/which)只用which的情况 作介宾且介词置于引导词之前时．The room in which he lives is very large. 引导非限定性定语从句时（主，宾都用which,都不能省略）Football, which is a very interesting game, is played all over the world.The house, which I visited yesterday, is very large. which指整个句子的内容或部分内容，引导非限定性定语从句He always makes fun of me, which upsets me. （三）其他特殊情况 先行词是these, those指人时，关系代词只用whoThose who are playing over there are my students 先行词是人称代词(he, she…)时，关系代词只用whoHe who doesn’t reach the Great Wall is not a true man 不定代词someone, anyone,everyone, no one, somebody, anybody, everybody作先行词时，关系代词用whoAnybody who breaks the rules would be pubnished (注意是breaks，Anybody在意思上指“全部”， 语法上只做第三人称单数用) 先行词是the only one of +可数名词复数，在定语从句中作主语时，定语从句中的谓语用单数形式, 因为此时限定的是the only one 注意以下两个例句定语从句speak的形式区别He is the only one of the students who(口语)/that speaks Japanese in our classHe is one of the students who speak Japanese in our class 当先行词是the way, 在定语从句中充当方式状语时（the way表＂以…方式／方法＂），引导词通常用that或省略，也可用in which．I don’t like the way (that) you speakI don’t like the way in which you speak 关系代词或关系副词在从句中充当一个句子成分，因此要注意避免从句中句子成分的重复出现This isthe most beautiful place that I have visited it. (错误: it重复，that在这里已经做宾语 ）his isthe most beautiful place thatI have visited 定语从句中关系代词或关系副词的选择取决于它们在从句中所充当的句子成分。如作主语和宾语用关系代词；作状语，用关系副词I’ll never forget the day when I went abroad myself.我永远记得我独自在国外的日子, （这里的the day 是一个抽象的概念，指一段日子）I’ll never forget the days that we spent together.我永远不会忘记我们一起度过的那些天/日子, (这里的the days是一个具体的概念) the day (minute)等表时间的单数名词后+关系副词when （表抽象的一段时间）the days(minutes)等表时间的复数名词后+关系代词that 、which （表具体的一段时间） 定从经典组合（介词+关系代词）十大难点Note: 介词+关系代词主要看结构（一） 介词+which在定语从句中分别作时间、地点和原因状语，代替相应的关系副词when,where和why，介词+which合化 when/where/why I still remember the day on which(when) I first came to school （我仍然记得当初来学校的那一天） 理解： I came to school on the day.2. The factory in which(where) I work is a large one. (我工作的工厂是一个大工厂)理解： factory不可能做work的宾语（工作工厂）， 是在工厂工作， I work in the factory3. This is the reason for which(why) he was late (这就是他为什么迟到的原因)理解： reason不可能做late的宾语， be late for因为什么迟到 （二） 介词+which（指物）/ whom（指人）在定语从句中作地点状语，表示存在关系，定语从句主谓一般要倒置。 打南边来了一个喇嘛；背上背着一个胖娃娃 They arrived at a farm house, in front of which sat a small boy 他来到一处农舍，(农舍)前边坐着一个小男孩。 理解： a small boy sat in front of the farm house（此时a small boy是主语， sat 是谓语）, 地点状语做主语之后，主谓倒装， a small boy 做sat的宾语2. I saw a man,on the head of whom stood a bird.理解： 道理同上 a bird stood on the head of a man. 地点状语在前，主谓倒装 （三） 介词+ which（指物）/ whom（指人）在定语从句中作目的、方式或地点状语。这种结构中的介词一般受动词或介词后的名词所制约。找定语从句里的动词看它应该搭配什么介词 Could you tell me for whom you brought this coat (你能告诉我这件衣服是给谁买的吗？) 理解： buy sth for sb, for whom 在此处是目的，指给某人2. The man, from whom I learned the news, is an engineer. (这人是一位工程师，我是从他那里得到这消息的。)理解： learn sth from sb ，此处是方式 （四） 介词+which/whom，用于被动结构的定语从句中，作状语，说明动作的发出者。 被动的使用是为了更加强调动作发出者的厉害 The wolf by which the sheep was killed was shot (伤害羊的那只狼被打死了) 理解： the sheep was killed by the wolf, 上面句子中的which就是表示the wolf.2. The man by whom the wolf was shot was a good hunter. 打死狼的那人是个好猎手。理解： the wolf was shot by the man, 上面句子中的whom表示the man 倒装句英语倒装结构的六大形式详解（一） 否定副词位于句首时的倒装在正式文体中，never, seldom, rarely, little,hardly, scarcely, no sooner, no longer, nowhere 等含有否定意义的副词若位于句首，则其后要用部分倒装： I shall never forgive him -&gt; Never shall I forgive him. 我永远不会宽恕他。 He seldom goes out for dinner -&gt; Seldom does he go out for dinner. 他很少出去吃饭。 She hardly has time to listen to music -&gt; Hardly does she have time to listen to music. 她几乎没时间听音乐。 He little realizes how important this meeting is -&gt; Little doeshe realize how important this meeting is. 他不甚明白这个会议的重要性 We had no sooner reached the airport than the plane took off -&gt; No sooner had we reached the airport than the plane took off. 我们刚到机场,飞机就起飞了。 注意： in no time(立即，马上)位于句首时，其后无需用倒装语序： In no time he worked out the problem. 他马上就算出了那道题。 (二) only+状语”位于句首时的倒装当一个状语受副词only的修饰且置于句首时，其后用部分倒装语序： Only then did he realize that he was wrong. 到那时他才意识到他错了。 Only in this way are you able to do it well. 你只有用这种方法才能把它做好。 Only when he returned home did he realize what had happened. 当他回到家里时，才知道出了什么事。 (三) so+adj. / adv.”位于句首时的倒装副词so后接形容词或副词位于句首时，其后用部分倒装 The weather was so cold that we had to stay at home. -&gt; So cold was the weather that we had to stay at home. 天气太冷，我们只好呆在家里。 Light travels so fast that we can hardly imagine its speed -&gt; So fastdoes light travel that we can hardly imagine its speed. 光速很快，我们几乎没法想像它的速度。 The attack was so sudden that we had no time to escape -&gt; So suddenwas the attack that we had no time to escape. 袭击来得非常突然，我们来不及逃跑。 总结： 此类型的原句就是so…that (如此.. 以至于..) (四) so+助动词+主语”倒装当要表示前面提出的某一肯定的情况也同样适合于后者 You are young and so am I. (你年轻，我也年轻) 注意： 不能省略and, so am I 是一个句子，需要连接She likes music and so do I. (她喜欢音乐，我也喜欢）If he can do it,so can I. (要是他能做此事，我也能) 注意“逗号”的使用， 条件从句若前面提出某一否定的情况，要表示后者也属于同样的否定情况，则应将其中的so改为neither或norYou aren’t young and neither am I. (你不年轻，我也不年轻)She hasn’t read it and nor have I. (她没有读它，我也没有读)注意该结构与表示强调或同意的“so+主语+特殊动词”结构的区别, 此种情况不需要倒装A: “It was cold yesterday.(昨天很冷)” B: “So it was. (的确很冷)”A: “Father, you promised.(爸爸，你答应过的)” B: “Well,so I did. （嗯，是答应过）”注意： so + adj/adv 基本可以互换such a/an + adj + n, such开头的也要倒装，但是互换有时会改变表达情感 （五） 由not only…but also引出的倒装当not only…but also位于句首引出句子时，not only 后的句子通常用部分倒装形式， but also 后面正常语序 Not only is he a teacher, but also he is a poet. (他不仅是一位教师，而且是一位诗人)Not only did he speak more correctly, but also he spoke more easily. (不仅他讲得更正确，也讲得更不费劲了) 注意： not only .. but also 中but also不一定非要连在一起，也可以只留but或只留also ： Not only is he a teacher, but he is also a poet (这样写更舒服地道) (六) 虚拟条件句的省略与倒装当if引导的虚拟条件从句中含有had, were, should等时，如将if省略，则要将had, were, should等移到主语前，构成倒装句 If you had come yesterday, you would have seen him. -&gt; Had you come yesterday, you would have seen him.If you should require anything give me a ring. -&gt; Should you require anything give me a ring.If it were not for your help,I would still be homeless. -&gt; Were it not for your help, I would still be homeless. (要不是你帮助，我会仍然无家可归)省略if后提前的had不一定是助动词If I had money, I would buy it. -&gt; Had I money, I would buy it. (此处的had是实意动词) （七） As 引导的让步状语从句倒装as作“虽然”解，引导让步状语从句时，必须将表语、状语或动词原形提到as前面。此时应注意几点： 若提前的表语是没有形容词修饰的单数可数名词，要省略不定冠词； 若提前的是动词原形(多为不及物动词)，与之连用的通常是may, might, will, would等，且这些词都要保留在原来的位置上(主语后)； though有时也可像as这样使作倒装， although绝对不能倒装** Tired（形容词） as I was, I tried to help them. 虽然我很累，我还是努力帮助他们。 =Although I was tired, I tried to help them.Try（动词） as he would, he couldn’t open the door. 他试过多次了, 却仍打不开那门。 =Although he would try, he couldn’t open the door.Search(动词） as they would, they would find nobody in the house. 无论怎样搜查，他们在房子里仍然没有找到一个人。 =Although they would search, they would find nobody in the house.Hard(副词） as (though) they tried, they couldn’t make her change her mind. 尽管他们做了很大努力，却没法让她改变主意。 =Although they tried hard, they couldn’t make her change her mind.Boy(名词无冠词） as he was, he behaved like a girl. 他虽是个男孩，但举止却像个女孩。 =Although he was a boy, he behaved like a girl. 状语从句状语主要是用来修饰动词和形容词的，以表明动作发生或状态存在的时间、地点、原因、目的、结果等。状语从句即指在主从复合句中用作状语的从句。状语从句主要用来修饰主句或主句的谓语（一） 时间状语从句时间状语从句用表示时间的连词连接一个句子作状语，这样的主从复合句就是时间状语从句, 常用引导词：when, as, while, as soon as, before, after, since , till, until 由when,while, as引导的时间状语从句的区别用法 when引导的从句的谓语动词可以是延续性的动词，又可以是瞬时动词, 并且when有时表示“就在那时”When she came in, I stopped eating.她进来时，我在吃饭。(瞬时动词) [came in 此时是瞬间动词， 她进来我有注意到她，吃饭停了一下]When I lived in the countryside, I used to carry some water for him.当我的住在农村时，我常常为他担水。（延续性的动词） [live in 是延续性动词，一直在住着]We were about to leave when he came in.我们就要离开，就在那时他进来了。（就在那时） 总结： when 引导的从句有激活主句的感觉，从句的内容要平行并列主句. While引导的从句的谓语动作必须是延续性的，并强调主句和从句的动作同时发生（或者相对应）。并且while有时还可以表示对比My wife was reading the newspaper, while I was watching TV. 我妻子在看报纸，我在看电视。(was reading是延续性的动词，并且was reading和was watching同时发生)I like playing football while you like playing basketball.我喜欢踢足球，而你喜欢打篮球。 (此处表示对比) 总结： while后面始终要加延续性动词 As表示“一边……一边”，as引导的动作是延续性的动作，一般用于主句和从句动作同时发生；as也可以强调“一先一后。We always sing as we walk.我们总是边走边唱。（as表示“一边……一边”） [这里强调我们持续这样很长时间，像是一辈子的习惯]As we was going out, it began to snow. 当我们出门时，开始下雪了。（as强调句中两个动作紧接着先后发生，而不强调开始下雪的特定时间） 总结： as表示的持续性甚至是一种习惯 Note: 主从复合句，要强调的东西在前面写，这也是英文的的使用习惯，强调的东西始终放在第一位 . 由before和after引导的时间状语从句的区别用法 before引导的从句不再用否定式的谓语，并且当before引导的从句位于主句之后，有时译成“就，才”或“ 还没来得及… 就”。还要注意主句和从句之间的时间关系。当主句用将来时，从句总是用现在时；如果before引导的从句谓语用的是过去时，则主句动词多用过去完成时，这样以便体现动作发生的先后It will be four days before they come back. （主将从现，一一对应） (他们要过四天才能回来)Einstein almost knocked me down before he saw me. （几乎同时发生） (爱因斯坦几乎把我撞倒才看到我)My father had left for Canada just before the letter arrived. （主过完从过） (我父亲恰好在信到之前去加拿大了) leave for smw (离开去某地)They had not been married four months before they were divorced. (他们结婚还不到四个月就离婚了) after表示主句动作发生在从句动作之后。主句和从句的动作的时间关系正好与before引导的从句相反After you think it over, please let me know what you decide. (你仔细考虑过以后，告诉我你是怎样决定的)After we had finished the work, we went home. (完成工作之后，我们回家了) （从句用过去完成时，主句用一般过去时） till或until引导的时间状语从句的区别 till和until一般情况下两者可以互换，但是在强调句型中多用until,但是注意注意注意：①如果主句中的谓语动词是瞬时动词时，必须用否定形式；②如果主句中的谓语动词是延续性动词时，用肯定或否定形式都可以，但表达的意思不同。③till不可以用在句首，而until可以放在句首。I didn’t go to bed until（till）my father came back. (直到我父亲回来我才上床睡觉。)It was not until the meeting was over that he began to teach me English. (直到散会之后他才开始教我英语)I worked until he came back.我工作到他回来为止。（前肯意为否）I didn’t work until he came back.他回来我这才开始工作。（前否意为肯）Please wait until I arrived.在我到达之前请等我。 since引导的时间状语从句的用法 since引导的从句的谓语动词可以是延续性的动词，又可以是瞬时动词。一般情况下，从句谓语动词用一般过去时，而主句的谓语动词用现在完成时。但在It is ＋时间＋since从句的句型中，主句多用一般现在时I have been in Beijing since you left. （主现完从过去） (自从你离开以来，我一直在北京了)Where have you been since I last saw you? （主现完从过去） (自上次我和你见面以后，你到哪里去了？)It is four years since my sister lived in Beijing. (我妹妹不在北京住有四年了)（今日重点句型，表示相反意思） 在时间状语从句中 当主句是一般将来时或祈使句表示将来的意义时，时间状语从句用一般现在时I’ll let him know as soon as she comes.（主将从现） (她一来，我就会让你知道) （二） 原因状语从句用表示原因的连词连接一个句子作状语，这样的主从复合句就是原因状语从句，原因状语从句通常由because, since, as,for 引导 项目 位置 内涵 语气 能否回答why because(因为) 主句前或者后，通常放在后面为好 直接因果关系，或一些不太想说的原因 强 能 as(由于) 主句前或者后 双方都知道的原因 弱 不能 since/now that (既然) 主语前 双方都知道原因 弱 不能 for (因为) 句中，通常由逗号隔开 补充说明原因或推断的依据 弱 不能 because表示直接原因，语气最强。Because引导的原因状语从句多放在主句之后。回答由why提出的问题，只能用because。I was absent from the meeting because I was ill. as和since语气较弱，一般用来表示明显的原因,即众所周知或当事人都知道，由as和since引导的原因状语从句多放在句首As it is raining, we will not go to the park. (PS:下雨就在眼前，都知道)Now that/ Since everybody is here, let’s begin our meeting. for有时也可引出表示原因的分句，但它只能位于后面，对前一分句加以解释或推断It must have rained last night, for the ground is wet． (三) 目的状语从句*用表示目的的连词连接一个句子作状语，这样的主从复合句就是目的状语从句，目的状语从句通常由so that, in order to , in case, for fear * I hired a boat so that I could go fishing. (我租了一条船去钓鱼) Take your raincoat in case it rains (should rain). (带上雨衣以防下雨) He studied hard in order that he could pass the exam. (他努力学习是为了能通过考试) 注意： in case 和 for fear 的区别： in case 指“假如某种情况出现,我们要……” 同时发生的可能性非常大不可避免,for fear指“我们要……以免某种情况出现”,前者强调主语的能动性 He worked hard for fear that he might be fired by the boss (他拼命地干活惟恐被老板解雇) He walked fast for fear that he should be late. (他快走,以免迟到) 注意： so that既可引导目的状语从句，又可引导结果状语从句。区别这两种从句的办法有两个 目的状语从句里往往带有情态动词can, could, may, might等,从意思上看，目的状语从句往往表示的目的很明确Speak clearly so that they may understand you. (目的状语从句)Jack is badly ill so that he has to rest. (结果状语从句) （四） 条件状语从句用表示条件的连词连接一个句子作状语，这样的主从复合句就是条件状语从句，引导条件状语从句的从属连词主要有if, unless，as long as, 激活条件 Don’t come unless I telephone (除非我打电话，否则你别来) If you watch carefully you will **see how to do it (如果你仔细看，你会看出该怎样做) I’ll help you with your English if I am free tomorrow (如果我明天有空，我就帮你辅导英语) He won’t be late unless he is ill (除非他病了，否则他不会迟到) 注意： 祈使句连词要在中间 在条件状语从句里，谓语动词通常用现在时态表示将来的动作或状态（主将从现），但是条件是不可能发生或实现的就是虚拟语气了，“If I were you ” （五） 结果状语从句引导结果状语从句的从属连词主要有so that, so…that，such…that等 在由so…that引导的结果状语从句中，so是副词，与形容词连用。其结构是: “…so + 形容词（副词）+ that + 从句 The hall is so big that it can hold 2,000 people (这个大厅大得能容纳2000人) Mother lives so far away that we hardly ever see her (妈妈住得太远了我们都无法常见面) He shut the window with such force that the glass broke (他关窗子用力太大，玻璃都震破了) 在由such…that引导的结果状语从句中，such是形容词，它修饰的可以是单数或复数可数名词，也可以是不可数名词；名词前面可以带形容词，也可不带。如果是单数可数名词，前面需加不定冠词a或an It was such a hot day that nobody wanted to do anything (天太热了，没人愿意干活) He made such rapid progress that he did very well in the mid-term. (他进步很快，期中表现非常好) 如果名词前由many, much, little, few等词修饰时，只能用so, 不用such, 即“多多少少只能用so” Soon there were so many deer(单复数一样) that they ate up all the wild roses (很快就聚集了许多鹿，啃光了所有的野玫瑰) He has so little time that he can’t go to the cinema with you (他几乎没时间跟你们去电影院) so…that…句型的否定形式可用简单句too…to…或not…enough to代替 He is so young that he can’t go to school = He is too young to go to school 当so/such…that结构中的so或such放在句首时，主句用倒装语序 So proud was he that he never listened to any advice (他太骄傲了以致于从来听不进任何建议) (六) 让步状语从句 项目 位置 注意事项 though 句首,或句末 放在句末，做副词，意为“可是，不过” ,不可与but连用，可与yet,still连用 even though 通常放在句中链接主从句 even if 通常放在句中链接主从句 although 句首或句中 在句首需要有逗号，在句中不需要逗号，不可与but连用，可与yet,still连用 引导让步状语从句的从属连词主要有although, though, even though，even if（即使） Though we are poor, we are still happy. 我们虽然穷，但是很快活。 He went out even though it was raining. 尽管下着雨，他还是出去了。 It’s hard work, I enjoy it though. 工作很辛苦，可我乐意干 The speech is good, it could be better though. 这次演讲不错，虽然还可以再好一点 Although Princeton has a world famous university, it is still a small quiet town. 普林斯顿虽然有一所闻名世界的大学，但仍然是个安静的小镇。 He often helps me with my English although he is pretty busy. 尽管他相当忙，但还是常常帮助我学英语。 Although the book was old , we decided to buy it . 尽管这本书很旧，我们还是决定买。 Though she was busy with her work, yet she managed to find time to stay with her family 虽然她忙于工作,但她还是挤出时间与家人在一起. She was busy with her work ,and yet she managed to find time to stay with her family (这里是副词and yet ==but ) She was busy with her work , yet she managed to find time to stay with her family （这里是连接词,解释为：虽然,但是=but ） 连词while有时也可表示“尽管”、“虽然”，引导让步状语从句 While we don’t agree with each other, we continue to be friends. 尽管我们意见不同，我们还是朋友 whatever, whoever, however, whenever, wherever等引导让步状语从句, 歌词中多见 Don’t lose heart whatever you do. 不管你做什么，都不要灰心。 Whoever you are, you can’t pass this way. 不管你是谁，你都不能从这里通过 as也可引导让步状语从句，但要将名词、形容词或副词等提到as前，若提前的是单数可数名词，要省略a或an，引导让步状语从句 Teacher as he is, he can’t know everything. 虽然是老师，他也不可能什么都懂。 Though引导的让步状语从句可用部分倒装，倒装后位于句首的名词之前不用冠词a或an Poor though I am ,I can afford it. 我虽穷，但这东西还是买得起的。 习语 as though (好像，仿佛)，even though (即使，纵然)， 有一种虚拟在里面, 不确定是否是某种情况 She closed her eyes as though she were tired. 她闭上眼，仿佛很疲劳似的。He is an honest man, I must say, even though I has opposed him. 尽管我反对他，我还得说他是个诚实的人。 (七) 地点状语从句注意区分where引导的定语从句与状语从句 You’d better make a mark where you have any questions. (状语从句)你最好在有疑问的地方做个记号。 You’d better make a mark at the place where you have any questions. (定语从句) 你最好在有疑问的地方做个记号。 Where引导状语从句—副词性从句 当Where引导状语从句时，Where前没有表示地点的先行词，Where是从属连词，Where引导的从句修饰主句的谓语动词 The famous scientist grew up where he was born and in 1930 he came to Shanghai. (这位知名的科学家就在出生地成长，1930年来到上海。)评析：句中“the famous scientist grew up “这一部分是该句的主句，Where到句子最后是地点状语从句，where前没有表示地点的先行词. She found her passport where she lost it . (她在她丢护照的地方找到了护照。)评析：”passport”是主句 found 后的宾语，它并不是从句中lost的地点，因此 where 引导的是地点状语从句，从属连词where引导的从句修饰主句的谓语动词 found 。 Where引导定语从句—形容词性从句 当where 引导定语从句时，Where前有表示地点的先行词，where 引导的从句修饰先行词，Where是关系副词，在从句中作地点状语 He’s got himself into a dangerous situation where is likely to lose control over the plane . (他在飞机上失去控制，处于极其危险的境地。)评析：situation 是先行词，其后是Where引导的定语从句。 This is the place where Luxun once lived . (这是鲁迅曾经生活过的地方。)评析： the place 是先行词，其后是 where引导的定语从句 ，where 在从句中作地点状语。 在有些情况下,where引导的定语从句可转换为where引导的地点状语从句. A tall building was put up at the place where there used to be a desert.＝A tall building was put up where there used to be a desert. (在以前曾是沙漠的地方盖起了一幢高楼.) where引导宾语从句、表语从句、主语从句———名词性从句 This is where Luxun once lived. 这是鲁迅曾经住的地方(where 引导表语从句) I don’t know where Luxun once lived .我不清楚鲁迅曾经住在哪里。(where 引导宾语从句) She was free to go to where she liked . 她可以去任何她喜欢的地方。(where 引导宾语从句) Where Mary was born is Beijing . 玛利出身的地方是北京。(where 引导主语从句) 学后感 先行词是地点类的名词 place situation case， 后面的where引导定语从句 where 出现在什么地方就是充当什么成分 主句动词后面除了宾语和表语，剩下的就是状语 状语用来修饰的是主句的动词 课后习题 有志者事竟成。 Where there is a will, there is a way. 书在你原来放的地方。 The book is where you left it. 她回到了她刚才坐的地方。 She is back to where she sat just now. 请呆在原处。 Please stay where you are. 这就是他曾工作过的农场。 This is the farm where he once worked. （八） 比较状语从句常见的引导词有： as…as,not so (as)…as, than, the more…the more等 the more + 主谓， the more + 名词 + 主谓 The harder you work, the more progress you will make. 你越努力，取得的进步就越大。 The more you study, the more knowledge you can get. 你学的知识越多，你的知识越丰富。 not so/as … as 之间只能是形容词原级，不可以是比较级和最高级 The work is not so difficult as you imagine. 这工作不像你想像的那么困难。 He doesn’t work as hard as she (does). 他工作不像她那样努力。 表示倍数的三种句型 倍数＋as many +可数名词复数+as 倍数+as much+不可数名词+as 倍数+as+形容词原级+名词+as I have twice as many books as you do. 我拥有的书是你的两倍。 It is reported that the United States uses twice as much energy as the whole of Europe. 据报道美国人使用的能源是整个欧洲的两倍。 I can rent three times as big a room as yours in my city using that money. 用那些钱我能在我们的城市租一个三倍大的房间。 注意： adj + a/an + 名词 （九） 方式状语从句常见的引导词有：as ,as if ，as though ** as if 从句用陈述语气的情况,当说话者认为句子所述的是真实的或极有可能发生或存在的事实时 ** It sounds as if it is raining．听起来像是在下雨。 He talks as if he is drunk．从他谈话的样子来看他是醉了。 as if 从句用虚拟语气的情况,当说话人认为句子所述的是不真实的或极少有可能发生或存在的情况时。从句虚拟语气动词时态的形式如下 如果从句表示与现在事实相反，谓语动词用一般过去时 You look as if you didn’t care． 你看上去好像并不在乎。 He talks as if he knew where she was． 他说话的样子，好像他知道她在哪里似的。 从句表示与过去事实相反，谓语动词用“had＋过去分词” He talks about Rome as if he had been there before． 他说起罗马来好像他以前去过罗马似的。 The girllistened as if she had been turned to stone． 那女孩倾听着，一动也不动，像已经变成了石头似的。 从句表示与将来事实相反，谓语动词用“would／could／might＋动词原形” He opened his mouth as if he would say something． 他张开嘴好像要说什么。 It looks as if it might snow．看来好像要下雪了。 注意： as if /though引导的从句常用虚拟语气，表示非真实情况，但如果从句中陈述的情况很可能实现，也可用陈述语气 （十） 状语从句的省略当时间、条件、让步、方式和比较状语从句的主语与主句一致或为it 或 there且谓语动词含be动词时，从句中的主语和谓语可以一起省去 Don’t speak until spoken to.( 省略了you are) 你不要讲话，除非让你讲话。 I have no money. If any, I will lend yousome. 我手里没有钱，有的话，我会借给你的。( 省略了there is) Though cold, he still wore a shirt. 尽管很冷，他却只穿一件短袖。 ( 省略了it was) 强调句（一） 区分强调句与其他类型从句（主、定、状） 强调句与主语从句的区别 It is true that he is honest. (主语从句) 他真的很诚实。 True he is honest (去掉It is … that 之后不成句子，所以是主语从句，强调句去掉仍然成句子如： It is Mr Fu that is honest) It is known to all that China is a country with a long history. (主语从句) 众所周知，中国是一个历史悠久的国家。It was here that he fell off his bicycle.(强调句) 这正是他从自行车上摔下来的地方。 总结： “It is / was + 形容词 / 分词 / + that从句”是主语从句，它译成中文时不可加上“正是……”“就是……”之类字眼， 含有定语从句的强调句型 (在被强调的名词后再设计一个以该名词为先行词的定语从句，这时不要把定语从句当作强调句)。 It was this school where (in which) he once studied that gave him a chance of teaching.正是这所他曾经学习过的学校给了他教学的机会。 总结： 这种句子先写主干： It was this school…. that gave him a chance of teaching 强调句型与状语从句的区别 It was at 7:00 that I arrived.(强调句型，强调时间状语at 7:00)正是在7:00时， 我到了。 It was 7:00 when I arrived.(时间状语从句，在7:00前无介词at) 当我到达时， 时间是7:00。 It was two years ago that I began to learn drawing.(强调句型，前后时态一致) 正是在两年前我开始学习绘画。 It is(has been) two years since I began to learn drawing.(since引导的时间状语从句，前后时态不一致) 自从我学习绘画以来已经有两年了。 It was two years before they came to see us.(时间状语从句) 过了两年后他们才来看我们。 It was two years later that they came to see us.(强调句型) 正是两年后他们才来看我们的。 It won’t be long before we graduate from the school. (时间状语从句) 不久我就将毕业了。 It will be two years before we graduate from this university. (时间状语从句) 再过两年我们就将大学毕业了。 总结： 可以看先行词，如果是引导时间的词since before after 就是时间状语从句， that是强调句 （二） 强调三关 常用句式 sb1 cut sb1 off sb1截断了sb2的来源（多只经济来源） My daddy cut me off 我老爸断了我的经济来源sth cut sb off (sth断了)Machine cut me off (电话断了) sb is dumb blonde that has no common sense 某人是没有常识的金发女郎（世界观及价值观与常人不同） I knew it was stupid and I shouldn’t have done it 我知道这事情很蠢我也不该这么做 shouldn’t have done, 本来不该做的事情做了，同理，should have done,本该做的事情没做，口语中使用频率很高.You shouldn’t have said that. sb is at rock bottom 某人在很惨/低谷的时候 I think it is the best thing that could’ve ever happened to you get out on one’s way 自力更生 We should get out on our way. How does he expect me to do sth 责备的语气，怎么可以这样？太过分了 How does my boss expect me to work overtime tune (曲调，调整，使一致) tune in(收听) America tuned in to watch six very attractive singles navigate relationships and life in New York Citystay tuned (不要换台，不要走开， DJ常用语) clip 小段音频或视频， next clip， clip section 2 wind(wound) up doing == end up doing 最终.. Right in the very beginning 就在一开始 *we really just fell in love and adored（倾慕） each other instantly * sitcom = situation comedy （情景喜剧） Who have the best chemistry of the group? chemistry: 化学反应，相互吸引，并非配合的默契 take sb under one’s … he graciously took me under his wings. be filthy rich filthy /‘fɪlθi/ 肮脏的，污秽的，猥亵的， 是指有铜臭的那种感觉 Tom is filthy rich. I don’t want to go into sth 我不想详细的解释/讲这件事， 因为懒/麻烦不愿意说 It won’t work out …行不通 have words 达成一致 His mind is blown/ sb blew his mind 脑袋爆炸，指信息量很大，一时接受不了 But not yet …还没怎样，但是要快了 I expect(预测)/look forward to(期盼) it will rain today What if I … 如果我…. 通常接过去时/过去完成时 What if I was still fat （过去时）What if I had had the guts(勇气) to quit my job （过去完成时）What if…? 主要有三种用法，此处表示假设，意思是“要是……将会怎么样”。此外，它还可以表示邀请或建议，意思是“如果……如何？”What if…? 还可以表示某事不重要，常常与so连用，意为“就算……那又怎样？What if you join us for lunch? 同我们一起吃晚饭怎么样 （表示邀请/建议）So what if we’re a little late? 就算我们迟到一小会又怎样 （表示某事不重要） golden years 黄金年代 prime time 黄金时间 That’s for sure 那毋庸置疑， 可以在自己说的句子末尾加上这句话， 也可以在别人说过话之后说这句话表示肯定和认可 Don’t dwell (不要沉溺于过去) dwell /dwɛl/ (vi. 居住；存在于；细想某事)move on / look forward 是其反义词 表示向前看 casual Friday 通常所说的happy Friday, 指工作族不用在星期五穿西装打领带那么不自由 only if/if only only if 的only 是重点，”只有如果(当…)”,if only 的if是重点”如果…就好了(既然假设就虚拟)” You guys really think that I’m that shallow (你们真的那么认为我那么肤浅/浅薄吗？) wear a tie (戴领带) sb have a knack for sth 某人有… 天分 knack /næk/ n. 诀窍；本领；熟练技术；巧妙手法 I have a knack for stocks 我有炒股票的天分/潜质 quit my job 放弃我的工作，表示辞职 I have to admit, *the horoscope stuff really caught my attention. 我不得不承认，星座运势这东西引起了我的兴趣 Virgos have a strong attention to detail, they are known to take good care of people 处女座及其关注细节，他们是公认的擅长照顾别人 Do you have some studying(homework) to do? Do you not wanna be seen with me? 和 Don’t you wanna be seen with me? (两者表达的意思不一样， 前者在当时的对话情景猜测到对方的意思) I’m about to leave (我马上要离开， 指下一秒将要做某事) *you may frown upon that. * （你可能心里头不舒服，表示表情上，内心里（暗暗）不满，不同意， 而disapprove,disagree 表示言语上的不同意） You are so fired. ！ 你铁定被解雇了 有点你会被解雇的很惨的意思 you are so dead 你死定了 what are you [doing] 句型扩展 what are you trying to say. (你想说什么)情景应用： A: 说了半天也说不明白，或者在纠结该不该说 B: what are you trying to say? 你现在正在尝试要说什么？ what do you want to say? (你想说什么)情景应用： A: 跑到B面前说“Can I talk to you?” B: what do you want to say? 你想要说什么？ what are you doing saying this （你说这个干什么，带有责备语气）情景应用： 一般情况下，句型 what are you doing [doing] 带有责备的情感在里面 what are you doing talking to her about that? 你和她谈论那个干什么？ Please bear in mind 请记住 Please bear in mind that I love you forever. Twist the knife 往伤口上撒盐，揭伤疤 They’re all twisting the knife. Split the cost 分摊成本，类似于中国的AA制 you can’t be too careful in your work A：你出门还带刀自我保护，太夸张了吧 B：You can’t be too careful.（现在世道这么乱，再怎么小心也不为过, 小心使得万年船） Do you mind if we switch places？ （becasue I get off next 可说可不说） 类似于在电梯中请求互换位置 mean to do sth 有意做某事 故意做某事 // run into sb 不小心撞到别人，偶遇别人=bump into Oops, I did not mean to run into you like that, sir 哎呀！我没成想要这么碰到你的，对不起，先生。 school night/work night school night 明早还要上学work night 明天要上班以上两种句型的理解：上班(上学)期间，不是放假期间，晚上不要玩疯，要做准备，为了第二天工作、学习 Is it a school night and she has a lot of homework to do? Bring ’em on 放马过来 还想说什么就说吧 girl/boy scouts 美国12岁以下孩子的一个real life的锻炼活动， 猜测类似夏令营， 为了筹办活动买girl/boy scouts cookies Tell sb good luck with sth. 表示“祝某人在某事上有好运”，口语中经常使用。 A: Tom will have an exam tomorrow. 汤姆明天有个考试。 B: Tell him good luck with that. 帮我祝他好运。 I can let it go for eight. (结合上下文是8000元成交的意思， 其中let it go， 可以想象养了好久的宠物要走了，舍不得，此处理解为“勉强成交，非常不情愿的让价”) We stand firm at $10 (我们坚决付十块， stand firm at … 坚定..立场) I’m over it (不在乎，无所谓了) hold out sth （伸出手里的东西，直直的拿着…） Engagement ring 结婚戒指 poker face （ 一本正经的面容, 面无表情的人） a man-to-man talk (一对一的，坦率的,直言不讳的; 畅所欲言的) count on sb (依赖/指望某人) Don’t count on me (别指望我)You can count on us (你可以指望/依赖我们) toe the line (脚靠着线，不要越界，循规蹈矩，遵守规则) thread the needle (有balance的意思 也有讽刺这个东西很难， “线穿针眼”) it’s like thread the needle. (这个东西很难) think outside the box (创新思维，摆脱思维定式) I have bigger fish to fry (有更大、重要的事情要处理) 通常会说 I have bigger fish *sb is heartless * ( 某人无情无义) she/he gets on one knee （单膝跪地求婚） take a knee (教练：围起来听教练讲话) We’re engaged 我们订婚了 engagement ring 订婚戒指 We’re dying out here! ( 我们等得快急死了！) be likely to do sth. (表示“很有可能做某事”，强调可能性) It is likely to rain. 好像快要下雨了。be unlikely to (不大可能，不再发生)These tactics are unlikely to be helpful to you (这种方法对你未必有用)He is very ill and unlikely to recover (他病得很重，不大可能恢复健康了) lose one’s temper （失态） the box that it came in （包装的箱子） shake hand (握手) Parents shouldn’t play favorites （父母不应偏心） I’m the favorite (我是父母喜欢的那一个) I’m kind/sort of （kina）tired （我有点累，比I’m a little bit tired更地道） clever/smart/resourceful/competent 在美国clever带有“小聪明”的意思，也有指动物的聪明， 在英国clever可以指人的聪明， 所以夸人聪明还是用smart比较合适resourceful 形容人比较足智多谋，资源分丰富competent/incompetent 有能力的和没有能力的 形容人 *get the hell out of here * （滚出去 也有强调的意思， 要读的快和地道才有感觉） check clear/bounce (形容支票是可以支出钱或不能支出钱) I can’t wait to see everything again! （ 我都等不及要再次看到它们了！） can’t wait to do sth.表示“迫不及待要做某事”，口语中的使用频率很高。 can’t/couldn’t help doing sth. (情不自禁做某事) I can’t help laughing. (我忍不住大笑) hit 常用短语总结： hit on sb (撩妹，泡妞) —— Cindy never realizes when boys are hitting on her(Cindy 总是浑然不知有男生在追她) hit on sth (灵机一动想到sth) —— He hit on an idea that would be a perfect surprise (他灵机一动，想到了完美的生日趴体惊喜) hit smw (上路去哪) —— Let’s hit the road after staying here for a night (我们在这呆一晚就上路吧) hit the sack/hay (就寝、睡觉) —— Tina was so tired that she hit the sack soon after long hours works （Tina 实在是太累了，长时间工作以后早早睡觉去了） hit the nail[指甲、钉子] (说话中肯，一针见血) —— He always hit the nail on the head so all people found him extremly reliable （他说话总是一针见血，所有人都觉得他很靠谱） hit the jackpot (中头彩) —— Jocelin is the perfect girl for me, I’ve hit the jackpot in life being with her (Jocelin是我的真命天女，能和她在一起真是我这辈子最大的福分) hit it off well (一拍即合) —— We all thought the two of you would hit it off well （我们大家都认为你们会相处愉快） hit the bottle (酗酒) —— He started to hit the bottle to relieve stress. (他开始用酗酒来释放压力) hit the light (开灯) —— Would you please hit the light for me? （请问你可以帮我开一下灯么？） hit the big (做到，成功) —— We hit the big (我们成功了) hit the book (啃书，用工读书) —— I got an exam tomorrow. so I got to hit the books tonight. （我明天有个考试，今晚我要念书呢） hit the roof (暴跳如雷，大怒) —— My parents would hit the roof if he knew that I wrecked his car （如果我爸发现我毁了他的车，一定会暴跳如雷的） hit me (场景： 对酒吧调酒师说hit me, 指再来一杯) *ground rules = basic rule * (基本规则) Are there ground rules (有什么基本的规则吗？ 如在玩游戏前做好规则) I’m just saying (A: you’re so handsome, I’m just saying. 为了避免尴尬的局面，可以说I’m just saying.) He really told her off (他臭骂了她一顿) shave a head (理发) *on top of * (并且 另外) *reduce anxiety * (减少、降低焦虑，注意动词的使用) fixate on sth (提起sth) Why does everyone keep fixating on that? (为什么大家都绕着这个话题打转？ ) *of course it was a line * (显然这是骗你的) live off (以…为食料；靠…生活；住在…之外) You can’t live off your parents all the time (你不能一直靠你父母生活) 是（is）, 有（there be）, 时（when） (万能转换) loudly 和 loud 的区别 loudly 有吵闹的声音大的感觉speak loud and clear 为某人支付费用 cover for you (暂时帮你付，回头你需要归还) I forgot my wallet, can you cover me? (我忘记带钱包了，能先临时帮我付一下吗？)pay for you (帮你付，不需要你还) She gives him a withering look （她用一个绝望或失望的眼神看了他一眼） You had one job (就让你干了一件事还干不好的意思) *beyond one’s grasp, beyond one’s capatibility , out of reach, out of control 区别 * beyond one’s grasp (鞭长莫及，有能力，但是远水解不了近渴的感觉) I can’t help him because it’s beyond my graspbeyond one’s capatibility (超出某人的能力范围) The work is difficult and beyond my capatibility (工作太难超出了我的能力范围，也可以直接说 it’s beyond me)out of reach (指空间距离的不能及) I’m in BJ， teaching in SH is out of reachout of control (某物不可控) The fire is out of control (大火失去了控制) a family of three (三口之家) *have yet to do sth * (used for saying that something has not happened or been done up to the present time, especially when you think it should have happened or been done) As for accommodation, the resort has yet to announce the price of a stay in its hotel rooms. (至于膳宿，度假胜地还没有公布酒店的费用) trial run/flight/version (试运行/试飞/试用版本) turn over in one’s mind (Think about something thoroughly) My father gave me some advice that I’ve been turning over in my mind ever since (我父亲教导过我一句话，我至今还念念不忘) web celebrity (网红， celebrity也可以指名声名气) *You have got to do sth * (强烈建议做某事， got 要加重音) You’ve got to try this. I’m not that much of … (我还没那么…,还没到..程度，也算是一种谦虚的说法) I’m not that much of an artistI’m not that much of a sweet tooth (我不那么喜欢吃甜食) This is the best sth/sb I have ever done This is the best radio show I have ever listened to.This is the best movie I have ever seen Sth is addressed to you* (sth是邮寄给你的) This is not addressed to you (这不是邮寄给你的)注意名词动词的读音区分 vt. 演说；从事；忙于；写姓名地址；向…致辞；与…说话；提出；处理 n. 地址；演讲；致辞；说话的技巧；称呼 send away send away for sth (request another sth) 想象“让快递小哥送过来sth” ** I’ll be right with you.** (等等，我马上就来) Wait a few minutes and I’ll be right with you. (请等一下，我马上就来) sink one’s teeth into sth/sb bite to sth/sbI can’t wait to sink my teeth into that delicious-looking dessert(餐后甜点) you madeThe dog sunk his teeth into the little boy’s arm. get a chance to do something energetically or productivelyI want to give the students a project they can really sink their teeth into.I’m so bored at work. I would like something I can sink my teeth into. first-tier city (一线城市) take sb/sth for granted (把…当成理所当然) So many of us take clean water for granted.Children often take their parents for granted. slow motion hair shake (慢动作甩头发) It’s a running gag （不停出现的笑点） gag me (short for gag me with a spoon) Shit i have so much homework. Gag meee! (杀了我吧，恶心死我吧) stare at sb ( 盯着某人看， 不是很礼貌的行为) Don’t stare wafer thin ice (很危险了) you’re standing on thin ice （你很危险了，“别嘚瑟了，再触碰底线就死定了”） sth rules (sth很给力，指很过瘾) movie rules / water rules *leg warms * (秋裤) You shush （你闭嘴吧） 口语中，You shush或者Shush的使用频率很高，说话者用来让对方“闭嘴”或者“安静一下Shush! I want to hear the weather. (安静！我要听天气预报)Shush! Here he comes. I’ll talk to you later. (嘘！他来了。我一会儿再跟你说)Don’t shush me. (让对方安静的意思)注意： Shush与Shut up所表达的含义相同，但Shush的语气比较委婉和客气，而Shut up则比较粗鲁，一般是急了的情况下用这种表达来让对方“住口” *one hit wonder * (one hit wonder，指代一个歌手或者组合只有一首成功的单曲) There are lots of singers are one hit wonder tell each other secrets (互相揭穿秘密) freshman sophomore junior senior (大一大二大三大四) *valley girl * （说话声音比较大，比较兴奋的女孩，会让周围的人觉得很吵 ） 英语中没有学哥小妹，只需要说来自同一个学校就可以了， he was my friend from college 或者 alumni /ə’lʌmnaɪ/ 校友 to make matters worse (更糟糕的是) tough cookie = a difficult people (难相处的人) wedding vows （very serious promise， 现在多数在结婚时候用了） 婚姻誓词 flash back episode (回顾片段 电影中的回忆片段) *steal one’s thunder * (抢了谁的风头) Your roof, your rules (你的地盘你做主) a blessing in disguise (塞翁失马，因祸得福) word on the street (小道消息) *second mother tongue * （第二母语） serve for sth （服务../用来做..） show off (炫耀，显摆) Reading makes a full man; conference a ready man;and writing an exact man (读书使人充实；交谈使人机敏；笔记使人精确) learn from the past (从历史/过去中学习) Those are way too expensive (way too + adj 太…) He’s a pushover (他是一个容易被掌控使唤的人) He’s a buzzkill (他是一个扫兴的人) i’m not doing it/sth (正在否认不做什么) I’m not returning them, you’ll see (you’ll see 等着看吧，尾语) 成语短语总结 不管三七二十一 &lt;——&gt; 瞻前顾后 rain or shine &lt;——&gt; take a look around You have to carry out(贯彻，执行) your plan, rain or shine. Buddy, just keep going， I’ll be along with you, rain or shine. If you take a look around, you will miss a lot of oppotunities that were supposed to belong to you. 不寒而栗 Make one’ s teeth chatter(使卡嗒卡嗒作声). Make one’s flesh(肉体) creep The mysterious /mɪ’stɪrɪəs/ sound in the dark made Lily’s teeth chatter. The news that fake vaccines were being sold to different provinces in China made my teeth chatter. 不可救药 &lt;——&gt; 微感不适 beyond remedy(补救，治疗，赔偿) &lt;——&gt; To feel off color Robert’s laziness is beyond remedy. Tom feels off color 不可同日而语 &lt;——&gt; 相提并论 can’t be mentioned on the same day &lt;——&gt; place on par John’s idea is different from Jean’s, they can’t be mentioned on the same day. Both of things can not be placed on par. 生词表 序号 单词 音标 词性和解释 1 ditch /dɪtʃ/ vt. 在…上掘沟；把…开入沟里；丢弃 n. 沟渠；壕沟 2 custod /‘kʌstədi/ n. 保管；监护；拘留；抚养权 3 alcoholic /,ælkə’hɔlɪk/ adj. 酒精的，含酒精的 n. 酒鬼，酗酒者 4 revelation /‘rɛvə’leʃən/ n. 启示；揭露；出乎意料的事；被揭露的真相 5 massage /mə’sɑːʒ n. 按摩；揉 vt. 按摩；揉 6 horoscope /‘hɔrəskop n. 占星术；星象；十二宫图 7 nonsense /‘nɑnsɛn/ n. 胡说；废话 8 charming /‘tʃɑrmɪŋ/ adj. 迷人的；可爱的 9 arrogant /‘ærəɡən/ adj. 自大的，傲慢的 10 oops /uːps/ （表示惊讶或后悔）哎哟… 11 taboo /təˈbuː/ 禁忌 12 dash /dæʃ/ 连字符”-“ 13 underscore /ˌʌn.dɚˈskɔːr/ 下划线”_” 14 money-oriented / -ɔːr.i.en.t̬ɪd/ 导向钱的, 注意连字符的使用 15 detail-oriented / -ɔːr.i.en.t̬ɪd/ 导向细节的， 注意连字符的使用，可能几百年后就是一个单词，中间没有连字符 16 alley / ˈæl.i/ 小街, 小巷，胡同, （尤指两边有树或灌木的）小径… 17 stove / stoʊv/ （用于取暖的）炉，火炉, 炉灶… 18 ramen /ˈrɑː.men/ 日式拉面 方便面 19 drip-&gt;dribble /drɪp/ /ˈdrɪb.əl/ 滴嗒-&gt;滴滴答答 frequentative form 反复动词 20 murmur /ˈmɝː.mɚ/ 轻声说, 低声说 ,喃喃自语 frequentative form 反复动词 21 jerk /dʒɜːk/ （美俚) foolish person 蠢人.阿呆,笨瓜,不懂世故 （适合好朋友之间用，有点幼稚，可爱的感觉） 22 seminar /ˈsem.ə.nɑːr/ 专题讨论会, 研讨会… 23 bluff /blʌf/ 以假象欺骗，蒙，唬 24 bury /ˈber.i/ 埋, 埋葬，安葬, 掩埋 25 hatchet /ˈhætʃ.ɪt/ 小斧头 26 cosmetic /kɑːzˈmet̬.ɪk/ adj. 美容的；化妆用的 n. 化妆品；装饰品 27 sentimental /‘sɛntə’mɛntl/ adj. 伤感的；多愁善感的；感情用事的；寓有情感的 28 bend（过去时bent”弯曲的”） /bɛnd/ vt. 使弯曲；使屈服；使致力；使朝向 vi. 弯曲，转弯；屈服；倾向；专心于 n. 弯曲 29 daisy /‘deɪzɪ/ n. 雏菊；菊科植物；极好的东西 adj. 极好的；上等的 30 tassel /‘tæsl/ n. 流苏；缨；穗 vt. 用流苏装饰；摘下…穗 31 step-dad, step-mom, step-brother, step-sister 继父,继母,继兄,继女 32 asbestos /æz’bestɒs / n.石棉 33 ceiling /‘siːlɪŋ/ 天花板 34 oven /‘ʌvən/ n. 烤箱 35 bulb /bʌlb/ n. 电灯泡 36 bittersweet /‘bɪtɚ,swit/ adj. 苦乐参半的；又苦又甜的 n. 又苦又甜的东西；蜀羊泉 37 narcissist /nɑr’sɪsɪst/ n. 自我陶醉者 自恋的人 38 narcissism /‘nɑrsɪ’sɪzə/ n. [心理] 自恋，自我陶醉 39 downhill /,daʊn’hɪl/ adv. 下坡；向下；每况愈下 adj. 下坡的；容易的 n. 下坡；滑降 40 punchline /‘pʌntʃlaɪn/ n. 笑点；结尾警语；妙语如珠 41 bald /bɔld/ adj. 秃顶的；光秃的；单调的；无装饰的 vi. 变秃 42 therapy /‘θɛrəpi/ n. 治疗，疗法 43 tuition /tʊ’ɪʃən/ n. 学费；讲授 44 tutor /‘tʊtɚ/ vt. 辅导；约束 n. 导师；家庭教师；助教 vi. 当家庭教师；（美）在家庭教师指导下学习 45 scooter /ˈskuː.t̬ɚ/ n. 单脚滑行车 46 ambidextrous /‘æmbə’dɛkstrəs/ n. 旁观者 47 onlooker = spectator /‘ɑnlʊkɚ/ adj. 双手灵巧的；怀有二心的 48 vague /veɡ/ adj. 模糊的；含糊的；不明确的；暧昧的 49 genetics /dʒə’nɛtɪks/ n. 遗传学 50 clumsy /‘klʌmzi/ adj. 笨拙的 51 stigma /‘stɪɡmə/ n. [植] 柱头；耻辱；污名；烙印；特征 52 gasp /ɡæsp/ vi. 喘气；喘息；渴望 vt. 气喘吁吁地说；喘着气说话 n. 喘气 (很惊讶的场景，倒吸一口气) 53 creamy /‘krimi/ adj. 奶油色的；乳脂状的；含乳脂的 54 hypocrite /‘hɪpə’krɪ/ n. 伪君子；伪善者 55 foreshadow /fɔrˈʃæd·oʊ/ vt. 预示；成为…的前兆，做铺垫 n. 预兆，铺垫 56 cliche /kliːˈʃeɪ/ n. 陈词滥调；[印刷] 铅版；陈腐思想 adj. 陈腐的 a saying or remark that is very often made and is therefore not original and not interesting ,想象剧情中的甩头发太普遍了，烂大街了 57 conversationalist /ˌkɑːn.vɚˈseɪ.ʃən.əl.ɪst/ n. 健谈的人 someone who enjoys or is good at talking with people 58 intently /ɪnˈtent·li/ adv. 专心地；一心一意地；心无旁骛地 in a way that shows great attention to something 59 pathetic /pəˈθet̬.ɪk/ adj. 可怜的，悲哀的；感伤的；乏味的","categories":[{"name":"Life","slug":"Life","permalink":"https://dayarch.top/categories/Life/"},{"name":"English","slug":"Life/English","permalink":"https://dayarch.top/categories/Life/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://dayarch.top/tags/English/"}]},{"title":"Hexo在github上搭建自己的博客","slug":"buildGithubBlog","date":"2015-08-09T12:01:29.000Z","updated":"2019-11-07T05:16:06.555Z","comments":true,"path":"/p/build-github-pages-blog.html","link":"","permalink":"https://dayarch.top/p/build-github-pages-blog.html","excerpt":"引言 长时间在某平台上写博客记录些什么，但是近期该平台陆陆续续出现一些小问题，让写博客这么愉快的事情总是充斥着各种插曲，稍稍不爽，于是乎开始准备搭建自己的的博客，通过查阅资料用了两天时间初步搭建起来，收获颇丰，所以趁热打铁记录整个过程，搭建过程参考了非常多前辈们的blog，先真诚的道一声“感谢”，文章末尾会给出相关的参考链接。可搭建博客的框架很多，参考静态博客框架对比，选择你看上眼的，本文选择Hexo，为什么选择它，我只能说对比之后喜欢. 为什么选择github平台？ 为什么选择github平台，我们通过下面的两组问题就可以得到答案了. 博友们是否在编写博客的时候遇到过以下问题： 1.","text":"引言长时间在某平台上写博客记录些什么，但是近期该平台陆陆续续出现一些小问题，让写博客这么愉快的事情总是充斥着各种插曲，稍稍不爽，于是乎开始准备搭建自己的的博客，通过查阅资料用了两天时间初步搭建起来，收获颇丰，所以趁热打铁记录整个过程，搭建过程参考了非常多前辈们的blog，先真诚的道一声“感谢”，文章末尾会给出相关的参考链接。可搭建博客的框架很多，参考静态博客框架对比，选择你看上眼的，本文选择Hexo，为什么选择它，我只能说对比之后喜欢. 为什么选择github平台？为什么选择github平台，我们通过下面的两组问题就可以得到答案了. 博友们是否在编写博客的时候遇到过以下问题： 博客平台升级维护 没有网络（比博客升级和维护还惨） 不够定制化 github上搭建自己的博客当然是有很多好处的： 学着用github，享受github的便利，上面有很多大牛，眼界会开阔很多 顺便看看github工作原理，最好的团队协作流程 自我认为开源是一种趋势，github上有良好的开源氛围与精神 定制化的博客，可以按照自己的喜好来做更改 即便离线我也可以按照Markdown语法来编写博客，有网络时上传即可 一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成，可读性强 搭建过程按照下面的过程逐步进行，细心理解领会，你会发现搭建过程很简单, 下文都是在Windows 环境进行搭建。 前期准备工作安装Hexo很简单，但是需要下面两样东东的支持： Node.js Git 在Windows 环境安装真的是太简单了，基本上是无脑下一步 Hexo安装在某个磁盘目录下新建一个文件夹，然后鼠标右键单击【Git Bash】, 进入下图： 执行下面命令安装Hexo： $ npm install -g hexo-cli 查看一下安装的Hexo版本（本人安装的是3.1.1） hexo的命令要怎么用？必须help命令来帮忙 安装好后就需要初始化Hexo来创建项目了 $ hexo init 该文件夹下会生成以下文件： scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能 source 存放博客正文内容 source/_drafts 草稿箱 source/_posts 文件箱 themes 存放皮肤的目录 themes/landscape 默认的皮肤 _config.yml 全局的配置文件 db.json 静态常量 项目创建完毕，就要启动了 $ hexo server 这个地方可能会遇到错误， 因为server在Hexo 3的版本被分离出来，需要单独安装： $ npm install hexo-server –save 这样重新启动就好了. 这时端口4000被打开了，我们能过浏览器打址，http://localhost:4000/ 我们可以使用下面命令来创建新page来写博客了 $ hexo new myNewPage 创建好myNewPage.md文件会自动放在source/_posts目录下，生成的md后缀的文件需要采用Markdown进行编写，然后刷新页面，你就会发现你的新文章了，是不是有点小激动，还有更好的，往下看。 更改Hexo主题安装好的Hexo我们都是一样的在source/themes默认主题landscape, 是不是觉得不够爽， 那就选择主题, 这里面应该有你想要的那一款吧。 执行下面命令将选好的主题clone到自己的hexo空间 $ git clone https://github.com/A-limon/pacman.git themes/pacman 这样你会发现pacman这个主题就在你的themes文件下了，想让自己博客指定主题，只需要修改hexo的主题文件_config.yml 中的theme属性即可 theme: pacman 重新启动，刷新你的页面，主题变了吧。 配置和使用Github我们如何让本地git项目与远程的github建立联系呢？用SSH keys开始菜单处单击【Git Bash】** 首先我们需要检查你电脑上现有的ssh key： $ cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用git， 接下来需要生成SSH keys $ ssh-keygen -t rsa -C “邮件地址@youremail.com”Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 注意: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」 系统要求输入密码和确认密码： $ Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;$ Enter same passphrase again:&lt;再次输入加密串&gt; 最后看到下面界面就生成了SSH keys 按照log提示找到id_rsa.pub文件，复制里面的内容，然后将SSH keys添加到github上，登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys 可以通过下面命令来进行测试是否成功 $ ssh -T git@github.com 现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。 $ git config –global user.name “your name”$ git config –global user.email “username@gmail.com“ 至此SSH keys设置成功 发布博客到Github我们的终极目标是将博客发布到github上，我们还是需要有一些准备工作要做。在github上新建username.github.io的repository，至于为什么请参考github pages 本地新建一个文件夹，该文件夹下右键单击【Git Bash】 执行命令 $ git clone git@github.com:username/username.github.io.git 这样就在本地生成了自己的repository 怎样发布到github上去，我们同样要修改hexo下的_config.yml文件，在最后deployment处增加这样两行 deploy:type: githubrepo: git@github.com:username/username.github.io.git 然后执行命令进行静态化，将所有文件静态化到public文件夹下 $ hexo generate 然后进行部署 $ hexo deploy 这个地方可能又遇到问题了，提示【hexo ERROR Deployer not found: github】，同样是3以上版本的问题，按照下面操作即可： $ npm install hexo-deployer-git –save 然后将上面说到的部署文件的type由github改为git deploy:type: gitrepo: git@github.com:username/username.github.io.git 重新生成静态文件，然后发布，这样在浏览器中输入username.github.io就可以到你在github上的博客了， 有没有小激动？ 最后小伙伴们哪里看不懂或哪里有问题欢迎留言，我进行补充或回答, 更多问题可以参考官网文档Docs . 最后真的感激前辈们的博文指点，下面提供我参考过的一些链接： 如何搭建一个独立博客——简明GithubPages与Hexo教程 Hexo在github上构建免费的Web应用 搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门 用Jekyll在github上写博客——《搭建一个免费的，无限流量的Blog》的注脚","categories":[{"name":"Coding","slug":"Coding","permalink":"https://dayarch.top/categories/Coding/"},{"name":"Others","slug":"Coding/Others","permalink":"https://dayarch.top/categories/Coding/Others/"}],"tags":[{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://dayarch.top/tags/GitHub-Pages/"}]}]}
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>ForkJoinPool大剖析 | 日拱一兵｜Java｜Spring Boot｜Java并发编程｜最新干货分享</title>
  
  <meta name="keywords" content="ForkJoinPool,ForkJoinTask,分治算法,RecursiveTask,RecursiveAction, Java,SpringBoot,并发编程, ElasticSearch, 日拱一兵">
  
  
  <meta name="description" content="ForkJoinPool 是分治算法 Java 的典型应用，这是一个效率更高的线程池，但是理解它的原理还是相对困难，本文就从源码剖析的角度来理解 ForkJoinPool, 本站是日拱一兵的技术分享博客，内容涵盖Java后端技术、Spring Boot、Java并发编程等技术研究与分享，用有趣的方式解读技术">
  

  
  <link rel="alternate" href="/atom.xml" title="日拱一兵｜Java｜Spring Boot｜Java并发编程｜最新干货分享">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-147539283-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-147539283-1');
    </script>
  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f553477a3dc5ab3837e9a4dead4e0bc7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  


  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-1774278264048334",
        enable_page_level_ads: true
      });
    </script>

    
        <script>
        (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
        daovoice('init', {
            app_id: "8a3d6849"
        });
        daovoice('update');
        </script>
    
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <img class='logo' src='/assets/logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="世界很大，搜索一下" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
              rel="nofollow"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/categories/"
            
              rel="nofollow"
            
            
            id="categories">
            <i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/tags/"
            
              rel="nofollow"
            
            
            id="tags">
            <i class='fas fa-tags fa-fw'></i>&nbsp;标签
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/archives/"
            
              rel="nofollow"
            
            
            id="archives">
            <i class='fas fa-archive fa-fw'></i>&nbsp;归档
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/comments/"
            
              rel="nofollow"
            
            
            id="comments">
            <i class='fas fa-comments fa-fw'></i>&nbsp;留言板
          </a>
        </li>
      
    
  </ul>
</div>

<br>
<div class="description center-align">
    
    <span id="typed"></span>
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.9"></script>
    <script>
        var typed = new Typed("#typed", {
            strings: ['从来没有真正的绝境, 只有心灵的迷途', 'Never really desperate, only the lost of the soul'],
            startDelay: 300,
            typeSpeed: 100,
            loop: true,
            backSpeed: 50,
            showCursor: true
        });
    </script>
    
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>		
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          日拱一兵
        
      </a>
		<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                    rel="nofollow"
                  
                  
                  id="home">
									<i class='fas fa-home fa-fw'></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="tags">
									<i class='fas fa-tags fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="archives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友链
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/comments/"
                  
                    rel="nofollow"
                  
                  
                  id="comments">
									<i class='fas fa-comments fa-fw'></i>&nbsp;留言板
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>
		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                  rel="nofollow"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/categories/"
                
                  rel="nofollow"
                
                
                id="categories">
								<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/tags/"
                
                  rel="nofollow"
                
                
                id="tags">
								<i class='fas fa-tags fa-fw'></i>&nbsp;标签
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/"
                
                  rel="nofollow"
                
                
                id="archives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/comments/"
                
                  rel="nofollow"
                
                
                id="comments">
								<i class='fas fa-comments fa-fw'></i>&nbsp;留言板
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
      <a title='ForkJoinPool大剖析' href='/p/java-fork-join-pool.html'><img class='thumbnail' src='https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-imgconcurrency.png'></a>
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/p/java-fork-join-pool.html">
        ForkJoinPool大剖析
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="https://dayarch.top" rel="nofollow">
        
          <img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-imgavatar.png">
        
        <p>tanθ</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2021-02-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/Coding/Java-Concurrency/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Coding&nbsp;/&nbsp;Java-Concurrency</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p>并发工具类我们已经讲了很多，这些工具类的「目标」是让我们只关注任务本身，并且忽视线程间合作细节，简化了并发编程难度的同时，也增加了很多安全性。工具类的对使用者的「目标」虽然一致，但每一个工具类本身都有它独特的应用场景，比如：</p>
<ul>
<li><a href="https://dayarch.top/p/why-we-need-to-use-threadpool.html">我会手动创建线程，为什么要使用线程池?</a> 介绍了使用线程池管理线程将一个大任务分解成多个子任务来简单执行，借助 <a href="https://dayarch.top/p/java-future-and-callable.html">不会用Java Future，我怀疑你泡茶没我快, 又是超长图文！！</a> 的 Future 特性获取子任务执行结果——<strong>二者结合使用就可以处理简单的并行任务</strong></li>
<li><a href="https://dayarch.top/p/java8-completablefuture-tutorial.html">搞定 CompletableFuture，并发异步编程和编写串行程序还有什么区别？</a> 借助 CompletableFuture 大大降低了异步编程的难度——<strong>使用串行的思维对任务进行编排执行（AND 或 OR 聚合）</strong></li>
<li><a href="https://dayarch.top/p/executorservice-vs-completionservice.html">既生 ExecutorService, 何生 CompletionService？</a> 由于任务完成时间有先后，为避免等待阻塞——<strong>CompletionService 是批量并行任务的最佳选择</strong></li>
</ul>
<p>将上面三种通用场景形象化展示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201228204001.png" alt=""></p>
<p>结合上图相信你的脑海里已经浮现出这几个工具类的具体实现方式，感觉这已经涵盖了所有的并发场景。</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201228205507.png" alt=""></p>
<p>TYTS，以上这些方式的子线程接到任务后不会再继续拆分成「子子」任务，也就是说，子线程即便接到很大或很复杂的任务也得硬着头皮努力执行完，很显然这个大任务是问题关键</p>
<p><strong>如果能把大任务拆分成更小的子问题，直到子问题简单到可以直接求解就好了</strong>，这就是分治的思想</p>
<h2 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h2><p> 在计算机科学中，分治法是一种很重要的算法。字面上的解释是「分而治之」，就是把一个复杂的问题<strong>分成</strong>两个或更多的相同或相似的<strong>子问题</strong>，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解就变成了子问题解的<strong>合并</strong>。</p>
<p>这个技巧是很多高效算法的基础，如排序算法 (快速排序，归并排序)，傅立叶变换 (快速傅立叶变换)……，如果你是搞大数据的，MapReduce 就是分支思想的典型，如果你想更详细的理解分治相关的算法，请参考这篇<a href="https://mp.weixin.qq.com/s/kRBAwF5xAV54AqdvmMLxAg" target="_blank" rel="noopener">一文图解分治算法和思想</a></p>
<p>结合上面的描述，相信你脑海中已经构建出来分治的模型了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201228211510.png" alt=""></p>
<p>那所有的大任务都能用分治算法来解决吗？很显然不是的</p>
<h3 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a>分治法适用的情况</h3><p>总体来说，分治法所能解决的问题一般具有以下几个特征：</p>
<ol>
<li><p>该问题的规模缩小到一定的程度就可以容易地解决</p>
</li>
<li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
</li>
<li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p>
</li>
<li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题</p>
</li>
</ol>
<p>了解了分治算法的核心思想，我们就来看看 Java 是如何利用分治思想拆分与合并任务的吧</p>
<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>有子任务，自然要用到多线程。我们很早之前说过，<strong>执行子任务的线程不允许单独创建，要用线程池管理</strong>。秉承相同设计理念，再结合分治算法， ForkJoin 框架中就出现了 ForkJoinPool 和 ForkJoinTask。正所谓:</p>
<blockquote>
<p>天对地，雨对风。大陆对长空。山花对海树，赤曰对苍穹</p>
</blockquote>
<p>套用已有知识，简单理解就是这样滴:</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210217110917.png" alt=""></p>
<p>我们之前说过无数次，JDK 不会重复造轮子，这里谈及相似是为了让大家有个简单的直观印象，内里肯定有所差别，我们先大致看一下这两个类：</p>
<h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><p>又是这个男人，<code>Doug Lea</code>，怎么就那么牛（破音）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract base class for tasks that run within a &#123;<span class="doctag">@link</span> ForkJoinPool&#125;.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> ForkJoinTask&#125; is a thread-like entity that is much</span></span><br><span class="line"><span class="comment"> * lighter weight than a normal thread.  Huge numbers of tasks and</span></span><br><span class="line"><span class="comment"> * subtasks may be hosted by a small number of actual threads in a</span></span><br><span class="line"><span class="comment"> * ForkJoinPool, at the price of some usage limitations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>ForkJoinTask</code> 实现了 <code>Future</code> 接口（那就是具有 Future 接口的特性），同样如其名，<code>fork()</code> 和 <code>join()</code> 自然是它的两个核心方法</p>
<ul>
<li><code>fork()</code> : 异步执行一个子任务（上面说的拆分）</li>
<li><code>join()</code> : 阻塞当前线程等待子任务的执行结果（上面说的合并）</li>
</ul>
<p>另外，从上面代码中可以看出，<code>ForkJoinTask</code> 是一个抽象类，在分治模型中，它还有两个抽象子类 <code>RecursiveAction</code> 和 <code>RecursiveTask</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201228221139.png" alt=""></p>
<p>那这两个子抽象类有什么差别呢？如果你打开 IDE，你应该一眼就能看出差别，so easy</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201228221929.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span>&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个类里面都定义了一个<strong>抽象</strong>方法 <code>compute()</code> ，需要子类重写实现具体逻辑</p>
<blockquote>
<p>那子类要遵循什么逻辑重写这个方法呢？</p>
</blockquote>
<p>遵循分治思想，重写的逻辑很简单，就是回答三个问题：</p>
<ul>
<li>什么时候进一步拆分任务？</li>
<li>什么时候满足最小可执行任务，即不再进行拆分？</li>
<li>什么时候汇总子任务结果</li>
</ul>
<p>用「伪代码」再翻译一下上面这段话，大概就是这样滴：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(任务小到不用继续拆分）&#123;</span><br><span class="line">    直接计算得到结果</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    拆分子任务</span><br><span class="line">    调用子任务的fork()进行计算</span><br><span class="line">    调用子任务的join()合并计算结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（作为程序员，如果你写过递归运算，这个逻辑理解起来是非常简单的）</p>
<p>介绍到这里，就可以用 ForkJoin 干些事情了——经典 <strong>Fibonacci</strong> 计算就可以用分治思想（不信，你逐条按照上面<strong>分治算法适用情况</strong>自问自答一下？），直接借用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html" target="_blank" rel="noopener">官方 Docs</a> （注意看 compute 方法），额外添加个 main 方法来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为了追踪子线程名称，需要重写 ForkJoinWorkerThreadFactory 的方法</span></span><br><span class="line">		<span class="keyword">final</span> ForkJoinPool.ForkJoinWorkerThreadFactory factory = pool -&gt; &#123;</span><br><span class="line">			<span class="keyword">final</span> ForkJoinWorkerThread worker = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);</span><br><span class="line">			worker.setName(<span class="string">"my-thread"</span> + worker.getPoolIndex());</span><br><span class="line">			<span class="keyword">return</span> worker;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建分治任务线程池，可以追踪到线程名称</span></span><br><span class="line">		ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>, factory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 快速创建 ForkJoinPool 方法</span></span><br><span class="line">		<span class="comment">// ForkJoinPool forkJoinPool = new ForkJoinPool(4);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建分治任务</span></span><br><span class="line">		Fibonacci fibonacci = <span class="keyword">new</span> Fibonacci(n);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用 invoke 方法启动分治任务</span></span><br><span class="line">		Integer result = forkJoinPool.invoke(fibonacci);</span><br><span class="line">		log.info(<span class="string">"Fibonacci &#123;&#125; 的结果是 &#123;&#125;"</span>, n, result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">	Fibonacci(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		<span class="keyword">this</span>.n = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//和递归类似，定义可计算的最小单元</span></span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 想查看子线程名称输出的可以打开下面注释</span></span><br><span class="line">		<span class="comment">//log.info(Thread.currentThread().getName());</span></span><br><span class="line"></span><br><span class="line">		Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 拆分成子任务</span></span><br><span class="line">		f1.fork();</span><br><span class="line">		Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">		<span class="comment">// f1.join 等待子任务执行结果</span></span><br><span class="line">		<span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201229223143.png" alt=""></p>
<p>进展到这里，相信基本的使用就已经搞定了，上面代码中使用了 ForkJoinPool，那问题来了：</p>
<blockquote>
<p>池化既然是一类思想，Java 已经有了 <code>ThreadPoolExecutor</code> ，为什么又要搞出个 <code>ForkJoinPool</code>  呢？</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201230205543.png" alt=""></p>
<p>借助下面这张图，先来回忆一下 ThreadPoolExecutor 的实现原理（详情请看<a href="https://dayarch.top/p/why-we-need-to-use-threadpool.html">为什么要使用线程池</a>）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20201230215609.png" alt=""></p>
<p>一眼就能看出来这是典型的<code>生产者/消费者</code>模式，<strong>消费者线程都从一个共享的 Task Queue 中消费提交的任务</strong>。ThreadPoolExecutor 简单的并行操作主要是为了<strong>执行时间不确定的任务</strong>（I/O 或定时任务等）</p>
<p>JDK 重复造轮子是不可能的，分治思想其实也可以理解成一种父子任务依赖的关系，当依赖层级非常深，用 <code>ThreadPoolExecutor</code> 来处理这种关系很显然是不太现实的，所以 <code>ForkJoinPool</code> 作为功能补充就出现了</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>任务拆分后有依赖关系，还得减少线程之间的竞争，那就让线程执行属于自己的 task 就可以了呗，所以较 <code>ThreadPoolExecutor</code> 的单个 TaskQueue 的形式，<code>ForkJoinPool</code> 是多个 TaskQueue的形式，简单用图来表示，就是这样滴：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210102222146.png" alt=""></p>
<p>有多个任务队列，所以在 ForkJoinPool 中就有一个数组形式的成员变量 <code>WorkQueue[]</code>。那问题又来了</p>
<blockquote>
<p>任务队列有多个，提交的任务放到哪个队列中呢？（上图中的 <code>Router Rule</code> 部分）</p>
</blockquote>
<p>这就需要一套路由规则，从上面的代码 Demo 中可以理解，提交的任务主要有两种：</p>
<ul>
<li><p>有外部直接提交的（<strong>submission task</strong>）</p>
</li>
<li><p>也有任务自己 fork 出来的（<strong>worker task</strong>）</p>
</li>
</ul>
<p>为了进一步区分这两种 task，Doug Lea 就设计一个简单的路由规则：</p>
<ul>
<li>将  <code>submission task</code> 放到 WorkQueue 数组的<code>「偶数」</code>下标中</li>
<li>将 <code>worker task</code> 放在 WorkQueue 的<code>「奇数」</code>下标中，并且只有奇数下标才有线程( worker )与之相对</li>
</ul>
<p>应局部丰富一下上图就是这样滴：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210217101059.png" alt=""></p>
<p>每个任务执行时间都是不一样的（当然是在 CPU 眼里），执行快的线程的工作队列的任务就可能是空的，为了最大化利用 CPU 资源，就允许空闲线程拿取其它任务队列中的内容，这个过程就叫做 <code>work-stealing</code> (工作窃取)</p>
<p>当前线程要执行一个任务，其他线程还有可能过来窃取任务，这就会产生竞争，为了减少竞争，WorkQueue 就设计成了一个双端队列：</p>
<ul>
<li>支持 LIFO(last-in-first-out) 的push（放）和pop（拿）操作——<strong>操作 top 端</strong></li>
<li>支持 FIFO (first-in-first-out) 的 poll （拿）操作——<strong>操作 base 端</strong></li>
</ul>
<p>线程（worker）操作自己的 WorkQueue 默认是 LIFO 操作(可选FIFO)，当线程（worker）尝试窃取其他 WorkQueue 里的任务时，这个时候执行的是FIFO操作，即从 base 端窃取，用图丰富一下就是这样滴：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210103103303.png" alt=""></p>
<p>这样的好处非常明显了：</p>
<ol>
<li>LIFO 操作只有对应的 worker 才能执行，push和pop不需要考虑并发</li>
<li>拆分时，越大的任务越在WorkQueue的base端，尽早分解，能够尽快进入计算</li>
</ol>
<p>从 WorkQueue 的成员变量的修饰符中也能看出一二了(base 有 volatile 修饰，而 top 却没有)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line"><span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br></pre></td></tr></table></figure>



<p>到这里，相信你已经了解  ForkJoinPool 的基本实现原理了，但也会伴随着很多疑问（这都是怎么实现的？），比如：</p>
<ul>
<li>有竞争就需要锁，ForkJoinPool 是如何控制状态的呢？</li>
<li>ForkJoinPool 的线程数是怎么控制的呢？</li>
<li>上面说的路由规则的具体逻辑是什么呢？</li>
<li>……</li>
</ul>
<p>保留住这些问题，一点点看源码来了解一下吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210217111929.png" alt=""></p>
<h2 id="源码分析（JDK-1-8）"><a href="#源码分析（JDK-1-8）" class="headerlink" title="源码分析（JDK 1.8）"></a>源码分析（JDK 1.8）</h2><p>ForkJoinPool 的源码涉及到大量的位运算，这里会把核心部分说清楚，想要理解的更深入，还需要大家自己一点点追踪查看</p>
<p>结合上面的铺垫，你应该知道 ForkJoinPool 里有三个重要的角色：</p>
<ul>
<li>ForkJoinWorkerThread（继承 Thread）：就是我们上面说的线程（Worker）</li>
<li>WorkQueue：双向的任务队列</li>
<li>ForkJoinTask：Worker 执行的对象</li>
</ul>
<p>源码分析的整个流程也是围绕这几个类的方法来说明，但在了解这三个角色之前，我们需要先了解 ForkJoinPool 都为这三个角色铺垫了哪些内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-imgae2c6e1dly1geiq8cgrnag20b20b27wh.gif" alt=""></p>
<p>故事就得从 ForkJoinPool 的构造方法说起</p>
<h3 id="ForkJoinPool-构造方法"><a href="#ForkJoinPool-构造方法" class="headerlink" title="ForkJoinPool 构造方法"></a>ForkJoinPool 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">       defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">       checkFactory(factory),</span><br><span class="line">       handler,</span><br><span class="line">       asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">       <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">  checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了以上三个构造方法之外，在 JDK1.8 中还增加了另外一种初始化 ForkJoinPool 对象的方式（QQ：这是什么设计模式？）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the common pool instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool <span class="title">commonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert common != null : "static init error";</span></span><br><span class="line">  <span class="keyword">return</span> common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Common 是在静态块里面初始化的(只会被执行一次)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">common = java.security.AccessController.doPrivileged</span><br><span class="line">            (<span class="keyword">new</span> java.security.PrivilegedAction&lt;ForkJoinPool&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ForkJoinPool <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> makeCommonPool(); &#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ... 其他默认初始化内容 </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">      parallelism = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">    parallelism = MAX_CAP;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行上面的构造方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                          <span class="string">"ForkJoinPool.commonPool-worker-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这是一个单例通用的 ForkJoinPool，所以切记：</p>
<blockquote>
<p>如果使用通用 ForkJoinPool，最好只做 CPU 密集型的计算操作，不要有不确定性的 I/O 内容在任务里面，以防拖垮整体</p>
</blockquote>
<p>上面所有的构造方法最后都会调用这个私有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">  <span class="keyword">this</span>.factory = factory;</span><br><span class="line">  <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">  <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">  <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">  <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参数有点多，在这里解释一下每个参数的含义：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数名</th>
<th>描述/解释</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>parallelism</td>
<td>并行度，这并不是定义的线程数，具体线程数，以及 WorkQueue 的长度等都是根据这个并行度来计算的，通过上面 <strong>makeCommonPool</strong> 方法可以知道，parallelism 默认值是 CPU 核心线程数减 1</td>
</tr>
<tr>
<td>2</td>
<td>factory</td>
<td>很常见了，创建 ForkJoinWorkerThread 的工厂接口</td>
</tr>
<tr>
<td>3</td>
<td>handler</td>
<td>每个线程的异常处理器</td>
</tr>
<tr>
<td>4</td>
<td>mode</td>
<td>上面说的 WorkQueue 的模式，LIFO/FIFO；</td>
</tr>
<tr>
<td>5</td>
<td>workerNamePrefix</td>
<td>ForkJoinWorkerThread的前缀名称</td>
</tr>
<tr>
<td>6</td>
<td>ctl</td>
<td>线程池的核心控制线程字段</td>
</tr>
</tbody></table>
<p>在构造方法中就已经有位运算了，太难了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210103112940.png" alt=""></p>
<p>想知道 ForkJoinPool 的成员变量 config 要表达的意思，就要仔细拆开来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK        = <span class="number">0xffff</span>;        <span class="comment">// short bits == max index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br></pre></td></tr></table></figure>

<p><code>parallelism &amp; SMASK</code> 其实就是要保证并行度的值不能大于 SMASK，上面所有的构造方法在传入 parallelism 的时候都会调用 <code>checkParallelism</code> 来检查合法性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP      = <span class="number">0x7fff</span>;        <span class="comment">// max #workers - 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkParallelism</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parallelism &lt;= <span class="number">0</span> || parallelism &gt; MAX_CAP)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> parallelism;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 parallelism 的最大值就是 <code>MAX_CAP</code> 了，<code>0x7fff</code> 肯定小于<code>0xffff</code>。所以 config 的值其实就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.config = parallelism | mode;</span><br></pre></td></tr></table></figure>

<p>这里假设 parallelism 就是  <code>MAX_CAP</code> , 然后与 mode 进行<code>或运算</code>，其中 mode 有三种：</p>
<ul>
<li>LIFO_QUEUE</li>
<li>FIFO_QUEUE</li>
<li>SHARED_QUEUE</li>
</ul>
<p>下面以 LIFO_QUEUE 和 FIFO_QUEUE 举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mode bits for ForkJoinPool.config and WorkQueue.config</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK    = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// top half of int</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE   = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE   = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// must be negative</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215155932.png" alt=""></p>
<p>所以 <code>parallelism | mode</code> 根据 mode 的不同会产生两种结果，但是会得到一个确认的信息：</p>
<blockquote>
<p>config 的第 17 位表示模式，低 15 位表示并行度 parallelism</p>
</blockquote>
<p>当我们需要从 config 中获取模式 mode 时候，只需要用mode 掩码 （MODE_MASK）和 config 做<code>与运算</code>就可以了</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215160028.png" alt=""></p>
<p>所以一张图概括 config 就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215160533.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215161815.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码就是将并行度 parallelism 补码转换为 long 型，以  <code>MAX_CAP</code>  作为并行度为例，np 的值就是</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215162208.png" alt=""></p>
<p>这个 np 的值，就会用作 ForkJoinPool 成员变量 ctl 的计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Active counts 活跃线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  AC_SHIFT   = <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK    = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Total counts 总线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TC_SHIFT   = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT    = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK    = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>); <span class="comment">// sign</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 ctl </span></span><br><span class="line"><span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br></pre></td></tr></table></figure>



<ul>
<li><code>np &lt;&lt; AC_SHIFT</code> 即 np 向左移动 48 位，这样原来的低 16 位变成了高 16 位，再用 AC 掩码（AC_MASK） 做<code>与运算</code>，也就是说 ctl 的 49 ～ 64 位表示活跃线程数</li>
<li><code>np &lt;&lt; TC_SHIFT</code> 即 np 向左移动 32 位，这样原来的低 16 位变成了 33 ～ 48 位，再用 TC 掩码做<code>与运算</code>，也就是说 ctl 的 33 ～ 48 位表示总线程数</li>
</ul>
<p>最后二者再进行或运算，如果并行度还是  <code>MAX_CAP</code> ，那 ctl 的最后结果就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215172727.png" alt=""></p>
<p>到这里，我们才阅读完一个构造函数的内容，从最终的结论可以看出，初始化后 AC = TC，并且 ctl 是一个小于零的数，ctl 是 64 位的 long 类型，低 32 位是如何构造的并没有在构造函数中体现出来，但注释给了明确的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Bits and masks for field ctl, packed with 4 16 bit subfields:</span></span><br><span class="line"><span class="comment">* AC: Number of active running workers minus target parallelism</span></span><br><span class="line"><span class="comment">* TC: Number of total workers minus target parallelism</span></span><br><span class="line"><span class="comment">* SS: version count and status of top waiting thread</span></span><br><span class="line"><span class="comment">* ID: poolIndex of top of Treiber stack of waiters</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* When convenient, we can extract the lower 32 stack top bits</span></span><br><span class="line"><span class="comment">* (including version bits) as sp=(int)ctl.  The offsets of counts</span></span><br><span class="line"><span class="comment">* by the target parallelism and the positionings of fields makes</span></span><br><span class="line"><span class="comment">* it possible to perform the most common checks via sign tests of</span></span><br><span class="line"><span class="comment">* fields: When ac is negative, there are not enough active</span></span><br><span class="line"><span class="comment">* workers, when tc is negative, there are not enough total</span></span><br><span class="line"><span class="comment">* workers.  When sp is non-zero, there are waiting workers.  To</span></span><br><span class="line"><span class="comment">* deal with possibly negative fields, we use casts in and out of</span></span><br><span class="line"><span class="comment">* "short" and/or signed shifts to maintain signedness.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Because it occupies uppermost bits, we can add one active count</span></span><br><span class="line"><span class="comment">* using getAndAddLong of AC_UNIT, rather than CAS, when returning</span></span><br><span class="line"><span class="comment">* from a blocked join.  Other updates entail multiple subfields</span></span><br><span class="line"><span class="comment">* and masking, requiring CAS.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这段注释主要说明了低 32 位的作用（后面会从源码中体现出来，这里先有个印象会对后面源码阅读有帮助），按注释含义先完善一下 ctl 的值：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215175423.png" alt=""></p>
<ul>
<li><strong>SS：</strong>栈顶工作线程状态和版本数（每一个线程在挂起时都会持有前一个等待线程所在工作队列的索引，由此构成一个等待的工作线程栈，栈顶是最新等待的线程），第一位表示状态  <code>1：不活动(inactive)</code>； <code>0：活动(active)</code>，后15表示版本号，防止 ABA 问题</li>
<li><strong>ID:</strong> 栈顶工作线程所在工作队列的索引</li>
</ul>
<p>注释中还说，另 <code>sp=(int)ctl</code>，即获取 64 位 ctl 的低 32 位（<code>SS | ID</code>），因为低 32 位都是创建出线程之后才会存在的值，所以推断出，如果 sp != 0， 就存在等待的工作线程，唤醒使用就行，不用创建新的线程。这样就通过 ctl 可以获取到有关线程所需要的一切信息了</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215180950.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215180028.png" alt=""></p>
<p>除了构造方法所构建的成员变量，ForkJoinPool 还有一个非常重要的成员变量 <code>runState</code>，和你之前了解的知识一样，线程池也需要状态来进行管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;               <span class="comment">// lockable status</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// runState bits: SHUTDOWN must be negative, others arbitrary powers of two</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSLOCK     = <span class="number">1</span>;       <span class="comment">//线程池被锁定</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSIGNAL    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;	<span class="comment">//线程池有线程需要唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STARTED    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;  <span class="comment">//线程池已经初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STOP       = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;	<span class="comment">//线程池停止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TERMINATED = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//线程池终止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  SHUTDOWN   = <span class="number">1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">//线程池关闭</span></span><br></pre></td></tr></table></figure>

<p><code>runState</code> 有上面 6 种状态切换，按注释所言，只有 <code>SHUTDOWN</code> 状态是负数，其他都是整数，在并发环境更改状态必然要用到锁，ForkJoinPool 对线程池加锁和解锁分别由 <code>lockRunState</code> 和 <code>unlockRunState</code> 来实现 (这两个方法可以暂且不用深入理解，可以暂时跳过，只需要理解它们是帮助安全更改线程池状态的锁即可)</p>
<p>不深入了解可以，但是我不能不写啊…… 你待会不是得回看吗？</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210215182810.png" alt=""></p>
<h3 id="lockRunState"><a href="#lockRunState" class="headerlink" title="lockRunState"></a>lockRunState</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires the runState lock; returns current (locked) runState.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 从方法注释中看到，该方法一定会返回 locked 的 runState，也就是说一定会加锁成功</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockRunState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> rs;</span><br><span class="line">  <span class="keyword">return</span> ((((rs = runState) &amp; RSLOCK) != <span class="number">0</span> ||</span><br><span class="line">           !U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs |= RSLOCK)) ?</span><br><span class="line">          awaitRunStateLock() : rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为 RSLOCK = 1，如果 runState &amp; RSLOCK == 0，则说明目前没有加锁，进入<code>或运算</code>的下半段 CAS</li>
<li>先通过 CAS 尝试加锁，尝试成功直接返回，尝试失败则要调用 <code>awaitRunStateLock</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Spins and/or blocks until runstate lock is available.  See</span></span><br><span class="line"><span class="comment">* above for explanation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitRunStateLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object lock;</span><br><span class="line">  <span class="keyword">boolean</span> wasInterrupted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> spins = SPINS, r = <span class="number">0</span>, rs, ns;;) &#123;</span><br><span class="line">    <span class="comment">//判断是否加锁（==0表示未加锁）</span></span><br><span class="line">    <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过CAS加锁</span></span><br><span class="line">      <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, ns = rs | RSLOCK)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重置线程终端标记</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            <span class="comment">// 这里竟然 catch 了个寂寞</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加锁成功返回最新的 runState，for 循环的唯一正常出口</span></span><br><span class="line">        <span class="keyword">return</span> ns;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">      r = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>; <span class="comment">// xorshift</span></span><br><span class="line">      <span class="keyword">if</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">        --spins;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Flag1 如果是其他线程正在初始化占用锁，则调用 yield 方法让出 CPU，让其快速初始化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> || (lock = stealCounter) == <span class="keyword">null</span>)</span><br><span class="line">      Thread.yield();   <span class="comment">// initialization race</span></span><br><span class="line">    <span class="comment">// Flag2 如果其它线程持有锁，并且线程池已经初始化，则将唤醒位标记为1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs | RSIGNAL)) &#123;</span><br><span class="line">      <span class="comment">// 进入互斥锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 再次判断，如果等于0，说明进入互斥锁前刚好有线程进行了唤醒，就不用等待，直接进行唤醒操作即可，否则就进入等待</span></span><br><span class="line">        <span class="keyword">if</span> ((runState &amp; RSIGNAL) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(Thread.currentThread() <span class="keyword">instanceof</span></span><br><span class="line">                  ForkJoinWorkerThread))</span><br><span class="line">              wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          lock.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面代码 33 ～ 34 （Flag1）行以及 36 ～ 50 （Flag2） 行，如果你没看后续代码，现在来理解是有些困难的，我这里先提前说明一下：</p>
<p><strong>Flag1:</strong> 当完整的初始化 ForkJoinPool 时，直接利用了 stealCounter 这个原子变量，因为初始化时（调用 externalSubmit 时），才会对 StealCounter 赋值。所以，这里的逻辑是，当状态不是 STARTED 或者 stealCounter 为空，让出线程等待，也就是说，别的线程还没初始化完全，让其继续占用锁初始化即可</p>
<p><strong>Flag2:</strong> 我们在讲等待/通知模型时就说，不要让无限自旋尝试，如果资源不满足就等待，如果资源满足了就通知，所以，如果 <code>(runState &amp; RSIGNAL) == 0</code> 成立，说明有线程需要唤醒，直接唤醒就好，否则也别浪费资源，主动等待一会</p>
<p>当阅读到这的代码时，马上就抛出来两个问题：</p>
<blockquote>
<p><strong>Q1:</strong>  既然是加锁，为什么不用已有的轮子 ReentrantLock 呢？</p>
</blockquote>
<p><strong>PS：</strong>如果你读过并发系列 <a href="https://dayarch.top/p/java-aqs-and-reentrantlock.html">Java AQS队列同步器以及ReentrantLock的应用</a> ，你会知道 ReentrantLock 是用一个完整字段 state 来控制同步状态。但这里在竞争锁的时候还会判断线程池的状态，如果是初始化状态主动 yield 放弃 CPU 来减少竞争；另外，用一个完整的 runState 不同位来表示状态也体现出更细的粒度吧</p>
<blockquote>
<p><strong>Q2:</strong> synchronized 大法虽好，但是我们都知道这是比较重量级的锁，为什么还在这里应用了呢？</p>
</blockquote>
<p><strong>PS：</strong> 首先 synchronized 经过不断优化，没有它刚诞生时那么重，另外按照 Flag 2 的代码含义，进入 synchronized 同步块的概率还是很低的，可以用最简单的方式稳稳兜底（奥卡姆剃刀了原理？）</p>
<p>有加锁自然要解锁，向下看 unlockRunState</p>
<h3 id="unlockRunState"><a href="#unlockRunState" class="headerlink" title="unlockRunState"></a>unlockRunState</h3><p>解锁的逻辑相对简单多了，总体目标是清除锁标记位。如果顺利将状态修改为目标状态，自然解锁成功；否则表示有别的线程进入了wait，需要调用notifyAll唤醒，重新尝试竞争</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlocks and sets runState to newRunState.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldRunState a value returned from lockRunState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newRunState the next value (must have lock bit clear).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockRunState</span><span class="params">(<span class="keyword">int</span> oldRunState, <span class="keyword">int</span> newRunState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, oldRunState, newRunState)) &#123;</span><br><span class="line">        Object lock = stealCounter;</span><br><span class="line">        runState = newRunState;              <span class="comment">// clears RSIGNAL bit</span></span><br><span class="line">        <span class="keyword">if</span> (lock != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; lock.notifyAll(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这两个方法贯穿着后续代码分析的始终，多注意 <code>unlockRunState</code> 的入参即可，另外你也看到了通知都是用的 notifyAll，而不是 notify，这个问题我们之前重点说明过，你还记得为什么吗？如果不记得，打开<a href="https://dayarch.top/p/waiting-notification-mechanism.html">并发编程之等待通知机制</a> 回忆一下吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210216151930.png" alt=""></p>
<p>第一层知识铺垫已经差不多了，前进</p>
<h3 id="invoke-submit-execute"><a href="#invoke-submit-execute" class="headerlink" title="invoke/submit/execute"></a>invoke/submit/execute</h3><p>回到本文最开始带有 main 函数的 demo，我们向 ForkJoinPool 提交任务调用的是 invoke 方法, 其实 ForkJoinPool 还支持 submit 和 execute 两种方式来提交任务。并发的玩法非常类似，这三类方法的作业也很好区分：</p>
<ul>
<li>invoke：提交任务，并等待返回执行结果</li>
<li>submit：提交并立刻返回任务，ForkJoinTask实现了Future，可以充分利用 Future 的特性</li>
<li>execute：只提交任务</li>
</ul>
<p>在这三大类基础上又重载了几个更细粒度的方法，这里不一一列举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  externalPush(task);</span><br><span class="line">  <span class="keyword">return</span> task.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  externalPush(task);</span><br><span class="line">  <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  externalPush(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信你已经发现了，提交任务的方法都会调用 externalPush(task) 这个用法，源码的主角终于要登场了</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img6af89bc8gw1f8qhfrzhgyg206t046k6a.gif" alt=""></p>
<p>但是……</p>
<p>如果你看 externalPush 代码，第一行就是声明一个 WorkQueue 数组变量，为了后续流程更加丝滑，咱还得铺垫一点 WorkQueue 的知识（又要铺垫）</p>
<h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>一看这么多成员变量，还是很慌的，不过，我们只需要把我几个主要的就足够了</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210216162722.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始队列容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"><span class="comment">//最大队列容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instance fields</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line"><span class="keyword">int</span> stackPred;             <span class="comment">// pool stack (ctl) predecessor  前任池（WorkQueue[]）索引，由此构成一个栈</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               <span class="comment">// number of steals  偷取的任务个数</span></span><br><span class="line"><span class="keyword">int</span> hint;                  <span class="comment">// randomization and stealer index hint  记录偷取者的索引，方便后面顺藤摸瓜</span></span><br><span class="line"><span class="keyword">int</span> config;                <span class="comment">// pool index and mode</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line"><span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)  任务数组</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// owning thread or null if shared  当前工作队列的工作线程，共享模式下为null</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    <span class="comment">// == owner during call to park; else null  调用park阻塞期间为owner，其他情况为null</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin  记录当前join来的任务</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer  记录从其他工作队列偷取过来的任务</span></span><br></pre></td></tr></table></figure>



<p>我们上面说了，WorkQueue 是一个双端队列，线程池有 runState，WorkQueue 有 scanState</p>
<ul>
<li>小于零：inactive (未激活状态)</li>
<li>奇数：scanning （扫描状态）</li>
<li>偶数：running （运行状态）</li>
</ul>
<p>操作线程池需要锁，操作队列也是需要锁的，qlock 就派上用场了</p>
<ul>
<li>1: 锁定</li>
<li>0：未锁定</li>
<li>小于零：终止状态</li>
</ul>
<p>WorkQueue 中也有个 config，但是和 ForkJoinPool 中的是不一样的，WorkQueue 中的config 记录了该 WorkQueue 在 WorkQueue[] 数组的下标以及 mode</p>
<p>其他字段的含义我们就写在代码注释中吧，主角重新登场，这次是真的</p>
<h3 id="externalPush"><a href="#externalPush" class="headerlink" title="externalPush"></a>externalPush</h3><p>文章前面说过，task 会细分成 <code>submission task</code> 和 <code>worker task</code>，<code>worker task</code> 是 <code>fork</code> 出来的，那从这个入口进入的，自然也就是 <code>submission task</code> 了，也就是说：</p>
<blockquote>
<ul>
<li><p>通过<code>invoke()</code> ｜ <code>submit()</code> | <code>execute()</code> 等方法提交的 task, 是 <code>submission task</code>，会放到 WorkQueue 数组的<strong>偶数</strong>索引位置</p>
</li>
<li><p>调用 <code>fork()</code> 方法生成出的任务，叫 worker task，会放到 WorkQueue 数组的<strong>奇数</strong>索引位置</p>
</li>
</ul>
</blockquote>
<p>该方法上的注释也写的很清楚，具体请参考代码注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to add the given task to a submission queue at</span></span><br><span class="line"><span class="comment"> * submitter's current queue. Only the (vastly) most common path</span></span><br><span class="line"><span class="comment"> * is directly handled in this method, while screening for need</span></span><br><span class="line"><span class="comment"> * for externalSubmit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">  	<span class="comment">//Flag1: 通过ThreadLocalRandom产生随机数，用于下面计算槽位索引</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">int</span> rs = runState; <span class="comment">//初始状态为0</span></span><br><span class="line">  	<span class="comment">//Flag2: 如果ws，即ForkJoinPool中的WorkQueue数组已经完成初始化，且根据随机数定位的index存在workQueue,且cas的方式加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">//对WorkQueue操作加锁</span></span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;</span><br><span class="line">      	<span class="comment">//WorkQueue中的任务数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">            (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;  <span class="comment">//组长度大于任务个数，不需要扩容</span></span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE; <span class="comment">//WorkQueue中的任务数组不为空</span></span><br><span class="line">            U.putOrderedObject(a, j, task); <span class="comment">//向Queue中放入任务</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);<span class="comment">//top值加一</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);  <span class="comment">//对WorkQueue操作解锁</span></span><br><span class="line">          	<span class="comment">//任务个数小于等于1，那么此槽位上的线程有可能等待，如果大家都没任务，可能都在等待，新任务来了，唤醒，起来干活了</span></span><br><span class="line">          	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">              	<span class="comment">//唤醒可能存在等待的线程</span></span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//任务入队失败，前面加锁了，这里也要解锁</span></span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//Flag3: 不满足上述条件，也就是说上面的这些 WorkQueue[]等都不存在，就要通过这个方法一切从头开始创建</span></span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面加了三处 Flag，为了让大家更好的理解代码还是有必要做进一步说明的：</p>
<p><strong>Flag1:</strong>  ThreadLocalRandom 是 ThreadLocal 的衍生物，每个线程默认的 probe 是 0，当线程调用ThreadLocalRandom.current()时，会初始化 seed 和 probe，维护在线程内部，这里就知道是生成一个随机数就好，具体细节还是值得大家自行看一下</p>
<p><strong>Flag2:</strong>  这里包含的信息还是非常多的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制为：0000 0000 0000 0000 0000 0000 0111 1110 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK       = <span class="number">0x007e</span>;        <span class="comment">// max 64 (even) slots</span></span><br></pre></td></tr></table></figure>

<ul>
<li>m 的值代表 WorkQueue 数组的最大下表</li>
<li>m &amp; r 会保证随机数 r 大于 m 的部分不可用</li>
<li>m &amp; r &amp; SQMASK 因为 SQMASK 最后一位是 0，最终的结果就会是偶数</li>
<li>r  != 0 说明当前线程已经初始化过一些内容</li>
<li>rs &gt; 0 说明 ForkJoinPool 的 runState 也已经被初始化过</li>
</ul>
<p><strong>Flag3:</strong>  看过 flag2 的描述，你也就很好理解 Flag 3 了，如果是第一次提交任务，必走 Flag 3 的 <code>externalSubmit</code> 方法</p>
<h3 id="externalSubmit"><a href="#externalSubmit" class="headerlink" title="externalSubmit"></a>externalSubmit</h3><p>这个方法很长，但没超过 80 行，具体请看方法注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//初始化所需要的一切  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> r;                                    <span class="comment">// initialize caller's probe</span></span><br><span class="line">     	<span class="comment">//生成随机数</span></span><br><span class="line">       <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">           ThreadLocalRandom.localInit();</span><br><span class="line">           r = ThreadLocalRandom.getProbe();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> rs, m, k;</span><br><span class="line">           <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line">         	<span class="comment">// 如果线程池的状态为终止状态，则帮助终止</span></span><br><span class="line">           <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">           &#125;</span><br><span class="line">         	<span class="comment">//Flag1: 再判断一次状态是否为初始化，因为在lockRunState过程中有可能状态被别的线程更改了</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                    ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">               <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">             	<span class="comment">//Flag1.1: 加锁</span></span><br><span class="line">               rs = lockRunState();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                     	<span class="comment">// 初始化stealcounter的值（任务窃取计数器，原子变量）</span></span><br><span class="line">                       U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>,</span><br><span class="line">                                              <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                       <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                     	<span class="comment">//取config的低16位（确切说是低15位），获取并行度</span></span><br><span class="line">                       <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                     	<span class="comment">//Flag1.2: 如果你看过HashMap 的源码，这个就很好理解了，获取2次幂大小</span></span><br><span class="line">                       <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                       n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                       n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                     	<span class="comment">//初始化 WorkQueue 数组</span></span><br><span class="line">                       workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                     	<span class="comment">// 标记初始化完成</span></span><br><span class="line">                       ns = STARTED;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 	<span class="comment">// 解锁</span></span><br><span class="line">                   unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         </span><br><span class="line">         	<span class="comment">//Flag2 上面分析过，取偶数位槽位，将任务放进偶数槽位</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             	<span class="comment">// 对 WorkQueue 加锁</span></span><br><span class="line">               <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                   ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                   <span class="keyword">int</span> s = q.top;</span><br><span class="line">                 	<span class="comment">// 初始化任务提交标识</span></span><br><span class="line">                   <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                     	<span class="comment">//计算内存偏移量，放任务，更新top值</span></span><br><span class="line">                       <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                           (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                           U.putOrderedObject(a, j, task);</span><br><span class="line">                           U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                         	<span class="comment">//提交任务成功</span></span><br><span class="line">                           submitted = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     	<span class="comment">//WorkQueue解锁</span></span><br><span class="line">                       U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                 	<span class="comment">// 任务提交成功了</span></span><br><span class="line">                   <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                     	<span class="comment">//自然要唤醒可能存在等待的线程来处理任务了</span></span><br><span class="line">                       signalWork(ws, q);</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             	<span class="comment">//任务提交没成功，可以重新计算随机数，再走一次流程</span></span><br><span class="line">               move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">           &#125;</span><br><span class="line">         	<span class="comment">//Flag3: 接Flag2，如果找到的槽位是空，则要初始化一个WorkQueue</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">               q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">             	<span class="comment">// 设置工作队列的窃取线索值</span></span><br><span class="line">               q.hint = r;</span><br><span class="line">             	<span class="comment">// 如上面 WorkQueue 中config 的介绍，记录当前WorkQueue在WorkQueue[]数组中的值，和队列模式</span></span><br><span class="line">               q.config = k | SHARED_QUEUE;</span><br><span class="line">             	<span class="comment">// 初始化为 inactive 状态</span></span><br><span class="line">               q.scanState = INACTIVE;</span><br><span class="line">             	<span class="comment">//加锁</span></span><br><span class="line">               rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">               <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                   ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">             	<span class="comment">//解锁</span></span><br><span class="line">               unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">           <span class="keyword">if</span> (move)</span><br><span class="line">               r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>Flag1.1 :</strong>  有个细节需要说一下，我们在 <a href="https://dayarch.top/p/java-aqs-and-reentrantlock.html">Java AQS队列同步器以及ReentrantLock的应用</a> 时提到过使用锁的范式以及为什么要这样用，<code>ForkJoinPool</code> 这里同样遵循这种范式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Flag1.2:</strong> 简单描述这个过程，就是根据不同的并行度来初始化不同大小的 WorkQueue[]数组，数组大小要求是 2 的 n 次幂，所以给大家个表格直观理解一下并行度和队列容量的关系：</p>
<table>
<thead>
<tr>
<th>并行度p</th>
<th>容量</th>
</tr>
</thead>
<tbody><tr>
<td>1，2</td>
<td>4</td>
</tr>
<tr>
<td>3，4</td>
<td>8</td>
</tr>
<tr>
<td>5 ～ 8</td>
<td>16</td>
</tr>
<tr>
<td>9 ～ 16</td>
<td>32</td>
</tr>
</tbody></table>
<p><strong>Flag 1，2，3：</strong> 如果你理解了上面这个方法，很显然，第一次执行这个方法内部的逻辑顺序应该是 <code>Flag1</code>——&gt; <code>Flag3</code>——&gt;<code>Flag2</code></p>
<p>externalSubmit 如果任务成功提交，就会调用 <code>signalWork</code> 方法了</p>
<h3 id="signalWork"><a href="#signalWork" class="headerlink" title="signalWork"></a>signalWork</h3><p>前面铺垫的知识要大规模派上用场（一大波僵尸来袭），are you ready?</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img006r3PQBjw1fb7sgrb00kg308i08cgq6.gif" alt=""></p>
<p>如果 ForkJoinPool 的 ctl 成员变量的作用已经忘了，赶紧向上翻重新记忆一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ       = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// version count</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">      	<span class="comment">// ctl 小于零，说明活动的线程数 AC 不够</span></span><br><span class="line">        <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">          	<span class="comment">// 取ctl的低32位，如果为0，说明没有等待的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">              	<span class="comment">// 取TC的高位，如果不等于0，则说明目前的工作着还没有达到并行度</span></span><br><span class="line">                <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                  	<span class="comment">//添加 Worker，也就是说要创建线程了</span></span><br><span class="line">                    tryAddWorker(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//未开始或者已停止，直接跳出</span></span><br><span class="line">            <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          	<span class="comment">//i=空闲线程栈顶端所属的工作队列索引</span></span><br><span class="line">            <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">          	<span class="comment">//程序执行到这里，说明有空闲线程，计算下一个scanState，增加了版本号，并且调整为 active 状态</span></span><br><span class="line">            <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">            <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">            <span class="comment">//计算下一个ctl的值，活动线程数 AC + 1，通过stackPred取得前一个WorkQueue的索引，重新设置回sp，行程最终的ctl值</span></span><br><span class="line">          	<span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">          	<span class="comment">//更新 ctl 的值</span></span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">                v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">              	<span class="comment">//如果有线程阻塞，则调用unpark唤醒即可 </span></span><br><span class="line">              	<span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//没有任务，直接跳出</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>假设程序刚开始执行，那么活动线程数以及总线程数肯定都没达到并行度要求，这时就会调用 <code>tryAddWorker</code> 方法了</p>
<h3 id="tryAddWorker"><a href="#tryAddWorker" class="headerlink" title="tryAddWorker"></a>tryAddWorker</h3><p>tryAddWorker 的逻辑就非常简单了，因为是操作线程池，同样会用到 <code>lockRunState</code>/<code>unlockRunState</code> 的锁控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//初始化添加worker表识</span></span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      	<span class="comment">//因为要添加Worker，所以AC和TC都要加一</span></span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">      	<span class="comment">//ctl还没被改变</span></span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">              	<span class="comment">//更新ctl 的值，</span></span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          	<span class="comment">//ctl值更新成功，开始真正的创建Worker</span></span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 重新获取ctl，并且没有达到最大线程数，并且没有空闲的线程</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一切顺利，就要调用 createWorker 方法来创建真正的 Worker 了，形势逐渐明朗</p>
<h3 id="createWorker"><a href="#createWorker" class="headerlink" title="createWorker"></a>createWorker</h3><p>介绍过了 WorkerQueue 和 ForkJoinTask，上文说的三个重要角色中的最后一个 <code>ForkJoinWorkerThread</code> 终于登场了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//如果工厂已经存在了，就用factory来创建线程，会去注册线程，这里的this就是ForkJoinPool对象</span></span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//启动线程  </span></span><br><span class="line">          wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果创建线程失败，就要逆向注销线程，包括前面对ctl等的操作</span></span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker 线程是如何与 WorkQueue 对应的，就藏在 <code>fac.newThread(this)</code> 这个方法里面，下面这点代码展示一下调用过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread(pool);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">  <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">  <span class="keyword">this</span>.pool = pool;</span><br><span class="line">  <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然核心内容在 <code>registerWorker</code> 方法里面了</p>
<h3 id="registerWorker"><a href="#registerWorker" class="headerlink" title="registerWorker"></a>registerWorker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">  <span class="keyword">this</span>.pool = pool;</span><br><span class="line">  <span class="keyword">this</span>.owner = owner;</span><br><span class="line">  <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">  base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">  UncaughtExceptionHandler handler;</span><br><span class="line">  <span class="comment">//这里线程被设置为守护线程，因为，当只剩下守护线程时，JVM就会推出</span></span><br><span class="line">  wt.setDaemon(<span class="keyword">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">  <span class="comment">//填补处理异常的handler</span></span><br><span class="line">  <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">    wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">  <span class="comment">//创建一个WorkQueue，并且设置当前WorkQueue的owner是当前线程</span></span><br><span class="line">  WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">  <span class="comment">//又用到了config的知识，提取出我们期望的WorkQueue模式</span></span><br><span class="line">  <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">  <span class="comment">//加锁</span></span><br><span class="line">  <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">    <span class="comment">//判断ForkJoinPool的WorkQueue[]都初始化完全</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//一种魔数计算方式，用以减少冲突</span></span><br><span class="line">      <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">      <span class="comment">//假设WorkQueue的初始长度是16，那这里的m就是15，最终目的就是为了得到一个奇数</span></span><br><span class="line">      <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//和得到偶数的计算方式一样，得到一个小于m的奇数i</span></span><br><span class="line">      i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">      <span class="comment">//如果这个槽位不为空，说明已经被其他线程初始化过了，也就是有冲突，选取别的槽位</span></span><br><span class="line">      <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">        <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">        <span class="comment">//步长加2，也就保证step还是奇数</span></span><br><span class="line">        <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//一直遍历，直到找到空槽位，如果都遍历了一遍，那就需要对WorkQueue[]扩容了</span></span><br><span class="line">        <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">            workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">            m = n - <span class="number">1</span>;</span><br><span class="line">            probes = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//初始化一个随机数</span></span><br><span class="line">      w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">      <span class="comment">//如文章前面所说，config记录索引值和模式</span></span><br><span class="line">      w.config = i | mode;</span><br><span class="line">      <span class="comment">//扫描状态也记录为索引值，如文章前面所说，奇数表示为scanning状态</span></span><br><span class="line">      w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">      <span class="comment">//把初始化好的WorkQueue放到ForkJoinPool的WorkQueue[]数组中</span></span><br><span class="line">      ws[i] = w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置worker的前缀名，用于业务区分</span></span><br><span class="line">  wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">  <span class="comment">//返回当前线程创建的WorkQueue，回到上一层调用栈，也就将WorkQueue注册到ForkJoinWorkerThread里面了</span></span><br><span class="line">  <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里线程是顺利创建成功了，可是如果线程没有创建成功，就需要 deregisterWorker来做善后工作了</p>
<h3 id="deregisterWorker"><a href="#deregisterWorker" class="headerlink" title="deregisterWorker"></a>deregisterWorker</h3><p>deregisterWorker 方法接收刚刚创建的线程引用和异常作为参数，来做善后工作，将 registerWorker 相关工作撤销回来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> </span>&#123;</span><br><span class="line">  WorkQueue w = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (wt != <span class="keyword">null</span> &amp;&amp; (w = wt.workQueue) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    WorkQueue[] ws;                           <span class="comment">// remove index from array</span></span><br><span class="line">    <span class="comment">//获取当前线程注册的索引值</span></span><br><span class="line">    <span class="keyword">int</span> idx = w.config &amp; SMASK;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="comment">//如果奇数槽位都不为空，则清空内容</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">      ws[idx] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> c;                                       <span class="comment">// decrement counts</span></span><br><span class="line">  <span class="comment">//死循环式CAS更改ctl的值，将前面AC和TC加1的值再减1，ctl就在那里，不增不减</span></span><br><span class="line">  <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong</span><br><span class="line">               (<span class="keyword">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                                     (TC_MASK &amp; (c - TC_UNIT)) |</span><br><span class="line">                                     (SP_MASK &amp; c))));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//清空WorkQueue，将其中的task取消掉</span></span><br><span class="line">  <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;</span><br><span class="line">    w.qlock = -<span class="number">1</span>;                             <span class="comment">// ensure set</span></span><br><span class="line">    w.transferStealCount(<span class="keyword">this</span>);</span><br><span class="line">    w.cancelAll();                            <span class="comment">// cancel remaining tasks</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//可能的替换操作</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;                                    <span class="comment">// possibly replace</span></span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m, sp;</span><br><span class="line">    <span class="comment">//如果线程池终止了，那就跳出循环即可</span></span><br><span class="line">    <span class="keyword">if</span> (tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>) || w == <span class="keyword">null</span> || w.array == <span class="keyword">null</span> ||</span><br><span class="line">        (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> ||</span><br><span class="line">        (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)              <span class="comment">// already terminating</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前线程创建失败，通过sp判断，如果还存在空闲线程，则调用tryRelease来唤醒这个线程，然后跳出</span></span><br><span class="line">    <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>) &#123;         <span class="comment">// wake up replacement</span></span><br><span class="line">      <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没空闲线程，并且还没有达到满足并行度的条件，那就得再次尝试创建一个线程，弥补刚刚的失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="keyword">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123;</span><br><span class="line">      tryAddWorker(c);                      <span class="comment">// create replacement</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                      <span class="comment">// don't need replacement</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ex == <span class="keyword">null</span>)                               <span class="comment">// help clean on way out</span></span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    ForkJoinTask.helpExpungeStaleExceptions();</span><br><span class="line">  <span class="keyword">else</span>                                          <span class="comment">// rethrow</span></span><br><span class="line">    ForkJoinTask.rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之 deregisterWorker 方法从线程池里注销线程，清空WorkQueue，同时更新ctl，最后做可能的替换，根据线程池的状态决定是否找一个自己的替代者：</p>
<ul>
<li>有空闲线程，则唤醒一个</li>
<li>没有空闲线程，再次尝试创建一个新的工作线程</li>
</ul>
<p>deregisterWorker 线程解释清楚了是为了帮助大家完整理解流程，但 registerWorker 成功后的流程还没走完，咱得继续，有了 Worker，那就调用  <code>wt.start()</code> 干活吧</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>ForkJoinWorkerThread 继承自Thread，调用start() 方法后，自然要调用自己重写的 run() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      onStart();</span><br><span class="line">      <span class="comment">//Work开始工作，处理workQueue中的任务</span></span><br><span class="line">      pool.runWorker(workQueue);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      exception = ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        onTermination(exception);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">          exception = ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        pool.deregisterWorker(<span class="keyword">this</span>, exception);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的重点自然是进入到 runWorker </p>
<h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><p>runWorker 是很常规的三部曲操作：</p>
<ul>
<li>scan: 通过扫描获取任务</li>
<li>runTask：执行扫描到的任务</li>
<li>awaitWork：没任务进入等待</li>
</ul>
<p>具体请看注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//初始化队列，并根据需要是否扩容为原来的2倍</span></span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//死循环更新偏移r，为扫描任务作准备  </span></span><br><span class="line">  	<span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">      	<span class="comment">//扫描任务</span></span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)</span><br><span class="line">          	<span class="comment">//扫描到就执行任务</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">      	<span class="comment">//没扫描到就等待，如果等也等不到任务，那就跳出循环别死等了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看 scan 方法</p>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p>ForkJoinPool 的任务窃取机制要来了，如何 steal 的，就藏在scan 方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">  WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line">  <span class="comment">//再次验证workQueue[]数组的初始化情况</span></span><br><span class="line">  <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//获取当前扫描状态</span></span><br><span class="line">    <span class="keyword">int</span> ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//又一个死循环，注意到出口位置就好</span></span><br><span class="line">    <span class="comment">//和前面逻辑类似，随机一个起始位置，并赋值给k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">      WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">      <span class="keyword">int</span> b, n; <span class="keyword">long</span> c;</span><br><span class="line">      <span class="comment">//如果k槽位不为空</span></span><br><span class="line">      <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//base-top小于零，并且任务q不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (a = q.array) != <span class="keyword">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">          <span class="comment">//获取base的偏移量，赋值给i</span></span><br><span class="line">          <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">          <span class="comment">//从base端获取任务，和前文的描述的steal搭配上了，是从base端steal</span></span><br><span class="line">          <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                    U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">              q.base == b) &#123;</span><br><span class="line">            <span class="comment">//是active状态</span></span><br><span class="line">            <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//更新WorkQueue中数组i索引位置为空，并且更新base的值</span></span><br><span class="line">              <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                q.base = b + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//n&lt;-1,说明当前队列还有剩余任务，继续唤醒可能存在的其他线程</span></span><br><span class="line">                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                  signalWork(ws, q);</span><br><span class="line">                <span class="comment">//直接返回任务</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                     w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">              tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果获取任务失败，则准备换位置扫描</span></span><br><span class="line">          <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">            ss = w.scanState;</span><br><span class="line">          r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">          origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">          oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        checkSum += b;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//k一直在变，扫描到最后，如果等于origin，说明已经扫描了一圈还没扫描到任务</span></span><br><span class="line">      <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">        <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">            oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//准备inactive当前工作队列</span></span><br><span class="line">          <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">          <span class="comment">//活动线程数AC减1</span></span><br><span class="line">          <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                     (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">          w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">          U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">          <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">            ss = ns;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">        &#125;</span><br><span class="line">        checkSum = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果顺利扫描到任务，那就要调用 runTask 方法来真正的运行这个任务了</p>
<h3 id="runTask"><a href="#runTask" class="headerlink" title="runTask"></a>runTask</h3><p>马上就接近真相了，steal 到任务了，就干点正事吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">      	<span class="comment">//Flag1: 记录当前的任务是偷来的，至于如何执行task，是我们写在compute方法中的，我们一会看doExec() 方法</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">      	<span class="comment">//累加偷来的数量，亲兄弟明算帐啊，虽然算完也没啥实际意义</span></span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">      	<span class="comment">//任务执行完后，就重新更新scanState为SCANNING</span></span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Flag1:</strong> doExec 方法才是真正执行任务的关键，它是链接我们自定义 compute 方法的核心，来看 doExec 方法</p>
<h3 id="doExec"><a href="#doExec" class="headerlink" title="doExec"></a>doExec</h3><p>形势一片大好，挺住，揭开 exec 的面纱，就看到本质了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ForkJoinTask中的抽象方法，RecursiveTask 和 RecursiveAction 都重写了它</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">  <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      </span><br><span class="line">      completed = exec();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">      <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completed)</span><br><span class="line">      s = setCompletion(NORMAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RecursiveTask重写的内容，终于看到我们文章开头 demo 中的compute 了</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  result = compute();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经看到本质了，绕了这么一大圈，终于和我们自己重写的compute方法联系到了一起，真是不容易，但是 runWorker 三部曲还差最后一曲 awaitWork 没谱，我们来看看</p>
<h3 id="awaitWork"><a href="#awaitWork" class="headerlink" title="awaitWork"></a>awaitWork</h3><p>上面说的是 scan 到了任务，要是没有scan到任务，那就得将当前线程阻塞一下，具体标注在注释中，可以简单了解一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">      <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">        WorkQueue v; WorkQueue[] ws; <span class="keyword">int</span> s, j; AtomicLong sc;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">            <span class="comment">//前驱任务队列还在</span></span><br><span class="line">            (v = ws[j]) != <span class="keyword">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">            <span class="comment">//并且工作队列已经激活，说明任务来了了</span></span><br><span class="line">            (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">          <span class="comment">//继续自旋等一会，别返回false</span></span><br><span class="line">          spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自旋之后，再次检查工作队列是否终止，若是，退出扫描</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">      <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">      <span class="keyword">int</span> ac = (<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">      <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) ||</span><br><span class="line">          (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">        prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">        <span class="keyword">int</span> t = (<span class="keyword">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">        parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">        deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">      w.parker = wt;</span><br><span class="line">      <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">        U.park(<span class="keyword">false</span>, parkTime);</span><br><span class="line">      U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">      U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">          deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">          U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，ForkJoinPool 的完整流程算是有个基本了解了，但是我们前面讲的这些内容都是从 submission task 作为切入点的。刚刚聊到的 compute 方法，我们按照分治算法范式写了自己的逻辑，具体请回看文中开头的demo，很关键的一点是，我们在 compute 中调用了 fork 方法，这就给我们了解 worker task 的机会了，继续来看 fork 方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210216220956.png" alt=""></p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>Fork 方法的逻辑很简单，如果当前线程是 ForkJoinWorkerThread 类型，也就是说已经通过上文注册的 Worker，那么直接调用 push 方法将 task 放到当前线程拥有的 WorkQueue 中，否则就再调用 externalPush 重走我们已上说的所有逻辑（你敢再走一遍吗？）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread t;</span><br><span class="line">  <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">    ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push 方法很简单，这里就不再过多解释了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">  ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">  <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">  <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">    <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">    U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">    U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">        p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">      growArray();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有 fork 就有 join，继续看一下 join 方法()</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join 的核心调用在 doJoin，但是看到这么多级联三元运算符，我慌了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s;</span><br><span class="line">  <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">    reportException(s);</span><br><span class="line">  <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">  <span class="comment">//status,task 的运行状态</span></span><br><span class="line">  <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">  ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">    (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">    tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">  wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">  externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将 doJoin 方法用我们最熟悉的 if/else 做个改动，是不是就豁然开朗了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s;</span><br><span class="line">  Thread t;</span><br><span class="line">  ForkJoinWorkerThread wt;</span><br><span class="line">  ForkJoinPool.WorkQueue w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((s = status) &lt; <span class="number">0</span>) &#123; <span class="comment">// 有结果，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123; 		</span><br><span class="line">      <span class="comment">// 如果是 ForkJoinWorkerThread Worker</span></span><br><span class="line">      <span class="keyword">if</span>((w = (wt = (ForkJoinWorkerThread) t).workQueue).tryUnpush(<span class="keyword">this</span>) <span class="comment">// 类似上面提到的 scan，但是是专项尝试从本工作队列里取出等待的任务</span></span><br><span class="line">         <span class="comment">// 取出了任务，就去执行它，并返回结果</span></span><br><span class="line">         &amp;&amp; (s = doExec()) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 也有可能别的线程把这个任务偷走了，那就执行内部等待方法</span></span><br><span class="line">        <span class="keyword">return</span> wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 如果不是 ForkJoinWorkerThread，执行外部等待方法</span></span><br><span class="line">      <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中 awaitJoin 和 externalAwaitDone 都用到了 Helper（帮助） 和 Compensating（补偿） 两种策略，这两种策略大家完全可以自行阅读了，尤其是 awaitJoin 方法，强烈推荐大家自行阅读，其中 pop 的过程在这里，这里不再展开</p>
<p>到这里，有关 ForkJoinPool 相关的内容就算是结束了，为了让大家有个更好的理解 fork/join 机制，我们还是画几张图解释一下</p>
<h2 id="Fork-Join-图解"><a href="#Fork-Join-图解" class="headerlink" title="Fork/Join 图解"></a>Fork/Join 图解</h2><blockquote>
<p>假设我们的大任务是 Task(8), 最终被分治成可执行的最小单元是 Task(1)</p>
</blockquote>
<p>按照分治思想拆分任务的整体目标就是这样滴：</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210216230129.png" alt=""></p>
<p>从外部先提交一个大的 Task(8)，将其放在偶数槽位中（<strong>请注意颜色对应</strong>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210216231549.png" alt=""></p>
<p>不满足并行度，会创建 Worker 1 来扫描，并从 base 端窃取到任务 task(8)，执行到 compute, fork</p>
<p>出两个 task(4), 并 push到 WorkQueue 中</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210216232529.png" alt=""></p>
<p>在执行任务时始终会确认是否满足并行度要求，如果没有就会继续创建新的Worker，与此同时，也会继续 fork 任务，直到最小单元。Worker1 会从 top 端 pop 出来 task(4) 来继续 compute 和 fork，并重新 push 到 WorkQueue 中</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210216234013.png" alt=""></p>
<p>task(2) 还不是最小单元，所以会继续 pop 出 task(2)，并最终 fork 出两个 task(1) push 到 WorkQueue中</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210217100238.png" alt=""></p>
<p>task(1) 已经是最小粒度了，可以直接 pop 出来执行，获取最终结果；在 Worker1 进行这些 pop 操作的同时，为了满足并行度要求也会创建的其他Worker，比如  Worker 2，这时 Worker2 会从 Worker 1 所在队列的 base 端窃取任务</p>
<p><img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host@master/blog-img20210217100724.png" alt=""></p>
<p>Worker 2 依旧是按照这个规则进行 pop-&gt;fork，到最终可以 exec 任务，假设 Worker 1 的任务先执行完，要 join 结果，当 join task(4) 时，通过 hint 定位到是谁偷走了 task(4)，这时顺藤摸瓜找到 Worker2，如果 Worker2 还有任务没执行完，Worker1 再窃取回来帮着执行，这样互帮互助，最终快速完成任务</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li><p>为什么说 ForkjoinPool 效率要更高？同时建议使用 commonPool？ </p>
</li>
<li><p>JDK1.8 Stream 底层就充分用到了 ForkJoinPool，你知道还有哪里用到了 ForkJoinPool 了吗？</p>
</li>
<li><p>ForkJoinPool 最多会有多少个槽位？</p>
</li>
<li><p>下面代码有人说不能充分利用 ForkJoinPool，多个 task 的提交要用 invokeAll，你知道为什么吗？如果不用 invokeAll，要怎样使用 fork/join 呢？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (任务足够小) &#123;</span><br><span class="line">        <span class="keyword">return</span> cal();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    SumTask subtask1 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">    SumTask subtask2 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 分别对子任务调用fork():</span></span><br><span class="line">    subtask1.fork();</span><br><span class="line">    subtask2.fork();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 分别获取合并结果:</span></span><br><span class="line">    Long subresult1 = subtask1.join();</span><br><span class="line">    Long subresult2 = subtask2.join();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> subresult1 + subresult2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这又是一篇长文，很多小伙伴私下都建议我将长文拆开，一方面读者好消化，另一方面我自己也在数量的体现上变得高产。几次想拆开，但好多文章拆开就失去了连续性（大家都有遗忘曲线）。过年没回老家，就有时间撸文章了。为了更好的理解源码，文章的基础铺垫内容很多，看到这，你应该很累了，想要将更零散的知识点串起来，那就多看代码注释回味一下，然后一起膜拜 Doug Lea 吧</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Java 并发编程实战</li>
<li><a href="https://www.liaoxuefeng.com/article/1146802219354112" target="_blank" rel="noopener">https://www.liaoxuefeng.com/article/1146802219354112</a></li>
<li><a href="https://www.cnblogs.com/aniao/p/aniao_fjp.html#" target="_blank" rel="noopener">https://www.cnblogs.com/aniao/p/aniao_fjp.html#</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1705833" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1705833</a></li>
</ol>

      </div>
      <!-- <div class="tuijian">
        <br><br>
        📚相关文章
        <ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-aqs-acquireshared-and-semaphore.html" title="Java AQS共享式获取同步状态及Semaphore的应用分析" rel="bookmark">Java AQS共享式获取同步状态及Semaphore的应用分析</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-countdownlatch-vs-cyclicbarrier.html" title="CountDownLatch 和 CyclicBarrier 傻傻的分不清楚？" rel="bookmark">CountDownLatch 和 CyclicBarrier 傻傻的分不清楚？</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/executorservice-vs-completionservice.html" title="ExecutorService VS CompletionService" rel="bookmark">ExecutorService VS CompletionService</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-aqs-and-reentrantlock.html" title="Java AQS队列同步器以及ReentrantLock的应用" rel="bookmark">Java AQS队列同步器以及ReentrantLock的应用</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-future-and-callable.html" title="Java Future详解与使用" rel="bookmark">Java Future详解与使用</a></h3></div></li></ul>
      </div> -->
      <div class="personalweixin">
        <br><br>
        <blockquote>
          <a href="https://mp.weixin.qq.com/s/G7BXuZh0Qh1-mE6ts4LJqQ" target="_blank" rel="noopener">加我微信</a>，咱们交流技术与思想，共同成长
        </blockquote>
        <br>

      </div>
      
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-02-17T15:35:31+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>更新于 2021年2月17日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java-Concurrency/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>Java-Concurrency</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://dayarch.top/p/java-fork-join-pool.html&title=ForkJoinPool大剖析 | 日拱一兵｜Java｜Spring Boot｜Java并发编程｜最新干货分享&pics=https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-imgavatar.png&summary=知识回顾
并发工具类我们已经讲了很多，这些工具类的「目标」是让我们只关注任务本身，并且忽视线程间合作细节，简化了并发编程难度的同时，也增加了很多安全性。工具类的对使用者的「目标」虽然一致，但每一个工具类本身都有它独特的应用场景，比如：

 * 我会手动创建线程，为什么要使用线程池? 介绍了使用线程池管理线程将一个大任务分解成多个子任务来简单执行，借助 不会用Java Future，我怀疑你泡茶没我快, 又是超长图文！！ 的 Future 特性获取子任务执行结果——二者结合使用就可以处理简单的并行任务
 * 搞定 CompletableFuture，并发异步编程和编写串行程序还有什么区别？ 借助"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://dayarch.top/p/java-fork-join-pool.html&title=ForkJoinPool大剖析 | 日拱一兵｜Java｜Spring Boot｜Java并发编程｜最新干货分享&pics=https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-imgavatar.png&summary=知识回顾
并发工具类我们已经讲了很多，这些工具类的「目标」是让我们只关注任务本身，并且忽视线程间合作细节，简化了并发编程难度的同时，也增加了很多安全性。工具类的对使用者的「目标」虽然一致，但每一个工具类本身都有它独特的应用场景，比如：

 * 我会手动创建线程，为什么要使用线程池? 介绍了使用线程池管理线程将一个大任务分解成多个子任务来简单执行，借助 不会用Java Future，我怀疑你泡茶没我快, 又是超长图文！！ 的 Future 特性获取子任务执行结果——二者结合使用就可以处理简单的并行任务
 * 搞定 CompletableFuture，并发异步编程和编写串行程序还有什么区别？ 借助"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://dayarch.top/p/java-fork-join-pool.html&title=ForkJoinPool大剖析 | 日拱一兵｜Java｜Spring Boot｜Java并发编程｜最新干货分享&pics=https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-imgavatar.png&summary=知识回顾
并发工具类我们已经讲了很多，这些工具类的「目标」是让我们只关注任务本身，并且忽视线程间合作细节，简化了并发编程难度的同时，也增加了很多安全性。工具类的对使用者的「目标」虽然一致，但每一个工具类本身都有它独特的应用场景，比如：

 * 我会手动创建线程，为什么要使用线程池? 介绍了使用线程池管理线程将一个大任务分解成多个子任务来简单执行，借助 不会用Java Future，我怀疑你泡茶没我快, 又是超长图文！！ 的 Future 特性获取子任务执行结果——二者结合使用就可以处理简单的并行任务
 * 搞定 CompletableFuture，并发异步编程和编写串行程序还有什么区别？ 借助"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/p/jenkins-environment-variables.html" rel="prev" title="Jenkins 使用环境变量">
                                  
                                      Jenkins 使用环境变量
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/Jenkins/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Jenkins</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>


  
    
  
    
      
        
          
  <section class='widget related_posts'>
    
<header class='pure'>
  <div><i class="fas fa-bookmark fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;相关文章</div>
  
</header>

    <div class="content pure">
      <ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-aqs-acquireshared-and-semaphore.html" title="Java AQS共享式获取同步状态及Semaphore的应用分析" rel="bookmark">Java AQS共享式获取同步状态及Semaphore的应用分析</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-countdownlatch-vs-cyclicbarrier.html" title="CountDownLatch 和 CyclicBarrier 傻傻的分不清楚？" rel="bookmark">CountDownLatch 和 CyclicBarrier 傻傻的分不清楚？</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/executorservice-vs-completionservice.html" title="ExecutorService VS CompletionService" rel="bookmark">ExecutorService VS CompletionService</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-aqs-and-reentrantlock.html" title="Java AQS队列同步器以及ReentrantLock的应用" rel="bookmark">Java AQS队列同步器以及ReentrantLock的应用</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-future-and-callable.html" title="Java Future详解与使用" rel="bookmark">Java Future详解与使用</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-concurrency-interrupt-mechnism.html" title="Java多线程中断机制" rel="bookmark">Java多线程中断机制</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-thread-life-cycle.html" title="Java线程生命周期这样理解挺简单的" rel="bookmark">Java线程生命周期这样理解挺简单的</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java8-completablefuture-tutorial.html" title="java8 CompletableFuture 使用详解" rel="bookmark">java8 CompletableFuture 使用详解</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/java-concurrency-dead-lock.html" title="Java并发死锁解决思路" rel="bookmark">Java并发死锁解决思路</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/p/difference-between-volatile-and-synchronized-keyword.html" title="volatile和synchronized图文透彻讲解" rel="bookmark">volatile和synchronized图文透彻讲解</a></h3></div></li></ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
    
  


  <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
      
        <section id="comments">
          <div id="gitalk-container"></div>
        </section>
      
      
    </section>
  </article>






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'ForkJoinPool大剖析',
      tools: true
    }
  </script>



  <script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
  <script>
      const btw = new BTWPlugin();
      btw.init({
          id: 'post',
          blogId: '10015-1569397635991-668',
          name: '日拱一兵',
          qrcode: 'https://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/_image/2019-07-25/qrcode.jpg',
          keyword: 'tanrgyb',
      });
  </script>
  

</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
        
          
          
            
              <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-imgqrcode.jpg'/>
      </div>
    
    
      <div class='text'>
        
        
        
          <p><span id="jinrishici-sentence">从来没有真正的绝境，只有心灵的迷途</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:dayarch@126.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/FraserYu"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#知识回顾"><span class="toc-text">知识回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治思想"><span class="toc-text">分治思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分治法适用的情况"><span class="toc-text">分治法适用的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoin"><span class="toc-text">ForkJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask"><span class="toc-text">ForkJoinTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool"><span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析（JDK-1-8）"><span class="toc-text">源码分析（JDK 1.8）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool-构造方法"><span class="toc-text">ForkJoinPool 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lockRunState"><span class="toc-text">lockRunState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlockRunState"><span class="toc-text">unlockRunState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invoke-submit-execute"><span class="toc-text">invoke/submit/execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkQueue"><span class="toc-text">WorkQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#externalPush"><span class="toc-text">externalPush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#externalSubmit"><span class="toc-text">externalSubmit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#signalWork"><span class="toc-text">signalWork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryAddWorker"><span class="toc-text">tryAddWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createWorker"><span class="toc-text">createWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#registerWorker"><span class="toc-text">registerWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deregisterWorker"><span class="toc-text">deregisterWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run"><span class="toc-text">run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runWorker"><span class="toc-text">runWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scan"><span class="toc-text">scan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runTask"><span class="toc-text">runTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doExec"><span class="toc-text">doExec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitWork"><span class="toc-text">awaitWork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-text">join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-Join-图解"><span class="toc-text">Fork/Join 图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#灵魂追问"><span class="toc-text">灵魂追问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
    <div class="footer">
      <p><strong>If you can NOT explain it simply, you do NOT understand it well enough</strong></p>

    </div>
    <br>
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:dayarch@126.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/FraserYu"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  Copyright <i class="far fa-copyright"></i>  2018-2019 
  <a href="https://www.itrhx.com/" target="_blank"> Tanθ's Blog </a>
  &nbsp;&nbsp;|&nbsp;&nbsp;<img src="https://cdn.jsdelivr.net/gh/FraserYu/img-host/blog-imgicp.png">
  <a href="http://www.beian.miit.gov.cn/" target="_blank">辽ICP备19017651号-1</a>

  &nbsp;&nbsp;|&nbsp;&nbsp;  
  
    &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
        class="white-color">255k</span>&nbsp;字
    

  &nbsp;&nbsp;|&nbsp;&nbsp;  
  
    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
        var now = new Date(); 
        function createtime() { 
            var grt= new Date("05/22/2019 09:09:06");//在此处修改你的建站时间
            now.setTime(now.getTime()+250); 
            days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
            hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
            if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
            mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
            seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
            snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
            document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 "; 
            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
        } 
    setInterval("createtime()",250);
    </script>
    
  &nbsp;&nbsp;|&nbsp;&nbsp;<a href="https://dayarch.top/sitemap.xml" target="_blank">站点地图</a>
  &nbsp;&nbsp;|&nbsp;&nbsp;<a href="https://tongji.baidu.com/web/welcome/ico?s=f553477a3dc5ab3837e9a4dead4e0bc7" target="_blank">站长统计</a>
  
  




  <div>
    <!-- 本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题 -->
    
      <!-- ， -->
      <!-- 总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-eyes" aria-hidden="true"></i></span>
      次 -->
      <span id="busuanzi_container_site_pv">
        &nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
            class="white-color"></span>&nbsp;次
    </span>
      <!-- &nbsp;&nbsp;|&nbsp;&nbsp; -->
      <!-- 总访客量 -->
      <!-- <span id="busuanzi_container_site_uv"><i class="fas fa-eyes" aria-hidden="true"></i></span> -->
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
            class="white-color"></span>&nbsp;人
    </span>
      <!-- 人 -->
    
    。
  </div>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <!-- <div class="github-badge">
      <a style="color: #fff" rel="license" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动">
      <span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a>
    </div> -->
</footer>
<script>setLoadingBarProgress(80);</script>


<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
   

      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <!-- <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script> -->










  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: "57bd3ce366ba25a73a1a",
      clientSecret: "bab4a248180b9ac85b16fb44bf4ba171648f9cab",
      repo: "myBlogTalk",
      owner: "FraserYu",
      admin: "FraserYu",
      
        id: location.pathname,      // Ensure uniqueness and length less than 50
      
      distractionFreeMode: false  // Facebook-like distraction free mode
    });
    gitalk.render('gitalk-container');
  </script>





  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>

<!-- 鼠标点击火花效果 -->
<!-- <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/fireworks.js"></script> -->

<!-- 腾讯分析代码 -->
<!-- <script type="text/javascript" src="http://tajs.qq.com/stats?sId=66485661" charset="UTF-8"></script> -->

  <!--动态线条背景-->
<!-- <script type="text/javascript" color="100,220,220" opacity='0.8' zIndex="-2" count="400" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script> -->
<!-- 样式二（飘动的彩带） -->
<!-- <script src="https://g.joyinshare.com/hc/piao.js" type="text/javascript"></script> -->
<!-- 样式一（鼠标点击更换样式） -->
<!-- <script src="https://g.joyinshare.com/hc/ribbon.min.js" type="text/javascript"></script> -->
</body>
</html>
